@article{springer_10_1134_s106373971903003x,
  title = {Extracting a Logic Gate Network from a Transistor-Level CMOS Circuit},
  author = {Cheremisinov, D. I. and Cheremisinova, L. D.},
  journal = {Russian Microelectronics},
  year = {2019},
  volume = {48},
  number = {3},
  pages = {187-196},
  publisher = {Pleiades Publishing Ltd},
  doi = {10.1134/s106373971903003x},
  url = {https://doi.org/10.1134/s106373971903003x},
  abstract = {In this paper, we address the problem of converting a flat CMOS circuit of transistors in the SPICE format into a hierarchical circuit of CMOS gates in the same format. This problem arises in the process of layout versus schematic (LVS) verification, as well as when reengineering integrated circuits. A method for recognizing subcircuits (CMOS gates) is described. The method is implemented as a C++ program; it recognizes subcircuits that are described by the same logic functions but are not isomorphic at the transistor level as different ones. This provides the isomorphism of the original and decompiled circuits.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_98488_9_10,
  title = {The File MyMusic.class: On Decompiling Software},
  author = {Tzitzikas, Yannis and Marketakis, Yannis},
  booktitle = {Cinderella's Stick},
  year = {2018},
  pages = {95-103},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98488-9\_10},
  url = {https://doi.org/10.1007/978-3-319-98488-9\_10},
  abstract = {This chapter describes the pattern “Software Decompiling”. The episode describes the efforts of Robert to decompile a particular piece of software. The technical sections discuss compilers, interpreters and decompilers, and provide examples of programming language code (Java) and software build automation tools (Maven).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_4941_3_6,
  title = {Diagnostic Tools},
  author = {Akinshin, Andrey},
  booktitle = {Pro .NET Benchmarking},
  year = {2019},
  pages = {365-399},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4941-3\_6},
  url = {https://doi.org/10.1007/978-1-4842-4941-3\_6},
  abstract = {Benchmarking is only one of the performance investigation steps. In this chapter, you will find a brief overview of the some important diagnostic tools that can be useful for the whole investigation. We will learn the following kinds of tools:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_24268_8_22,
  title = {A Survey of Software Reverse Engineering Applications},
  author = {Chen, Zhuangyou and Pan, Bing and Sun, Yanbin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {235-245},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-24268-8\_22},
  url = {https://doi.org/10.1007/978-3-030-24268-8\_22},
  abstract = {With the development of software, software maintenance and software security become an important research of software engineering. Software reverse engineering plays an irreplaceable role in software maintenance and software security. In this paper, the applications of software reverse engineering in software maintenance and malware analysis, as well as the legitimacy of software reverse engineering research are briefly discussed, and then software reverse engineering, disassembly, decompilation and so on are introduced. Related technique such as software protection technology, static analysis technology, dynamic analysis technology are described. Then, we discuss the application of software reverse engineering, such as software maintenance, software vulnerability mining, malware analysis and so on. In addition, we also describe how to use software reverse engineering to learn the method of software cracking, so as to resist reverse attack and improve the ability of anti-piracy of software itself.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_30215_3_20,
  title = {Automated Reconstruction of Control Logic for Programmable Logic Controller Forensics},
  author = {Qasim, Syed Ali and Lopez, Juan and Ahmed, Irfan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {402-422},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-30215-3\_20},
  url = {https://doi.org/10.1007/978-3-030-30215-3\_20},
  abstract = {This paper presents Similo , an automated scalable framework for control logic forensics in industrial control systems. Similo is designed to investigate denial of engineering operations (DEO) attacks, recently demonstrated to hide malicious control logic in a programmable logic controller (PLC) at field sites from an engineering software (at control center). The network traffic (if captured) contains substantial evidence to investigate DEO attacks including manipulation of control logic. Laddis , a state-of-the-art forensic approach for DEO attacks, is a binary-logic decompiler for the Allen-Bradley’s RSLogix engineering software and MicroLogix 1400 PLC. It is developed with extensive manual reverse engineering effort of the underlying proprietary network protocol and the binary control logic. Unfortunately, Laddis is not scalable and requires similar efforts to extend on other engineering software/PLCs. The proposed solution, Similo , is based on the observation that engineering software of different vendors are equipped with decompilers. Similo is a virtual-PLC framework that integrates the decompilers with their respective (previously-captured) ICS network traffic of control logic. It recovers the binary logic into a high-level source code (of the programming languages defined by IEC 61131-3 standard) automatically. Similo can work with both proprietary/open protocols without requiring protocol specifications and the binary formats of control logic. Thus, it is scalable to different ICS vendors. We evaluate Similo on three PLCs of two ICS vendors, i.e. MicroLogix 1400, MicroLogix 1100, and Modicon M221. These PLCs support proprietary protocols and the control logics written in two programming languages: Ladder Logic and Instruction List. The evaluation results show that Similo can accurately reconstruct a control logic from an ICS network traffic and can be used to investigate the DEO attacks effectively.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_4300_8_8,
  title = {Exploiting Mobile, Web, and Network for IoT},
  author = {Gupta, Aditya},
  booktitle = {The IoT Hacker's Handbook},
  year = {2019},
  pages = {187-222},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4300-8\_8},
  url = {https://doi.org/10.1007/978-1-4842-4300-8\_8},
  abstract = {In this chapter, we look at some of the additional ways of exploiting IoT devices, which are through the mobile application, web application, and network penetration testing skills.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_14234_6_19,
  title = {Analyzing Use of High Privileges on Android: An Empirical Case Study of Screenshot and Screen Recording Applications},
  author = {Meng, Mark H. and Bai, Guangdong and Liu, Joseph K. and Luo, Xiapu and Wang, Yu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {349-369},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-14234-6\_19},
  url = {https://doi.org/10.1007/978-3-030-14234-6\_19},
  abstract = {The number of Android smartphone and tablet users has experienced a rapid growth in the past few years and it raises users’ awareness on privacy and security issues of their mobile devices. There are lots of users rooting their Android devices for some useful functions, which are not originally provided to developers and users, such as taking screenshot and screen recording. However, after observing the danger of rooting devices, the developers begin to look for non-root alternatives to implement those functions. Android Debug Bridge (ADB) workaround is one of the best known non-root alternatives to help app gain a higher privilege on Android. It used to be considered as a secure practice until some cases of ADB privilege leakage have been found. In this paper, we propose an approach to identify the potential privilege leakage in Android apps that using ADB workaround. We apply our approach to analyze three real-world apps that are downloaded from Google Play Store. We then present a general methodology to conduct exploitation on those apps using ADB workaround. Based on our study, we suggest some mitigation techniques to help developers create their apps that not only satisfy users’ needs but also protect users’ privacy from similar attacks in future.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_017_9564_7,
  title = {A comparison of code similarity analysers},
  author = {Ragkhitwetsagul, Chaiyong and Krinke, Jens and Clark, David},
  journal = {Empirical Software Engineering},
  year = {2018},
  volume = {23},
  number = {4},
  pages = {2464-2519},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-017-9564-7},
  url = {https://doi.org/10.1007/s10664-017-9564-7},
  abstract = {Copying and pasting of source code is a common activity in software engineering. Often, the code is not copied as it is and it may be modified for various purposes; e.g. refactoring, bug fixing, or even software plagiarism. These code modifications could affect the performance of code similarity analysers including code clone and plagiarism detectors to some certain degree. We are interested in two types of code modification in this study: pervasive modifications, i.e. transformations that may have a global effect, and local modifications, i.e. code changes that are contained in a single method or code block. We evaluate 30 code similarity detection techniques and tools using five experimental scenarios for Java source code. These are (1) pervasively modified code, created with tools for source code and bytecode obfuscation, and boiler-plate code, (2) source code normalisation through compilation and decompilation using different decompilers, (3) reuse of optimal configurations over different data sets, (4) tool evaluation using ranked-based measures, and (5) local + global code modifications. Our experimental results show that in the presence of pervasive modifications, some of the general textual similarity measures can offer similar performance to specialised code similarity tools, whilst in the presence of boiler-plate code, highly specialised source code similarity detection techniques and tools outperform textual similarity measures. Our study strongly validates the use of compilation/decompilation as a normalisation technique. Its use reduced false classifications to zero for three of the tools. Moreover, we demonstrate that optimal configurations are very sensitive to a specific data set. After directly applying optimal configurations derived from one data set to another, the tools perform poorly on the new data set. The code similarity analysers are thoroughly evaluated not only based on several well-known pair-based and query-based error measures but also on each specific type of pervasive code modification. This broad, thorough study is the largest in existence and potentially an invaluable guide for future users of similarity detection in source code.},
  content_type = {Article},
}


@article{springer_10_1007_s11416_019_00332_z,
  title = {Experimental analysis of Android malware detection based on combinations of permissions and API-calls},
  author = {Singh, Abhishek Kumar and Jaidhar, C. D. and Kumara, M. A. Ajay},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2019},
  volume = {15},
  number = {3},
  pages = {209-218},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-019-00332-z},
  url = {https://doi.org/10.1007/s11416-019-00332-z},
  abstract = {Android-based smartphones are gaining popularity, due to its cost efficiency and various applications. These smartphones provide the full experience of a computing device to its user, and usually ends up being used as a personal computer. Since the Android operating system is open-source software, many contributors are adding to its development to make the interface more attractive and tweaking the performance. In order to gain more popularity, many refined versions are being offered to customers, whose feedback will enable it to be made even more powerful and user-friendly. However, this has attracted many malicious code-writers to gain anonymous access to the user’s private data. Moreover, the malware causes an increase of resource consumption. To prevent this, various techniques are currently being used that include static analysis-based detection and dynamic analysis-based detection. But, due to the enhancement in Android malware code-writing techniques, some of these techniques are getting overwhelmed. Therefore, there is a need for an effective Android malware detection approach for which experimental studies were conducted in the present work using the static features of the Android applications such as Standard Permissions with Application Programming Interface (API) calls, Non-standard Permissions with API-calls, API-calls with Standard and Nonstandard Permissions. To select the prominent features, Feature Selection Techniques (FSTs) such as the BI-Normal Separation (BNS), Mutual Information (MI), Relevancy Score (RS), and the Kullback-Leibler (KL) were employed and their effectiveness was measured using the Linear-Support Vector Machine (L-SVM) classifier. It was observed that this classifier achieved Android malware detection accuracy of 99.6\% for the combined features as recommended by the BI-Normal Separation FST.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_17642_6_33,
  title = {AppNet: A Large-Scale Multi-layer Heterogeneous Complex App Network for Intelligent Program Search},
  author = {Xiao, Jianmao and Chen, Shizhan and Feng, Zhiyong and Yang, Jian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {394-399},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-17642-6\_33},
  url = {https://doi.org/10.1007/978-3-030-17642-6\_33},
  abstract = {The resources of mobile application in the app stores contains a vast amount of code and knowledge, which is of great significance to intelligent program search technology, but how to organize and utilize these multi-source heterogeneous data efficiently and integrate semantic information is still a key problem. In this paper, WordNet based AppNet, a multi-layer heterogeneous complex app network model was proposed, it completely describes the hierarchical structure between app-related tags, attributes, and code and in which aims to explore its application in the intelligent program search. Firstly, we expound the construction mechanism of AppNet and describe how does it realize mapping with WordNet, and then two simple real application scenarios were conducted based on AppNet in which to verify its validity and feasibility. We believe that the proposed AppNet model will provide researchers with more efficient ideas in the field of intelligent software development and search.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_1301_5_25,
  title = {ADS-SA: System for Automatically Detecting Sensitive Path of Android Applications Based on Static Analysis},
  author = {Song, Hong and Lin, Dandan and Zhu, Shuang and Wang, Weiping and Zhang, Shigeng},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {309-322},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-1301-5\_25},
  url = {https://doi.org/10.1007/978-981-15-1301-5\_25},
  abstract = {With the booming mobile Internet and Android App market, Android security issues have become increasingly prominent. As the main way for information disclosure in Android Apps, sensitive path has become an important part of Android security research. Aiming at the problem that static analysis cannot verify whether the sensitive path is triggered by reality, this paper proposes a system ADS-SA based on static analysis to automatically detect sensitive path. The system first constructs an Android component conversion diagram through data flow analysis, and then obtains an Android function call graph through control flow analysis. Secondly, the sensitive path backtracking algorithm is designed and used to obtain the sensitive path set. Finally, the automated testing framework, Appium, is used to trigger and verify the authenticity of the sensitive path set. The test results show that the ADS-SA can automatically detect more than 87\% of sensitive paths at a low time cost with high reliability and effectiveness.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_21373_2_10,
  title = {Android Malware Detection Based on Sensitive Permissions and APIs},
  author = {Zhao, Chunhui and Wang, Chundong and Zheng, Wenbai},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2019},
  pages = {105-113},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-21373-2\_10},
  url = {https://doi.org/10.1007/978-3-030-21373-2\_10},
  abstract = {With the widespread use of the Android operating system, the number of applications based on the Android platform is growing. How to effectively identify malware is critical to the security of phones. This paper proposes an Android malware detection method based on the combination of sensitive permissions and API features. This method extracts the permission features and API features by decompiling the APK file, and then uses the mutual information to select sensitive permissions and APIs as feature sets. On this basis, an ensemble learning model based on decision tree classifier and KNN classifier is used to quickly and accurately detect unknown APKs. The experimental results show that the discriminative accuracy of the proposed method is higher than that of the permission set or the API set alone, and the accuracy rate can reach up to 95.5\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_4460_9_9,
  title = {Malware Forensics},
  author = {Reddy, Niranjan},
  booktitle = {Practical Cyber Forensics},
  year = {2019},
  pages = {277-315},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4460-9\_9},
  url = {https://doi.org/10.1007/978-1-4842-4460-9\_9},
  abstract = {Malware is a term coined by merging two words – malicious and software, which is used to define a broad range of software that disrupt computer services, steal data, or compromise user safety. It is used to define a range of intrusive and hostile software applications. Malware are software designed for malicious purposes and deliberately cause harm to its target.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_22038_9_6,
  title = {Overshadow PLC to Detect Remote Control-Logic Injection Attacks},
  author = {Yoo, Hyunguk and Kalle, Sushma and Smith, Jared and Ahmed, Irfan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {109-132},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-22038-9\_6},
  url = {https://doi.org/10.1007/978-3-030-22038-9\_6},
  abstract = {Programmable logic controllers (PLCs) in industrial control systems (ICS) are vulnerable to remote control logic injection attacks. Attackers target the control logic of a PLC to manipulate the behavior of a physical process such as nuclear plants, power grids, and gas pipelines. Control logic attacks have been studied extensively in the literature, including hiding the transfer of a control logic over the network from both packet header-based signatures, and deep packet inspection. For instance, these attacks transfer a control logic code as data, into small fragments (one-byte per packet), that are further padded with noise data. To detect control logic in ICS network traffic, this paper presents Shade , a novel shadow memory technique that observes the network traffic to maintain a local copy of the current state of a PLC memory. To analyze the memory contents, Shade employs a classification algorithm with 42 unique features categorized into five types at different semantic levels of a control logic code, such as number of rungs, number of consecutive decompiled instructions, and n-grams. We then evaluate Shade against control logic injection attacks on two PLCs, Modicon M221 and MicroLogix 1400 from two ICS vendors, Schneider electric and Allen-Bradley, respectively. The evaluation results show that Shade can detect an attack instance (i.e., identifying at least one attack packet during the transfer of a malicious control logic) accurately without any false alarms.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_019_09738_1,
  title = {Empirical assessment of the effort needed to attack programs protected with client/server code splitting},
  author = {Viticchié, Alessio and Regano, Leonardo and Basile, Cataldo and Torchiano, Marco and Ceccato, Mariano and Tonella, Paolo},
  journal = {Empirical Software Engineering},
  year = {2020},
  volume = {25},
  number = {1},
  pages = {1-48},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09738-1},
  url = {https://doi.org/10.1007/s10664-019-09738-1},
  abstract = {Context Code hardening is meant to fight malicious tampering with sensitive code executed on client hosts. Code splitting is a hardening technique that moves selected chunks of code from client to server. Although widely adopted, the effective benefits of code splitting are not fully understood and thoroughly assessed. Objective The objective of this work is to compare non protected code vs. code splitting protected code, considering two levels of the chunk size parameter, in order to assess the effectiveness of the protection - in terms of both attack time and success rate - and to understand the attack strategy and process used to overcome the protection. Method We conducted an experiment with master students performing attack tasks on a small application hardened with different levels of protection. Students carried out their task working at the source code level. Results We observed a statistically significant effect of code splitting on the attack success rate that, on the average, was reduced from 89\% with unprotected clear code to 52\% with the most effective protection. The protection variant that moved some small-sized code chunks turned out to be more effective than the alternative moving fewer but larger chunks. Different strategies were identified yielding different success rates. Moreover we discovered that successful attacks exhibited different process w.r.t. failed ones. Conclusions We found empirical evidence of the effect of code splitting, assessed the relative magnitude, and evaluated the influence of the chunk size parameter. Moreover we extracted the process used to overcome such obfuscation technique.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_13_6577_5_64,
  title = {Design and Implementation of Obfuscating Tool for Software Code Protection},
  author = {Kumar, Akshay and Sharma, Seema},
  booktitle = {Lecture Notes in Mechanical Engineering},
  year = {2019},
  pages = {665-676},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-6577-5\_64},
  url = {https://doi.org/10.1007/978-981-13-6577-5\_64},
  abstract = {Code obfuscation is a technique to protect the raw source code by making different transformations like changing layout and control flow of the code. This is primarily done by the developers/programmers to obstruct code, understanding, and delay malicious code change such that reversing of coding becomes uneconomical by the man at the end (i.e., end user). This technique is adopted in such a fashion that it does not affect the functionalities of the program. The aim of the paper is to make an obfuscator tool, which will provide a graphical utility to the programmers to obfuscate their code. This tool can be used for protecting many high-level languages like Python, JavaScript, Java, and C and C++. It will use cryptographic algorithm to hide the program logic by encrypting and renaming identifier. This paper also aims at introducing a new cryptographic algorithm, which encrypts text to unicode by applying base64 and Devanagari encoding.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_019_09760_3,
  title = {Empirical study of android repackaged applications},
  author = {Khanmohammadi, Kobra and Ebrahimi, Neda and Hamou-Lhadj, Abdelwahab and Khoury, Raphaël},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {6},
  pages = {3587-3629},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09760-3},
  url = {https://doi.org/10.1007/s10664-019-09760-3},
  abstract = {The growing popularity of Android applications has generated increased concerns over the danger of piracy and the spread of malware, and particularly of adware: malware that seeks to present unwanted advertisements to the user. A popular way to distribute malware in the mobile world is through repackaging of legitimate apps. This process consists of downloading, unpacking, manipulating, recompiling an application, and publishing it again in an app store. In this paper, we conduct an empirical study of over 15,000 apps to gain insights into the factors that drive the spread of repackaged apps. We also examine the motivations of developers who publish repackaged apps and those of users who download them, as well as the factors that determine which apps are chosen for repackaging, and the ways in which the apps are modified during the repackaging process. Having observed that adware is particularly prevalent in repackaged apps, we focus on this type of malware and examine how the app is modified when it is injected in an app’s code. Our findings shed much needed light on this class of malware that can be useful to security experts, and allow us to make recommendations that could lead to the creation of more effective malware detection tools, Furthermore, on the basis of our results, we propose a novel app indexing scheme that minimizes the number of comparisons needed to detect repackaged apps.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_15_0118_0_16,
  title = {Integrated Multi-featured Android Malicious Code Detection},
  author = {Yu, Qing and Zhao, Hui},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {207-216},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-0118-0\_16},
  url = {https://doi.org/10.1007/978-981-15-0118-0\_16},
  abstract = {To solve the problem that using a single feature cannot play the role of multiple features of Android application in malicious code detection, an Android malicious code detection mechanism is proposed based on integrated learning on the basis of dynamic and static detection. Considering three types of Android behavior characteristics, a three-layer hybrid algorithm was proposed. And it combined the malicious code detection based on digital signature to improve the detection efficiency. The digital signature of the known malicious code was extracted to form a malicious sample library. The authority that can reflect Android malicious behavior, API call and the running system call features were also extracted. An expandable hybrid discriminant algorithm was designed for the above three types of features. The algorithm was tested with machine learning method by constructing the optimal classifier suitable for the above features. Finally, the Android malicious code detection system was designed and implemented based on the multi-layer hybrid algorithm. The experimental results show that the system performs Android malicious code detection based on the combination of signature and dynamic and static features. Compared with other related work, the system has better performance in execution efficiency and detection rate.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_019_09708_7,
  title = {Understanding the motivations, challenges and needs of Blockchain software developers: a survey},
  author = {Bosu, Amiangshu and Iqbal, Anindya and Shahriyar, Rifat and Chakraborty, Partha},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {4},
  pages = {2636-2673},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09708-7},
  url = {https://doi.org/10.1007/s10664-019-09708-7},
  abstract = {The blockchain technology has potential applications in various areas such as smart-contracts, Internet of Things (IoT), land registry, supply chain management, storing medical data, and identity management. Although GitHub currently hosts more than six thousand active Blockchain software (BCS) projects, few software engineering researchers have investigated these projects and their contributors. Although the number of BCS projects is growing rapidly, the motivations, challenges, and needs of BCS developers remain a puzzle. Therefore, the primary objective of this study is to understand the motivations, challenges, and needs of BCS developers and analyze the differences between BCS and non-BCS development . On this goal, we sent an online survey to 1,604 active BCS developers identified by mining the GitHub repositories of 145 popular BCS projects. The survey received 156 responses that met our criteria for analysis. The results suggest that the majority of the BCS developers are experienced in non-BCS development and are primarily motivated by the ideology of creating a decentralized financial system. Although most of the BCS projects are Open Source Software (OSS) projects by nature, more than 93\% of our respondents found BCS development somewhat different from a non-BCS development as BCS projects have higher emphasis on security and reliability than most of the non-BCS projects. Other differences include: higher costs of defects, decentralized and hostile environment, technological complexity, and difficulty in upgrading the software after release. These differences were also the primary sources of challenges to them. Software development tools that are tuned for non-BCS development are inadequate for BCS and the ecosystem needs an array of new or improved tools, such as: customized IDE for BCS development tasks, debuggers for smart-contracts, testing support, easily deployable simulators, and BCS domain specific design notations.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_05487_8_3,
  title = {If I Had a Million Cryptos: Cryptowallet Application Analysis and a Trojan Proof-of-Concept},
  author = {Haigh, Trevor and Breitinger, Frank and Baggili, Ibrahim},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2019},
  pages = {45-65},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-05487-8\_3},
  url = {https://doi.org/10.1007/978-3-030-05487-8\_3},
  abstract = {Cryptocurrencies have gained wide adoption by enthusiasts and investors. In this work, we examine seven different Android cryptowallet applications for forensic artifacts, but we also assess their security against tampering and reverse engineering. Some of the biggest benefits of cryptocurrency is its security and relative anonymity. For this reason it is vital that wallet applications share the same properties. Our work, however, indicates that this is not the case. Five of the seven applications we tested do not implement basic security measures against reverse engineering. Three of the applications stored sensitive information, like wallet private keys, insecurely and one was able to be decrypted with some effort. One of the applications did not require root access to retrieve the data. We were also able to implement a proof-of-concept trojan which exemplifies how a malicious actor may exploit the lack of security in these applications and exfiltrate user data and cryptocurrency.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_019_00339_6,
  title = {Function matching between binary executables: efficient algorithms and features},
  author = {Karamitas, Chariton and Kehagias, Athanasios},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2019},
  volume = {15},
  number = {4},
  pages = {307-323},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-019-00339-6},
  url = {https://doi.org/10.1007/s11416-019-00339-6},
  abstract = {Binary diffing consists in comparing syntactic and semantic differences of two programs in binary form, when source code is unavailable. It can be reduced to a graph isomorphism problem between the Control Flow Graphs , Call Graphs or other forms of graphs of the compared programs. Here we present REveal, a prototype tool which implements a binary diffing algorithm and an associated set of features, extracted from a binary’s CG and CFGs. Additionally, we explore the potential of applying Markov lumping techniques on function CFGs. The proposed algorithm and features are evaluated in a series of experiments on executables compiled for i386 , amd64 , arm and aarch64 . Furthermore, the effectiveness of our prototype tool, code-named REveal, is assessed in a second series of experiments involving clustering of a corpus of 18 malware samples into 5 malware families. REveal’s results are compared against those produced by Diaphora, the most widely used binary diffing software of the public domain. We conclude that REveal improves the state-of-the-art in binary diffing by achieving higher matching scores, obtained at the cost of a slight running time increase, in most of the experiments conducted. Furthermore, REveal successfully partitions the malware corpus into clusters consisting of samples of the same malware family.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_13_5826_5_30,
  title = {DeepMal4J: Java Malware Detection Employing Deep Learning},
  author = {Jha, Pallavi Kumari and Shankar, Prem and Sujadevi, V. G. and Prabhaharan, P.},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {389-402},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-5826-5\_30},
  url = {https://doi.org/10.1007/978-981-13-5826-5\_30},
  abstract = {Java is a cross-platform general purpose programming language. Hence, any Java based malware becomes a cross-platform threat. Since 3 Billion devices run Java, it is a serious threat. Currently, there is very little research done in the area of detection of Java malwares. As deep learning recently has proven to be effective in malware detection, we experimented with deep learning algorithms for detecting Java based malware. We name it DeepMal4J and evaluated using Long Short Term Memory (LSTM) and Gated Recurrent Unit (GRU). Our work is a first attempt to use deep neural network for the detection of Java malwares. Our system achieved accuracy of 93.33\% using LSTM. This is the first ever reported results of deep learning for Java malware detection. We also present the comparison of performances and accuracy rates. Our system can be scaled up for large scale malware analysis.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_02768_1_15,
  title = {Formal Small-Step Verification of a Call-by-Value Lambda Calculus Machine},
  author = {Kunze, Fabian and Smolka, Gert and Forster, Yannick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {264-283},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-02768-1\_15},
  url = {https://doi.org/10.1007/978-3-030-02768-1\_15},
  abstract = {We formally verify an abstract machine for a call-by-value \\(\\lambda \\) -calculus with de Bruijn terms, simple substitution, and small-step semantics. We follow a stepwise refinement approach starting with a naive stack machine with substitution. We then refine to a machine with closures, and finally to a machine with a heap providing structure sharing for closures. We prove the correctness of the three refinement steps with compositional small-step bottom-up simulations. There is an accompanying Coq development verifying all results.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_29962_0_3,
  title = {BinEye: Towards Efficient Binary Authorship Characterization Using Deep Learning},
  author = {Alrabaee, Saed and Karbab, ElMouatez Billah and Wang, Lingyu and Debbabi, Mourad},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {47-67},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-29962-0\_3},
  url = {https://doi.org/10.1007/978-3-030-29962-0\_3},
  abstract = {In this paper, we present BinEye , an innovative tool which trains a system of three convolutional neural networks to characterize the authors of program binaries based on novel sets of features. The first set of features is obtained by converting an executable binary code into a gray image; the second by transforming each executable into a series of bytecode; and the third by representing each function in terms of its opcodes. By leveraging advances in deep learning, we are then able to characterize a large set of authors. This is accomplished even without the missing features and despite the complications arising from compilation. In fact, BinEye does not require any prior knowledge of the target binary. More important, an analysis of the model provides a satisfying explanation of the results obtained: BinEye is able to auto-learn each author’s coding style and thus characterize the authors of program binaries. We evaluated BinEye on large datasets extracted from selected open-source C++ projects in GitHub, Google Code Jam events, and several programming projects, comparing it wiexperimental results demonstrate that BinEye characterizes a larger number of authors with a significantly higher accuracy (above 90\%). We also employed it in the context of several case studies. When applied to Zeus and Citadel, BinEye found that this pair might be associated with common authors. For other packages, BinEye demonstrated its ability to identify the presence of multiple authors in binary code.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_019_00338_7,
  title = {A Cyber-Kill-Chain based taxonomy of crypto-ransomware features},
  author = {Dargahi, Tooska and Dehghantanha, Ali and Bahrami, Pooneh Nikkhah and Conti, Mauro and Bianchi, Giuseppe and Benedetto, Loris},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2019},
  volume = {15},
  number = {4},
  pages = {277-305},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-019-00338-7},
  url = {https://doi.org/10.1007/s11416-019-00338-7},
  abstract = {In spite of being just a few years old, ransomware is quickly becoming a serious threat to our digital infrastructures, data and services. Majority of ransomware families are requesting for a ransom payment to restore a custodian access or decrypt data which were encrypted by the ransomware earlier. Although the ransomware attack strategy seems to be simple, security specialists ranked ransomware as a sophisticated attack vector with many variations and families. Wide range of features which are available in different families and versions of ransomware further complicates their detection and analysis. Though the existing body of research provides significant discussions about ransomware details and capabilities, the all research body is fragmented. Therefore, a ransomware feature taxonomy would advance cyber defenders’ understanding of associated risks of ransomware. In this paper we provide, to the best of our knowledge, the first scientific taxonomy of ransomware features, aligned with Lockheed Martin Cyber Kill Chain (CKC) model. CKC is a well-established model in industry that describes stages of cyber intrusion attempts. To ease the challenge of applying our taxonomy in real world, we also provide the corresponding ransomware defence taxonomy aligned with Courses of Action matrix (an intelligence-driven defence model). We believe that this research study is of high value for the cyber security research community, as it provides the researchers with a means of assessing the vulnerabilities and attack vectors towards the intended victims.},
  content_type = {Article},
}


@article{springer_10_1007_s11280_019_00675_z,
  title = {MALDC: a depth detection method for malware based on behavior chains},
  author = {Zhang, Hao and Zhang, Wenjun and Lv, Zhihan and Sangaiah, Arun Kumar and Huang, Tao and Chilamkurti, Naveen},
  journal = {World Wide Web},
  year = {2020},
  volume = {23},
  number = {2},
  pages = {991-1010},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11280-019-00675-z},
  url = {https://doi.org/10.1007/s11280-019-00675-z},
  abstract = {Malicious behavior detection is a key topic that has been a focus in the field of intrusion detection. Current intrusion detection systems are primarily based on single-point monitoring and detection and cannot detect attack modes with a hidden attack frequency. The idea presented in this paper is the incorporation of API call sequence software into the analysis and the construction of behavior chains to express the behavior patterns in software. This paper introduces related definitions of behavioral points and behaviors and proposes a depth-detection method for malware based on behavior chains (MALDC). The method monitors behavior points based on API calls and then uses the calling sequence of those behavior points at runtime to construct a behavior chain. Finally, we use depth detection method based on long short-term memory(LSTM) to detect malicious behavior from the behavior chains. To verify the performance of the proposed model, we conducted a large experiment on 54,324 malware and 53,361 benign samples collected from Windows systems and used those samples to train and test the model. Comparative verification by using various classifiers showed that the behavior points extracted based on the above method and the constructed behavior chains can be used to recognize malicious behavior at a high recognition rate. The method achieved an accuracy of 98.64\% with a false positive rate of less than 2\% in the best case, which is a satisfactory recognition rate for detecting malicious software behavior.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_7605_3_125,
  title = {Method to Modify the Hex of Android Manifest File in Android Apps for Dynamic Analysis},
  author = {Lee, Suhyoo and Park, Junhoo and Ryou, Jaecheol},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2018},
  pages = {784-789},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-7605-3\_125},
  url = {https://doi.org/10.1007/978-981-10-7605-3\_125},
  abstract = {Analysts sometimes need to analyze the app depending on the situation. There are two main ways to analyze Android apps. This is the static analysis that grasps the flow of the app through the source code and the dynamic analysis that analyzes the variable that changes during the app’s operation. For dynamic analysis, this can be done by setting the debugging option of the Android Manifest file. In most cases, modification is done by decompiling the app and modifying the original source. In some cases, however, there is a problem with the decompiling process. So we propose a way to modify the debugging option of the Android manifest file to “true” without decompiling the app.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_019_09699_5,
  title = {Semantics-driven extraction of timed automata from Java programs},
  author = {Liva, Giovanni and Khan, Muhammad Taimoor and Pinzger, Martin},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {5},
  pages = {3114-3150},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09699-5},
  url = {https://doi.org/10.1007/s10664-019-09699-5},
  abstract = {The automatic verification of time properties of models extracted from programs is challenging, mainly because modern programming languages, such as Java, represent time without a proper semantics. Current approaches to extract time models from source code either represent time only as a tree-like sequence of events or require developers to manually provide a formal model of the time behavior. This makes it difficult for software developers to verify various aspects of their systems, such as timeouts, delays and periodicity of the execution. In this paper, we introduce a formal definition of the time semantics for the Java programming language. Based on the semantics, we present an approach to automatically extract timed automata and their time constraints from Java programs at method level. First, our approach detects the Java statements that involve time, from which it then extracts the timed automata. Our extracted automata are directly amenable to the verification of time properties of the corresponding Java methods. We evaluated the accuracy of our approach on twenty open source Java projects that implement time behavior in their source code. The results show that our approach achieves 100\% precision and recall in identifying time related information. They also show that 95\% of the timed automata extracted from source code correctly model the time behavior of the method. Finally, we show the applicability of our timed automata to identify eight real errors in four open source Apache systems.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_3108_1_8,
  title = {Classes and Fields},
  author = {Weston, Toby},
  booktitle = {Scala for Java Developers},
  year = {2018},
  pages = {43-52},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-3108-1\_8},
  url = {https://doi.org/10.1007/978-1-4842-3108-1\_8},
  abstract = {How Scala makes things easier when defining fields.},
  content_type = {Chapter},
}


@article{springer_10_1007_s42044_019_00032_3,
  title = {A new technique for intent elicitation in Android applications},
  author = {El-Zawawy, Mohamed A.},
  journal = {Iran Journal of Computer Science},
  year = {2019},
  volume = {2},
  number = {2},
  pages = {113-124},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42044-019-00032-3},
  url = {https://doi.org/10.1007/s42044-019-00032-3},
  abstract = {Android is the most common operating system for smart phones. An Android application is composed of components. Intents are messaging objects. Components communicate using intents. This communication is between components of the same application or different applications. Many security attacks use intents. This paper introduces a new technique, IntGet , for elicitation of intents from Android applications. IntGet was implemented and tested on 359461 smali files of 40 applications. The experimental results revealed that IntGet can be used for designing efficient malware detection methods. The paper shows comparisons between results obtained by IntGet and those obtained by Androguard .},
  content_type = {Article},
}


@article{springer_10_1007_s42417_019_00172_7,
  title = {Study for the Identification of Dominant Frequencies and Sensitive Structure on Machine Tools Using Modal Decoupling and Structural Sensitivity Analysis},
  author = {Yin, Ling and Liu, Quanxin and Zhang, Fei and Zhou, Zirong and Ullah, Saif},
  journal = {Journal of Vibration Engineering \& Technologies},
  year = {2019},
  volume = {7},
  number = {5},
  pages = {507-517},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42417-019-00172-7},
  url = {https://doi.org/10.1007/s42417-019-00172-7},
  abstract = {Background The research on machine tool vibration has significant impact to improve the processing quality of the processed parts. The vibration response on the surface quality is quite different based on different modes of vibration. Purpose Current study proposed a new approach of modes decoupling based on Operational Deflection Shape (ODS) and structural sensitivity analysis, which used to identify the structural vibrations on surface topography in manufacturing process. Method According to the modes decoupling based on the ODS method, the dominant vibration frequencies of machine tool are identified in a wide range of frequency band. Furthermore, the modal mass distribution matrix analysis is used to determine the sensitive structures that cause greater machining errors. A milling process is used to conduct experiments. Results The experimental and theoretical results indicate that (i) the contribution of dominant vibration frequency to the vibration of machine tool is larger than weak modes vibration and (ii) the sensitive structure has higher vibration energy than the insensitive structures. Conclusion The multimode vibration at dominant frequencies of the sensitive structures (MVDFSS) directly can determine the surface topography of the products.},
  content_type = {Article},
}


@article{springer_10_1186_s13635_019_0095_1,
  title = {Crowdsourcing for click fraud detection},
  author = {Mouawi, Riwa and Elhajj, Imad H. and Chehab, Ali and Kayssi, Ayman},
  journal = {EURASIP Journal on Information Security},
  year = {2019},
  volume = {2019},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13635-019-0095-1},
  url = {https://doi.org/10.1186/s13635-019-0095-1},
  abstract = {Mobile ads are plagued with fraudulent clicks which is a major challenge for the advertising community. Although popular ad networks use many techniques to detect click fraud, they do not protect the client from possible collusion between publishers and ad networks. In addition, ad networks are not able to monitor the user’s activity for click fraud detection once they are redirected to the advertising site after clicking the ad. We propose a new crowdsource-based system called Click Fraud Crowdsourcing (CFC) that collaborates with both advertisers and ad networks in order to protect both parties from any possible click fraudulent acts. The system benefits from both a global view, where it gathers multiple ad requests corresponding to different ad network-publisher-advertiser combinations, and a local view, where it is able to track the users’ engagement in each advertising website. The results demonstrated that our approach offers a lower false positive rate (0.1) when detecting click fraud as opposed to proposed solutions in the literature, while maintaining a high true positive rate (0.9). Furthermore, we propose a new mobile ad charging model that benefits from our system to charge advertisers based on the duration spent in the advertiser’s website.},
  content_type = {Article},
}


@article{springer_10_1007_s13389_019_00215_5,
  title = {Physical model of sensitive data leakage from PC-based cryptographic systems},
  author = {Levina, Alla and Mostovoi, Roman and Sleptsova, Daria and Tcvetkov, Lavrentii},
  journal = {Journal of Cryptographic Engineering},
  year = {2019},
  volume = {9},
  number = {4},
  pages = {393-400},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s13389-019-00215-5},
  url = {https://doi.org/10.1007/s13389-019-00215-5},
  abstract = {In this paper, we present an examination of several side-channel attack scenarios on PC-based cryptosystems. Our goal was the development of a unified physical model for sensitive information leakage. The main focus of our work was electromagnetic side channels since signals with high signal-to-noise ratio (SNR) can be more conveniently captured. Moreover, the attacker can make correlations of the EM signal with other types of side-channel signals (such as voltage fluctuations and acoustic emanations). It shows that there may be a common source for a vulnerable signal that passes through several sides channels. We have simulated several attacks on targeted cryptosystems with distinct instruction sets. Trace analysis reveals empirical evidence. which corresponds to the theoretical principles of the mechanisms x86 and x64 processors. Hardware reasons for leakage come from the instructions and data in the processor cache, to be specific, from the fluctuations of power consumption, leading to changes in the voltage regulator of the processor. Thus, the fluctuations in LC circuits result in leakage on multiple side channels. In general, the obtained data together with the principles of signal formation can be used in vulnerability testing, which can examine side-channel robustness of cryptographic software on the first steps of development.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_5287_1_14,
  title = {Reading and Understanding Code},
  author = {Smith, Stephen},
  booktitle = {Raspberry Pi Assembly Language Programming},
  year = {2019},
  pages = {265-279},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-5287-1\_14},
  url = {https://doi.org/10.1007/978-1-4842-5287-1\_14},
  abstract = {We’ve now learned quite a bit of ARM 32-bit Assembly language; one of the things we can do is read another programmer’s code. Reading other programmer’s code is a great way to add to our toolkit of tips and tricks and improve our own coding. We’ll review some places where you can find Assembly source code for the ARM 32. Then we’ll look at how the GNU C compiler writes Assembly code and how we can analyze it. We’ll look at the NSA’s Ghidra hacking tool that can convert Assembly code back into C code—at least approximately.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_10_8639_7_9,
  title = {Android Malware Detection Mechanism Based on Bayesian Model Averaging},
  author = {Roopak, S. and Thomas, Tony and Emmanuel, Sabu},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {87-96},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-8639-7\_9},
  url = {https://doi.org/10.1007/978-981-10-8639-7\_9},
  abstract = {Since Android is the most widely used operating system for mobile devices, it has been a target for widespread malware attacks. During the past years, many new malware detection mechanisms have been introduced for the Android platform. These methods are generally classified as static analysis and dynamic analysis methods. However, none of the existing mechanisms are able to detect the malware applications with reasonable false positive and negative rates. This is a major concern in the field of Android malware detection. In this paper, we propose a novel malware detection mechanism by combining the estimated malicious probability values of three distinct naive Bayes classifiers based on API calls, permissions, and system calls using Bayesian model averaging approach. The majority of the existing Android malwares have signatures in at least one of API calls, permissions, or system call sequences. Hence, the proposed mechanism can overcome the limitations of the existing static and dynamic malware detection mechanism to a good extent. Our experiments have shown that the proposed mechanism is more accurate than the existing static and dynamic malware detection mechanisms.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_74950_1_6,
  title = {Reverse Engineering of Code},
  author = {Lysne, Olav},
  booktitle = {The Huawei and Snowden Questions},
  year = {2018},
  pages = {47-55},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-74950-1\_6},
  url = {https://doi.org/10.1007/978-3-319-74950-1\_6},
  abstract = {The ability to reverse engineer a product has been important for as long as technology has existed. A vital activity in most branches of industrial design and production has been to acquire samples of the products sold by competing companies and pick them apart. Understanding the engineering done by your competing opponents can shed insight into the strengths and weaknesses of their products, reveal the engineering ideas behind their products’ features, and fertilize and further improve the innovation that goes on in one’s own company.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_13_3702_4_2,
  title = {Byte Label Malware Classification Using Image Entropy},
  author = {Dey, Ayan and Bhattacharya, Sukriti and Chaki, Nabendu},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {17-29},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-3702-4\_2},
  url = {https://doi.org/10.1007/978-981-13-3702-4\_2},
  abstract = {Malware continues to be an ongoing threat to modern computing. In our research, we present a byte level malware classification technique which is basically an improvement on an existing work [ 1 ]. We introduced an information theoretic point of view an already existing image-based malware detection method. The introducing entropy filter helps to identify the hidden patterns introduced by certain packers and encryptors, hence yields better accuracy and false positive rate than the existing method. We have implemented a proof-of-concept version of the proposed technique and evaluated it over a fairly large set of malware samples cover different malware classes from different malware families and malware authors.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_019_00335_w,
  title = {Mac-A-Mal: macOS malware analysis framework resistant to anti evasion techniques},
  author = {Pham, Duy-Phuc and Vu, Duc-Ly and Massacci, Fabio},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2019},
  volume = {15},
  number = {4},
  pages = {249-257},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-019-00335-w},
  url = {https://doi.org/10.1007/s11416-019-00335-w},
  abstract = {With macOS increasing popularity, the number, and variety of macOS malware are rising as well. Yet, very few tools exist for dynamic analysis of macOS malware. In this paper, we propose a macOS malware analysis framework called Mac-A-Mal. We develop a kernel extension to monitor malware behavior and mitigate several anti-evasion techniques used in the wild. Our framework exploits the macOS features of XPC service invocation that typically escape traditional mechanisms for detection of children processes. Performance benchmarks show that our system is comparable with professional tools and able to withstand VM detection. By using Mac-A-Mal, we discovered 71 unknown adware samples (8 of them using valid distribution certificates), 2 keyloggers, and 1 previously unseen trojan involved in the APT32 OceanLotus.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_8848_3_31,
  title = {A Comparative Analysis of Static and Dynamic Java Bytecode Watermarking Algorithms},
  author = {Kumar, Krishan and Kaur, Prabhpreet},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {319-334},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-8848-3\_31},
  url = {https://doi.org/10.1007/978-981-10-8848-3\_31},
  abstract = {Software piracy is one of the most serious issues confronted by software industry creating a huge number of dollars misfortune consistently to the product creating organizations. The worldwide income misfortune was assessed to be more than \$62.7 billion in the year 2013 because of the product theft. Software watermarking demoralizes theft, as a proof of procurement or origin, and likewise helps in following the wellspring of unlawful redistribution of duplicates of programming. In this paper, we have compared and analyzed the static and dynamic Java bytecode watermarking algorithms. Firstly, each Java jar file is watermarked using the watermarking algorithms, and after this, distortive attacks are applied to each watermarked program by applying obfuscation and optimizing. After studying the results obtained, we found that dynamic watermarking algorithms are slightly better than static watermarking algorithms.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_35092_5_5,
  title = {Running on Fumes},
  author = {Albert, Elvira and Gordillo, Pablo and Rubio, Albert and Sergey, Ilya},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {63-78},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-35092-5\_5},
  url = {https://doi.org/10.1007/978-3-030-35092-5\_5},
  abstract = {Gas is a measurement unit of the computational effort that it will take to execute every single operation that takes part in the Ethereum blockchain platform. Each instruction executed by the Ethereum Virtual Machine (EVM) has an associated gas consumption specified by Ethereum. If a transaction exceeds the amount of gas allotted by the user (known as gas limit), an out-of-gas exception is raised. There is a wide family of contract vulnerabilities due to out-of-gas behaviors. We report on the design and implementation of Gastap , a Gas-Aware Smart contracT Analysis Platform, which takes as input a smart contract (either in EVM, disassembled EVM, or in Solidity source code) and automatically infers gas upper bounds for all its public functions. Our bounds ensure that if the gas limit paid by the user is higher than our inferred gas bounds, the contract is free of out-of-gas vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_13_1733_0_1,
  title = {A Multidimensional Feature Extraction Method Based on Android Malware Detection},
  author = {Xue, Fei and You, Siqing and Qi, Zhaoqun and Liu, Hongjie},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2019},
  pages = {3-8},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-1733-0\_1},
  url = {https://doi.org/10.1007/978-981-13-1733-0\_1},
  abstract = {Due to its unique open source Android system has become a leader in the field of smart phones, allowing researchers to conduct a multi-angle study of the Android system. However, Android system has become malicious code attacks preferred target because of its open source features. For the existing detection scheme in terms of feature extraction due to the selection of too few types of features, the selected features contribute little to the classification accuracy of the classifier is not high and so on. This paper proposes a combination of dynamic and static multidimensional mixed feature extraction scheme, compared with the extraction scheme which only analyzes the authority and the function call, this paper extracts twelve types of features, which reflect the behavior of Android application from multiple perspectives and improve the comprehensiveness of feature extraction.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_59463_7_75,
  title = {DroidMark: A Lightweight Android Text and Space Watermark Scheme Based on Semantics of XML and DEX},
  author = {Zeng, Lingling and Ren, Wei and Lei, Min and Yang, Yu},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2018},
  pages = {756-766},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-59463-7\_75},
  url = {https://doi.org/10.1007/978-3-319-59463-7\_75},
  abstract = {Android platform induces an open application development framework to attract more developers and promote larger market occupations at the same time. However, the open architecture also makes it easier to reverse engineering and application piracy. These result in the property loss for developers and companies, and increase the risks of mobile malicious code. Copyright protection for android application is thus of significant importance. Currently, many solutions for application copyright protection apply overload methods, assuming the availability of source code, which could be impractical for a large scale application protection. In this paper, we propose a lightweight copyright protection method for android application called DroidMark. The copyright is protected by text and space watermark based on semantics of xml and dex. Functional files are chosen as watermark carriers to increase watermark semi-fragileness and concealment. And the DroidMark can be accomplished without secret keys. Models and algorithms are proposed and analyzed all sidedly. The experiment results and analysis justified that DroidMark is secure and efficient.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_8848_3_26,
  title = {Control Flow Graph Matching for Detecting Obfuscated Programs},
  author = {Behera, Chandan Kumar and Sanjog, Genius and Lalitha Bhaskari, D.},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {267-275},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-8848-3\_26},
  url = {https://doi.org/10.1007/978-981-10-8848-3\_26},
  abstract = {Malicious programs like the viruses, worms, Trojan horses, and backdoors infect host computers by taking advantage of flaws of the software and thereby introducing some kind of secret functionalities. The authors of these malicious programs attempt to find new methods to get avoided from detection engines. They use different obfuscation techniques such as dead code insertion, instruction substitution to make the malicious programs more complex. Initially, obfuscation techniques those are used by software developers to protect their software from piracy are now misused by these malware authors. This paper intends to detect such obfuscated programs or malware using control flow graph (CFG) matching technique, using VF2 algorithm. If the original CFG of the executable is found to be isomorphic to subgraph of obfuscated CFG (under examination), then it can be classified as an obfuscated one.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11227_017_2205_5,
  title = {Mobile forensic reference set (MFReS) and mobile forensic investigation for android devices},
  author = {Kim, Dohyun and Lee, Yunho and Lee, Sangjin},
  journal = {The Journal of Supercomputing},
  year = {2018},
  volume = {74},
  number = {12},
  pages = {6618-6632},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-017-2205-5},
  url = {https://doi.org/10.1007/s11227-017-2205-5},
  abstract = {This paper proposes the mobile forensic reference set (MFReS), a mobile forensic investigation procedure and a tool for mobile forensics that we developed. The MFReS consists of repositories, databases, and services that can easily retrieve data from a database, which can be used to effectively classify meaningful data related to crime, among numerous data types in mobile devices. Mobile data consist of system data, application data, and multimedia data according to characteristics and format. We have developed a mobile forensic process that can effectively analyze information from installed applications and user behavior through these data. In particular, our tool can be useful for investigators because it can analyze the log files of all applications (apps) and analyze behavior based on timeline, geodata, and other characteristics. Our research can contribute to the study of mobile forensic support systems and suggest the direction of mobile data analysis tool development.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_6385_5_23,
  title = {Android Malware Detection Using Local Binary Pattern and Principal Component Analysis},
  author = {Wu, Qixin and Qin, Zheng and Zhang, Jinxin and Yin, Hui and Yang, Guangyi and Hu, Kuangsheng},
  booktitle = {Communications in Computer and Information Science},
  year = {2017},
  pages = {262-275},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-6385-5\_23},
  url = {https://doi.org/10.1007/978-981-10-6385-5\_23},
  abstract = {Nowadays, analysis methods based on big data have been widely used in malicious software detection. Since Android has become the dominator of smartphone operating system market, the number of Android malicious applications are increasing rapidly as well, which attracts attention of malware attackers and researchers alike. Due to the endless evolution of the malware, it is critical to apply the analysis methods based on machine learning to detect malwares and stop them from leakaging our privacy information. In this paper, we propose a novel Android malware detection method based on binary texture feature recognition by Local Binary Pattern and Principal Component Analysis, which can visualize malware and detect malware accurately. Also, our method analyzes malware binary directly without any decompiler, sandbox or virtual machines, which avoid time and resource consumption caused by decompiler or monitor in this process. Experimentation on 5127 benigns and 5560 malwares shows that we obtain a detection accuracy of 90\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_03745_1_15,
  title = {Analysis and Detection of Android App Privilege Escalation Vulnerability Based on Machine Learning},
  author = {Xin, Jiang and Wen, Zhang and Shaozhang, Niu and Yiming, Xue},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2019},
  pages = {117-123},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-03745-1\_15},
  url = {https://doi.org/10.1007/978-3-030-03745-1\_15},
  abstract = {Android is currently playing an important role in smartphone operating systems. However, there are potential risks hidden in Android applications. One of them is application vulnerability, which can put users’ information in danger. In this paper, we investigate the machine learning techniques in identify one of the most common application vulnerabilities—privilege escalation vulnerability (referred as PE vulnerability). We propose a machine learning system for detecting PE vulnerability. Our method is component-based detection, which means a more granular method. In this way, we can not only identify App with problems, but also locate component with loopholes. We first analyze the principle of PE vulnerability’s formation process, and then propose an EMPC model according to key elements in the process. The model is used to select features in the following steps. Second, we apply machine learning techniques to build a classification model to classify samples. Seven classification algorithms are applied. The experiment results show that our method is feasible in detecting PE vulnerability in component-degree.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_26601_1_3,
  title = {Formal Verification of Memory Preservation of x86-64 Binaries},
  author = {Bockenek, Joshua A. and Verbeek, Freek and Lammich, Peter and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {35-49},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-26601-1\_3},
  url = {https://doi.org/10.1007/978-3-030-26601-1\_3},
  abstract = {Formal verification of a binary can provide high software assurance, even when the source code is unavailable. It is, however, inherently hard due to the low level of abstraction involved; instead of verifying typed and structured source code, one has to verify machine code or reconstructed assembly. This paper presents a semi-automated methodology for formally verifying memory preservation, as well as register preservation, over disassembled binaries. The methodology is based on formal symbolic execution and Floyd-style verification. We show that the methodology is compositional on the function level, which is crucial for scalability. The methodology works for loops, recursion, and both optimized and non-optimized code. It can be used to expose preconditions required for non-exceptional behavior. We demonstrate applicability by verifying a set of functions from the HermitCore unikernel library.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_04648_4_27,
  title = {App Tamper Detection and Retrospective Program Research},
  author = {Jiang, Wenrong},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {318-329},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-04648-4\_27},
  url = {https://doi.org/10.1007/978-3-030-04648-4\_27},
  abstract = {In recent years, the rapid development of mobile Internet, the arrival of 3G, 4G era, the decline in the cost of production of smart mobile terminals, smart phones in people learning, work and life in the penetration rate is higher and higher. But some of the free open source platform features not only give developers a broader space for development, but also to the user to add a lot of security risks, especially the risk of APP to tamper-based. Based on the research of APP tampering detection and retrospective research, this paper elaborates its research background and significance, and introduces the present situation of mainstream protection technology. Then, it introduces the reliable identification of APP tampering, tampering with APP’s retrospective and tampering with APP risk surface Evaluation, probe SDK self-protection technology program design, and the program to test the environment deployment, display functional effects.e sheet.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_13_9190_3_67,
  title = {Malware Detection Method Based on CNN},
  author = {Kuo, Wen-Chung and Lin, Yu-Pin},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {608-617},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-9190-3\_67},
  url = {https://doi.org/10.1007/978-981-13-9190-3\_67},
  abstract = {With the widespread use of smartphones, many malware attacks such as user’s private information is stolen or leaking have been proposed. Furthermore, the hacker can manipulate these smartphones to become a member of malicious attackers. Therefore, how to detect the malware application has become one of the most important issues. Until now, two detection methods (static analysis and dynamic analysis) were discussed. For the static analysis view, it observes the source code to determine whether it is a malware application. However, the source code will be processed (such as packing or confusion) before it is shared. Therefore, the static analysis method is not able to detect it because we cannot get the recover code correctly and completely. In order to overcome this disadvantage, a new detection method based on CNN (convolutional neural network) will be proposed in this paper. The major contribution of our proposed scheme is that we can decompress the APK (Android application package) file directly, to obtain the classes.dex file and then uses the training detection model to determine whether the input classes.dex is malicious code or not. Finally, according to the experiment results, our proposed scheme is available for all APKs with an accuracy rate is 94\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_05487_8_4,
  title = {AndroParse - An Android Feature Extraction Framework and Dataset},
  author = {Schmicker, Robert and Breitinger, Frank and Baggili, Ibrahim},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2019},
  pages = {66-88},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-05487-8\_4},
  url = {https://doi.org/10.1007/978-3-030-05487-8\_4},
  abstract = {Android malware has become a major challenge. As a consequence, practitioners and researchers spend a significant time analyzing Android applications (APK). A common procedure (especially for data scientists) is to extract features such as permissions, APIs or strings which can then be analyzed. Current state of the art tools have three major issues: (1) a single tool cannot extract all the significant features used by scientists and practitioners (2) Current tools are not designed to be extensible and (3) Existing parsers can be timely as they are not runtime efficient or scalable. Therefore, this work presents AndroParse which is an open-source Android parser written in Golang that currently extracts the four most common features: Permissions, APIs, Strings and Intents. AndroParse outputs JSON files as they can easily be used by most major programming languages. Constructing the parser allowed us to create an extensive feature dataset which can be accessed by our independent REST API. Our dataset currently has 67,703 benign and 46,683 malicious APK samples.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_13_9942_8_18,
  title = {Ransomware Analysis Using Reverse Engineering},
  author = {Naveen, S. and Gireesh Kumar, T.},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {185-194},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-9942-8\_18},
  url = {https://doi.org/10.1007/978-981-13-9942-8\_18},
  abstract = {Ransomware threat continues to grow over years. The existing defense techniques for detecting malicious malware will never be sufficient because of Malware Persistence Techniques. Packed malware makes analysis harder \& also it may sound like a trusted executable for evading modern antivirus. This paper focuses on the analysis part of few ransomware samples using different reverse engineering tools \& techniques. There are many automated tools available for performing malware analysis, but reversing it manually helped to write two different patches for Wannacry ransomware. Execution of patched ransomware will not encrypt the user machine. Due to new advanced evading techniques like Anti-Virtual Machine (VM) \& Anti-debugging, automated malware analysis tools will be less useful. The Application Programming Interface (API) calls which we used to create patch, were used to create Yara rule for detecting different variants of the same malware as well.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_21548_4_40,
  title = {Automated Cash Mining Attacks on Mobile Advertising Networks},
  author = {Ji, Woojoong and Kim, Taeyun and Kim, Kuyju and Kim, Hyoungshick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {679-686},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-21548-4\_40},
  url = {https://doi.org/10.1007/978-3-030-21548-4\_40},
  abstract = {Rewarded advertisements are popularly used in the mobile advertising industry. In this paper, we analyze several rewarded advertisement applications to discover security weaknesses, which allow malicious users to automatically generate in-app activities for earning cash rewards on advertisement networks; we call this attack automated cash mining . To show the risk of this attack, we implemented automated cashing attacks on four popularly used Android applications ( Cash Slide , Fronto , Honey Screen and Screen Stash ) with rewarded advertisements through reverse engineering and demonstrated that all the tested reward apps are vulnerable to our attack implementation.},
  content_type = {Conference paper},
}


@article{springer_10_3103_s0146411618080096,
  title = {An Approach to the Programs Security Analysis using Vector Representation of Machine Code},
  author = {Demidov, R. A. and Pechenkin, A. I.},
  journal = {Automatic Control and Computer Sciences},
  year = {2018},
  volume = {52},
  number = {8},
  pages = {1010-1016},
  publisher = {Allerton Press},
  doi = {10.3103/s0146411618080096},
  url = {https://doi.org/10.3103/s0146411618080096},
  abstract = {In this article, the authors propose an approach to the security analysis of program code using vector representations of machine instructions. The article also proposes a method for constructing multidimensional vector spaces for a set of program code instructions. The construction of semantically expressive vector representations of machine instructions is considered as one of the important tasks in constructing a neural network code classifier for vulnerabilities. The applicability of the principle of transfer learning to machine code is demonstrated experimentally.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_15_0111_1_17,
  title = {Data Obfuscation Using Secret Sharing},
  author = {Sidhardhan, Manasa and Praveen, K.},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {183-191},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-0111-1\_17},
  url = {https://doi.org/10.1007/978-981-15-0111-1\_17},
  abstract = {Many software developers use the technique of obfuscation to make data and code unintelligible. Obfuscation techniques can be used independently for code and data alone, but these days software developers combine these techniques to protect code and data which in turn increases the complexity of reverse engineering. Data obfuscation is used to protect personally identifiable information or sensitive information used in military applications. Data obfuscation is also used to protect digital content under the Digital Rights Management (DRM) Protection. Code obfuscation can be used to protect the code. This paper proposes a variable encoding data obfuscation approach using secret sharing technique. Here in our approach an integer variable is encoded using number theory based Shamir’s Secret Sharing method. We have also shown that our obfuscation approach is resilient to slicing attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_22868_2_34,
  title = {Evaluating Machine Learning Models on the Ethereum Blockchain for Android Malware Detection},
  author = {Rana, Md. Shohel and Gudla, Charan and Sung, Andrew H.},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {446-461},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-22868-2\_34},
  url = {https://doi.org/10.1007/978-3-030-22868-2\_34},
  abstract = {Android, the most popular mobile operating system, with billions of active users and more than 2 million apps, has motivated advertisers, hackers, fraudsters and cyber-criminals to develop malware of all types for it. In recent years, extensive research has been conducted on malware analysis and detection for Android devices, even though Android has already implemented various security mechanisms to deal with the problem. In this paper, we developed a consortium blockchain network to evaluate various machine learning models for a given malware dataset. A reward is offered using smart contracts as an incentive to the competitors for their work by allowing them to submit solutions through training with selected machine learning models in a secure and trustworthy manner. The analysis of datasets by competitors helps various organizations in the network to enhance or boost their current malware detection or defense tools. The decentralized network provides transparency, enhances security and reduces the cost in managing all relevant data by eliminating third parties. We used DREBIN dataset in the developed framework for initial experiments and the encouraging results are presented.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_8968_8_27,
  title = {Android Anti-malware Techniques and Its Vulnerabilities: A Survey},
  author = {Thakur, Deepak and Gera, Tanya and Singh, Jaiteg},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {315-328},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-8968-8\_27},
  url = {https://doi.org/10.1007/978-981-10-8968-8\_27},
  abstract = {Android was initially presented in 2008, and luckily it has pulled in countless customers inside to make use of its services exhaustively. Utilization of Android gadgets is consistently expanding at colossal rate. As per Gartner’s report, in the cell phone working framework (OS) market, Google’s Android broadened its lead by catching 82\% of the aggregate market in the final quarter of 2016. As per a report, the quantity of mobile applications in the Google Play Store had now outperformed a check of 2.5 million applications and all are accessible for download. Advanced features have been giving the clients simplicity of person-to-person communication, managing an account, i.e., making user to transfer money around the globe. As versatile applications are increasing, thereby expanding prominence among clients, and at the same time protection and security of smartphone clients turn into a worry, its open-source nature has turned into a fascination point for spammers and malware creators to perform unintended errands. Scholastic analysts and anti-malware organizations have understood that the static investigation strategies are helpless. Specifically, the common stealth strategies, for example, encryption and code obfuscation, are equipped for creating variations of known malware. This has prompted the utilization of dynamic examination-based strategies. Since a solitary approach might be incapable against the propelled procedures, numerous corresponding methodologies can be utilized as a part of pair for powerful malware discovery. This article gives an understanding into the qualities and inadequacies of the known anti-malware techniques from year 2009 to 2017. Our contribution to this paper is we have framed comparative study of various techniques and have provide major research gaps in summarized way which gives a stage, to the scientists and specialists, toward proposing the cutting-edge Android security, examination, and malware discovery methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_27713_0_1,
  title = {Detecting Time-Fragmented Cache Attacks Against AES Using Performance Monitoring Counters},
  author = {Prada, Iván and Igual, Francisco D. and Olcoz, Katzalin},
  booktitle = {Communications in Computer and Information Science},
  year = {2019},
  pages = {3-15},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-27713-0\_1},
  url = {https://doi.org/10.1007/978-3-030-27713-0\_1},
  abstract = {Cache timing attacks use shared caches in multi-core processors as side channels to extract information from victim processes. These attacks are particularly dangerous in cloud infrastructures, in which the deployed countermeasures cause collateral effects in terms of performance loss and increase in energy consumption. We propose to monitor the victim process using an independent monitoring (detector) process, that continuously measures selected Performance Monitoring Counters (PMC) to detect the presence of an attack. Ad-hoc countermeasures can be applied only when such a risky situation arises. In our case, the victim process is the Advanced Encryption Standard (AES) encryption algorithm and the attack is performed by means of random encryption requests. We demonstrate that PMCs are a feasible tool to detect the attack and that sampling PMCs at high frequencies is worse than sampling at lower frequencies in terms of detection capabilities, particularly when the attack is fragmented in time to try to be hidden from detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_26763_6_35,
  title = {Malware Detection in Android System Based on Change Perception},
  author = {Zhang, Hua-li and Yang, Hua-yong and Yang, Fan and Jiang, Wei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {356-366},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-26763-6\_35},
  url = {https://doi.org/10.1007/978-3-030-26763-6\_35},
  abstract = {The existing detection methods of Android mobile malware mainly include signature scanning, heuristic method and behavior monitoring method. These traditional detection methods have a common limitation: they are not adaptive. The detection methods based on artificial immune system, such as dendritic cell algorithm, have some self-adaptability, but they depend too much on artificial experience, and the self-adaptability is obviously insufficient. Therefore, in order to overcome the lack of self-adaptability of existing detection methods, this paper introduces a change perception method based on danger theory to detect malicious software by looking for change in Android mobile phone system, that is, danger signal. When studying the generation of dangerous signal, this paper uses the method of describing the law of function change in mathematics to describe the change in smartphone system with the concept of differential, and then defines and expresses dangerous signal. Considering the discrete type of data in Android mobile phone system, this paper realizes the expression of dangerous signal based on the theory of numerical differentiation, and puts forward the method of calculating dangerous signal in Android system.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_91008_6_37,
  title = {Deobfuscation of Computer Virus Malware Code with Value State Dependence Graph},
  author = {Dychka, Ivan and Tereikovskyi, Ihor and Tereikovska, Liudmyla and Pogorelov, Volodymyr and Mussiraliyeva, Shynar},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2019},
  pages = {370-379},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-91008-6\_37},
  url = {https://doi.org/10.1007/978-3-319-91008-6\_37},
  abstract = {This paper deals with improvement of malware protection efficiency. The analysis of applied scientific research on malware protection development has shown that improvement of the methods for deobfuscation of program code being analyzed is one of the main means of increasing efficiency of malware recognition. This paper demonstrates that the main drawback of the modern-day deobfuscation methods is that they are insufficiently adapted to the formalized presentation of the functional semantics of programs being tested. Based on the research results, we suggest that theoretical solutions which have been tried out in program code optimization procedures may be used for code deobfuscation. In the course of the study, we have developed a program code deobfuscation procedure utilizing a value state dependence graph. Utilization of the developed procedure was found to enable presentation of the functional semantics of the programs being tested in a graph form. As the result, identification of malware based on its execution semantics became possible. The paper shows that further research should focus on the development of a method for comparison of the value state dependence graph of the program being tested with corresponding graphs of security software and malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_34175_6_15,
  title = {Android Multitasking Mechanism: Formal Semantics and Static Analysis of Apps},
  author = {He, Jinlong and Chen, Taolue and Wang, Ping and Wu, Zhilin and Yan, Jun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {291-312},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-34175-6\_15},
  url = {https://doi.org/10.1007/978-3-030-34175-6\_15},
  abstract = {In this paper we formalize the semantics of the Android multitasking mechanism and develop efficient static analysis methods with automated tool supports. For the formalization, we propose an extension of the existing Android Stack Machine model to capture all the core elements of the mechanism, in particular, the intent flags used in inter-component communication. For the static analysis, we consider the configuration reachability and stack boundedness problem, designing new algorithms and developing a prototype tool TaskDroid to fully support automated model construction and analysis of Android apps. The experimental results show that TaskDroid is effective and efficient in analyzing Android apps in practice.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_24296_1_41,
  title = {Evaluation of Tools for Analyzing Smart Contracts in Distributed Ledger Technologies},
  author = {Kirillov, Denis and Iakushkin, Oleg and Korkhov, Vladimir and Petrunin, Vadim},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {522-536},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-24296-1\_41},
  url = {https://doi.org/10.1007/978-3-030-24296-1\_41},
  abstract = {Despite the fact that the extent of interest in distributed ledger technologies has slightly decreased after the peak of Bitcoin popularity this area continues to evolve. One of the popular areas is the development of smart contracts which introduces a new paradigm of writing programs. This inflicts additional difficulties associated primarily with the high costs of error. This paper reviews the typical vulnerabilities that are widespread during development in the Solidity language. It also presents an analysis of existing tools to help identify software bugs. It is shown that there is no universal technique at the moment and if the risks are high, one should not solely check the code with available instruments but also conduct a manual audit with help of an expert.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_24907_6_29,
  title = {Topic Model Based Android Malware Detection},
  author = {Song, Yucai and Chen, Yang and Lang, Bo and Liu, Hongyu and Chen, Shaojie},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {384-396},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-24907-6\_29},
  url = {https://doi.org/10.1007/978-3-030-24907-6\_29},
  abstract = {Nowadays, the security risks brought by Android malwares are increasing. Machine learning is considered as a potential solution for promoting the performance of malware detection. For machine learning based Android malware detection, feature extraction plays a key role. Thinking the source codes of applications are comparable with text documents, we propose a new Android malware detection method based on the topic model which is an effective technique in text feature extraction. Our method regards the decompiled codes of an application as a text document, and the topic model is used to mine the potential topics in the codes which can reflect the semantic feature of the application. The experimental results demonstrate that, our approach performs better than the state-of-the-art methods. Also, our method mines the features in the application files automatically without manually design, and therefore overcomes the limitation in present methods which relies on experts’ prior knowledge.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_17184_1_18,
  title = {Compiling Sandboxes: Formally Verified Software Fault Isolation},
  author = {Besson, Frédéric and Blazy, Sandrine and Dang, Alexandre and Jensen, Thomas and Wilke, Pierre},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {499-524},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-17184-1\_18},
  url = {https://doi.org/10.1007/978-3-030-17184-1\_18},
  abstract = {Software Fault Isolation (SFI) is a security-enhancing program transformation for instrumenting an untrusted binary module so that it runs inside a dedicated isolated address space, called a sandbox. To ensure that the untrusted module cannot escape its sandbox, existing approaches such as Google’s Native Client rely on a binary verifier to check that all memory accesses are within the sandbox. Instead of relying on a posteriori verification, we design, implement and prove correct a program instrumentation phase as part of the formally verified compiler CompCert that enforces a sandboxing security property a priori . This eliminates the need for a binary verifier and, instead, leverages the soundness proof of the compiler to prove the security of the sandboxing transformation. The technical contributions are a novel sandboxing transformation that has a well-defined C semantics and which supports arbitrary function pointers, and a formally verified C compiler that implements SFI. Experiments show that our formally verified technique is a competitive way of implementing SFI.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11219_019_09484_z,
  title = {Sentinel: generating GUI tests for sensor leaks in Android and Android wear apps},
  author = {Wu, Haowei and Zhang, Hailong and Wang, Yan and Rountev, Atanas},
  journal = {Software Quality Journal},
  year = {2020},
  volume = {28},
  number = {1},
  pages = {335-367},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11219-019-09484-z},
  url = {https://doi.org/10.1007/s11219-019-09484-z},
  abstract = {Due to the widespread use of Android devices and apps, it is important to develop tools and techniques to improve app quality and performance. Our work focuses on a problem related to hardware sensors on Android devices: the failure to disable unneeded sensors, which leads to sensor leaks and thus battery drain. We propose the Sentinel testing tool to uncover such leaks. The tool performs static analysis of app code and produces a model which maps GUI events to callback methods that affect sensor behavior. Edges in the model are labeled with symbols representing the acquiring/releasing of sensors and the opening/closing of UI windows. The model is traversed to identify paths that are likely to exhibit sensor leaks during run-time execution based on two context-free languages over the symbol alphabet. The reported paths are then used to generate test cases. The execution of each test case tracks the run-time behavior of sensors and reports observed leaks. This approach has been applied to both open-sourced and closed-sourced regular Android applications as well as watch faces for Android Wear smartwatches. Our experimental results indicate that Sentinel effectively detects sensor leaks, while focusing the testing efforts on a very small subset of possible GUI event sequences.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_12942_2_20,
  title = {Trends in Design of Ransomware Viruses},
  author = {Craciun, Vlad Constantin and Mogage, Andrei and Simion, Emil},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {259-272},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-12942-2\_20},
  url = {https://doi.org/10.1007/978-3-030-12942-2\_20},
  abstract = {The ransomware nightmare is taking over the internet, impacting common users, small businesses and large ones. The interest and investment which is pushed into this market each month, tell us a few things about the evolution of both technical and social engineering, along with what is to expect in the short-coming future from them. In this paper, we analyze how ransomware programs developed in the last few years and how they were released in certain market segments throughout the deep web via RaaS (Ransomware as a Service), exploits or SPAM, while learning from their own mistakes to bring profit to the next level. We also highlight a set of mistakes that were made, which allowed for total or partial recovery of the encrypted data. We also consider the ransomware authors preference for specific encryption types, encryption key exchange mechanisms and some edge cases of encryption, which may prove to be exploitable in the near future.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_37231_6_22,
  title = {On Effectiveness of Adversarial Examples and Defenses for Malware Classification},
  author = {Podschwadt, Robert and Takabi, Hassan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2019},
  pages = {380-393},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-37231-6\_22},
  url = {https://doi.org/10.1007/978-3-030-37231-6\_22},
  abstract = {Artificial neural networks have been successfully used for many different classification tasks including malware detection and distinguishing between malicious and non-malicious programs. Although artificial neural networks perform very well on these tasks, they are also vulnerable to adversarial examples. An adversarial example is a sample that has minor modifications made to it so that the neural network misclassifies it. Many techniques have been proposed, both for crafting adversarial examples and for hardening neural networks against them. Most previous work was done in the image domain. Some of the attacks have been adopted to work in the malware domain which typically deals with binary feature vectors. In order to better understand the space of adversarial examples in malware classification, we study different approaches of crafting adversarial examples and defense techniques in the malware domain and compare their effectiveness on multiple data sets.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_31175_9_6,
  title = {Checking the Expressivity of Firewall Languages},
  author = {Ceragioli, Lorenzo and Degano, Pierpaolo and Galletta, Letterio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {86-100},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-31175-9\_6},
  url = {https://doi.org/10.1007/978-3-030-31175-9\_6},
  abstract = {Designing and maintaining firewall configurations is hard, also for expert system administrators. Indeed, policies are made of a large number of rules and are written in low-level configuration languages that are specific to the firewall system in use. As part of a larger group, we have addressed these issues and have proposed a semantic-based transcompilation pipeline. It is supported by FWS, a tool that analyses a real configuration and ports it from a firewall system to another. To our surprise, we discovered that some configurations expressed in a real firewall system cannot be ported to another system, preserving the semantics. Here we outline the main reasons for the detected differences between the firewall languages, and describe F 2F, a tool that checks if a given configuration in a system can be ported to another system, and reports its user on which parts cause problems and why.},
  content_type = {Chapter},
}


@article{springer_10_1186_s13638_016_0720_3,
  title = {Structural analysis of packing schemes for extracting hidden codes in mobile malware},
  author = {Lim, Jongsu and Yi, Jeong Hyun},
  journal = {EURASIP Journal on Wireless Communications and Networking},
  year = {2016},
  volume = {2016},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13638-016-0720-3},
  url = {https://doi.org/10.1186/s13638-016-0720-3},
  abstract = {In the Internet of Things service environment where all things are connected, mobile devices will become an extremely important medium linking together things with built-in heterogeneous communication functions. If a mobile device is exposed to hacking in this context, a security threat arises where all things linked to the device become targets of cyber hacking; therefore, greater emphasis will be placed on the demand for swift mobile malware detection and countermeasures. Such mobile malware applies advanced code-hiding schemes to ensure that the part of the code that executes malicious behavior is not detected by an anti-virus software. In order to detect mobile malware, we must first conduct structural analysis of their code-hiding schemes. In this paper, we analyze the structure of the two representative Android-based code-hiding tools, Bangcle and DexProtector, and then introduce a method and procedure for extracting the hidden original code. We also present experimental results of applying these tools on sample malicious codes.},
  content_type = {Article},
}


@article{springer_10_1186_s42400_018_0011_x,
  title = {Automated identification of sensitive data from implicit user specification},
  author = {Yang, Ziqi and Liang, Zhenkai},
  journal = {Cybersecurity},
  year = {2018},
  volume = {1},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-018-0011-x},
  url = {https://doi.org/10.1186/s42400-018-0011-x},
  abstract = {The sensitivity of information is dependent on the context of application and user preference. Protecting sensitive data in the cloud era requires identifying them in the first place. It typically needs intensive manual efforts. More importantly, users may specify sensitive information only through an implicit manner. Existing research efforts on identifying sensitive data from its descriptive texts focus on keyword/phrase searching. These approaches can have high false positives/negatives as they do not consider the semantics of the descriptions. In this paper, we propose S3 , an automated approach to identify sensitive data based on users’ implicit specifications. Our approach considers semantic, syntactic and lexical information comprehensively, aiming to identify sensitive data by the semantics of its descriptive texts. We introduce the notion concept space to represent the user’s notion of privacy, by which our approach can support flexible user requirements in defining sensitive data. Our approach is able to learn users’ preferences from readable concepts initially provided by users, and automatically identify related sensitive data. We evaluate our approach on over 18,000 top popular applications from Google Play Store. S3 achieves an average precision of 89.2\%, and average recall 95.8\% in identifying sensitive data.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_15093_8_2,
  title = {Malware Detection Using Logic Signature of Basic Block Sequence},
  author = {Shi, Dawei and Xu, Qiang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {18-32},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-15093-8\_2},
  url = {https://doi.org/10.1007/978-3-030-15093-8\_2},
  abstract = {Malware detection is an important method for maintaining the security and privacy in cyberspace. As the most mainstream method currently, signature-based detecting is confronted with many obfuscation methods which can hide the true signature of malware. In our research, we propose a logic signature-based malware detecting method to overcome the shortcoming of being susceptible to disturbance in data signature-based method. Firstly, we achieve the logic of basic block based on Symbolic execution and Static Single Assignment, and then use a set of expression trees to represent the basic block logic, the trees set will be filtered to pick out the remarkable items. Depending on basic block logic trees set, we use n-gram method to select features for the discrimination of malicious and benign software. Every feature of program is a sequence of basic block logic and the feature matching is based on edit distance calculating. We design and implement a detector and evaluate its effectiveness by comparing with data signature-based detector. The experimental results indicate that the proposed malware detector using logic signature of basic block sequence has a higher performance than data signature-based detectors.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_21752_5_7,
  title = {A Multilateral Privacy Impact Analysis Method for Android Apps},
  author = {Hatamian, Majid and Momen, Nurul and Fritsch, Lothar and Rannenberg, Kai},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {87-106},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-21752-5\_7},
  url = {https://doi.org/10.1007/978-3-030-21752-5\_7},
  abstract = {Smartphone apps have the power to monitor most of people’s private lives. Apps can permeate private spaces, access and map social relationships, monitor whereabouts and chart people’s activities in digital and/or real world. We are therefore interested in how much information a particular app can and intends to retrieve in a smartphone. Privacy-friendliness of smartphone apps is typically measured based on single-source analyses, which in turn, does not provide a comprehensive measurement regarding the actual privacy risks of apps. This paper presents a multi-source method for privacy analysis and data extraction transparency of Android apps. We describe how we generate several data sets derived from privacy policies, app manifestos, user reviews and actual app profiling at run time. To evaluate our method, we present results from a case study carried out on ten popular fitness and exercise apps. Our results revealed interesting differences concerning the potential privacy impact of apps, with some of the apps in the test set violating critical privacy principles. The result of the case study shows large differences that can help make relevant app choices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_21548_4_27,
  title = {Practical Dynamic Taint Tracking for Exploiting Input Sanitization Error in Java Applications},
  author = {Ashouri, Mohammadreza},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {494-513},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-21548-4\_27},
  url = {https://doi.org/10.1007/978-3-030-21548-4\_27},
  abstract = {Errors in the sanitization of user inputs lead to serious security vulnerabilities. Many applications contain such errors, making them vulnerable to input sanitization exploits. Therefore, internet worms via exploiting vulnerabilities in applications infect hundreds of thousands of users in a matter of short time, causing hundreds of millions of dollars in damages. To successfully counter internet worm attacks, we need automatic detection and defense mechanisms. First, we need automatic detection mechanisms that can detect runtime attacks for vulnerabilities. A disclosure mechanism should be simple to deploy, resulting in few false positives and few false negatives. In this paper we present Tainer, an automatic dynamic taint analysis framework to detect and generate exploits for sanitization based vulnerabilities for Java web applications. Particularly, our method is based on tracking the flow of taint information from untrusted input the application sensitive methods (such as console, file, network, database or another program). Our proposed framework is portable, quick, accurate, and does not need the source code of applications. We demonstrate the usefulness of the framework by detecting several zero-day actual vulnerabilities in popular Java applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_20951_3_6,
  title = {Malware Classification Using Image Representation},
  author = {Singh, Ajay and Handa, Anand and Kumar, Nitesh and Shukla, Sandeep Kumar},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {75-92},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-20951-3\_6},
  url = {https://doi.org/10.1007/978-3-030-20951-3\_6},
  abstract = {In the recent years, there has been a rapid rise in the number of files submitted to anti-virus companies for analysis. It has become very difficult to analyse the functionality of each file manually. Malware developers have been highly successful in evading signature-based detection techniques. Most of the prevailing static analysis techniques involve a tool to parse the executable, and extract features or signatures. Most of the dynamic analysis techniques involve the binary file to be run in a sand-boxed environment to examine its behaviour. This can be easily thwarted by hiding the malicious activities of the file if it is being run inside a virtual environment. Hence, there has been a need to explore new approaches to overcome the limitations of static or dynamic analysis such as time intensity, resource consumption, scalability. In this paper, we have explored a new technique to represent malware as images. We have used 37, 374 samples belonging to 22 families and then applied deep neural network architectures such as ResNet-50 architecture including a dense Convolutional Neural Network (CNN) for classifying images. By converting the executable into an image representation, we have made our analysis process free from the problems faced by standard static and dynamic analyses. With our models, we have been able to get an accuracy of 98.98\%, and 99.40\% in classifying malware samples by using deep CNN, and ResNet-50 respectively on our dataset. In this paper, we have also compared the results of our proposed model on our collected dataset with the results obtained on publically available datasets like Malimg having 9,339 samples belonging to 25 families. We also present our findings on the limitation of this method through experimentation on packed and previously unseen classes of malware.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11241_017_9286_3,
  title = {High-assurance timing analysis for a high-assurance real-time operating system},
  author = {Sewell, Thomas and Kam, Felix and Heiser, Gernot},
  journal = {Real-Time Systems},
  year = {2017},
  volume = {53},
  number = {5},
  pages = {812-853},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11241-017-9286-3},
  url = {https://doi.org/10.1007/s11241-017-9286-3},
  abstract = {Worst-case execution time (WCET) analysis of real-time code needs to be performed on the executable binary code for soundness. Obtaining tight WCET bounds requires determination of loop bounds and elimination of infeasible paths. The binary code, however, lacks information necessary to determine these bounds. This information is usually provided through manual intervention, or preserved in the binary by a specially modified compiler. We propose an alternative approach, using an existing translation-validation framework, to enable high-assurance, automatic determination of loop bounds and infeasible paths. We show that this approach automatically determines all loop bounds and many (possibly all) infeasible paths in the seL4 microkernel, as well as in standard WCET benchmarks which are in the language subset of our C parser. We also design and validate an improvement to the seL4 implementation, which permits a key part of the kernel’s API to be available to users in a mixed-criticality setting.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_99073_6_2,
  title = {On Leveraging Coding Habits for Effective Binary Authorship Attribution},
  author = {Alrabaee, Saed and Shirani, Paria and Wang, Lingyu and Debbabi, Mourad and Hanna, Aiman},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {26-47},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-99073-6\_2},
  url = {https://doi.org/10.1007/978-3-319-99073-6\_2},
  abstract = {We propose BinAuthor , a novel and the first compiler-agnostic method for identifying the authors of program binaries. Having filtered out unrelated functions (compiler and library) to detect user-related functions, it converts user-related functions into a canonical form to eliminate compiler/compilation effects. Then, it leverages a set of features based on collections of authors’ choices made during coding. These features capture an author’s coding habits. Our evaluation demonstrated that BinAuthor outperforms existing methods in several respects. First, when tested on large datasets extracted from selected open-source C/C++ projects in GitHub, Google Code Jam events, and Planet Source Code contests, it successfully attributed a larger number of authors with a significantly higher accuracy: around \\(90\\\%\\) when the number of authors is 1000. Second, when the code was subjected to refactoring techniques, code transformation, or processing using different compilers or compilation settings, there was no significant drop in accuracy, indicating that BinAuthor is more robust than previous methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_59533_6_20,
  title = {The Multiresolution Analysis of Flow Graphs},
  author = {Huntsman, Steve},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {323-341},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-59533-6\_20},
  url = {https://doi.org/10.1007/978-3-662-59533-6\_20},
  abstract = {We introduce and prove basic results about several graph-theoretic notions relevant to the multiresolution analysis of flow graphs that represent the transfer of control in computer programs. We take a category-theoretical viewpoint to demonstrate that our definitions are natural and to motivate particular incarnations of related constructions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_99277_8_16,
  title = {Forensic Analysis of Android Steganography Apps},
  author = {Chen, Wenhao and Wang, Yangxiao and Guan, Yong and Newman, Jennifer and Lin, Li and Reinders, Stephanie},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2018},
  pages = {293-312},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-99277-8\_16},
  url = {https://doi.org/10.1007/978-3-319-99277-8\_16},
  abstract = {The processing power of smartphones supports steganographic algorithms that were considered to be too computationally intensive for handheld devices. Several steganography apps are now available on mobile phones to support covert communications using digital photographs. This chapter focuses on two key questions: How effectively can a steganography app be reverse engineered? How can this knowledge help improve the detection of steganographic images and other related files? Two Android steganography apps, PixelKnot and Da Vinci Secret Image, are analyzed. Experiments demonstrate that they are constructed in very different ways and provide different levels of security for hiding messages. The results of detecting steganography files, including images generated by the apps, using three software packages are presented. The results point to an urgent need for further research on reverse engineering steganography apps and detecting images produced by these apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_72344_0_6,
  title = {Auditing Access to Private Data on Android Platform},
  author = {Maral, Vishal and Trivedi, Nachiket and Das, Manik Lal},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {105-111},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-72344-0\_6},
  url = {https://doi.org/10.1007/978-3-319-72344-0\_6},
  abstract = {App-based utility service on mobile phone has found enormous success in modern digital society. While App-based services on mobile platform make life easy, security and privacy concern of App installed on mobile phone poses a potential threat to user of mobile phone. Users typically do not pay much attention at the time of App installation before accepting the privacy terms display on his/her mobile phone. In this paper, we present a security monitor, a user level tool to detect the events of sensitive data access by mobile Apps and alert user for any suspicious data access. The security monitor does not require the Android root permission to run on mobile platform, instead, it relies on adding hooks to the application package at the bytecode level. The experimental results show that the proposed security monitor can effectively detect private or sensitive data access of Apps with almost no overhead on power consumption of mobile phone and App performance.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_04879_2_5,
  title = {Translation Semantics and Static Analysis},
  author = {Crespi Reghizzi, Stefano and Breveglieri, Luca and Morzenti, Angelo},
  booktitle = {Texts in Computer Science},
  year = {2019},
  pages = {383-486},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-04879-2\_5},
  url = {https://doi.org/10.1007/978-3-030-04879-2\_5},
  abstract = {We present and discuss the translation techniques and the static analysis of programs. After abstractly defining a translation as a relation between strings, we present the operational models of transliteration and purely syntactic translation. These models are defined by means of regular translation expressions and by transduction grammars, also known as syntactic translation schemes; they are, respectively, computed by finite or pushdown transducers. Then we move to the more practical approach known as semantic translation, which consists of functions that operate on the syntactic tree of the source text, and compute the values of semantic attributes. Semantic translations are formalized by means of attribute grammars. We show some typical applications of attribute grammars for checking variable declaration, code generation and semantics-directed parsing. We examine the dependencies between semantic attributes and how they condition the evaluation order, and the number and direction of compiler passes. Finally, we consider the static analysis of programs: the program is viewed as a finite control-flow graph, and a few important properties concerning its correctness and efficiency are established, through an approach based on writing flow equations and iteratively solving them. The approach is illustrated by the problems of liveness intervals and reaching definitions, and their use for memory allocation and constant propagation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_73830_7_6,
  title = {Effective Malware Detection Based on Behaviour and Data Features},
  author = {Xu, Zhiwu and Wen, Cheng and Qin, Shengchao and Ming, Zhong},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {53-66},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73830-7\_6},
  url = {https://doi.org/10.1007/978-3-319-73830-7\_6},
  abstract = {Malware is one of the most serious security threats on the Internet today. Traditional detection methods become ineffective as malware continues to evolve. Recently, various machine learning approaches have been proposed for detecting malware. However, either they focused on behaviour information, leaving the data information out of consideration, or they did not consider too much about the new malware with different behaviours or new malware versions obtained by obfuscation techniques. In this paper, we propose an effective approach for malware detection using machine learning. Different from most existing work, we take into account not only the behaviour information but also the data information, namely, the opcodes, data types and system libraries used in executables. We employ various machine learning methods in our implementation. Several experiments are conducted to evaluate our approach. The results show that (1) the classifier trained by Random Forest performs best with the accuracy 0.9788 and the AUC 0.9959; (2) all the features (including data types) are effective for malware detection; (3) our classifier is capable of detecting some fresh malware; (4) our classifier has a resistance to some obfuscation techniques.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s40860_019_00080_3,
  title = {Systematic literature review and metadata analysis of ransomware attacks and detection mechanisms},
  author = {Maigida, Abdullahi Mohammed and Abdulhamid, Shafi’i Muhammad and Olalere, Morufu and Alhassan, John K. and Chiroma, Haruna and Dada, Emmanuel Gbenga},
  journal = {Journal of Reliable Intelligent Environments},
  year = {2019},
  volume = {5},
  number = {2},
  pages = {67-89},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s40860-019-00080-3},
  url = {https://doi.org/10.1007/s40860-019-00080-3},
  abstract = {Ransomware is advanced and upgraded malicious software which comes in the forms of Crypto or Locker, with the intention to attack and take control of basic infrastructures and computer systems. The vast majority of these threats are aimed at directly or indirectly making money from the victims by asking for a ransom in exchange for decryption keys. This systematic literature analysed the anatomy of ransomware, including its trends and mode of attacks to find the possible solutions by querying various academic literature. In contrast to previous reviews, sources of ransomware dataset are revealed in this review paper to ease the challenges of researchers in getting access to ransomware datasets. In addition, a taxonomy of ransomware current trends is presented in the paper. We discussed the articles in detail, the evolution and trend in ransomware researches. Most of the techniques deployed could not completely prevent ransomware attacks because of its obfuscation techniques, but rather recommend proper and regular backup of important files. This review can serve as a benchmark for researchers in proposing a novel ransomware detection methodology and starting point for novice researchers.},
  content_type = {Article},
}


@article{springer_10_1007_s11416_018_0316_z,
  title = {The duplication issue within the Drebin dataset},
  author = {Irolla, Paul and Dey, Alexandre},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2018},
  volume = {14},
  number = {3},
  pages = {245-249},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-018-0316-z},
  url = {https://doi.org/10.1007/s11416-018-0316-z},
  abstract = {The Drebin dataset (in: NDSS, 2014 ) is the most supplied academic dataset of Android malware. Therefore it is the most used dataset in research papers on Android malware detection. The research community is using it for evaluation and comparison of their algorithms. We discovered that 49.35\% of samples in this dataset has at least one other sample that is a repackaged version containing exactly the same sequence of opcode. The only differences between the original malware and the duplicated ones, in all cases, are the resources embedded and some strings in the code. For assessing the performance of malware detectors or classifiers, a part of the dataset is used for this purpose. So a major part of the testing set end up beeing the same samples that have been used in the training set. This situation can lead us, the research community, to overrate the performance of algorithms we are designing. In the worst case, it leads us to wrong conclusions and wrong directions for future research. Then we conduct an experiment where we test several classification algorithms on the Drebin dataset with and without the duplicates. Our results show that depending on the classifier the full dataset can lead from moderately (124\%) to strongly (172\%) underrated inaccuracy , and the order of performance of the algorithms is modified. Finally we provide the list of unique malware samples from the Drebin dataset , available on Github .},
  content_type = {Article},
}


@article{springer_10_1007_s10664_019_09725_6,
  title = {Evolutionary Fuzzing of Android OS Vendor System Services},
  author = {Cotroneo, Domenico and Iannillo, Antonio Ken and Natella, Roberto},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {6},
  pages = {3630-3658},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09725-6},
  url = {https://doi.org/10.1007/s10664-019-09725-6},
  abstract = {Android devices are shipped in several flavors by more than 100 manufacturer partners, which extend the Android “vanilla” OS with new system services, and modify the existing ones. These proprietary extensions expose Android devices to reliability and security issues. In this paper, we propose a coverage-guided fuzzing platform ( Chizpurfle ) based on evolutionary algorithms to test proprietary Android system services. A key feature of this platform is the ability to profile coverage on the actual, unmodified Android device, by taking advantage of dynamic binary re-writing techniques. We applied this solution on three high-end commercial Android smartphones. The results confirmed that evolutionary fuzzing is able to test Android OS system services more efficiently than blind fuzzing. Furthermore, we evaluate the impact of different choices for the fitness function and selection algorithm.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_018_9629_2,
  title = {What can Android mobile app developers do about the energy consumption of machine learning?},
  author = {McIntosh, Andrea and Hassan, Safwat and Hindle, Abram},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {2},
  pages = {562-601},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-018-9629-2},
  url = {https://doi.org/10.1007/s10664-018-9629-2},
  abstract = {Machine learning is a popular method of learning functions from data to represent and to classify sensor inputs, multimedia, emails, and calendar events. Smartphone applications have been integrating more and more intelligence in the form of machine learning. Machine learning functionality now appears on most smartphones as voice recognition, spell checking, word disambiguation, face recognition, translation, spatial reasoning, and even natural language summarization. Excited app developers who want to use machine learning on mobile devices face one serious constraint that they did not face on desktop computers or cloud virtual machines: the end-user’s mobile device has limited battery life, thus computationally intensive tasks can harm end users’ phone availability by draining batteries of their stored energy. Currently, there are few guidelines for developers who want to employ machine learning on mobile devices yet are concerned about software energy consumption of their applications. In this paper, we combine empirical measurements of different machine learning algorithm implementations with complexity theory to provide concrete and theoretically grounded recommendations to developers who want to employ machine learning on smartphones. We conclude that some implementations of algorithms, such as J48, MLP, and SMO, do generally perform better than others in terms of energy consumption and accuracy, and that energy consumption is well-correlated to algorithmic complexity. However, to achieve optimal results a developer must consider their specific application as many factors — dataset size, number of data attributes, whether the model will require updating, etc. — affect which machine learning algorithm and implementation will provide the best results.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_019_09749_y,
  title = {Are free Android app security analysis tools effective in detecting known vulnerabilities?},
  author = {Ranganath, Venkatesh-Prasad and Mitra, Joydeep},
  journal = {Empirical Software Engineering},
  year = {2020},
  volume = {25},
  number = {1},
  pages = {178-219},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09749-y},
  url = {https://doi.org/10.1007/s10664-019-09749-y},
  abstract = {Increasing interest in securing the Android ecosystem has spawned numerous efforts to assist app developers in building secure apps. These efforts have resulted in tools and techniques capable of detecting vulnerabilities and malicious behaviors in apps. However, there has been no evaluation of the effectiveness of these tools and techniques in detecting known vulnerabilities. The absence of such evaluations puts app developers at a disadvantage when choosing security analysis tools to secure their apps. In this regard, we evaluated the effectiveness of vulnerability detection tools for Android apps. We reviewed 64 tools and empirically evaluated 14 vulnerability detection tools against 42 known unique vulnerabilities captured by Ghera benchmarks, which are composed of both vulnerable and secure apps. Of the 20 observations from the evaluation, the main observation is existing vulnerability detection tools for Android apps are very limited in their ability to detect known vulnerabilities — all of the evaluated tools together could only detect 30 of the 42 known unique vulnerabilities . More effort is required if security analysis tools are to help developers build secure apps. We hope the observations from this evaluation will help app developers choose appropriate security analysis tools and persuade tool developers and researchers to identify and address limitations in their tools and techniques. We also hope this evaluation will catalyze or spark a conversation in the software engineering and security communities to require a more rigorous and explicit evaluation of security analysis tools and techniques.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_13_1924_2_8,
  title = {A Development Platform for Embedded Domain-Specific Languages},
  author = {Chiba, Shigeru and Zhuang, YungYu and Dao, Thanh-Chung},
  booktitle = {Advanced Software Technologies for Post-Peta Scale Computing},
  year = {2019},
  pages = {139-161},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-13-1924-2\_8},
  url = {https://doi.org/10.1007/978-981-13-1924-2\_8},
  abstract = {The use of domain-specific languages (DSLs) is a promising approach to helping programmers write an efficient program for high-performance computing. The programmers would feel difficulties in writing such a program by hand with only low-level abstractions, such as arrays and loops, provided by a general-purpose language. This chapter presents our new implementation technique for domain-specific languages. Since existing techniques are not satisfactory, we developed our technique called deep reification . This chapter also presents Bytespresso , which is our prototype system to use deep reification. Several Java-embedded DSLs implemented with Bytespresso are presented to assess the effectiveness of deep reification and Bytespresso. Program fragments written in these DSLs are embedded in Java, but they are dynamically off-loaded to native hardware to obtain good execution performance. Since they are embedded in Java, the syntax of Java is reused by those DSLs, and hence the development costs of these DSLs are reduced.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_01090_4_30,
  title = {EthIR: A Framework for High-Level Analysis of Ethereum Bytecode},
  author = {Albert, Elvira and Gordillo, Pablo and Livshits, Benjamin and Rubio, Albert and Sergey, Ilya},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {513-520},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-01090-4\_30},
  url = {https://doi.org/10.1007/978-3-030-01090-4\_30},
  abstract = {Analyzing Ethereum bytecode, rather than the source code from which it was generated, is a necessity when: (1) the source code is not available (e.g., the blockchain only stores the bytecode), (2) the information to be gathered in the analysis is only visible at the level of bytecode (e.g., gas consumption is specified at the level of EVM instructions), (3) the analysis results may be affected by optimizations performed by the compiler (thus the analysis should be done ideally after compilation). This paper presents EthIR , a framework for analyzing Ethereum bytecode, which relies on (an extension of) Oyente , a tool that generates CFGs; EthIR produces from the CFGs, a rule-based representation (RBR) of the bytecode that enables the application of (existing) high-level analyses to infer properties of EVM code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_73830_7_14,
  title = {Research on Dynamic Safe Loading Techniques in Android Application Protection System},
  author = {Cai, Shubin and Huang, Rongjie and Yang, Ningsheng and Jiang, Jinwen and Ming, Zhong and Liang, Zhengping and Shan, Zhiguang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {134-143},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73830-7\_14},
  url = {https://doi.org/10.1007/978-3-319-73830-7\_14},
  abstract = {Android is a widespread used embedded system. The number of Android applications has been rapidly growing. Because of Android open source policy and limited application security mechanism, Android applications are confronted with many serious security threats. By malicious reverse and illegal tampering, thousands of Android applications have been infected and millions of users have been exposed to dangers. In this paper, we proposed an improved Android applications protection system based on DEX block encryption and multi-file features checksum. Experiment results show that the proposed system is more reliable than the commonly-used Android application protection systems when facing with attack tools such as APK Tools and IDA pro.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_98488_9_1,
  title = {A Few Words About Digital Preservation and Book Overview},
  author = {Tzitzikas, Yannis and Marketakis, Yannis},
  booktitle = {Cinderella's Stick},
  year = {2018},
  pages = {1-12},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98488-9\_1},
  url = {https://doi.org/10.1007/978-3-319-98488-9\_1},
  abstract = {This chapter introduces the reader to the basic concepts of Digital Preservation and justifies the significance of the topic. Subsequently, it decomposes the problem, and introduces the notion of Digital Preservation Pattern that is used in the next chapters of the book. Finally, it describes the structure of the book and the relationships amongst chapters.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_4856_0_2,
  title = {Exploring C\#},
  author = {Strauss, Dirk},
  booktitle = {Exploring Advanced Features in C\#},
  year = {2019},
  pages = {55-104},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4856-0\_2},
  url = {https://doi.org/10.1007/978-1-4842-4856-0\_2},
  abstract = {This chapter will have a look at some of the features in C\# that developers might overlook. This is a statement I hear all too often when discussing a specific feature: “I’ve heard of it but not used it before.”},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_89722_6_13,
  title = {Transcompiling Firewalls},
  author = {Bodei, Chiara and Degano, Pierpaolo and Focardi, Riccardo and Galletta, Letterio and Tempesta, Mauro},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {303-324},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-89722-6\_13},
  url = {https://doi.org/10.1007/978-3-319-89722-6\_13},
  abstract = {Porting a policy from a firewall system to another is a difficult and error prone task. Indeed, network administrators have to know in detail the policy meaning, as well as the internals of the firewall systems and of their languages. Equally difficult is policy maintenance and refactoring, e.g., removing useless or redundant rules. In this paper, we present a transcompiling pipeline that automatically tackles both problems: it can be used to port a policy into an equivalent one, when the target firewall language is different from the source one; when the two languages coincide, transcompiling supports policy maintenance and refactoring. Our transcompiler and its correctness are based on a formal intermediate firewall language that we endow with a formal semantics.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_99073_6_4,
  title = {MobileFindr: Function Similarity Identification for Reversing Mobile Binaries},
  author = {Liao, Yibin and Cai, Ruoyan and Zhu, Guodong and Yin, Yue and Li, Kang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {66-83},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-99073-6\_4},
  url = {https://doi.org/10.1007/978-3-319-99073-6\_4},
  abstract = {Identifying binary code at function level has been applied to a broad range of software security applications and reverse engineering tasks, including patch analysis, vulnerability assessment, code plagiarism detection, malware analysis, etc. However, various anti-reverse engineering techniques (e.g., obfuscation, anti-emulator, etc.) employed by the mobile apps make existing approaches ineffective when performing function identification. In this paper, we propose MobileFindr, an on-device trace-based function similarity identification framework on the mobile platform. MobileFindr runs on real mobile devices and mitigates many prevalent anti-reversing techniques by extracting function execution behaviors via dynamic instrumentation, then characterizing functions with collected behaviors and performing function matching via distance calculation. We have evaluated MobileFindr using real-world top-ranked mobile frameworks and applications. The experimental results showed that MobileFindr outperforms existing state-of-the-art tools in terms of better obfuscation resilience and accuracy.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_018_9625_6,
  title = {Understanding the behaviour of hackers while performing attack tasks in a professional setting and in a public challenge},
  author = {Ceccato, Mariano and Tonella, Paolo and Basile, Cataldo and Falcarin, Paolo and Torchiano, Marco and Coppens, Bart and De Sutter, Bjorn},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {1},
  pages = {240-286},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-018-9625-6},
  url = {https://doi.org/10.1007/s10664-018-9625-6},
  abstract = {When critical assets or functionalities are included in a piece of software accessible to the end users, code protections are used to hinder or delay the extraction or manipulation of such critical assets. The process and strategy followed by hackers to understand and tamper with protected software might differ from program understanding for benign purposes. Knowledge of the actual hacker behaviours while performing real attack tasks can inform better ways to protect the software and can provide more realistic assumptions to the developers, evaluators, and users of software protections. Within Aspire, a software protection research project funded by the EU under framework programme FP7, we have conducted three industrial case studies with the involvement of professional penetration testers and a public challenge consisting of eight attack tasks with open participation. We have applied a systematic qualitative analysis methodology to the hackers’ reports relative to the industrial case studies and the public challenge. The qualitative analysis resulted in 459 and 265 annotations added respectively to the industrial and to the public challenge reports. Based on these annotations we built a taxonomy consisting of 169 concepts. They address the hacker activities related to (i) understanding code; (ii) defining the attack strategy; (iii) selecting and customizing the tools; and (iv) defeating the protections. While there are many commonalities between professional hackers and practitioners, we could spot many fundamental differences. For instance, while industrial professional hackers aim at elaborating automated and reproducible deterministic attacks, practitioners prefer to minimize the effort and try many different manual tasks. This analysis allowed us to distill a number of new research directions and potential improvements for protection techniques. In particular, considering the critical role of analysis tools, protection techniques should explicitly attack them, by exploiting analysis problems and complexity aspects that available automated techniques are bad at addressing.},
  content_type = {Article},
}


@article{springer_10_3103_s0146411617080259,
  title = {Identifying a potential insider using classification models},
  author = {Zaytsev, A. S. and Malyuk, A. A.},
  journal = {Automatic Control and Computer Sciences},
  year = {2017},
  volume = {51},
  number = {8},
  pages = {860-866},
  publisher = {Allerton Press},
  doi = {10.3103/s0146411617080259},
  url = {https://doi.org/10.3103/s0146411617080259},
  abstract = {Classification models based on statistical data have been developed that make it possible to identify a potential insider based on the indicators that manifest in the context of data incompleteness regarding the insider’s behavior.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_03638_6_28,
  title = {When Harry Met Tinder: Security Analysis of Dating Apps on Android},
  author = {Kim, Kuyju and Kim, Taeyun and Lee, Seungjin and Kim, Soolin and Kim, Hyoungshick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {454-467},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-03638-6\_28},
  url = {https://doi.org/10.1007/978-3-030-03638-6\_28},
  abstract = {As the number of smartphone users has increased, so has the popularity of dating apps such as Tinder, Hinge, Grindr and Bumbler. At the same time, however, many users have growing privacy concerns about these applications disclosing their sensitive and private information to other service providers and/or strangers. This is particularly exacerbated due to the nature of dating apps requiring access to users’ personal contents such as chat messages, photos, video clips and locations. In this paper, we present an analysis of security and privacy issues in popular dating apps on Android. We carefully analyze the possibility of software vulnerabilities on the five most popular dating apps on Android through network traffic analyses and reverse engineering techniques for each dating app. Our experiment results demonstrate that user credential data can be stolen from all five applications; three apps may lead to the disclosure of user profiles, and one app may lead to the disclosure of chat messages.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11704_017_6493_y,
  title = {Fingerprinting Android malware families},
  author = {Xie, Nannan and Wang, Xing and Wang, Wei and Liu, Jiqiang},
  journal = {Frontiers of Computer Science},
  year = {2019},
  volume = {13},
  number = {3},
  pages = {637-646},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11704-017-6493-y},
  url = {https://doi.org/10.1007/s11704-017-6493-y},
  abstract = {The domination of the Android operating system in the market share of smart terminals has engendered increasing threats of malicious applications (apps). Research on Android malware detection has received considerable attention in academia and the industry. In particular, studies on malware families have been beneficial to malware detection and behavior analysis. However, identifying the characteristics of malware families and the features that can describe a particular family have been less frequently discussed in existing work. In this paper, we are motivated to explore the key features that can classify and describe the behaviors of Android malware families to enable fingerprinting the malware families with these features. We present a framework for signature-based key feature construction. In addition, we propose a frequency-based feature elimination algorithm to select the key features. Finally, we construct the fingerprints of ten malware families, including twenty key features in three categories. Results of extensive experiments using Support Vector Machine demonstrate that the malware family classification achieves an accuracy of 92\% to 99\%. The typical behaviors of malware families are analyzed based on the selected key features. The results demonstrate the feasibility and effectiveness of the presented algorithm and fingerprinting method.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_52709_3_13,
  title = {Formalizing Structured Control Flow Graphs},
  author = {Sabne, Amit and Sakdhnagool, Putt and Eigenmann, Rudolf},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {153-168},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-52709-3\_13},
  url = {https://doi.org/10.1007/978-3-319-52709-3\_13},
  abstract = {Structured programs are believed to be easier to understand, and compiler friendly [ 5 , 10 , 45 ]. However, compilers do not process the source programs directly; they instead work on control flow graphs (CFGs) of the programs. Unfortunately, there is little formalization of structured CFGs. This paper shows how the lack of formalization has led to varying interpretations of structured CFGs. The paper next presents new formalization of structured CFGs which eliminates the ambiguity. Structured CFGs gain importance as they ease compiler optimizations, decompilation, and help reduce the performance degradation caused by thread divergence on SIMD units. The paper elaborates on these benefits. It also shows that compilers, both front-ends and back-ends, may generate unstructured CFGs from structured program sources, which necessitates mechanisms to obtain structured CFGs from unstructured ones.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_6385_5_32,
  title = {Research on Linux Kernel Version Diversity for Precise Memory Analysis},
  author = {Zhang, Shuhui and Meng, Xiangxu and Wang, Lianhai and Liu, Guangqi},
  booktitle = {Communications in Computer and Information Science},
  year = {2017},
  pages = {373-385},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-6385-5\_32},
  url = {https://doi.org/10.1007/978-981-10-6385-5\_32},
  abstract = {The diversity of Linux versions brings challenges to Linux memory analysis, which is an established technique in security and forensic investigations. During memory forensics, kernel data structures are essential information. Existing solutions obtain this information by analyzing debugging information or by decompiling kernel functions to handle a certain range of versions. In this paper, by collecting and analyzing a number of Linux versions, we characterize the properties of different Linux kernel versions and how struct offsets change between versions. Furthermore, the Linux kernel provides over 10,000 configurable features, which leads to different kernel structure layouts for the same kernel version. To deal with this problem, we propose a method of identifying kernel struct layout based on brute-force matching. By examining the relationships between kernel structures, common features are extracted and exploited for brute-force matching. The experimental results show that the proposed technology can deduce structure member offsets accurately and efficiently.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_76451_1_25,
  title = {An Automatic Approach of Building Threat Patterns in Android},
  author = {Chen, Chia-Mei and Tsai, Yu-Hsuan and Lai, Gu-Hsin},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2018},
  pages = {267-274},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-76451-1\_25},
  url = {https://doi.org/10.1007/978-3-319-76451-1\_25},
  abstract = {Nowadays, handheld devices have become popular but volume of malwares on mobile platform has also grown rapidly. To detect mobile malware, static approaches and dynamic approaches are two common ways used to analyze suspicious applications. Dynamic approaches detect malware base on the actual behaviors of applications, but how to trigger malicious behavior and the efficient of dynamic approaches are the difficulties of this kind of approaches. Due to the limited resource of mobile devices, static analysis approach is the practicable way to detect malwares on mobile device. Anti-virus software is the typical paradigm of static analysis approach. However, the effectiveness of Anti-virus software rely on its signatures. How to find an efficient and automatic way to build thread pattern of mobile malware is a critical issue to detect new or zero-day malware. In this paper, a detect mechanism based on data flow is proposed. The proposed system analyzes the function calls and the data flow to identify malicious behaviors in Android mobile devices. Machine learning approach is used to build threat patterns automatically within a great volume of applications. The experimental result shows that the proposed system could detect malware with high accuracy and low false positive rate.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_03427_6_22,
  title = {Smart Contracts and Opportunities for Formal Methods},
  author = {Miller, Andrew and Cai, Zhicheng and Jha, Somesh},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {280-299},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-03427-6\_22},
  url = {https://doi.org/10.1007/978-3-030-03427-6\_22},
  abstract = {Smart contracts are programs that run atop of a blockchain infrastructure. They have emerged as an important new programming model in cryptocurrencies like Ethereum, where they regulate flow of money and other digital assets according to user-defined rules. However, the most popular smart contract languages favor expressiveness rather than safety, and bugs in smart contracts have already lead to significant financial losses from accidents. Smart contracts are also appealing targets for hackers since they can be monetized. For these reasons, smart contracts are an appealing opportunity for systematic auditing and validation, and formal methods in particular. In this paper, we survey the existing smart-contract ecosystem and the existing tools for analyzing smart contracts. We then pose research challenges for formal-methods and program analysis applied to smart contracts.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10586_017_0981_6,
  title = {Android malware detection method based on naive Bayes and permission correlation algorithm},
  author = {Shang, Fengjun and Li, Yalin and Deng, Xiaolin and He, Dexiang},
  journal = {Cluster Computing},
  year = {2018},
  volume = {21},
  number = {1},
  pages = {955-966},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-017-0981-6},
  url = {https://doi.org/10.1007/s10586-017-0981-6},
  abstract = {In order to detect Android malware more effectively, an Android malware detection model was proposed based on improved naive Bayes classification. Firstly, considering the unknown permission that may be malicious in detection samples, and in order to improve the Android detection rate, the algorithm of malware detection is proposed based on improved naive Bayes. Considering the limited training samples, limited permissions, and the new malicious permissions in the test samples, we used the impact of the new malware permissions and training permissions as the weight. The weighted naive Bayesian algorithm improves the Android malware detection efficiency. Secondly, taking into account the detection model, we proposed a detection model of permissions and information theory based on the improved naive Bayes algorithm. We analyzed the correlation of the permission. By calculating the Pearson correlation coefficient, we determined the value of Pearson correlation coefficient r , and delete the permissions whose value r is less than the threshold \\(\\rho \\) and get the new permission set. So, we got the improved detection model by clustering based on information theory. Finally, we detected the 1725 Android malware and 945 non malicious application of multiple data sets in the same simulation environment. The detection rate of the improved the naive Bayes algorithm is 86.54\%, and the detection rate of the non-malicious application is increased to 97.59\%. Based on the improved naive Bayes algorithm, the false detection rate of the improved detection model is reduced by 8.25\%.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_69471_9_22,
  title = {My Smartphone Knows Your Health Data: Exploiting Android-Based Deception Attacks Against Smartbands},
  author = {Xie, Jun and Wu, Sha and Li, Yansong and Guo, Jun and Sun, Wen and Liu, Jiajia},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {291-306},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69471-9\_22},
  url = {https://doi.org/10.1007/978-3-319-69471-9\_22},
  abstract = {Although a number of vulnerabilities have been reported for smart wearables and lots of efforts have been taken to strengthen their security, wearable devices face still significant threats of privacy leakage due to their own inherent characteristics. Towards this end, we re-investigate in this paper the security concerns of smartbands. In particular, we first introduce our detailed methodology for security analysis, including log analysis, Hook technology, and Android reverse engineering. Then, we apply it to popular commercial smartbands of three different brands the concrete information of which is omitted, identify their common vulnerabilities, and develop accordingly a fake Android application (App) utilizing the identified loopholes, given the protection measures of shelling, obfuscation, as well as forcible pairing and resetting. By installing the fake App, we are able to conduct deception attacks against the targeted smartbands, succeeding to remotely activate/deactivate shaking function, to adjust/modify time (including value and format), and to obtain the smartband owner’s sensitive/health data. During our deception attacks, no cooperation from the smartband owner is required, neither the pairing process between the targeted smartbands and our fake App.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11036_018_1012_4,
  title = {Attack Detection Application with Attack Tree for Mobile System using Log Analysis},
  author = {Kim, Duhoe and Shin, Dongil and Shin, Dongkyoo and Kim, Yong-Hyun},
  journal = {Mobile Networks and Applications},
  year = {2019},
  volume = {24},
  number = {1},
  pages = {184-192},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11036-018-1012-4},
  url = {https://doi.org/10.1007/s11036-018-1012-4},
  abstract = {Recently, the use of smart phones has greatly increased because of the development of cheap high-performance hardware. The biggest threat to a smart phone user is the loss of his/her personal information by an attacker. To protect a user’s information from these threats, an attack detection application for the Android OS is proposed and developed, in which the detection system is comprised of two phases: the mobile detection system pre-phase and post-phase. The pre-phase includes the steps performed before an attack occurs for the comparison and analysis step of the post-phase, and the post-phase includes the steps performed to detect malware using an attack tree with level assignments from the post-phase. Three classes, interception, modification, and system damage, are defined to classify attacks to determine the attacker’s purpose. When an attack occurs, the application can recognize what kind of route the mobile attack goes through by comparing and analyzing the attack tree from the pre-phase and current attack data in the post-phase. Attack trees are used to easily extract attack scenarios and determine when an attack is occurring. We expect that using the proposed application will protect a user’s personal information on a mobile system.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_3108_1_9,
  title = {Classes and Objects},
  author = {Weston, Toby},
  booktitle = {Scala for Java Developers},
  year = {2018},
  pages = {53-65},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-3108-1\_9},
  url = {https://doi.org/10.1007/978-1-4842-3108-1\_9},
  abstract = {How you can define fields within the class body rather than on the class definition line and how this affects the generated methods.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_17184_1_23,
  title = {A Categorical Model of an \$\$\\mathbf \{i/o\}\$\$ -typed \$\$\\pi \$\$ -calculus},
  author = {Sakayori, Ken and Tsukada, Takeshi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {640-667},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-17184-1\_23},
  url = {https://doi.org/10.1007/978-3-030-17184-1\_23},
  abstract = {This paper introduces a new categorical structure that is a model of a variant of the \\( \\mathbf \{i/o\} \\) -typed \\( \\pi \\) -calculus, in the same way that a cartesian closed category is a model of the \\( \\lambda \\) -calculus. To the best of our knowledge, no categorical model has been given for the \\( \\mathbf \{i/o\} \\) -typed \\( \\pi \\) -calculus, in contrast to session-typed calculi, to which corresponding logic and categorical structure were given. The categorical structure introduced in this paper has a simple definition, combining two well-known structures, namely, closed Freyd category and compact closed category. The former is a model of effectful computation in a general setting, and the latter describes connections via channels, which cause the effect we focus on in this paper. To demonstrate the relevance of the categorical model, we show by a semantic consideration that the \\( \\pi \\) -calculus is equivalent to a core calculus of Concurrent ML.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42452_019_1124_x,
  title = {The Android malware detection systems between hope and reality},
  author = {Bakour, Khaled and Ünver, Halil Murat and Ghanem, Razan},
  journal = {SN Applied Sciences},
  year = {2019},
  volume = {1},
  number = {9},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42452-019-1124-x},
  url = {https://doi.org/10.1007/s42452-019-1124-x},
  abstract = {The widespread use of Android-based smartphones made it an important target for malicious applications’ developers. So, a large number of frameworks have been proposed to tackle the huge number of daily published malwares. Despite there are many review papers that have been conducted in order to shed light on the works that achieved in Android malware analysing domain, the number of conducted review papers do not fit with the importance of this research field and with the volume of achieved works. Also, there is no comprehensive taxonomy for all research trends in the field of analysing malicious applications targeting the Android system. Furthermore, none of the existing review papers contains a schematic model that makes it easy for the reader to know the methods and methodologies used in a particular field of research without much effort. This paper aims at proposing a comprehensive taxonomy and suggesting a new schematic review approach. To this end, a review of a large number of works that achieved between 2009 and 2019 has been conducted. The achieved study includes more than 200 papers that have different goals such as apps’ behaviour analysis, automatic user interface triggers or packer/unpacker frameworks development. Also, a comprehensive taxonomy has been proposed so that most of the previous works can be classified under it. To the best of our knowledge, the suggested taxonomy is the widest and the most comprehensive in terms of the covered research trends. Moreover, we have proposed a detailed schematic model (called Schematic Review Model) illustrates the process of detecting the malignant applications of an Android in the light of the studied works and the proposed taxonomy. To our knowledge, this is the first time that the Android malware detection methods have been explained in this way with this amount of detail. Furthermore, the studied researches have been analysed according to multiple criteria such as used analysing method, used features, used detection method, and used dataset. Also, the features used in the studied works were discussed in detail by dividing it into multiple classes. Moreover, the challenges facing Android’s malware analysing methods were discussed in detail. Finally, it has been concluded that there are gaps between the size and the goal of the conducted works and the number of malicious apps published every day, so some future works areas have been proposed and discussed.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_01701_9_9,
  title = {Automated Identification of Sensitive Data via Flexible User Requirements},
  author = {Yang, Ziqi and Liang, Zhenkai},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2018},
  pages = {151-171},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-01701-9\_9},
  url = {https://doi.org/10.1007/978-3-030-01701-9\_9},
  abstract = {Protecting sensitive data in web and mobile applications requires identifying sensitive data, which typically needs intensive manual efforts. In addition, deciding sensitive data subjects to users’ requirements and the application context. Existing research efforts on identifying sensitive data from its descriptive texts focus on keyword/phrase searching. These approaches can have high false positives/negatives as they do not consider the semantics of the descriptions. In this paper, we propose S3, an automated approach to identify sensitive data based on user requirements. It considers semantic, syntactic and lexical information comprehensively, aiming to identify sensitive data by the semantics of its descriptive texts. We introduce the notion concept space to represent the user’s notion of privacy, by which our approach can support flexible user requirements in defining sensitive data. Our approach is able to learn users’ preferences from readable concepts initially provided by users, and automatically identify related sensitive data. We evaluate our approach on over 18,000 top popular applications from Google Play Store. S3 achieves an average precision of 89.2\%, and average recall 95.8\% in identifying sensitive data.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_68542_7_48,
  title = {Android Malware Detection Using Hybrid Analysis and Machine Learning Technique},
  author = {Yang, Fan and Zhuang, Yi and Wang, Jun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {565-575},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68542-7\_48},
  url = {https://doi.org/10.1007/978-3-319-68542-7\_48},
  abstract = {This paper proposes a two-stage Android malware detection and classification mechanism based on machine learning algorithm. In this paper, we use the static analysis method to extract the software’s package features, permission features, component features and triggering mechanism. Then we use the dynamic analysis tools to obtain the dynamic behavior characters of the software, and format the static and dynamic features. Finally, we use the machine learning algorithm to deal with the feature eigenvectors in two stages, and then we will get the malicious classification of the software. The experimental results show that in the data set used in this paper the proposed method based on the combination of dynamic and static malicious code detection is more accurate than the common detection engine, and the ability of classifying malicious family is much stronger.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_94496_8_9,
  title = {Idea: Benchmarking Android Data Leak Detection Tools},
  author = {Corrodi, Claudio and Spring, Timo and Ghafari, Mohammad and Nierstrasz, Oscar},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {116-123},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-94496-8\_9},
  url = {https://doi.org/10.1007/978-3-319-94496-8\_9},
  abstract = {Virtual application stores for mobile platforms contain many malign and benign applications that exhibit security issues, such as the leaking of sensitive data. In recent years, researchers have proposed a myriad of techniques and tools to detect such issues automatically. However, it is unclear how these approaches perform compared to each other. The tools are often no longer available, thus comparing different approaches is almost infeasible. In this work, we propose an approach to execute static analysis tools and collect their output to obtain unified reports in a common format. We review the current state-of-the-art in Android data leak detection tools, and from a list of 87 approaches, of which we were able to obtain and execute five. We compare these using a set of known vulnerabilities and discuss the overall performance of the tools. We further present an approach to compare security analysis tools by normalising their interfaces, which simplifies result reproduction and extension.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_3820_2_11,
  title = {Building},
  author = {Späth, Peter},
  booktitle = {Pro Android with Kotlin},
  year = {2018},
  pages = {285-295},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-3820-2\_11},
  url = {https://doi.org/10.1007/978-1-4842-3820-2\_11},
  abstract = {In this chapter, we talk about the building process of your apps. Although building an app with source files can be done both using a terminal and using the graphical interface of the Android Studio IDE, this is not an introduction to Android Studio nor a code reference. For this type of in-depth instruction, please refer to the help included or to other books and online resources.},
  content_type = {Chapter},
}


@article{springer_10_3103_s0146411617080156,
  title = {Application of clustering methods for analyzing the security of Android applications},
  author = {Pavlenko, E. Yu. and Yarmak, A. V. and Moskvin, D. A.},
  journal = {Automatic Control and Computer Sciences},
  year = {2017},
  volume = {51},
  number = {8},
  pages = {867-873},
  publisher = {Allerton Press},
  doi = {10.3103/s0146411617080156},
  url = {https://doi.org/10.3103/s0146411617080156},
  abstract = {This paper presents the results from developing the system for detecting malicious Android applications based on the fuzzy clustering method. We have described the format of the application feature vector, as well as presented studies on the effectiveness of using different criteria for separability. The high efficiency of the proposed approach has been experimentally confirmed.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_02744_5_30,
  title = {Android Malware Detection Methods Based on the Combination of Clustering and Classification},
  author = {Xiong, Zhi and Guo, Ting and Zhang, Qinkun and Cheng, Yu and Xu, Kai},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {411-422},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-02744-5\_30},
  url = {https://doi.org/10.1007/978-3-030-02744-5\_30},
  abstract = {With the popularity of Android platform, Android malware detection is a challenging practical problem that needs to be resolved urgently. In this paper, we propose two static analysis methods for Android malware detection based on the combination of clustering and classification. First, we obtain original feature set from the manifest file and disassembled code of Android applications. Then, through the analysis of the category and appearance frequency of each feature, we extract some key features for malware detection so as to reduce the dimensionality of feature vector. Finally, we propose two methods based on the combination of clustering and classification to distinguish malicious and benign applications. One is mixed clustering, which clusters the malicious and benign samples together; the other is separate clustering, which clusters the malicious and benign samples separately. We choose to use the K-mean clustering algorithm and the K-Nearest Neighbor (KNN) classification algorithm. Evaluation results show that our methods outperform the common SVM-based method in detection accuracy, and outperform the KNN-based method in prediction time. In addition, the detection ability for unknown malware families of our methods is also better than that of the SVM-based method.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11277_017_5069_3,
  title = {Defect Prediction in Android Binary Executables Using Deep Neural Network},
  author = {Dong, Feng and Wang, Junfeng and Li, Qi and Xu, Guoai and Zhang, Shaodong},
  journal = {Wireless Personal Communications},
  year = {2018},
  volume = {102},
  number = {3},
  pages = {2261-2285},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11277-017-5069-3},
  url = {https://doi.org/10.1007/s11277-017-5069-3},
  abstract = {Software defect prediction locates defective code to help developers improve the security of software. However, existing studies on software defect prediction are mostly limited to the source code. Defect prediction for Android binary executables (called apks) has never been explored in previous studies. In this paper, we propose an explorative study of defect prediction in Android apks. We first propose smali2vec, a new approach to generate features that capture the characteristics of smali (decompiled files of apks) files in apks. Smali2vec extracts both token and semantic features of the defective files in apks and such comprehensive features are needed for building accurate prediction models. Then we leverage deep neural network (DNN), which is one of the most common architecture of deep learning networks, to train and build the defect prediction model in order to achieve accuracy. We apply our defect prediction model to more than 90,000 smali files from 50 Android apks and the results show that our model could achieve an AUC (the area under the receiver operating characteristic curve) of 85.98\% and it is capable of predicting defects in apks. Furthermore, the DNN is proved to have a better performance than the traditional shallow machine learning algorithms (e.g., support vector machine and naive bayes) used in previous studies. The model has been used in our practical work and helped locate many defective files in apks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_5281_1_7,
  title = {Using Weighted Based Feature Selection Technique for Android Malware Detection},
  author = {Mazlan, Nurul Hidayah and Hamid, Isredza Rahmi A.},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2018},
  pages = {54-64},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-5281-1\_7},
  url = {https://doi.org/10.1007/978-981-10-5281-1\_7},
  abstract = {Recently, the popularity of mobile devices has risen drastically due to the increased functionality of the devices. This matter forces a large number of security challenges that need high consideration. Android malware detection method can be divided into two types, which are static and dynamic analysis. Static techniques are often prone to high false negative rates due to evolution in code basis and code repacking, although fast and efficient. While dynamic and behavior based analysis aims to provide methods for effectively and efficiently extracting unique patterns of each malware family based on its behavior. To address some of those shortcomings, the study uses permission-based Android malware feature as a basis for malware detection using weighted based technique.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_05051_1_21,
  title = {Maintaining Root via Custom Android Kernel Across Over-The-Air Upgrade},
  author = {Zucheng, Huang and Lu, Liu and Yuanzhang, Li and Yu, Zhang and Qikun, Zhang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {299-309},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-05051-1\_21},
  url = {https://doi.org/10.1007/978-3-030-05051-1\_21},
  abstract = {People can obtain the highest privileges and control devices by Android root. However, an Android phone has been rooted, it is difficult for the user to update the Android system. Aiming at these problems, this paper proposes a maintaining root via custom Android kernel across Over-The-Air (OTA) upgrade. By customizing the kernel in boot and recovery, the boot will be replaced with rooted boot after updating automatically, so that system not only can be updated successfully but also maintain root. Experiments show that there is no abnormal between rooted mobile with a customized kernel and normal mobile during a minor system update.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_95270_3_40,
  title = {Vulkan Abstraction Layer for Large Data Remote Rendering System},
  author = {Lavrič, Primož and Bohak, Ciril and Marolt, Matija},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {480-488},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-95270-3\_40},
  url = {https://doi.org/10.1007/978-3-319-95270-3\_40},
  abstract = {New graphics APIs require users to implement a lot of needed functionality, such as memory management, by themselves. In this paper we present an abstraction layer build on top of such API, in our case the Vulkan API, for purpose of off-screen rendering of large data. We also present a use case for such abstraction layer implementation – a remote rendering system for simple Path Tracing accessible through web-based client-side application. The preliminary evaluation results show that implementation of simple Path Tracer is significantly faster then comparable implementation in OpenCL. In conclusion we also present possible extension and improvements of the developed abstraction layer.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_23467_0_15,
  title = {Instruction Level Loop De-optimization},
  author = {Hu, Erh-Wen and Su, Bogong and Wang, Jian},
  booktitle = {Studies in Computational Intelligence},
  year = {2016},
  pages = {221-234},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-23467-0\_15},
  url = {https://doi.org/10.1007/978-3-319-23467-0\_15},
  abstract = {Instruction level loop optimization has been widely used in modern compilers. Decompilation—the reverse of compilation—has also generated much interest for its applications in porting legacy software written in assembly language to new architectures, re-optimizing assembly code, and more recently, in detecting and analyzing malware. However, little work has been reported on loop decompilation at instruction level. In this paper, we report our work on loop de-optimization at instruction level. We demonstrate our approach with a practical working example and carried out experiments on TIC6x, a digital signal processor with a compiler supporting instruction level parallelism. The algorithms developed in this paper should help interested readers gain insight especially in the difficult tasks of loop rerolling and software de-pipelining, the necessary steps to decompile loops at instruction level.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_98488_9_9,
  title = {The File destroyAll.exe: On Executing Proprietary Software},
  author = {Tzitzikas, Yannis and Marketakis, Yannis},
  booktitle = {Cinderella's Stick},
  year = {2018},
  pages = {83-93},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98488-9\_9},
  url = {https://doi.org/10.1007/978-3-319-98488-9\_9},
  abstract = {This chapter describes the pattern “Executables: Safety and Dependencies”. This episode observes Robert’s attempt to check whether it is safe to execute a particular executable file. The technical sections discuss the fundamental concepts of program termination, decidability and tractability, as well as software engineering concepts including code injection, software viruses, antivirus software, and finally, software emulation and virtual machines.},
  content_type = {Chapter},
}


@article{springer_10_1007_s13369_017_2951_y,
  title = {Bio-inspired for Features Optimization and Malware Detection},
  author = {Razak, Mohd Faizal Ab and Anuar, Nor Badrul and Othman, Fazidah and Firdaus, Ahmad and Afifi, Firdaus and Salleh, Rosli},
  journal = {Arabian Journal for Science and Engineering},
  year = {2018},
  volume = {43},
  number = {12},
  pages = {6963-6979},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s13369-017-2951-y},
  url = {https://doi.org/10.1007/s13369-017-2951-y},
  abstract = {The leaking of sensitive data on Android mobile device poses a serious threat to users, and the unscrupulous attack violates the privacy of users. Therefore, an effective Android malware detection system is necessary. However, detecting the attack is challenging due to the similarity of the permissions in malware with those seen in benign applications. This paper aims to evaluate the effectiveness of the machine learning approach for detecting Android malware. In this paper, we applied the bio-inspired algorithm as a feature optimization approach for selecting reliable permission features that able to identify malware attacks. A static analysis technique with machine learning classifier is developed from the permission features noted in the Android mobile device for detecting the malware applications. This technique shows that the use of Android permissions is a potential feature for malware detection. The study compares the bio-inspired algorithm [particle swarm optimization (PSO)] and the evolutionary computation with information gain to find the best features optimization in selecting features. The features were optimized from 378 to 11 by using bio-inspired algorithm: particle swarm optimization (PSO). The evaluation utilizes 5000 Drebin malware samples and 3500 benign samples. In recognizing the Android malware, it appears that AdaBoost is able to achieve good detection accuracy with a true positive rate value of 95.6\%, using Android permissions. The results show that particle swarm optimization (PSO) is the best feature optimization approach for selecting features.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_59608_2_1,
  title = {AppShield: Enabling Multi-entity Access Control Cross Platforms for Mobile App Management},
  author = {Qu, Zhengyang and Guo, Guanyu and Shao, Zhengyue and Rastogi, Vaibhav and Chen, Yan and Chen, Hao and Hong, Wangjun},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2017},
  pages = {3-23},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-59608-2\_1},
  url = {https://doi.org/10.1007/978-3-319-59608-2\_1},
  abstract = {Bring-your-own-device (BYOD) is getting popular. Diverse personal devices are used to access enterprise resources, and deployment of the solutions with customized operating system (OS) dependency will thus be restricted. Moreover, device utilization for both business and personal purposes creates new threats involving leakage of sensitive data. As for functionalities, a BYOD solution should isolate an arbitrary number of entities, such as those relating to business and personal uses and provide fine-grained access control on multi-entity management. Existing BYOD solutions lack in these aspects; we propose a system, called AppShield , which supports multi-entity management and role-based access control with file-level granularity, apart from local data sharing/isolation. AppShield includes (1) application rewriting framework for Android apps, which builds Mobile Application Management (MAM) features into app automatically with complete mediation, (2) cross-platform proxy-based data access mechanism, which can enforce arbitrary access control policies. The fully functional controller with data proxy is implemented for both Android and iOS. AppShield allows for enterprise policy management without modifying device OS. The evaluation shows that AppShield is successful at policy enforcement and is reliable. It induces little impact on application’s performance and size, for example, our app rewriting introduces less than 5\% code size increment in over 95\% apps in our evaluation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_05063_4_14,
  title = {MulAV: Multilevel and Explainable Detection of Android Malware with Data Fusion},
  author = {Li, Qun and Chen, Zhenxiang and Yan, Qiben and Wang, Shanshan and Ma, Kun and Shi, Yuliang and Cui, Lizhen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {166-177},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-05063-4\_14},
  url = {https://doi.org/10.1007/978-3-030-05063-4\_14},
  abstract = {With the popularization of smartphones, the number of mobile applications has grown substantially. However, many malware are emerging and thus pose a serious threat to the user’s mobile phones. Malware detection has become a public concern that requires urgent resolution. In this paper, we propose MulAV, a multilevel and explainable detection method with data fusion. Our method obtain information from multiple levels (the APP source code, network traffic, and geospatial information) and combine it with machine learning method to train a model which can identify mobile malware with high accuracy and few false alarms. Experimental result shows that MulAV outperforms other anti-virus scanners and methods and achieves a detection rate of 97.8\% with 0.4\% false alarms. Furthermore, for the benefit of users, MulAV displays the explanation for each detection, thus revealing relevant properties of the detected malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_89500_0_28,
  title = {Deobfuscation of Virtualization-Obfuscated Code Through Symbolic Execution and Compilation Optimization},
  author = {Liang, Mingyue and Li, Zhoujun and Zeng, Qiang and Fang, Zhejun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {313-324},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-89500-0\_28},
  url = {https://doi.org/10.1007/978-3-319-89500-0\_28},
  abstract = {Virtualization-obfuscation replaces native code in a binary with semantically equivalent and self-defined bytecode, which, upon execution, is interpreted by a custom virtual machine. It makes the code very difficult to analyze and is thus widely used in malware. How to deobfuscate such virtualization obfuscated code has been an important and challenging problem. We approach the problem from an innovative perspective by transforming it into a compilation optimization problem, and propose a novel technique that combines trace analysis, symbolic execution and compilation optimization to defeat virtualization obfuscation. We implement a prototype system and evaluate it against popular virtualization obfuscators; the results demonstrate that our method is effective in deobfuscation of virtualization-obfuscated code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_7844_6_11,
  title = {Malware Detection with Convolutional Neural Network Using Hardware Events},
  author = {Guo, Wei and Wang, Tenghai and Wei, Jizeng},
  booktitle = {Communications in Computer and Information Science},
  year = {2018},
  pages = {104-115},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-7844-6\_11},
  url = {https://doi.org/10.1007/978-981-10-7844-6\_11},
  abstract = {Detection of malicious programs (i.e., malwares) is a great challenge due to increasing amount and variety of attacks. Recent works have shown that machine learning, especially neural network, performs well in malware detection. In this paper, convolution neural network (CNN) is used to build the malware classification model. Different from other works, our work uses hardware events to generate the feature image of programs. These hardware events, such as cache miss rate, branch misprediction rate, can be collected from the performance counter in the Intel CPUs. We train CNN with kinds of data sizes and kernel sizes, and evaluate the result by the area under a receiver operating characteristics (ROC) curve (AUC). The results show the proposed classification model can achieve AUC = 0.9973 in best case and the influence by the data size or kernel size is very little. Moreover, by comparison with other CNNs trained with software-based features, it is indicated that the proposed model has higher accuracy than the other ones.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_51966_1_17,
  title = {On the Feasibility of Malware Authorship Attribution},
  author = {Alrabaee, Saed and Shirani, Paria and Debbabi, Mourad and Wang, Lingyu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {256-272},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-51966-1\_17},
  url = {https://doi.org/10.1007/978-3-319-51966-1\_17},
  abstract = {There are many occasions in which the security community is interested to discover the authorship of malware binaries, either for digital forensics analysis of malware corpora or for thwarting live threats of malware invasion. Such a discovery of authorship might be possible due to stylistic features inherent to software codes written by human programmers. Existing studies of authorship attribution of general purpose software mainly focus on source code, which is typically based on the style of programs and environment. However, those features critically depend on the availability of the program source code, which is usually not the case when dealing with malware binaries. Such program binaries often do not retain many semantic or stylistic features due to the compilation process. Therefore, authorship attribution in the domain of malware binaries based on features and styles that will survive the compilation process is challenging. This paper provides the state of the art in this literature. Further, we analyze the features involved in those techniques. By using a case study, we identify features that can survive the compilation process. Finally, we analyze existing works on binary authorship attribution and study their applicability to real malware binaries.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_78717_6_7,
  title = {Geometric Semantic Grammatical Evolution},
  author = {Moraglio, Alberto and McDermott, James and O’Neill, Michael},
  booktitle = {Handbook of Grammatical Evolution},
  year = {2018},
  pages = {163-188},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-78717-6\_7},
  url = {https://doi.org/10.1007/978-3-319-78717-6\_7},
  abstract = {Geometric Semantic Genetic Programming (GSGP) is a novel form of Genetic Programming (GP), based on a geometric theory of evolutionary algorithms, which directly searches the semantic space of programs. In this chapter, we extend this framework to Grammatical Evolution (GE) and refer to the new method as Geometric Semantic Grammatical Evolution (GSGE). We formally derive new mutation and crossover operators for GE which are guaranteed to see a simple unimodal fitness landscape. This surprising result shows that the GE genotype-phenotype mapping does not necessarily imply low genotype-fitness locality. To complement the theory, we present extensive experimental results on three standard domains (Boolean, Arithmetic and Classifier).},
  content_type = {Chapter},
}


@article{springer_10_1007_s00500_018_3377_5,
  title = {Entropy-based security risk measurement for Android mobile applications},
  author = {Deypir, Mahmood},
  journal = {Soft Computing},
  year = {2019},
  volume = {23},
  number = {16},
  pages = {7303-7319},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00500-018-3377-5},
  url = {https://doi.org/10.1007/s00500-018-3377-5},
  abstract = {Android as a widest used operating system for smartphones and mobile devices uses permissions to restrict malicious applications (apps). However, malware developers use various social engineering methods to entice users for installing malwares after granting critical permissions by users. Therefore, it is essential to estimate security risks of untrusted Android apps to help users for making better decisions regarding app selection and installation. In this paper, the concept of criticality for Android permissions is precisely defined according to the abuse of permissions by known malwares and their legal usage by useful apps. Based on this definition and analyzing requested permissions of large numbers of malwares and benign apps, a new criterion is proposed to measure the security risks of the apps. This measure benefits from the concepts of entropy and information gain of permissions regarding separating malwares from benign apps. In this criterion, more informative permissions have higher impacts on the computed risk values. In order to evaluate the proposed criterion, two new datasets of recent malicious and non-malicious Android apps have been constructed and analyzed against existing ones. This analysis shows that permission usage patterns of Android apps are changed over the time. Empirical evaluations on recent and previous malwares and benign apps reveal the superiority of the proposed criterion with respect to previously proposed ones in terms of assigning larger risk values to malwares.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_017_9507_3,
  title = {A study of the relation of mobile device attributes with the user-perceived quality of Android apps},
  author = {Noei, Ehsan and Syer, Mark D. and Zou, Ying and Hassan, Ahmed E. and Keivanloo, Iman},
  journal = {Empirical Software Engineering},
  year = {2017},
  volume = {22},
  number = {6},
  pages = {3088-3116},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-017-9507-3},
  url = {https://doi.org/10.1007/s10664-017-9507-3},
  abstract = {The number of mobile applications (apps) and mobile devices has increased considerably over the past few years. Online app markets, such as the Google Play Store, use a star-rating mechanism to quantify the user-perceived quality of mobile apps. Users may rate apps on a five point (star) scale where a five star-rating is the highest rating. Having considered the importance of a high star-rating to the success of an app, recent studies continue to explore the relationship between the app attributes, such as User Interface (UI) complexity, and the user-perceived quality. However, the user-perceived quality reflects the users’ experience using an app on a particular mobile device. Hence, the user-perceived quality of an app is not solely determined by app attributes. In this paper, we study the relation of both device attributes and app attributes with the user-perceived quality of Android apps from the Google Play Store. We study 20 device attributes, such as the CPU and the display size, and 13 app attributes, such as code size and UI complexity. Our study is based on data from 30 types of Android mobile devices and 280 Android apps. We use linear mixed effect models to identify the device attributes and app attributes with the strongest relationship with the user-perceived quality. We find that the code size has the strongest relationship with the user-perceived quality. However, some device attributes, such as the CPU, have stronger relationships with the user-perceived quality than some app attributes, such as the number of UI inputs and outputs of an app. Our work helps both device manufacturers and app developers. Manufacturers can focus on the attributes that have significant relationships with the user-perceived quality. Moreover, app developers should be careful about the devices for which they make their apps available because the device attributes have a strong relationship with the ratings that users give to apps.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_69155_8_10,
  title = {Security Protocol of Social Payment Apps},
  author = {Saini, Jasmeen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {139-150},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69155-8\_10},
  url = {https://doi.org/10.1007/978-3-319-69155-8\_10},
  abstract = {Social Payment Apps have now become an integral part of individual’s life and business operations because of its reliability, easiness, and pace of transferring money. However, with the development of new technology, the security related issues have also increased drastically. In this research, many problematic issues have been observed in various apps that are in use these days. Both technical and social vulnerabilities were observed, that would allow an adversary to steal individual’s credential information or leak it. Moreover, a usable and secure payment guidelines and steps will be provided to make a better payment application which will gain users’ trust and e-commerce business. To measure the performance of the used payment app, one needs to dive off the boat in order to understand the flaws. Venmo, Google Wallet, and Apple Pay are the key apps that are analyzed and risks are observed in relation to social engineering. Moreover, a secure payment protocol using one-time password tokenization method is proposed that will keep transactions more secure. This research enlightens the security challenges and possible mitigations to prevent data breaches.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_98488_9_14,
  title = {The Folder myExperiment: On Verifying and Reproducing Data},
  author = {Tzitzikas, Yannis and Marketakis, Yannis},
  booktitle = {Cinderella's Stick},
  year = {2018},
  pages = {133-145},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98488-9\_14},
  url = {https://doi.org/10.1007/978-3-319-98488-9\_14},
  abstract = {This chapter describes the pattern “Reproducibility of scientific results.” The episode describes the adventures of Robert to verify the claims of a research paper. The technical sections describe HTML resources, web archiving, web citation, scientific publishing, trust in digital repositories, the data–information–knowledge–wisdom hierarchy, lab notebooks, and the limitations stemming from Kurt Gödel’s work.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_89500_0_56,
  title = {Statically Defend Network Consumption Against Acker Failure Vulnerability in Storm},
  author = {Qian, Wenjun and Shen, Qingni and Yang, Yizhe and Yang, Yahui and Wu, Zhonghai},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {661-673},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-89500-0\_56},
  url = {https://doi.org/10.1007/978-3-319-89500-0\_56},
  abstract = {Storm has been a popular distributed real-time computation system for stream data processing, which currently provides an acker mechanism to enable all topologies to be processed reliably. In this paper, via the source code analysis, we point out that the acker failure and message retransmission result in the consumption of network resources. Even worse, adversary conducts a malicious topology to consume over unconstrained network resources, which seriously affects the average processing time of topology for normal users. Aiming at defending the vulnerability, we design an offline static detection against acker failure in Storm, mainly including the code decompile, the function call relationship and the judgement rules in offline module. Meanwhile, we validate the protection scheme in Storm 0.10.0 cluster, and experimental results show that our mentioned judgement rules can achieve well precision.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_75650_9_14,
  title = {Ethereum: State of Knowledge and Research Perspectives},
  author = {Tikhomirov, Sergei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {206-221},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-75650-9\_14},
  url = {https://doi.org/10.1007/978-3-319-75650-9\_14},
  abstract = {Ethereum is a major blockchain-based platform for smart contracts – Turing complete programs that are executed in a decentralized network and usually manipulate digital units of value. A peer-to-peer network of mutually distrusting nodes maintains a common view of the global state and executes code upon request. The stated is stored in a blockchain secured by a proof-of-work consensus mechanism similar to that in Bitcoin. The core value proposition of Ethereum is a full-featured programming language suitable for implementing complex business logic. Decentralized applications without a trusted third party are appealing in areas like crowdfunding, financial services, identity management, and gambling. Smart contracts are a challenging research topic that spans over areas ranging from cryptography, consensus algorithms, and programming languages to governance, finance, and law. This paper summarizes the state of knowledge in this field. We provide a technical overview of Ethereum, outline open challenges, and review proposed solutions. We also mention alternative smart contract blockchains.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_019_09687_9,
  title = {Studying the characteristics of logging practices in mobile apps: a case study on F-Droid},
  author = {Zeng, Yi and Chen, Jinfu and Shang, Weiyi and Chen, Tse-Hsun (Peter)},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {6},
  pages = {3394-3434},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09687-9},
  url = {https://doi.org/10.1007/s10664-019-09687-9},
  abstract = {Logging is a common practice in software engineering. Prior research has investigated the characteristics of logging practices in system software (e.g., web servers or databases) as well as desktop applications. However, despite the popularity of mobile apps, little is known about their logging practices. In this paper, we sought to study logging practices in mobile apps. In particular, we conduct a case study on 1,444 open source Android apps in the F-Droid repository. Through a quantitative study, we find that although mobile app logging is less pervasive than server and desktop applications, logging is leveraged in almost all studied apps. However, we find that there exist considerable differences between the logging practices of mobile apps and the logging practices in server and desktop applications observed by prior studies. In order to further understand such differences, we conduct a firehouse email interview and a qualitative annotation on the rationale of using logs in mobile app development. By comparing the logging level of each logging statement with developers’ rationale of using the logs, we find that all too often (35.4\%), the chosen logging level and the rationale are inconsistent. Such inconsistency may prevent the useful runtime information to be recorded or may generate unnecessary logs that may cause performance overhead. Finally, to understand the magnitude of such performance overhead, we conduct a performance evaluation between generating all the logs and not generating any logs in eight mobile apps. In general, we observe a statistically significant performance overhead based on various performance metrics (response time, CPU and battery consumption). In addition, we find that if the performance overhead of logging is significantly observed in an app, disabling the unnecessary logs indeed provides a statistically significant performance improvement. Our results show the need for a systematic guidance and automated tool support to assist in mobile logging practices.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_74500_8_17,
  title = {Detection and Classification of Malwares in Mobile Applications},
  author = {Ilham, Soussi and Ghadi, Abderrahim},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2018},
  pages = {188-199},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-74500-8\_17},
  url = {https://doi.org/10.1007/978-3-319-74500-8\_17},
  abstract = {Android is the most widely used as mobile operation system, the thing that make it the target of many attackers, day by day the market of malicious applications develop and grow to reach every applications store. In this purpose many researches have been made to deal with threats through proposing different malware detection techniques. The main objective of this thesis is to detect malwares in android mobiles by applying reverse engineering techniques to unpack malicious apps code and classify them in order to detect whether the app is malicious or not. This paper aims to give a comprehensive account of proposed techniques to detect and classify malicious applications in android mobiles based on machine learning algorithms and a comparison between those techniques in order to conclude the most efficient one and their limitations with a view to ameliorate them.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_01701_9_16,
  title = {FGFDect: A Fine-Grained Features Classification Model for Android Malware Detection},
  author = {Liu, Chao and Li, Jianan and Yu, Min and Luo, Bo and Li, Song and Chen, Kai and Huang, Weiqing and Lv, Bin},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2018},
  pages = {281-293},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-01701-9\_16},
  url = {https://doi.org/10.1007/978-3-030-01701-9\_16},
  abstract = {In Android malware detection, fine-grained features can provide a more accurate description of the application’s behavior. Nonetheless fine-grained feature extraction has not been done perfectly, hence, invalid features will not only bring additional overhead but also reduce the detection accuracy. In this paper, we propose FGFDect, a malware classification model by mining Android applications for fine-grained features. Our work aims to handle two types of features that frequently appear in Android malware. One of them refers to the permissions that have been registered, but actually not been used. The other is the API called via the reflection mechanism. This information improves the precision of static analysis, which no longer need to make conservative assumptions about coarse-grained features. These two feature sets are fed into the machine learning algorithms to classify the app into benign or malware. FGFDect is evaluated on a large real-world data set consisting of 6400 malware apps and 4600 popular benign apps. Compared with those traditional approaches with coarse-grained features, extensive evaluation results demonstrate that the proposed approach exhibits an impressive detection accuracy of 96.7\% with the false positive rate of 0.7\%. In addition, the proposed approach complements existing permission-based approaches and API-based approaches.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_98488_9_18,
  title = {The Meta-Pattern: Toward a Common Umbrella},
  author = {Tzitzikas, Yannis and Marketakis, Yannis},
  booktitle = {Cinderella's Stick},
  year = {2018},
  pages = {189-223},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98488-9\_18},
  url = {https://doi.org/10.1007/978-3-319-98488-9\_18},
  abstract = {This chapter attempts to generalize and describe a more universal “Meta-Pattern”. It can be considered as an agile approach that is based on the notion of task performability and is powered by knowledge-based reasoning services. This is the most compact, technically-wise, chapter of the book, suitable for all those who would embrace a deeper and more insightful inspection.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_97916_8_10,
  title = {Detecting Privacy Information Abuse by Android Apps from API Call Logs},
  author = {Ito, Katsutaka and Hasegawa, Hirokazu and Yamaguchi, Yukiko and Shimada, Hajime},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {143-157},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-97916-8\_10},
  url = {https://doi.org/10.1007/978-3-319-97916-8\_10},
  abstract = {In these years, the use of smartphones is spreading. Android is the most major smartphone OS in the world, and there are a lot of third-party application stores for Android. Such third-party stores make it easy to install third-party applications. However, these applications may access and obtain privacy information, in addition to their major functions. There is a survey showing that most users do not take good care of the settings about how their privacy information is handled by applications. Thus, privacy information abuse by authorized application is becoming a serious problem. In this paper, we propose a method to detect applications that access privacy information unrelated to their functionalities by analyzing API call logs, which can reveal the activities of the application. In order to record API call logs, we modified the Android source code, and run the rebuilt system on an emulator. We analyzed applications’ API call logs with a statistical method, based on the frequency of privacy information accessing and network activities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_00262_6_12,
  title = {Security and Software Engineering},
  author = {Malek, Sam and Bagheri, Hamid and Garcia, Joshua and Sadeghi, Alireza},
  booktitle = {Handbook of Software Engineering},
  year = {2019},
  pages = {445-489},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-00262-6\_12},
  url = {https://doi.org/10.1007/978-3-030-00262-6\_12},
  abstract = {Software systems are permeating every facet of our society, making security breaches costlier than ever before. At the same time, as software systems grow in complexity, so does the difficulty of ensuring their security. As a result, the problem of securing software, in particular software that controls critical infrastructure, is growing in prominence. Software engineering community has developed numerous approaches for promoting and ensuring security of software. In fact, many security vulnerabilities are effectively avoidable through proper application of well-established software engineering principles and techniques. In this chapter, we first provide an introduction to the principles and concepts in software security from the standpoint of software engineering. We then provide an overview of four categories of approaches for achieving security in software systems, namely, static and dynamic analyses, formal methods, and adaptive mechanisms. We introduce the seminal work from each area and intuitively demonstrate their applications on several examples. We also enumerate on the strengths and shortcomings of each approach to help software engineers with making informed decisions when applying these approaches in their projects. Finally, the chapter provides an overview of the major research challenges from each approach, which we hope to shape the future research efforts in this area.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_22102_1_12,
  title = {Improved Tool Support for Machine-Code Decompilation in HOL4},
  author = {Fox, Anthony},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {187-202},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-22102-1\_12},
  url = {https://doi.org/10.1007/978-3-319-22102-1\_12},
  abstract = {The HOL4 interactive theorem prover provides a sound logical environment for reasoning about machine-code programs. The rigour of HOL’s LCF-style kernel naturally guarantees very high levels of assurance, but it does present challenges when it comes implementing efficient proof tools. This paper presents improvements that have been made to our methodology for soundly decompiling machine-code programs to functions expressed in HOL logic. These advancements have been facilitated by the development of a domain specific language, called L3, for the specification of Instruction Set Architectures (ISAs). As a result of these improvements, decompilation is faster (on average by one to two orders of magnitude), the instruction set specifications are easier to write, and the proof tools are easier to maintain.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s42400_018_0007_6,
  title = {Using IM-Visor to stop untrusted IME apps from stealing sensitive keystrokes},
  author = {Tian, Chen and Wang, Yazhe and Liu, Peng and Zhou, Qihui and Zhang, Chengyi},
  journal = {Cybersecurity},
  year = {2018},
  volume = {1},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-018-0007-6},
  url = {https://doi.org/10.1186/s42400-018-0007-6},
  abstract = {Third-party IME (Input Method Editor) apps are often the preference means of interaction for Android users’ input. In this paper, we first discuss the insecurity of IME apps, including the Potentially Harmful Apps (PHAs) and malicious IME apps, which may leak users’ sensitive keystrokes. The current defense system, such as I-BOX, is vulnerable to the prefix substitution attack and the colluding attack due to the post-IME nature. We provide a deeper understanding that all the designs with the post-IME nature are subject to the prefix-substitution and colluding attacks. To remedy the above post-IME system’s flaws, we propose a new idea, pre-IME, which guarantees that “Is this touch event a sensitive keystroke?” analysis will always access user touch events prior to the execution of any IME app code. We design an innovative TrustZone-based framework named IM-Visor which has the pre-IME nature. Specifically, IM-Visor creates the isolation environment named STIE as soon as a user intends to type on a soft keyboard, then the STIE intercepts,Android event sub translates and analyzes the user’s touch input. If the input is sensitive, the translation of keystrokes will be delivered to user apps through a trusted path. Otherwise, IM-Visor replays non-sensitive keystroke touch events for IME apps or replays non-keystroke touch events for other apps. A prototype of IM-Visor has been implemented and tested with several most popular IMEs. The experimental results show that IM-Visor has small runtime overheads.},
  content_type = {Article},
}


@article{springer_10_1007_s12652_017_0657_3,
  title = {LMDGW: a novel matrix based dynamic graph watermark},
  author = {Zeng, Lingling and Ren, Wei and Chen, Yuling and Lei, Min},
  journal = {Journal of Ambient Intelligence and Humanized Computing},
  year = {2019},
  volume = {10},
  number = {1},
  pages = {295-304},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12652-017-0657-3},
  url = {https://doi.org/10.1007/s12652-017-0657-3},
  abstract = {Android platform induces an open application development framework to attract more developers and promote larger market occupations. However, the open architecture also makes it easier to reverse engineering, which results in the property loss for both developers and companies, and increases the risks of mobile malicious code. Therefore, copyright protection for android application is of significant importance. A class of copyright protection methods are based on Android watermark. Different from static watermark, the process of embedding and extracting of dynamic graph watermark (DGW) is based on the function path and operation process of the app, which has better concealment. In this paper, we proposed a late-model dynamic watermark based on matrix, called “LMDGW” . This method is proposed to overcome the shortcoming of unintuitive and vulnerable property of traditional numberal DGW. We encode a matrix with low rank into a watermark graph, and embed the graph construction statements into smali code. With the containing of sensitive block characteristics, LMDGW is able to perceive and locate the changes in the specific block. Besides, LWDGW has great performance in tamper-proof attacks. Experiment results and analysis justified that LMDGW has great data rate and robust, and is available in sensitive code locating. LMDGW is proved to be an intelligent watermarking scheme, and is enlightening for intelligent security.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_17184_1_5,
  title = {Codata in Action},
  author = {Downen, Paul and Sullivan, Zachary and Ariola, Zena M. and Peyton Jones, Simon},
  booktitle = {Lecture Notes in Computer Science},
  year = {2019},
  pages = {119-146},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-17184-1\_5},
  url = {https://doi.org/10.1007/978-3-030-17184-1\_5},
  abstract = {Computer scientists are well-versed in dealing with data structures. The same cannot be said about their dual: codata. Even though codata is pervasive in category theory, universal algebra, and logic, the use of codata for programming has been mainly relegated to representing infinite objects and processes. Our goal is to demonstrate the benefits of codata as a general-purpose programming abstraction independent of any specific language: eager or lazy, statically or dynamically typed, and functional or object-oriented. While codata is not featured in many programming languages today, we show how codata can be easily adopted and implemented by offering simple inter-compilation techniques between data and codata. We believe codata is a common ground between the functional and object-oriented paradigms; ultimately, we hope to utilize the Curry-Howard isomorphism to further bridge the gap.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_92970_5_10,
  title = {Cross-Architecture Lifter Synthesis},
  author = {van Tonder, Rijnard and Le Goues, Claire},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {155-170},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-92970-5\_10},
  url = {https://doi.org/10.1007/978-3-319-92970-5\_10},
  abstract = {Code translation is a staple component of program analysis. A lifter is a code translation unit that translates low-level code to a higher-level intermediate representation (IR). Lifters thus enable a host of static and dynamic analyses for such low-level code. However, writing a lifter is a tedious manual process which must be repeated for every architecture an analysis aims to support. We introduce cross-architecture lifter synthesis, a novel approach that automatically synthesizes lifters for previously unsupported architectures. Our insight is that lifter synthesis can be bootstrapped with existing IR sketches that exploit the shared semantic properties of heterogeneous architecture instruction sets. We show that our approach automates a significant amount of translation effort for a previously unsupported instruction set, and that it enables discovery of new bugs on new architecture targets through reuse of an existing IR-based analysis.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_78813_5_12,
  title = {Turing Obfuscation},
  author = {Wang, Yan and Wang, Shuai and Wang, Pei and Wu, Dinghao},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2018},
  pages = {225-244},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-78813-5\_12},
  url = {https://doi.org/10.1007/978-3-319-78813-5\_12},
  abstract = {Obfuscation is an important technique to protect software from adversary analysis. Control flow obfuscation effectively prevents attackers from understanding the program structure, hence impeding a broad set of reverse engineering efforts. In this paper, we propose a novel control flow obfuscation method which employs Turing machines to simulate the computation of branch conditions. By weaving the original program with Turing machine components, program control flow graph and call graph can become much more complicated. In addition, due to the runtime computation complexity of a Turing machine, program execution flow would be highly obfuscated and become resilient to advanced reverse engineering approaches via symbolic execution and concolic testing. We have implemented a prototype tool for Turing obfuscation. Comparing with previous work, our control flow obfuscation technique delivers three distinct advantages. (1) Complexity: the complicated structure of a Turing machine makes it difficult for attackers to understand the program control flow. (2) Universality: Turing machines can encode any computation and hence applicable to obfuscate any program component. (3) Resiliency: Turing machine brings in complex execution model, which is shown to withstand automated reverse engineering efforts. Our evaluation obfuscates control flow predicates of two widely-used applications, and the experimental results show that the proposed technique can obfuscate programs in stealth with good performance and robustness.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_73512_2_6,
  title = {Automotive Cybersecurity},
  author = {Möller, Dietmar P. F. and Haas, Roland E.},
  booktitle = {Computer Communications and Networks},
  year = {2019},
  pages = {265-377},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73512-2\_6},
  url = {https://doi.org/10.1007/978-3-319-73512-2\_6},
  abstract = {Cybersecurity is the body of technologies, processes, and practices designed to protect computers, data, networks, and programs against intrusion, damage, or unauthorized access by cyberattacks. Therefore, this chapter begins, in Sect. 6.1, with an overview of automotive cybersecurity issues subdivided into ten subsections. It focuses on the scale and complexity of vehicles cyber and physical components’ vulnerability to a variety of security challenges, intrusions, threats, and malicious cyberattacks whose intent is to disrupt communication, steal sensitive information or records, and impair the functioning of the system, identifying the risk level as a function of likelihood and consequences. Hence, a solid theoretical foundation for cybersecurity of vehicle cyber-physical systems is introduced too, based on concepts of artificial intelligence, deep neural networks (DNN), and deep learning (DL), control theory, epidemic theory, game theory, graph theory, and the importance of cybersecurity w.r.t. different kinds of attack scenarios, for example, the spear phishing attack. Section 6.2 introduces information technology security in automotive cyber-physical systems (CPSs) and the measures taken to ensure that automotive cyber-physical systems remain secure while interacting with other digital systems connected to a controller area network (CAN) system bus. It also describes the characteristics of today’s attack taxonomies. As a logical next step, Sect. 6.3 focuses on hacking, automotive attack surfaces, and vulnerabilities and summarizes the anatomy of attack surface intrusion points in vehicles and the associated risks. Therefore, vehicle security depends on a variety of different methods and tools that systematically perform security testing, such as functional security testing, fuzzing, penetration testing, and others. Section 6.4 discusses intrusion detection, described as the detection of any set of actions that attempts to compromise the integrity, confidentiality, or availability of a system, as well as intrusion prevention, actions which attempt to prevent a detected intrusion from succeeding. Different detection methods for different kinds of intrusion types are described, including numerous static, dynamic, and hybrid methods for prevention. Section 6.5 discusses security and functional safety with regard to wireless mobile and sensor networks, platform security, cloud computing, and data security, as well as functional safety. Section 6.6 includes several examples of car hacking. Section 6.7 contains a comprehensive set of questions on automotive cybersecurity topics, and and finally followed by references and suggestions for further reading.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_68690_5_26,
  title = {Learning Types for Binaries},
  author = {Xu, Zhiwu and Wen, Cheng and Qin, Shengchao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {430-446},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68690-5\_26},
  url = {https://doi.org/10.1007/978-3-319-68690-5\_26},
  abstract = {Type inference for Binary codes is a challenging problem due partly to the fact that much type-related information has been lost during the compilation from high-level source code. Most of the existing research on binary code type inference tend to resort to program analysis techniques, which can be too conservative to infer types with high accuracy or too heavy-weight to be viable in practice. In this paper, we propose a new approach to learning types for recovered variables from their related representative instructions. Our idea is motivated by “duck typing”, where the type of a variable is determined by its features and properties. Our approach first learns a classifier from existing binaries with debug information and then uses this classifier to predict types for new, unseen binaries. We have implemented our approach in a tool called BITY and used it to conduct some experiments on a well-known benchmark coreutils (v8.4). The results show that our tool is more precise than the commercial tool Hey-Rays, both in terms of correct types and compatible types.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_58424_9_1,
  title = {Computer Security},
  author = {Duffany, Jeffrey L.},
  booktitle = {Computer and Network Security Essentials},
  year = {2018},
  pages = {3-20},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-58424-9\_1},
  url = {https://doi.org/10.1007/978-3-319-58424-9\_1},
  abstract = {An overview of basic computer security concepts is presented along with a brief history of major computer security events of the late twentieth and early twenty-first centuries. This is followed by a description of the most important computer security vulnerabilities that exist today and countermeasures being used to mitigate them. Future trends in computer security are assessed.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_01701_9_10,
  title = {Understanding Android Obfuscation Techniques: A Large-Scale Investigation in the Wild},
  author = {Dong, Shuaike and Li, Menghao and Diao, Wenrui and Liu, Xiangyu and Liu, Jian and Li, Zhou and Xu, Fenghao and Chen, Kai and Wang, XiaoFeng and Zhang, Kehuan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2018},
  pages = {172-192},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-01701-9\_10},
  url = {https://doi.org/10.1007/978-3-030-01701-9\_10},
  abstract = {Program code is a valuable asset to its owner. Due to the easy-to-reverse nature of Java, code protection for Android apps is of particular importance. To this end, code obfuscation is widely utilized by both legitimate app developers and malware authors, which complicates the representation of source code or machine code in order to hinder the manual investigation and code analysis. Despite many previous studies focusing on the obfuscation techniques, however, our knowledge of how obfuscation is applied by real-world developers is still limited. In this paper, we seek to better understand Android obfuscation and depict a holistic view of the usage of obfuscation through a large-scale investigation in the wild. In particular, we focus on three popular obfuscation approaches: identifier renaming, string encryption and Java reflection. To obtain the meaningful statistical results, we designed efficient and lightweight detection models for each obfuscation technique and applied them to our massive APK datasets (collected from Google Play, multiple third-party markets, and malware databases). We have learned several interesting facts from the result. For example, more apps on third-party markets than malware use identifier renaming, and malware authors use string encryption more frequently. We are also interested in the explanation of each finding. Therefore we carry out in-depth code analysis on some Android apps after sampling. We believe our study will help developers select the most suitable obfuscation approach, and in the meantime help researchers improve code analysis systems in the right direction.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_93354_2_7,
  title = {Forensic Analysis of Android Runtime (ART) Application Heap Objects in Emulated and Real Devices},
  author = {Muniz Soares, Alberto Magno and de Sousa Junior, Rafael Timoteo},
  booktitle = {Communications in Computer and Information Science},
  year = {2018},
  pages = {130-147},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-93354-2\_7},
  url = {https://doi.org/10.1007/978-3-319-93354-2\_7},
  abstract = {Each new release of a mobile device operating system represents a renewed challenge for the forensics analyst. Even a small modification or fault correction of such basic software requires the revision of forensic tools and methods, frequently yielding to the development of new investigation tools and the consequent adaptation of methods. Forensic analysts then need to preserve each tool set and related methods and associate these sets to the specific mobile operating system release. This paper describes a case of transition consequent to the Android Runtime (ART) operating system release. The introduction of this system in the market required the development of a new forensic technique for analyzing ART memory objects using a volatile memory data extraction. Considering the Android Open Source Project (AOSP) source code, a method and associated software tools were developed allowing the location, extraction and interpretation of arbitrary ART memory instances with the respective object classes and their data properties. The proposed technique and tools were validated both for emulated and real devices, illustrating the difficulties related to the forensics analysis for the target system due to its particular implementations by multiple manufacturers of mobile devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_99828_2_20,
  title = {Hunting Password Leaks in Android Applications},
  author = {Feichtner, Johannes},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2018},
  pages = {278-292},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-99828-2\_20},
  url = {https://doi.org/10.1007/978-3-319-99828-2\_20},
  abstract = {A wide range of mobile applications for the Android operating system require users to input sensitive data, such as PINs or passwords. Given the ubiquitous and security-critical role of credentials, it is paramount that programs process secrets responsibly and do not expose them to unrelated parties. Unfortunately, users have no insight into what happens with their data after entrusting it to an application. In this paper, we introduce a new approach to identify and follow the trace of user input right from the point where it enters an application. By using a combination of static slicing in forward and backward direction, we are able to reveal potential data leaks and can pinpoint their origin. To evaluate the applicability of our solution, we conducted a manual and automated inspection of security-related Android applications that process user-entered secrets. We find that 182 out of 509 (36\%) applications insecurely store given credentials in files or pass them to a log output.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_72308_2_6,
  title = {How to Get an Efficient yet Verified Arbitrary-Precision Integer Library},
  author = {Rieu-Helft, Raphaël and Marché, Claude and Melquiond, Guillaume},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {84-101},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-72308-2\_6},
  url = {https://doi.org/10.1007/978-3-319-72308-2\_6},
  abstract = {The GNU Multi-Precision library is a widely used, safety-critical, library for arbitrary-precision arithmetic. Its source code is written in C and assembly, and includes intricate state-of-the-art algorithms for the sake of high performance. Formally verifying the functional behavior of such highly optimized code, not designed with verification in mind, is challenging. We present a fully verified library designed using the Why3 program verifier. The use of a dedicated memory model makes it possible to have the Why3 code be very similar to the original GMP code. This library is extracted to C and is compatible and performance-competitive with GMP.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_60789_4_9,
  title = {Real-World Abstract Machines},
  author = {Sestoft, Peter},
  booktitle = {Undergraduate Topics in Computer Science},
  year = {2017},
  pages = {161-181},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-60789-4\_9},
  url = {https://doi.org/10.1007/978-3-319-60789-4\_9},
  abstract = {This chapter discusses some widely used real-world abstract machines .},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_98989_1_4,
  title = {Investigating Fingerprinters and Fingerprinting-Alike Behaviour of Android Applications},
  author = {Ferreira Torres, Christof and Jonker, Hugo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {60-80},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-98989-1\_4},
  url = {https://doi.org/10.1007/978-3-319-98989-1\_4},
  abstract = {Fingerprinting of browsers has been thoroughly investigated. In contrast, mobile phone applications offer a far wider array of attributes for profiling, yet fingerprinting practices on this platform have hardly received attention. In this paper, we present the first (to our knowledge) investigation of Android libraries by commercial fingerprinters. Interestingly enough, there is a marked difference with fingerprinting desktop browsers. We did not find evidence of typical fingerprinting techniques such as canvas fingerprinting. Secondly, we searched for behaviour resembling that of commercial fingerprinters. We performed a detailed analysis of six similar libraries. Thirdly, we investigated \\(\\sim \\) 30,000 apps and found that roughly 19\% of these apps is using one of the these libraries. Finally, we checked how often these libraries were used by apps subject to the Children’s Online Privacy Protection Act (i.e. apps targeted explicitly at children), and found that these libraries were included 21 times.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_78816_6_13,
  title = {Human Factors, Self-awareness and Intervention Approaches in Cyber Security When Using Mobile Devices and Social Networks},
  author = {Eustace, Ken and Islam, Rafiqul and Tsang, Philip and Fellows, Geoff},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2018},
  pages = {166-181},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-78816-6\_13},
  url = {https://doi.org/10.1007/978-3-319-78816-6\_13},
  abstract = {This paper will describe three case studies on the human factors, in personal and public safety and cyber security from the Asia Pacific region (APAC). A deeper consideration of human factors, the impact of “Internet of Things” and cyber security education about the behaviour and actions that can be taken by individuals is at the foundation of public safety and cyber security. The growth of disruption by cyber criminals - especially when using small devices and applications to interact with large social networks is a cause for concern. This is part of the evolving development of a cyber-physical world. The paper presents three case studies and proposes a Self - awareness and Intervention Model for public safety and security by increasing and maintaining the awareness, understanding and preparedness of cyber security measures by the individual when using mobile device applications to participate in large social systems and concludes by highlighting the importance of including the human factors and message framing alongside the cyber security measures in place.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_00305_0_3,
  title = {On Symbolic Verification of Bitcoin’s script Language},
  author = {Klomp, Rick and Bracciali, Andrea},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {38-56},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-00305-0\_3},
  url = {https://doi.org/10.1007/978-3-030-00305-0\_3},
  abstract = {Validation of Bitcoin transactions rely upon the successful execution of scripts written in a simple and effective, non-Turing-complete by design language, simply called script . This makes the validation of closed scripts, i.e. those associated to actual transactions and bearing full information, straightforward. Here we address the problem of validating open scripts, i.e. we address the validation of redeeming scripts against the whole set of possible inputs, i.e. under which general conditions can Bitcoins be redeemed? Even if likely not one of the most complex languages and demanding verification problems, we advocate the merit of formal verification for the Bitcoin validation framework. We propose a symbolic verification theory for open script , a verifier tool-kit, and illustrate examples of use on Bitcoin transactions. Contributions include (1) a formalisation of (a fragment of script ) the language; (2) a novel symbolic approach to script verification, suitable, e.g. for the verification of newly defined and non-standard payment schemes; and (3) building blocks for a larger verification theory for the developing area of Bitcoin smart contracts. The verification of smart contracts, i.e. agreements built as transaction-based protocols, is currently a problem that is difficult to formalise and computationally demanding.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11277_016_3618_9,
  title = {Vulnerabilities of Android OS-Based Telematics System},
  author = {Jo, Hyo Jin and Choi, Wonsuk and Na, Seoung Yeop and Woo, Samuel and Lee, Dong Hoon},
  journal = {Wireless Personal Communications},
  year = {2017},
  volume = {92},
  number = {4},
  pages = {1511-1530},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11277-016-3618-9},
  url = {https://doi.org/10.1007/s11277-016-3618-9},
  abstract = {Intelligent vehicle technologies have been developed rapidly. Modern vehicles include many Electronic Control Units (ECUs) and in-vehicle networks. While these technologies offer accurate vehicle control and increase the convenience and safety of drivers, their vulnerabilities also have been analyzed and exploited. Nevertheless, open platforms, such as the Android OS, have been introduced into vehicle systems without careful consideration about security issues. In this paper, we indicate the security problems of an Android OS-based telematics system. Our target device’s firmware is offered on a public Web site and is easily analyzed using public analysis tools. This means that our analysis methods are more scalable and practical than previous ones for remote attacks that require difficult analysis skills, such as signal processing and reverse engineering. We also found that the device allows malicious firmware to be updated because of a problem related to misuse of certificates. Furthermore, we conducted attack experiments using a real vehicle.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_019_09697_7,
  title = {Siamese: scalable and incremental code clone search via multiple code representations},
  author = {Ragkhitwetsagul, Chaiyong and Krinke, Jens},
  journal = {Empirical Software Engineering},
  year = {2019},
  volume = {24},
  number = {4},
  pages = {2236-2284},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09697-7},
  url = {https://doi.org/10.1007/s10664-019-09697-7},
  abstract = {This paper presents a novel code clone search technique that is accurate, incremental, and scalable to hundreds of million lines of code. Our technique incorporates multiple code representations (i.e., a technique to transform code into various representations to capture different types of clones), query reduction (i.e., a technique to select clone search keywords based on their uniqueness), and a customised ranking function (i.e., a technique to allow a specific clone type to be ranked on top of the search results) to improve clone search performance. We implemented the technique in a clone search tool, called Siamese, and evaluated its search accuracy and scalability on three established clone data sets. Siamese offers the highest mean average precision of 95\% and 99\% on two clone benchmarks compared to seven state-of-the-art clone detection tools, and reported the largest number of Type-3 clones compared to three other code search engines. Siamese is scalable and can return cloned code snippets within 8 seconds for a code corpus of 365 million lines of code. Using an index of 130,719 GitHub projects, we demonstrate that Siamese’s incremental indexing capability dramatically decreases the index preparation time for large-scale data sets with multiple releases of software projects. The paper discusses the applications of Siamese to facilitate software development and research with two use cases including online code clone detection and clone search with automated license analysis.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_70395_4_16,
  title = {SECURING BLUETOOTH LOW ENERGY LOCKS FROM UNAUTHORIZEDACCESS AND SURVEILLANCE},
  author = {Rose, Anthony and Bindewald, Jason and Ramsey, Benjamin and Rice, Mason and Mullins, Barry},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2017},
  pages = {319-338},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70395-4\_16},
  url = {https://doi.org/10.1007/978-3-319-70395-4\_16},
  abstract = {This chapter describes several vulnerabilities that affect commercial and residential Bluetooth Low Energy security devices and outlines methods for exploiting plaintext, obfuscated and hard-coded passwords, brute forcing passwords and hashes, fuzzing commands and performing man-in-the-middle attacks. Evaluations reveal that 75\% of the tested security and access control systems have vulnerabilities that grant unauthorized access. In addition to obtaining access, malicious actors can extract sensitive information that can be used to develop patterns of human behavior. This chapter discusses five solutions for preventing or mitigating Bluetooth Low Energy security breaches, most of which involve minimal implementation overhead on the part of developers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_75160_3_19,
  title = {NativeSpeaker: Identifying Crypto Misuses in Android Native Code Libraries},
  author = {Wang, Qing and Li, Juanru and Zhang, Yuanyuan and Wang, Hui and Hu, Yikun and Li, Bodong and Gu, Dawu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {301-320},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-75160-3\_19},
  url = {https://doi.org/10.1007/978-3-319-75160-3\_19},
  abstract = {The use of native code (ARM binary code) libraries in Android apps greatly promotes the execution performance of frequently used algorithms. Nonetheless, it increases the complexity of app assessment since the binary code analysis is often sophisticated and time-consuming. As a result, many defects still exist in native code libraries and potentially threat the security of users. To assess the native code libraries, current researches mainly focus on the API invoking correctness and less dive into the details of code. Hence, flaws may hide in internal implementation when the analysis of API does not discover them effectively. The assessment of native code requires a more detailed code comprehension process to pinpoint flaws. In response, we design and implement NativeSpeaker , an Android native code analysis system to assess native code libraries. NativeSpeaker provides not only the capability of recognizing certain pattern related to security flaws, but also the functionality of discovering and comparing native code libraries among a large-scale collection of apps from non-official Android markets. With the help of NativeSpeaker , we analyzed 20,353 dynamic libraries (.so) collected from 20,000 apps in non-official Android markets. Particularly, our assessment focuses on searching crypto misuse related insecure code pattern in those libraries. The analyzing results show even for those most frequently used (top 1\%) native code libraries, one third of them contain at least one misuse. Furthermore, our observation indicates the misuse of crypto is often related to insecure data communication: about 25\% most frequently used native code libraries suffer from this flaw. Our conducted analysis revealed the necessity of in-depth security assessment against popular native code libraries, and proved the effectiveness of the designed NativeSpeaker system.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_00581_8_18,
  title = {Introductory Malware Analysis},
  author = {Lin, Xiaodong},
  booktitle = {Introductory Computer Forensics},
  year = {2018},
  pages = {425-454},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-00581-8\_18},
  url = {https://doi.org/10.1007/978-3-030-00581-8\_18},
  abstract = {This chapter serves as an introduction into malware analysis. This chapter discusses the different types of malware and describes how malware infects computers. Also, it introduces you to practical approaches of analyzing malware through three case examples so as to provide insight into different ways how malware works. The objectives of this chapter are to:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_05171_6_8,
  title = {Towards Accuracy in Similarity Analysis of Android Applications},
  author = {Kishore, Sreesh and Kumar, Renuka and Rajan, Sreeranga},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {146-167},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-05171-6\_8},
  url = {https://doi.org/10.1007/978-3-030-05171-6\_8},
  abstract = {Android malware is most commonly delivered to a user through the many open app marketplaces. Several recent attacks have shown that the same malware infects different apps in the app market. Automated triaging by computing similarity of apps to known software components can help learn the evolution and propagation of malware. While the emphasis of existing research is on detecting repackaged apps, a similarity analysis system that can identify similar portions of code in dissimilar apps, is important. Only few public tools exist that furnish these details accurately. In this paper, we present a proof-of-concept of an analysis system that compares Android apps using a technique that combines class and method features of an app. We use a two-step process that first compute similar classes and then compute similar methods of those classes. To identify similar classes, we propose a novel set of software birthmarks. We use Normalized Compression Distance to compute similar methods. The birthmarks are evaluated on a set of over 65,000 classes from 60 APKs. To evaluate the performance of our tool, we establish ground truth by manually reverse engineering each app. The proposed system is compared with Google’s androsim , the only open-source tool for similarity analysis that also uses NCD. Our approach shows an improvement in accuracy in the worst-case when comapred to androsim . Finally, we furnish a case-study of our system to detect fake and repackaged apps by analyzing 1470 Android apps from various sources.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_94821_8_4,
  title = {Software Tool Support for Modular Reasoning in Modal Logics of Actions},
  author = {Balco, Samuel and Frittella, Sabine and Greco, Giuseppe and Kurz, Alexander and Palmigiano, Alessandra},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {48-67},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-94821-8\_4},
  url = {https://doi.org/10.1007/978-3-319-94821-8\_4},
  abstract = {We present a software tool for reasoning in and about propositional sequent calculi for modal logics of actions. As an example, we implement the display calculus D.EAK of dynamic epistemic logic. The tool generates embeddings of the calculus in the theorem prover Isabelle/HOL for formalising proofs about D.EAK. Integrating propositional reasoning in D.EAK with inductive reasoning in Isabelle/HOL, we verify the solution of the muddy children puzzle for any number of muddy children. There also is a set of meta-tools that allows us to adapt the software for a wide variety of user defined calculi.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_3153_3_36,
  title = {Improvised Symbol Table Structure},
  author = {Kumar, Narander and Dubey, Shivani},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2017},
  pages = {363-371},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-3153-3\_36},
  url = {https://doi.org/10.1007/978-981-10-3153-3\_36},
  abstract = {Symbol table is the environment where the variables and functions/methods exist according to their scope and the most recent updated values are kept for the successful running of the code. It helps in code functioning. It is created during compilation and maintained, used during running of the code. Adding a utility called common file can help in conversion of one code to another code. As common file can be explained as the file containing the common functionalities of different languages, say, every language has a print function but with different syntax; these different syntax of print are added in common file which help in the conversion. In this paper, we present the compilation process mechanism with the help of common file in the symbol table. It also explains how a code is converted into another code.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00165_018_0462_6,
  title = {Code obfuscation against abstraction refinement attacks},
  author = {Bruni, Roberto and Giacobazzi, Roberto and Gori, Roberta},
  journal = {Formal Aspects of Computing},
  year = {2018},
  volume = {30},
  number = {6},
  pages = {685-711},
  publisher = {Association for Computing Machinery (ACM)},
  doi = {10.1007/s00165-018-0462-6},
  url = {https://doi.org/10.1007/s00165-018-0462-6},
  abstract = {Abstract Code protection technologies require anti reverse engineering transformations to obfuscate programs in such a way that tools and methods for program analysis become ineffective. We introduce the concept of model deformation inducing an effective code obfuscation against attacks performed by abstract model checking. This means complicating the model in such a way a high number of spurious traces are generated in any formal verification of the property to disclose about the system under attack.We transform the program model in order to make the removal of spurious counterexamples by abstraction refinement maximally inefficient. Because our approach is intended to defeat the fundamental abstraction refinement strategy, we are independent from the specific attack carried out by abstract model checking. A measure of the quality of the obfuscation obtained by model deformation is given together with a corresponding best obfuscation strategy for abstract model checking based on partition refinement.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_4027_4_7,
  title = {Garbage Collection - Introduction},
  author = {Kokosa, Konrad},
  booktitle = {Pro .NET Memory Management},
  year = {2018},
  pages = {507-574},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4027-4\_7},
  url = {https://doi.org/10.1007/978-1-4842-4027-4\_7},
  abstract = {Welcome to the most important part of this book. Previous chapters have described quite broadly the subject of memory management. We have experienced some theoretical and hardware introduction. We also got to know a lot of details about the organization of memory in the .NET environment - how it is divided into segments and generations and how all this infrastructure works with the operating system. Much of this knowledge is valuable in itself, allowing us, for example, to diagnose problems with too many allocations or how to use different methods to avoid them.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_4027_4_4,
  title = {.NET Fundamentals},
  author = {Kokosa, Konrad},
  booktitle = {Pro .NET Memory Management},
  year = {2018},
  pages = {233-338},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-4027-4\_4},
  url = {https://doi.org/10.1007/978-1-4842-4027-4\_4},
  abstract = {Although we are only in the fourth chapter, we have gone through quite a long journey about various aspects of memory management. They were discussed in general to make a more theoretical introduction to this topic. There were quite rare, specific references to .NET, which after all is what this book about. It's time to change that frequency. From this chapter to the end of the book, .NET will accompany us constantly. In this chapter we will look at it with a slightly broader perspective, we will learn some mechanisms behind it, and we will begin to delve into the topics related to how it manages memory. I strongly encourage you to acquire knowledge from the previous three chapters before continuing reading this one, but treat it as an optional approach. From now on, I will also assume some basic knowledge about assembly language for x86/x64 platforms as we are going into the .NET deeper and deeper. If you need some knowledge refresh, read, for example, an excellent book, Modern X86 Assembly Language Programming , by Daniel Kusswurm (Apress, 2014).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_04834_1_19,
  title = {Static Analysis for Security Vetting of Android Apps},
  author = {Roy, Sankardas and Chaulagain, Dewan and Bhusal, Shiva},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {375-404},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-04834-1\_19},
  url = {https://doi.org/10.1007/978-3-030-04834-1\_19},
  abstract = {In recent years, Android has become the most popular operating system worldwide for mobile devies, including smartphones and tablets. Unfortunately, the huge success of Android also attracted hackers to develop malicious apps or to exploit vulnerable apps (developed by others) for fun and profit. To guard against malicious apps and vulnerable apps, app vetting is important. Static analysis is a promising vetting technique as it investigates the entire codebase of the app, and it is hard to evade. In this article, we present the basic theory of static analysis (as applied to Android apps) for the beginners (who have recently started exploring this exciting yet challenging field) in a lucid language. Using short example apps, we explain how static analysis algorithms can achieve security vetting. For instance, we illustrate how tracking data flows and data dependency paths in an app can help us detect a private information leakage issue. We also review the state-of-the-art static analysis tools for security vetting of Android apps. We particularly study FlowDroid and Amandroid as the representatives of the state-of-the-art. Furthermore, we remind the reader about the limitations of static analysis.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11277_017_4859_y,
  title = {A Framework for Recognition and Confronting of Obfuscated Malwares Based on Memory Dumping and Filter Drivers},
  author = {Javaheri, Danial and Hosseinzadeh, Mehdi},
  journal = {Wireless Personal Communications},
  year = {2018},
  volume = {98},
  number = {1},
  pages = {119-137},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11277-017-4859-y},
  url = {https://doi.org/10.1007/s11277-017-4859-y},
  abstract = {In this paper obfuscation techniques used by novel malwares presented and compared. IAT smashing, string encryption and dynamic programing are explained in static methods and hooking at user and kernel level of OS with DLL injection, modifying of SSDT and IDT table addresses, filter IRPs, and possessor emulation are techniques in dynamic methods. This paper suggest Approach for passing through malware obfuscation techniques. In order that it can analyze malware behaviors. Our methods in proposed approach are detection presence time of a malware at user and kernel level of OS, dumping of malware executable memory at correct time and precise hook installing. Main purpose of this paper is establishment of an efficient platform to analyze behavior and detect novel malwares that by use of metamorphic engine, packer and protector tools take action for obfuscation and metamorphosis of themself. At final, this paper use a dataset embeds different kind of obfuscated and metamorphic malwares in order to prove usefulness of its methods experiments. Show that proposed methods can confront most malware obfuscation techniques. It evaluated success rate to unpacking, obfuscated malwares and it shows 85\% success rate to recognize kernel level malwares.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_62105_0_12,
  title = {JTR: A Binary Solution for Switch-Case Recovery},
  author = {Cojocar, Lucian and Kroes, Taddeus and Bos, Herbert},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {177-195},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-62105-0\_12},
  url = {https://doi.org/10.1007/978-3-319-62105-0\_12},
  abstract = {Most security solutions that rely on binary rewriting assume a clean separation between code and data. Unfortunately, jump tables violate this assumption. In particular, switch statements in binary code often appear as indirect jumps with jump tables that interleave with executable code—especially on ARM architectures. Most existing rewriters and disassemblers handle jump tables in a crude manner, by means of pattern matching. However, any deviation from the pattern (e.g. slightly different instructions) leads to a mismatch. Instead, we propose a complementary approach to “solve” jump tables and automatically find the right target addresses of the indirect jump by means of a tailored Value Set Analysis (VSA). Our approach is generic and applies to binary code without any need for source, debug symbols, or compiler generated patterns. We benchmark our technique on a large corpus of ARM binaries, including malware and firmware. For gcc binaries, our results approach those of IDA Pro when IDA has symbols (which is generally not the case), while for clang binaries we outperform IDA Pro with debug symbols by orders of magnitude: IDA finds 11 of 828 switch statements implemented as jump tables in SPEC, while we find 763.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10586_016_0630_5,
  title = {A study of android malware detection techniques in virtual environment},
  author = {Jung, Hyun Mi and Kim, Ki-Bong and Cho, Han-Jin},
  journal = {Cluster Computing},
  year = {2016},
  volume = {19},
  number = {4},
  pages = {2295-2304},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-016-0630-5},
  url = {https://doi.org/10.1007/s10586-016-0630-5},
  abstract = {With the rapid development of mobile environment, cyber-attacks have become more commonplace and more sophisticated. In smartphone operating system market, in particular, Android platform accounts for a large portion (65 \% or higher). At the same time, malwares on the Android platform, has increased exponentially. This, such as mobile Internet service provider (ISP) operator and device manufacturers, have applied an anti-virus product. However, there exhibit a high false-positive rate to detect malwares because these are based on patterns or heuristic. To solve this problem, this study proposed and implemented Android malware detection techniques in virtual environment, using single physical machine. The proposed system is divided into a host system and virtual environment. The former features black market crawler designed to collect malware, hypervisor targeted for the communication and control of virtual machine and host machine and main module which transmits analysis file and result log to each system. In virtual environment, agent and emulator were implemented to analyze malware-suspicious application. This study implemented more active and faster Android malware detection techniques through black market crawling and Linux kernel-hooking mechanism.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_89884_1_2,
  title = {HOBiT: Programming Lenses Without Using Lens Combinators},
  author = {Matsuda, Kazutaka and Wang, Meng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {31-59},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-89884-1\_2},
  url = {https://doi.org/10.1007/978-3-319-89884-1\_2},
  abstract = {We propose HOBiT, a higher-order bidirectional programming language, in which users can write bidirectional programs in the familiar style of conventional functional programming, while enjoying the full expressiveness of lenses. A bidirectional transformation, or a lens, is a pair of mappings between source and view data objects, one in each direction. When the view is modified, the source is updated accordingly with respect to some laws—a pattern that is found in databases, model-driven development, compiler construction, and so on. The most common way of programming lenses is with lens combinators, which are lens-to-lens functions that compose simpler lenses to form more complex ones. Lens combinators preserve the bidirectionality of lenses and are expressive; but they compel programmers to a specialised point-free style—i.e., no naming of intermediate computation results—limiting the scalability of bidirectional programming. To address this issue, we propose a new bidirectional programming language HOBiT, in which lenses are represented as standard functions, and combinators are mapped to language constructs with binders. This design transforms bidirectional programming, enabling programmers to write bidirectional programs in a flexible functional style and at the same time access the full expressiveness of lenses. We formally define the syntax, type system, and the semantics of the language, and then show that programs in HOBiT satisfy bidirectionality. Additionally, we demonstrate HOBiT ’s programmability with examples.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_73721_8_5,
  title = {Code Obfuscation Against Abstract Model Checking Attacks},
  author = {Bruni, Roberto and Giacobazzi, Roberto and Gori, Roberta},
  booktitle = {Lecture Notes in Computer Science},
  year = {2018},
  pages = {94-115},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-73721-8\_5},
  url = {https://doi.org/10.1007/978-3-319-73721-8\_5},
  abstract = {Code protection technologies require anti reverse engineering transformations to obfuscate programs in such a way that tools and methods for program analysis become ineffective. We introduce the concept of model deformation inducing an effective code obfuscation against attacks performed by abstract model checking. This means complicating the model in such a way a high number of spurious traces are generated in any formal verification of the property to disclose about the system under attack. We transform the program model in order to make the removal of spurious counterexamples by abstraction refinement maximally inefficient. A measure of the quality of the obfuscation obtained by model deformation is given together with a corresponding best obfuscation strategy for abstract model checking based on partition refinement.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_00581_8_15,
  title = {Android Forensics},
  author = {Lin, Xiaodong},
  booktitle = {Introductory Computer Forensics},
  year = {2018},
  pages = {335-371},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-00581-8\_15},
  url = {https://doi.org/10.1007/978-3-030-00581-8\_15},
  abstract = {The objectives of this chapter are to:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_00581_8_19,
  title = {Ransomware Analysis},
  author = {Lin, Xiaodong},
  booktitle = {Introductory Computer Forensics},
  year = {2018},
  pages = {455-504},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-00581-8\_19},
  url = {https://doi.org/10.1007/978-3-030-00581-8\_19},
  abstract = {This chapter focuses on the description and analysis of ransomware, which is an advanced type of malware that infects a computer and holds victim’s data hostage for a ransom, for example, encrypting the victim’s data until a ransom is paid to decrypt them. The objectives of this chapter are to:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_10_2738_3_40,
  title = {Vulnebdroid: Automated Vulnerability Score Calculator for Android Applications},
  author = {Gupta, Sugandha and Kaushal, Rishabh},
  booktitle = {Communications in Computer and Information Science},
  year = {2016},
  pages = {461-471},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-2738-3\_40},
  url = {https://doi.org/10.1007/978-981-10-2738-3\_40},
  abstract = {Nowadays mobile phone users download lots of applications for various purposes like learning, entertainment, businesses, etc. For a naive user, it is very difficult to identify whether the permissions provided to the application at the time of installation are being used properly or not. There are tools available for the detection of android malware but many of them are not open source or give tricky results which are not easily understandable. Various online services like VirusTotal uses the updated anti viruses for computing the malware detection ratio. However, since most of these anti-viruses are based on signature based detection methodology, therefore, it detection can be circumvented by using obfuscation methods. In our work we have implemented VULNEBDROID, an automated light weight obfuscation-tolerant static tool for computing the vulnerability score and assessing the vulnerability level of android applications. To assess the vulnerability, this tool selects the features of the application, like dangerous permissions used; vulnerable functions which can be used in order to misuse the application and can exploit the Application Programming Interface (API) to access the resources. Using this assessment tool, we are able to detect 96 \% of malicious application as vulnerable either with high or medium degree of vulnerability.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11042_018_5663_8,
  title = {Software randomness analysis and evaluation of lightweight ciphers: the prospective for IoT security},
  author = {Qasaimeh, Malik and Al-Qassas, Raad S. and Tedmori, Sara},
  journal = {Multimedia Tools and Applications},
  year = {2018},
  volume = {77},
  number = {14},
  pages = {18415-18449},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-018-5663-8},
  url = {https://doi.org/10.1007/s11042-018-5663-8},
  abstract = {In the past few years, various lightweight cryptographic algorithms have been proposed to balance the trade-offs between the requirements of resource constrained IoT devices and the need to securely transmit and protect data. However, it is critical to analyze and evaluate these algorithms to examine their capabilities. This paper provides a thorough investigation of the randomness of ciphertext obtained from Simeck, Kasumi, DES and AES. The design of our randomness analysis is based on five metrics implemented following the guidance of the NIST statistical test suite for cryptographic applications. This analysis also provides performance and power consumption evaluations for the selected cryptographic algorithms using different platforms and measures. Results from the evaluation reveal that lightweight algorithms have competitive randomness levels, lower processing time and lower power consumption when compared to conventional algorithms.},
  content_type = {Article},
}


@article{springer_10_1007_s00521_017_3077_6,
  title = {Malware detection based on deep learning algorithm},
  author = {Yuxin, Ding and Siyi, Zhu},
  journal = {Neural Computing and Applications},
  year = {2019},
  volume = {31},
  number = {2},
  pages = {461-472},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-017-3077-6},
  url = {https://doi.org/10.1007/s00521-017-3077-6},
  abstract = {In this study we represent malware as opcode sequences and detect it using a deep belief network (DBN). Compared with traditional shallow neural networks, DBNs can use unlabeled data to pretrain a multi-layer generative model, which can better represent the characteristics of data samples. We compare the performance of DBNs with that of three baseline malware detection models, which use support vector machines, decision trees, and the k-nearest neighbor algorithm as classifiers. The experiments demonstrate that the DBN model provides more accurate detection than the baseline models. When additional unlabeled data are used for DBN pretraining, the DBNs perform better than the other detection models. We also use the DBNs as an autoencoder to extract the feature vectors of executables. The experiments indicate that the autoencoder can effectively model the underlying structure of input data and significantly reduce the dimensions of feature vectors.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_69471_9_27,
  title = {DexPro: A Bytecode Level Code Protection System for Android Applications},
  author = {Zhao, Beibei and Tang, Zhanyong and Li, Zhen and Song, Lina and Gong, Xiaoqing and Fang, Dingyi and Liu, Fangyuan and Wang, Zheng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {367-382},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69471-9\_27},
  url = {https://doi.org/10.1007/978-3-319-69471-9\_27},
  abstract = {Unauthorized code modification through reverse engineering is a major concern for Android application developers. Code reverse engineering is often used by adversaries to remove the copyright protection or advertisements from the app, or to inject malicious code into the program. By making the program difficult to analyze, code obfuscation is a potential solution to the problem. However, there is currently little work on applying code obfuscation to compiled Android bytecode. This paper presents DexPro , a novel bytecode level code obfuscation system for Android applications. Unlike prior approaches, our method performs on the Android Dex bytecode and does not require access to high-level program source or modification of the compiler or the VM. Our approach leverages the fact all except floating operands in Dex are stored in a 32-bit register to pack two 32-bit operands into a 64-bit operand. In this way, any attempt to decompile the bytecode will result in incorrect information. Meanwhile, our approach obfuscates the program control flow by inserting opaque predicates before the return instruction of a function call, which makes it harder for the attacker to trace calls to protected functions. Experimental results show that our approach can deter sophisticate reverse engineering and code analysis tools, and the overhead of runtime and memory footprint is comparable to existing code obfuscation methods.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10586_017_0870_z,
  title = {A novel cloud scheduling algorithm optimization for energy consumption of data centres based on user QoS priori knowledge under the background of WSN and mobile communication},
  author = {Jin, Zhenjun and Xu, Gaochao and Li, Yang and Liu, Peng},
  journal = {Cluster Computing},
  year = {2017},
  volume = {20},
  number = {2},
  pages = {1587-1597},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-017-0870-z},
  url = {https://doi.org/10.1007/s10586-017-0870-z},
  abstract = {Cloud computing (CC) is present day innovation that comprises of system of frameworks that shape cloud. Energy utilization is the real worry in the distributed computing. Distributed computing is advancing region in effective usage of resources. Server farms pleasing cloud applications consume gigantic amounts of energy, adding to advanced uses. Subsequently, green CC resolutions are required to spare energy for the earth as well as to abatement working charges. In the manuscript, author accentuation on the improvement of energy based resource planning structure and present a calculation that consider the collaboration between different server farm foundations and execution. Likewise security of wireless sensor network (WSN) is considered through quality of service (QoS). Subsequently a novel cloud booking calculation improvement for energy utilization of data-centres in view of client QoS priori information under the foundation of WSN and mobile communication has been accomplished.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_1675_2_59,
  title = {Security Analysis of OnlineCabBooking Android Application},
  author = {Nishant Grover and Jyotsna Saxena and Vikas Sihag},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2017},
  pages = {603-611},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-1675-2\_59},
  url = {https://doi.org/10.1007/978-981-10-1675-2\_59},
  abstract = {Android devices are not just phones, they are necessity for its users. Android’s open-source nature leads to massive development of applications for end users to use which also create lots of vulnerable applications that are ready to be exploited. In this paper we discuss and analyse the OnlineCabBookings Android application which is used for booking cabs online through smartphones and present vulnerabilities in its implementation which make it a playground for attackers. With insight to the vulnerabilities of application under analysis, we proposed a security framework that can be used by other applications to authenticate users and conduct transactions in a secure manner.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_66284_8_34,
  title = {PolEnA: Enforcing Fine-grained Permission Policies in Android},
  author = {Costa, Gabriele and Sinigaglia, Federico and Carbone, Roberto},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {407-414},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-66284-8\_34},
  url = {https://doi.org/10.1007/978-3-319-66284-8\_34},
  abstract = {In this paper we present PolEnA, an extension of the Android Security Framework (ASF). PolEnA enables a number of features that are not currently provided by the ASF. Among them, PolEnA allows for the definition of fine-grained security policies and their dynamic verification. The runtime enforcement of the policies is supported by a state-of-the-art SAT solver. One of the main features of our approach is the low invasiveness as it does not require modifications to the operating system.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_59288_6_58,
  title = {AndroidProtect: Android Apps Security Analysis System},
  author = {Zhang, Tong and Li, Tao and Wang, Hao and Xiao, Zhijie},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2017},
  pages = {583-594},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-59288-6\_58},
  url = {https://doi.org/10.1007/978-3-319-59288-6\_58},
  abstract = {Android Apps market is the largest in the world. There are some features about Android Apps: massive, diverse, uncertain behaviors and permissions. That makes detecting malicious Apps very difficult. In this paper, a two layers model based on static analysis and dynamic analysis is proposed to solve it. We name the model AndroidProtect. We can use AndroidProtect to calculate feature value of massive Apps, monitor behavior of target Apps. The first layer identifies the dangerous Apps, The second layer analyzes their behavior. The experimental results show that in the case of similar static feature value, the dynamic analysis can fix deviation, and we can get more accurate assessment.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4939_6415_4_23,
  title = {Autonomous Vulnerability Scanning and Patching of Binaries},
  author = {Gamayunov, Dennis and Voronov, Mikhail and Lee, Newton},
  booktitle = {Google It},
  year = {2016},
  pages = {419-430},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4939-6415-4\_23},
  url = {https://doi.org/10.1007/978-1-4939-6415-4\_23},
  abstract = {In November 2014, Team DESCARTES led by Newton Lee and sponsored by the Institute for Education, Research, and Scholarships (IFERS) was among one of the 104 teams registered with the Defense Advanced Research Projects Agency (DARPA) for the first-ever Cyber Grand Challenge (CGC ). Only 28 teams, including Team DESCARTES, made it through two DARPA-sponsored dry runs and into the CGC Qualifying Event in June 2015.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_30303_1_11,
  title = {Evaluating Obfuscation Security: A Quantitative Approach},
  author = {Mohsen, Rabih and Pinto, Alexandre Miranda},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {174-192},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-30303-1\_11},
  url = {https://doi.org/10.1007/978-3-319-30303-1\_11},
  abstract = {State of the art obfuscation techniques rely on an unproven concept of security, therefore it is very hard to evaluate their protection quality. In previous work we introduced algorithmic information theory as a theoretical foundation for code obfuscation security. We propose Kolmogorov complexity, estimated by compression, as a software complexity metric to measure regularities in obfuscated programs. In this paper we provide a theoretical validation for its soundness as a software metric, so it can have as much credibility as other complexity metrics. Then, we conduct an empirical evaluation for 43 obfuscation techniques, which are applied to 10 Java byte code programs of SPECjvm2008 benchmark suite using three different decompilers as a threat model, aiming to provide experimental evidence that support the formal treatments.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_57078_5_58,
  title = {Integration of Eco-Efficiency and Efficiency Assessment Methodologies: The Efficiency Framework},
  author = {Baptista, A. J. and Lourenço, E. J. and Silva, E. J. and Estrela, M. A. and Peças, P.},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2017},
  pages = {613-623},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-57078-5\_58},
  url = {https://doi.org/10.1007/978-3-319-57078-5\_58},
  abstract = {The overall aim of the Efficiency Framework is to encourage a culture of continuous improvement and sustainability within manufacturing and process industries. The framework presented supports informed decision-making processes and helps to define strategies for continuous performance improvement. The proposed innovative Efficiency Framework, materialized through the integration of concepts and results provided by eco-efficiency methodology, namely Eco-Efficiency Integrated Methodology for Production Systems (ecoPROSYS) and the lean based resource efficiency assessment method, Multi-layer Stream Mapping (MSM). Thus, the framework assesses simultaneously the environmental, economic and efficiency performance of complex production systems, which helps to identify major inefficiencies and circumstances of low eco-efficiency performance, consequently leading to the definition of improvement priorities. Ultimately, this framework aims to facilitate the overall efficiency performance assessment, by an integrated multi-dimensional analysis, presented as the Total Efficiency Index. The logic behind this index is to combine, for each unit process and for the overall production process, two fundamental efficiency aspects, namely eco-efficiency and operations efficiency.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_26362_5_23,
  title = {Security Analysis of PHP Bytecode Protection Mechanisms},
  author = {Weißer, Dario and Dahse, Johannes and Holz, Thorsten},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {493-514},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-26362-5\_23},
  url = {https://doi.org/10.1007/978-3-319-26362-5\_23},
  abstract = {PHP is the most popular scripting language for web applications. Because no native solution to compile or protect PHP scripts exists, PHP applications are usually shipped as plain source code which is easily understood or copied by an adversary. In order to prevent such attacks, commercial products such as ionCube , Zend Guard , and Source Guardian promise a source code protection. In this paper, we analyze the inner working and security of these tools and propose a method to recover the source code by leveraging static and dynamic analysis techniques. We introduce a generic approach for decompilation of obfuscated bytecode and show that it is possible to automatically recover the original source code of protected software. As a result, we discovered previously unknown vulnerabilities and backdoors in 1 million lines of recovered source code of 10 protected applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_49586_6_24,
  title = {Recommending Features of Mobile Applications for Developer},
  author = {Yu, Hong and Lian, Yahong and Yang, Shuotao and Tian, Linlin and Zhao, Xiaowei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {361-373},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-49586-6\_24},
  url = {https://doi.org/10.1007/978-3-319-49586-6\_24},
  abstract = {Features recommendation is an important technique for getting the requirements to develop and update mobile Apps and it has been one of the frontier study in requirements engineering. However, the mobile Apps’ descriptions are always free-format and noisy, the classical features recommendation methods cannot be effectively applied to mobile Apps’ features recommendation. In addition, most mobile Apps’ source codes that contain API calling information can be obtained by software tools, which can accurately indicate the functional features. Therefore, this paper proposes a hybrid feature recommendation method of mobile Apps, which is based on both explicit description and implicit code information. A self-adaptive similarity measure and KNN is used to find relevant Apps, and functional features are extracted from the Apps and recommended for developers. Experimental results on four categories Apps show that the proposed features recommendation method with hybrid information is more effective than the classical method.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_49568_2_17,
  title = {A Return-Value-Unchecked Vulnerability Detection Method Based on Property Graph},
  author = {Kun, Han and Bo, Wu and Dan, Xin},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2017},
  pages = {114-123},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-49568-2\_17},
  url = {https://doi.org/10.1007/978-3-319-49568-2\_17},
  abstract = {Traditional static analysis methods for binary software vulnerability detection are used only to make use of a single aspect of the target software, so it is difficult to obtain the hidden global properties and relationships which leads to low detection accuracy and high rate of false positives. To improve the effectiveness of the binary software static vulnerability detection, this paper proposes a fusion method for binary software vulnerability detection which first represents the binary software as a single property graph and then the vulnerability is modeled and detected based on this property graph. Because property graph includes integrated information such as the relations between function calls, control flow, data flow relationship and so on, researchers can model vulnerability more easily and accurately. It can detect unknown vulnerabilities accurately and effi-ciently. The experiments of prototype system show that this method can effectively detect Return-Value-Unchecked Vulnerability in binary software.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_68690_5_12,
  title = {Detecting Energy Bugs in Android Apps Using Static Analysis},
  author = {Jiang, Hao and Yang, Hongli and Qin, Shengchao and Su, Zhendong and Zhang, Jian and Yan, Jun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {192-208},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-68690-5\_12},
  url = {https://doi.org/10.1007/978-3-319-68690-5\_12},
  abstract = {Energy bugs in Android apps are defects that can make Android systems waste much energy as a whole. Energy bugs detection in Android apps has become an important issue since smartphones usually operate on a limited amount of battery capacity and the existence of energy bugs may lead to serious drain in the battery power. This paper focuses on detecting two types of energy bugs, namely resource leak and layout defect, in Android apps. A resource leak is a particular type of energy wasting phenomena where an app does not release its acquired resources such as a sensor and GPS. A layout defect refers to a poor layout structure causing more energy consumption for measuring and drawing the layout. In this paper, we present a static analysis technique called SAAD, that can automatically detect energy bugs in a context-sensitive way. SAAD detects the energy bugs by taking an inter-procedural anaysis of an app. For resource leak analysis, SAAD decompiles APK file into Dalvik bytecodes files and then performs resource leak analysis by taking components call relationship analysis, inter-procedure and intra-procedure analysis. For detecting layout defect, SAAD firstly employs Lint to perform some traditional app analysis, then filters energy defects from reported issues. Our experimental result on 64 publicly-available Android apps shows that SAAD can detect energy bugs effectively. The accuracies of detecting resource leak and layout energy defect are \\(87.5\\\%\\) and \\(78.1\\\%\\) respectively.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10515_017_0228_z,
  title = {Lifting inter-app data-flow analysis to large app sets},
  author = {Sattler, Florian and von Rhein, Alexander and Berger, Thorsten and Johansson, Niklas Schalck and Hardø, Mikael Mark and Apel, Sven},
  journal = {Automated Software Engineering},
  year = {2018},
  volume = {25},
  number = {2},
  pages = {315-346},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-017-0228-z},
  url = {https://doi.org/10.1007/s10515-017-0228-z},
  abstract = {Mobile apps process increasing amounts of private data, giving rise to privacy concerns. Such concerns do not arise only from single apps, which might—accidentally or intentionally—leak private information to untrusted parties, but also from multiple apps communicating with each other. Certain combinations of apps can create critical data flows not detectable by analyzing single apps individually. While sophisticated tools exist to analyze data flows inside and across apps, none of these scale to large numbers of apps, given the combinatorial explosion of possible (inter-app) data flows. We present a scalable approach to analyze data flows across Android apps. At the heart of our approach is a graph-based data structure that represents inter-app flows efficiently. Following ideas from product-line analysis, the data structure exploits redundancies among flows and thereby tames the combinatorial explosion. Instead of focusing on specific installations of app sets on mobile devices, we lift traditional data-flow analysis approaches to analyze and represent data flows of all possible combinations of apps. We developed the tool Sifta and applied it to several existing app benchmarks and real-world app sets, demonstrating its scalability and accuracy.},
  content_type = {Article},
}


@article{springer_10_1007_s11280_017_0458_9,
  title = {An automatically vetting mechanism for SSL error-handling vulnerability in android hybrid Web apps},
  author = {Liu, Yang and Zuo, Chaoshun and Zhang, Zonghua and Guo, Shanqing and Xu, Xinshun},
  journal = {World Wide Web},
  year = {2018},
  volume = {21},
  number = {1},
  pages = {127-150},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11280-017-0458-9},
  url = {https://doi.org/10.1007/s11280-017-0458-9},
  abstract = {A large set of diverse hybrid mobile apps, which use both native Android app UIs and Web UIs, are widely available in today’s smartphones. These hybrid apps usually use SSL or TLS to secure HTTP based communication. However, researchers show that incorrect implementation of SSL or TLS may lead to serious security problems, such as Man-In-The-Middle (MITM) attacks and phishing attacks. This paper investigates a particular SSL vulnerability that results from error-handling code in the hybrid mobile Web apps. Usually such error-handling code is used to terminate an ongoing communication, but the vulnerability of interest is able to make the communication proceed regardless of SSL certificate verification failures, eventually lead to MITM attacks. To identify those vulnerable apps, we develop a hybrid approach, which combines both static analysis and dynamic analysis to (1) automatically distinguish the native Android UIs and Web UIs, and execute the Web UIs to trigger the error-handling code; (2) accurately select the correct paths from the app entry-point to the targeted code, meanwhile avoiding the crash of apps, and populate messaging objects for the communication between components. Specifically, we construct inter-component call graphs to model the connections, and design algorithms to select the paths from the established graph and determine the parameters by backtracing. To evaluate our approach, we have implemented and tested it with 13,820 real world mobile Web apps from Google Play. The experimental results demonstrate that 1,360 apps are detected as potentially vulnerable ones solely using the static analysis. The dynamic analysis process further confirms that 711 apps are truly vulnerable among the potentially vulnerable set.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_90800_7_1,
  title = {The Notion of a Software Language},
  author = {Lämmel, Ralf},
  booktitle = {Software Languages},
  year = {2018},
  pages = {1-49},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-90800-7\_1},
  url = {https://doi.org/10.1007/978-3-319-90800-7\_1},
  abstract = {In this chapter, we characterize the notion of “software language” in a broad sense. We begin by setting out diverse examples of programming, modeling, and specification languages to cover a wide range of use cases of software languages in software engineering. Then, we classify software languages along multiple dimensions and describe the lifecycle of software languages, with phases such as language definition and implementation. Finally, we identify areas in software engineering that involve software languages in different ways, for example, software reverse engineering and software re-engineering.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_2355_0_7,
  title = {iOS App Security Practices},
  author = {Relan, Kunal},
  booktitle = {iOS Penetration Testing},
  year = {2016},
  pages = {119-129},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2355-0\_7},
  url = {https://doi.org/10.1007/978-1-4842-2355-0\_7},
  abstract = {So far it has been a journey of testing, configuring, decompiling, and debugging the iOS apps. You have worked on different methodologies and techniques for penetrating into an iOS application. In this last chapter, we talk about securing iOS apps according to the best practices and industry standards. We all know that perfect security is an illusion; however, there is a lot we can do with our app to make sure we make it hard for someone to attack or play around with it. This chapter talks about best practices for storing data, communicating with the server, deploying apps on the App Store, and other methods to make sure we give our best to secure the application. We will be thinking like a security conscious app developer and a penetration tester at the same time to ensure we develop the application from both point of views.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_48829_5_10,
  title = {String-based Malware Detection for Android Environments},
  author = {Martín, Alejandro and Menéndez, Héctor D. and Camacho, David},
  booktitle = {Studies in Computational Intelligence},
  year = {2017},
  pages = {99-108},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-48829-5\_10},
  url = {https://doi.org/10.1007/978-3-319-48829-5\_10},
  abstract = {Android platforms are known as the less security smartphone devices. The increasing number of malicious apps published on Android markets suppose an important threat to users sensitive data, compromising more devices everyday. The commercial solutions that aims to fight against this malware are based on signature methodologies whose detection ratio is low. Furthermore, these engines can be easily defeated by obfuscation techniques, which are extremely common in app plagiarism. This work aims to improve malware detection using only the binary information and the permissions that are normally used by the anti-virus engines, in order to provide a scalable solution based on machine learning. In order to evaluate the performance of this approach, we carry out our experiments using 5000 malware and 5000 benign-ware, and compare the results with 56 Anti-Virus Engines from VirusTotal.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_38789_5_27,
  title = {Research on a Rapid Hierarchical Algorithm for the Wavelet Transform Based Contour Detection of Medium Plates},
  author = {Li, Ji and Hu, Xuxiao and Yang, Mingmin},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2017},
  pages = {173-190},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-38789-5\_27},
  url = {https://doi.org/10.1007/978-3-319-38789-5\_27},
  abstract = {This paper reviews two problems occur in the online real-time detection for cold rolled medium plates-low transmission efficiency and poor performance. The detecting process involves sending collected images to the industrial personal computer (IPC) of a camera where a rapid contour detection scheme of medium plates based on wavelet transform is presented. The overall architecture, contour detection principle and new two graded data transmission structure which are different from traditional ones will be analyzed. In the first place, the wavelet scalar quantization algorithm is used for pre-processing and compressing the picture captured by the image acquisition module. Subsequently, the processed data will be sent to the IPC where it is then uncompressed. Results show that the compressed image size equals 0.09 \% of the original one; hence the new method is of capability to improve the overall system effectiveness significantly without affecting the accuracy.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11390_015_1573_7,
  title = {Detecting Android Malware Using Clone Detection},
  author = {Chen, Jian and Alalfi, Manar H. and Dean, Thomas R. and Zou, Ying},
  journal = {Journal of Computer Science and Technology},
  year = {2015},
  volume = {30},
  number = {5},
  pages = {942-956},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11390-015-1573-7},
  url = {https://doi.org/10.1007/s11390-015-1573-7},
  abstract = {Android is currently one of the most popular smartphone operating systems. However, Android has the largest share of global mobile malware and significant public attention has been brought to the security issues of Android. In this paper, we investigate the use of a clone detector to identify known Android malware. We collect a set of Android applications known to contain malware and a set of benign applications. We extract the Java source code from the binary code of the applications and use NiCad, a near-miss clone detector, to find the classes of clones in a small subset of the malicious applications. We then use these clone classes as a signature to find similar source files in the rest of the malicious applications. The benign collection is used as a control group. In our evaluation, we successfully decompile more than 1 000 malicious apps in 19 malware families. Our results show that using a small portion of malicious applications as a training set can detect 95\% of previously known malware with very low false positives and high accuracy at 96.88\%. Our method can effectively and reliably pinpoint malicious applications that belong to certain malware families.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_64701_2_14,
  title = {DNA-Droid: A Real-Time Android Ransomware Detection Framework},
  author = {Gharib, Amirhossein and Ghorbani, Ali},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {184-198},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-64701-2\_14},
  url = {https://doi.org/10.1007/978-3-319-64701-2\_14},
  abstract = {Ransomware has become one of the main cyber-threats for mobile platforms and in particular for Android. The number of ransomware attacks are increasing exponentially, while even state of art approaches terribly fail to safeguard mobile devices. The main reason is that ransomware and generic malware characteristics are quite different. Current solutions produce low accuracy and high false positives in presence of obfuscation or benign cryptographic API usage. Moreover, they are inadequate in detecting ransomware attack in early stages before infection happens. In this paper, DNA-Droid, a two layer detection framework is proposed. It benefits of a dynamic analysis layer as a complementary layer on top of a static analysis layer. The DNA-Droid utilizes novel features and deep neural network to achieve a set of features with high discriminative power between ransomware and benign samples. Moreover, Sequence Alignment techniques are employed to profile ransomware families. This helps in detecting ransomware activity in early stages before the infection happens. In order to extract dynamic features, a fully automated Android sandbox is developed which is publicly available for researchers as a web service. The DNA-Droid is tested against thousands of samples. The experimental results shows high precision and recall in detecting even unknown ransomware samples, while keeping the false negative rate below 1.5\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_70278_0_33,
  title = {Defining the Ethereum Virtual Machine for Interactive Theorem Provers},
  author = {Hirai, Yoichi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {520-535},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70278-0\_33},
  url = {https://doi.org/10.1007/978-3-319-70278-0\_33},
  abstract = {Smart contracts in Ethereum are executed by the Ethereum Virtual Machine (EVM). We defined EVM in Lem, a language that can be compiled for a few interactive theorem provers. We tested our definition against a standard test suite for Ethereum implementations. Using our definition, we proved some safety properties of Ethereum smart contracts in an interactive theorem prover Isabelle/HOL. To our knowledge, ours is the first formal EVM definition for smart contract verification that implements all instructions. Our definition can serve as a basis for further analysis and generation of Ethereum smart contracts.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_49019_9_8,
  title = {State Space Obfuscation and Its Application in Hardware Intellectual Property Protection},
  author = {Chakraborty, Rajat Subhra and Bhunia, Swarup},
  booktitle = {Hardware Protection through Obfuscation},
  year = {2017},
  pages = {189-220},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-49019-9\_8},
  url = {https://doi.org/10.1007/978-3-319-49019-9\_8},
  abstract = {In this chapter, we describe the methodology of state space obfuscation for sequential circuits and its application in hardware intellectual property (IP) protection against piracy and tampering attacks. The state space obfuscation is achieved by transforming a given hardware design through judicious modification of the state transition function and insertion of special logic structures at well-chosen locations inside a design. Such modifications perturb the circuit functionality to a maximum extent, while keeping the overall hardware and performance overheads low. Normal functionality is enabled by the application of a specific sequence of vectors at the circuit input, which acts as the enabling key for the circuit. The proposed state space obfuscation methodology effectively locks a gate-level design, and only a legitimate user can unlock it with the application of a predefined key in the form of a sequence of input vectors. We also extend the proposed obfuscation concept to make a given design more robust against hardware Trojan horse (HTH) insertion, thereby increasing the detectability of inserted HTH instances, while incurring low hardware and performance overheads. We present a suitable metric to quantify the level of obfuscation. Finally, we point toward extension of the concept for register transfer level (RTL ) circuit descriptions.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_57837_8_9,
  title = {Contextual Modeling of Group Activity},
  author = {Brézillon, Patrick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {113-126},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-57837-8\_9},
  url = {https://doi.org/10.1007/978-3-319-57837-8\_9},
  abstract = {We extend the Contextual-Graphs formalism for modeling interaction in a group activity. Group activity is modeled as the cyclic traversing of a contextual meta-graph representing the group activity in terms of member activities, and of the shared context as a hub for interaction management. We propose a model of group-member interaction at the level of the transitions between turns. The model relies on the representation of members’ activities in terms of independent tasks that are structured by simulation parameters in the shared context.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_66402_6_6,
  title = {Source Code Authorship Attribution Using Long Short-Term Memory Based Networks},
  author = {Alsulami, Bander and Dauber, Edwin and Harang, Richard and Mancoridis, Spiros and Greenstadt, Rachel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {65-82},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-66402-6\_6},
  url = {https://doi.org/10.1007/978-3-319-66402-6\_6},
  abstract = {Machine learning approaches to source code authorship attribution attempt to find statistical regularities in human-generated source code that can identify the author or authors of that code. This has applications in plagiarism detection, intellectual property infringement, and post-incident forensics in computer security. The introduction of features derived from the Abstract Syntax Tree (AST) of source code has recently set new benchmarks in this area, significantly improving over previous work that relied on easily obfuscatable lexical and format features of program source code. However, these AST-based approaches rely on hand-constructed features derived from such trees, and often include ancillary information such as function and variable names that may be obfuscated or manipulated. In this work, we provide novel contributions to AST-based source code authorship attribution using deep neural networks. We implement Long Short-Term Memory (LSTM) and Bidirectional Long Short-Term Memory (BiLSTM) models to automatically extract relevant features from the AST representation of programmers’ source code. We show that our models can automatically learn efficient representations of AST-based features without needing hand-constructed ancillary information used by previous methods. Our empirical study on multiple datasets with different programming languages shows that our proposed approach achieves the state-of-the-art performance for source code authorship attribution on AST-based features, despite not leveraging information that was previously thought to be required for high-confidence classification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_0135_2_4,
  title = {A Survey of Android Malware Detection Strategy and Techniques},
  author = {Sharma, Mohit and Chawla, Meenu and Gajrani, Jyoti},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2016},
  pages = {39-51},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-0135-2\_4},
  url = {https://doi.org/10.1007/978-981-10-0135-2\_4},
  abstract = {The expeditious growth of Android malwares has posed a serious challenge in front of researchers. The researchers are continuously proposing countermeasures and developing tools to mitigate against such attacks. In this paper, widely used techniques that have been proposed recently by researchers have been explored. The key contributions of each of these techniques along with their limitations have been analyzed. All these techniques were compared based on nine parameters and it was identified that Mobile Sandbox tool is the best when time factor is not considered because it possess the capability of both a static and dynamic analysis, native API call tracking and web accessibility. If time factor is considered, then Dendroid performs best among all. This is due to the reason that it applies text mining to get the signature of malware and it can also classify unknown malware sample through 1-NN classifier.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_54380_2_12,
  title = {Protecting Document Outside Enterprise Network: A Confirmed Framework},
  author = {Aaber, Zeyad S. and Wills, Gary B. and Crowder, Richard M.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {259-275},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-54380-2\_12},
  url = {https://doi.org/10.1007/978-3-319-54380-2\_12},
  abstract = {Sharing e-documents are important components of any enterprise workflow. Keeping these e-documents secure is fundamental to enterprise security, especially in multi-site enterprises or when sharing e-documents with third party. For that purpose, enterprises use document management software. However, document leakage is the most challenging security issue. These leaks are mainly caused by internal attack wither intentional or due to accident and employee ignorance. After exploring the landscape of the current e-document sharing security issues, this chapter proposes a framework to address these issues. The proposed framework is adapting current technologies in new novel approach to deliver a secure environment to share e-documents and track them. The confirmed framework secures documents not only inside the enterprise, but also when they leave the enterprise boundaries via networks or portable devices. As the author’s knowledge extends, there is no other work similar to what this paper provide regarding proposing such a framework. The framework provides a persistent and secure environment through the e-document life cycle and ability to track the document. The framework components design is based on analysing the literature of the current issues and available solutions. These components were confirmed after surveying security professionals and interviewing fourteen security experts. The framework includes components utilising active document concept, digital right management concept, context awareness, and a central certification authority service.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_51966_1_1,
  title = {MalProfiler: Automatic and Effective Classification of Android Malicious Apps in Behavioral Classes},
  author = {La Marra, Antonio and Martinelli, Fabio and Saracino, Andrea and Sheikhalishahi, Mina},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {3-19},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-51966-1\_1},
  url = {https://doi.org/10.1007/978-3-319-51966-1\_1},
  abstract = {Android malicious apps are currently the main security threat for mobile devices. Due to their exponential growth in number of samples, it is vital to timely recognize and classify any new threat, to identify and effectively apply specific countermeasures. In this paper we propose MalProfiler, a framework which performs fast and effective analysis of Android malicious apps, based on the analysis of a set of static app features. The proposed approach exploits an algorithm named Categorical Clustering Tree (CCTree), which can be used both as a divisive clustering algorithm, or as a trainable classifier for supervised learning classification. Hence, the CCTree has been exploited to perform both homogeneous clustering, grouping similar malicious apps for simplified analysis, and to classify them in predefined behavioral classes. The approach has been tested on a set of 3500 real malicious apps belonging to more than 200 families, showing both an high clustering capability, measured through internal and external evaluation, together with an accuracy of 97\% in classifying malicious apps according to their behavior.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_24012_1_3,
  title = {Preserving Lexical Scoping When Dynamically Embedding Languages},
  author = {Ribeiro, Félix and Muhammad, Hisham and Maidl, André Murbach and Ierusalimschy, Roberto},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {31-43},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-24012-1\_3},
  url = {https://doi.org/10.1007/978-3-319-24012-1\_3},
  abstract = {There are various situations in which one may want to embed source code from one language into another, for example when combining relational query languages with application code or when performing staged meta-programming. Typically, one will want to transfer data between these languages. We propose an approach in which the embedded code shares variables with the host language, preserving lexical scoping rules even after the code is converted into an intermediate representation. We demonstrate this approach through a module for meta-programming using Lua as both embedded and host languages. Our technique supports dynamically generated code, requires no special annotation of functions to be translated and is implemented as a library, requiring no source pre-processing or changes to the host language execution environment.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_58460_7_48,
  title = {Detection and Auto-protection of Cache File Privacy Leakage for Mobile Social Networking Applications in Android},
  author = {Li, Hui and Liu, Wenling and Wang, Bin and Zhang, Wen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {703-721},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-58460-7\_48},
  url = {https://doi.org/10.1007/978-3-319-58460-7\_48},
  abstract = {A lot of privacy data are generated by using mobile social networking applications (MSNAs) and the values of user’s privacy data in those applications increase with the establishment and development of big data platform, which makes MSNAs the primary target to be analyzed. Therefore, it is important to analyze privacy leakage and protect user’s privacy in the MSNAs. However, the existing approaches of data leakage detection in the Android platform are not suitable for MSNAs, e.g. VetDroid are considered as an impractical means since they require users’ frequent participation; TaintDroid and the detection methods based on it require the modification of Android system or the modification and re-package of the application, so the cost of the experiment will increase, and the operating efficiency of the application will decrease apparently. In this paper, we propose a privacy leakage detection tool named X-Decaf (X-Posed based Detection of Cache File) as well as an auto-protection method named ATFed (Automatic Transparent File Encryption/Decryption) in MSNAs on the Android platform. These two methods are designed to solve the above-mentioned issues under the conditions of keeping low coupling with the Android system and posing low impacts on the original MSNA.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11042_017_4562_8,
  title = {A white-box AES-like implementation based on key-dependent substitution-linear transformations},
  author = {Xu, Tao and Liu, Feng and Wu, Chuankun},
  journal = {Multimedia Tools and Applications},
  year = {2018},
  volume = {77},
  number = {14},
  pages = {18117-18137},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-017-4562-8},
  url = {https://doi.org/10.1007/s11042-017-4562-8},
  abstract = {It is becoming increasingly common to deploy cryptographic algorithms within software applications which are executed in untrusted environments owned and controlled by a possibly malicious party. White-box cryptography aims to protect the secret key in such an environment. Chow et al. developed a white-box AES implementation in 2002 by hiding secret keys into lookup tables. Afterwards, some improvements were proposed. However, all the published schemes have been shown to be insecure. AES was originally designed without consideration of execution in a white-box attack context. Because of the fixed confusion and diffusion operations, it is easy to break AES’s white-box version. In this paper, we propose an AES-like cipher by replacing AES’s S-boxes and MixColumn matrices with key-dependent components while keeping their good cryptographic properties. We show that the white-box implementation of our AES-like cipher can resist current known attacks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_48628_4_8,
  title = {Engineering a Formal, Executable x86 ISA Simulator for Software Verification},
  author = {Goel, Shilpi and Hunt, Warren A. and Kaufmann, Matt},
  booktitle = {NASA Monographs in Systems and Software Engineering},
  year = {2017},
  pages = {173-209},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-48628-4\_8},
  url = {https://doi.org/10.1007/978-3-319-48628-4\_8},
  abstract = {Construction of a formal model of a computing system is a necessary practice in formal verification. The results of formal analysis can only be valued to the same degree as the model itself. Model development is error-prone, not only due to the complexity of the system being modeled, but also because it involves addressing disparate requirements. For example, a formal model should be defined using simple constructs to enable efficient reasoning but it should also be optimized to offer fast concrete simulations. Models of large computing systems are themselves large software systems and must be subject to rigorous validation. We describe our formal, executable model of the x86 instruction-set architecture; we use our model to reason about x86 machine-code programs. Validation of our x86 ISA model is done by co-simulating it regularly against a physical x86 machine. We present design decisions made during model development to optimize both validation and verification, i.e., efficiency of both simulation and reasoning. Our engineering process provides insight into the development of a software verification and model animation framework from the points of view of accuracy, efficiency, scalability, maintainability, and usability.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_50057_7_4,
  title = {IP Trust: The Problem and Design/Validation-Based Solution},
  author = {Dutta, Raj Gautam and Guo, Xiaolong and Jin, Yier},
  booktitle = {Fundamentals of IP and SoC Security},
  year = {2017},
  pages = {49-65},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-50057-7\_4},
  url = {https://doi.org/10.1007/978-3-319-50057-7\_4},
  abstract = {Globalization of the integrated circuit (IC) supply chain has raised security vulnerabilities at various stages of the IC design flow. Due to increasing demand for products, companies are trying to reduce the time-to-market (TTM) of ICs which, combined with the increased design complexity, boosts the intellectual property (IP) cores transaction market, and supports the growth of third-party design houses. Meanwhile, the exorbitant cost of in-house chip manufacturing and testing forces companies to outsource these services to foundries and third-party testing facilities. The use of third-party IPs and the outsourcing of fabrication and testing services have raised security concerns, thereby compelling companies to evaluate trustworthiness of their circuit designs. Many defense mechanisms have been proposed to protect IP/IC from reverse engineering, malicious tampering, piracy, counterfeiting, cloning, and overbuilding. In this chapter, we first illustrate different threats to an IP/IC as well as locations of possible adversaries in the supply chain. Subsequently, we discuss different protection methods for soft and firm IP cores. Among the two categories of protection methods, authentication, and prevention, we explain the prevention methods in greater details. We divide the prevention methods into combinational logic locking/encryption and finite state machine locking/encryption. Methods for protecting field-programmable gate array (FPGA) bitstreams are also included in the chapter. We then discuss various IP certification methods, which are used to ensure trustworthiness of IPs. Two main categories of formal methods are particularly elaborated within the scope of IP certification: theorem proving and equivalence checking.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_69659_1_21,
  title = {Nightingale: Translating Embedded VM Code in x86 Binary Executables},
  author = {Haijiang, Xie and Yuanyuan, Zhang and Juanru, Li and Dawu, Gu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {387-404},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69659-1\_21},
  url = {https://doi.org/10.1007/978-3-319-69659-1\_21},
  abstract = {Code protection schemes nowadays adopt language embedding, a technique in which a customized language is built within a general-purpose one, often referred to as the host language, to obfuscate original code through transforming it into a customized form with which the analyst is not familiar. The transformed code is then interpreted by a so-called Embedded VM. This type of transformation does increase the cost of code comprehending and maintaining, and introduces extra runtime overhead. In this paper, we conduct an in-depth study on embedded VM based code protection and propose a de-obfuscation approach that aims to recover the original code form. Our approach first pinpoints the interpretation procedure and partitions handlers of the embedded VM, and then employs a VM-state based handler translating, which represents the VM-state-updated behaviors of handlers. Finally, the translated operations of each handler is optimized and transformed into host code. After this process, we can obtain a clear and runtime efficient code representation. We build Nightingale , a binary translation tool, to fulfil this de-obfuscation automatically with x86 binary executables. We test our approach on the latest commercial code obfuscators, embedded domain-specific languages and a set of home brewed obfuscation schemes. The results demonstrate that this kind of obfuscated code can be simplified with host language effectively.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_69365_1_2,
  title = {Observatory for Language Resources and Machine Translation in Europe – LT\_Observatory},
  author = {Maegaard, Bente and Povlsen, Claus and Olsen, Sussi and Henriksen, Lina and Mazura, Margaretha and Lusicky, Vesna and Budin, Gerhard and Rodríguez, Blanca and Esparza, Ma Luz},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {20-37},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69365-1\_2},
  url = {https://doi.org/10.1007/978-3-319-69365-1\_2},
  abstract = {The European Digital Single Market, one of the main goals of Europe 2020, is still fragmented due to language barriers. Language technologies (LT), like Machine Translation (MT) solutions, are key elements for solving this fragmentation. Nevertheless, it is necessary to compile, benchmark the quality and facilitate the access to Language Resources to build successful MT solutions. With these aims, the LT\_Observatory project has been developed (2014–2016). The project was funded by the European Commission through the H2020 programme. This article describes the main outputs: An on-line catalogue of language resources in existing pools and other national resources based on pre-identified user needs. Methodologies for improving the quality and usability of language resources. National and regional language strategies, policies and funding sources to support language technologies. An EcoGuide that aims to adapt the findings of the LT\_Observatory project for various stakeholder groups providing practical information for operational usability of LRs and tools for MT application, funding opportunities, and recommendations geared at European, national and regional policy and decision makers. This project has been carried out by a team of five EU partners with complementary expertise: ZABALA (EU project management and community engagement), EMF (European Multimedia Forum with experience in outreach/social media, and funding, e.g. ESIF and combined funding), LT Innovate (the Language Technology Industry Association), CLARIN ERIC (LT resources and infrastructure, including a Virtual Language Observatory), and University of Vienna/InfoTerm (international information centre for terminology).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_70972_7_33,
  title = {Why Banker Bob (Still) Can’t Get TLS Right: A Security Analysis of TLS in Leading UK Banking Apps},
  author = {Chothia, Tom and Garcia, Flavio D. and Heppell, Chris and Stone, Chris McMahon},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {579-597},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70972-7\_33},
  url = {https://doi.org/10.1007/978-3-319-70972-7\_33},
  abstract = {This paper presents a security review of the mobile apps provided by the UK’s leading banks; we focus on the connections the apps make, and the way in which TLS is used. We apply existing TLS testing methods to the apps which only find errors in legacy apps. We then go on to look at extensions of these methods and find five of the apps have serious vulnerabilities. In particular, we find an app that pins a TLS root CA certificate, but do not verify the hostname. In this case, the use of certificate pinning means that all existing test methods would miss detecting the hostname verification flaw. We also find one app that doesn’t check the certificate hostname, but bypasses proxy settings, resulting in failed detection by pentesting tools. We find that three apps load adverts over insecure connections, which could be exploited for in-app phishing attacks. Some of the apps used the users’ PIN as authentication, for which PCI guidelines require extra security, so these apps use an additional cryptographic protocol; we study the underlying protocol of one banking app in detail and show that it provides little additional protection, meaning that an active man-in-the-middle attacker can retrieve the user’s credentials, login to the bank and perform every operation the legitimate user could.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_50380_6_6,
  title = {Hardware Obfuscation: Techniques and Open Challenges},
  author = {Becker, Georg T. and Fyrbiak, Marc and Kison, Christian},
  booktitle = {Foundations of Hardware IP Protection},
  year = {2017},
  pages = {105-123},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-50380-6\_6},
  url = {https://doi.org/10.1007/978-3-319-50380-6\_6},
  abstract = {While hardware obfuscation has been used in industry for many years, very few scientific papers discuss layout-level obfuscation. The main aim of this paper is to start a discussion about hardware obfuscation in the academic community and point out open research problems. In particular, we introduce a very flexible layout-level obfuscation tool that we use as a case study for hardware obfuscation. In this obfuscation tool, a small custom-made obfuscell is used in conjunction with a standard cell to build a new obfuscated standard cell library called Obfusgates . This standard cell library can be used to synthesize any HDL code with standard synthesis tools, e.g., Synopsis Design Compiler. However, only obfuscating the functionality of individual gates is not enough. Not only the functionality of individual gates, but also their connectivity, leaks important information about the design. In our tool we therefore designed the obfuscation gates to include a large number of “dummy wires”. Due to these dummy wires, the connectivity of the gates in addition to their logic functionality is obfuscated. We argue that this aspect of obfuscation is of great importance in practice and that there are many interesting open research questions related to this.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_47166_2_63,
  title = {Information Leakage Analysis of Complex C Code and Its application to OpenSSL},
  author = {Malacaria, Pasquale and Tautchning, Michael and DiStefano, Dino},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {909-925},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-47166-2\_63},
  url = {https://doi.org/10.1007/978-3-319-47166-2\_63},
  abstract = {The worldwide attention generated by the Heartbleed bug has demonstrated even to the general public the potential devastating consequences of information leaks. While substantial academic work has been done in the past on information leaks, these works have so far not satisfactorily addressed the challenges of automated analysis of real-world complex C code. On the other hand, effective working solutions rely on ad-hoc principles that have little or no theoretical justification. The foremost contribution of this paper is to bridge this chasm between advanced theoretical work and concrete practical needs of programmers developing real world software. We present an analysis, based on clear security principles and verification tools, which is largely automatic and effective in detecting information leaks in complex C code running everyday on millions of systems worldwide.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_42108_7_7,
  title = {The Design and Implementation on the Android Application Protection System},
  author = {Haoliang, Cui and Ruqiang, Huang and Chengjie, Shi and Shaozhang, Niu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {87-105},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-42108-7\_7},
  url = {https://doi.org/10.1007/978-3-319-42108-7\_7},
  abstract = {As an open-source mobile platform, Android is facing with the severe problems of security and then the applications that running on this platform also confront with the same threats. This paper concludes the secure problems with which android applications are facing and gives a research on the current defense solutions. A security reinforcement system based on the Dex protection is proposed in order to defense the dynamic monitoring and modification. This system combines the static defense solution and dynamic defense solution, implements the purpose to tamper-proofing, anti-debugging for Android applications and improves the reliability and security of the software.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_70848_5_13,
  title = {Sound Transpilation from Binary to Machine-Independent Code},
  author = {Metere, Roberto and Lindner, Andreas and Guanciale, Roberto},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {197-214},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-70848-5\_13},
  url = {https://doi.org/10.1007/978-3-319-70848-5\_13},
  abstract = {In order to handle the complexity and heterogeneity of modern instruction set architectures, analysis platforms share a common design, the adoption of hardware-independent intermediate representations. The usage of these platforms to verify systems down to binary-level is appealing due to the high degree of automation they provide. However, it introduces the need for trusting the correctness of the translation from binary code to intermediate language. Achieving a high degree of trust is challenging since this transpilation must handle (i) all the side effects of the instructions, (ii) multiple instruction encoding (e.g. ARM Thumb), and (iii) variable instruction length (e.g. Intel). We overcome these problems by formally modeling one of such intermediate languages in the interactive theorem prover HOL4 and by implementing a proof-producing transpiler. This tool translates ARMv8 programs to the intermediate language and generates a HOL4 proof that demonstrates the correctness of the translation in the form of a simulation theorem. We also show how the transpiler theorems can be used to transfer properties verified on the intermediate language to the binary code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_61204_1_16,
  title = {Breaking and Fixing Mobile App Authentication with OAuth2.0-based Protocols},
  author = {Yang, Ronghai and Lau, Wing Cheong and Shi, Shangcheng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {313-335},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-61204-1\_16},
  url = {https://doi.org/10.1007/978-3-319-61204-1\_16},
  abstract = {Although the OAuth2.0 protocol was originally designed to serve the authorization need for websites, mainstream identity providers like Google and Facebook have made significant changes on this protocol to support authentication for mobile apps. Prior research mainly focuses on how the features of mobile operating systems can affect the OAuth security. However, little has been done to analyze whether these significant modifications of the protocol call-flow can be well understood and implemented by app developers. Towards this end, we report a field-study on the Android OAuth2.0-based single-sign-on systems. In particular, we perform an in-depth static code analysis on three identity provider apps including Facebook, Google and Sina as well as their official SDKs to understand their OAuth-related transactions. We then dynamically test 600 top-ranked US and Chinese Android apps. Apart from various types of existing vulnerabilities, we also discover three previously unknown security flaws among these first-tier identity providers and a large number of popular 3rd-party apps. For example, 41\% apps under study are susceptible to a newly discovered profile attack, which unlike prior works, enables remote account hijacking without any need to trick or interact with the victim. The prevalence of vulnerabilities further motivates us to propose/implement an alternative, fool-proof OAuth SDK for one of the affected IdPs to automatically prevent from these vulnerabilities. To facilitate the adoption of our proposed fixes, our solution requires minimal code changes by the 3rd-party-developers of the affected mobile apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_2979_8_11,
  title = {Threads, the “t” in P.A.t.h.},
  author = {Ostermueller, Erik},
  booktitle = {Troubleshooting Java Performance},
  year = {2017},
  pages = {141-159},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2979-8\_11},
  url = {https://doi.org/10.1007/978-1-4842-2979-8\_11},
  abstract = {Knowing how much load to apply in a load test has long been a question without a well-defined answer. The Scalability Yardstick (Chapter 6) finally answers that question with an easy-to-follow test formula, which also provides an uncommonly convenient way to assess scalability. The test itself is just a small, evolutionary improvement to the very commonly used incremental load test.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_05948_8_9,
  title = {An Adaptable Infrastructure to Generate Training Datasets for Decompilation Issues},
  author = {Escalada, Javier and Ortin, Franciso},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2014},
  pages = {85-94},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-05948-8\_9},
  url = {https://doi.org/10.1007/978-3-319-05948-8\_9},
  abstract = {The conventional decompilation approach is based on a combination of heuristics and pattern matching. This approach depends on the processor architecture, the code generation templates used by the compiler, and the optimization level. In addition, there are specific scenarios where heuristics and pattern matching do not infer high-level information such as the return type of a function. Since AI has been previously used in similar scenarios, we have designed an adaptable infrastructure to facilitate the use of AI techniques for overcoming the decompilation issues detected. The proposed infrastructure is aimed at automatically generating training datasets. The architecture follows the Pipes and Filters architectural pattern that facilitates adapting the infrastructure to different kind of decompilation scenarios. It also makes it easier to parallelize the implementation. The generated datasets can be processed in any AI engine, training the predictive model obtained before adding it to the decompiler as a plug-in.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_69155_8_5,
  title = {An Experimental Framework for Investigating Security and Privacy of IoT Devices},
  author = {Tekeoglu, Ali and Tosun, Ali Şaman},
  booktitle = {Lecture Notes in Computer Science},
  year = {2017},
  pages = {63-83},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-69155-8\_5},
  url = {https://doi.org/10.1007/978-3-319-69155-8\_5},
  abstract = {With the rapid growth of Internet-of-Things (IoT) devices, security and privacy issues emerged as a potential roadblock for widespread adoption. Preliminary research indicates that many types of IoT devices have serious vulnerabilities. It is not easy to investigate security and privacy issues since each type of device is different and manual experiments need to be conducted on the device. In this paper, we propose a framework for investigation of security and privacy issues of IoT devices. The framework consists of four components, a testbed, set of topics to be investigated, a set of experiments for each topic investigated and a final report. Fundamental approach used in the framework is to capture layer 2 and layer 3 packets and to analyze the packets for various features. Proposed framework is low cost and is based on off-the-shelf hardware and open source software. Using the framework, we can investigate security and privacy issues of many IoT devices including HDMI sticks, IP cameras, activity trackers, smartwatches and drones. A large set of topics can be investigated on IoT devices using the framework including vulnerability issues, protocol security, firmware updates, authentication issues and privacy violations. Sample experimental results show the promise of the proposed framework. We believe this framework will serve as the foundation for a general automated framework to investigate security and privacy issues of most IoT devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_74250_2_4,
  title = {Pattern Maps and Labels},
  author = {Maloney, Ross J.},
  booktitle = {Low Level X Window Programming},
  year = {2017},
  pages = {85-138},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-74250-2\_4},
  url = {https://doi.org/10.1007/978-3-319-74250-2\_4},
  abstract = {Most, if not all, computer-based windowing systems have a means of displaying a fixed pattern on a window in such a way as to involve minimal processing. This is the generic pattern format of the windowing system. For the X Window System, this format is a Pixmap. There are two sub-categories of Pixmap: the single bit (or black and white) bitmap and the more general PixMap which is capable of representing colour. A complication is X Window System refers to the analogue of a window as a Pixmap. But all what can be done on, or with, a window is not true for a map-type Pixmap.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_31854_7_9,
  title = {Survey on Android Applications Security},
  author = {Fu, Chengzhou and Huang, Chang and Tang, Yong and Zeng, Weiquan and Wang, Dahao and Yuan, Chengzhe},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {92-103},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-31854-7\_9},
  url = {https://doi.org/10.1007/978-3-319-31854-7\_9},
  abstract = {Android plays a paramount role in mobile internet era and it is an extremely comfortable operating system to deploy in mobile devices. More and more security problems have been taken place on Android devices, and lead to leak users’ privilege information. In order to survey the security situation of Android application, we have downloaded 1901 Android APK files from the application market for study. We present several schemas to protect Android applications and avoid others to invade smartphones.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_6893_5_5,
  title = {DFP: A Data Fragment Protection Scheme for mHealth in Wireless Network},
  author = {Zhang, Lin and Chen, Zhigang and Zhang, Deyu},
  booktitle = {Communications in Computer and Information Science},
  year = {2017},
  pages = {60-74},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-6893-5\_5},
  url = {https://doi.org/10.1007/978-981-10-6893-5\_5},
  abstract = {The mHealth system gradually become widely promoted, the user data privacy issues by the community a strong concern in the complex wireless network environment. In this paper, we propose a data fragment protection scheme, named DFP. The proposed DFP scheme according to the characteristics of the medical environment to system preprocessing, let the wearable equipment or implantation equipment to collect the patient information classified as patient personal privacy data and general medical data, the two types of data on the degree of privacy of different treatment. And according to the data connectivity design reliable transmission scheme. Our framework can not only more reasonable protection of medical data privacy and security, but also to reduce communication consumption and reduce the average time delay. Extensive performance analysis and experimental results proves its effectiveness and reliability.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_45744_4_20,
  title = {Hey, You, Get Off of My Image: Detecting Data Residue in Android Images},
  author = {Zhang, Xiao and Aafer, Yousra and Ying, Kailiang and Du, Wenliang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {401-421},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-45744-4\_20},
  url = {https://doi.org/10.1007/978-3-319-45744-4\_20},
  abstract = {Android’s data cleanup mechanism has been called into question with the recently discovered data residue vulnerability. However, the existing study only focuses on one particular Android version and demands heavy human involvement. In this project, we aim to fill the gap by providing a comprehensive understanding of the data residue situation across the entire Android ecosystem. To this end, we propose ANRED(ANRED is a former French public institution for the recovery and disposal of waste.), an AN droid RE sidue D etector that performs static analysis on Android framework bytecode and automatically quantifies the risk for each identified data residue instance within collected system services. The design of ANRED has overcome several challenges imposed by the special characteristic of Android framework and data residue vulnerability. We have implemented ANRED in WALA and further evaluated it against 606 Android images. The analysis results have demonstrated the effectiveness, efficiency and reliability of ANRED. In particular, we have confirmed the effect of vendor customization and version upgrade on data residue vulnerability. We have also identified five new data residue instances that have been overlooked in the previous study, leading to data leakage and privilege escalation attacks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10766_016_0480_z,
  title = {Runtime Vectorization Transformations of Binary Code},
  author = {Hallou, Nabil and Rohou, Erven and Clauss, Philippe},
  journal = {International Journal of Parallel Programming},
  year = {2017},
  volume = {45},
  number = {6},
  pages = {1536-1565},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10766-016-0480-z},
  url = {https://doi.org/10.1007/s10766-016-0480-z},
  abstract = {In many cases, applications are not optimized for the hardware on which they run. Several reasons contribute to this unsatisfying situation, such as legacy code, commercial code distributed in binary form, or deployment on compute farms. In fact, backward compatibility of ISA guarantees only the functionality, not the best exploitation of the hardware. In this work, we focus on maximizing the CPU efficiency for the SIMD extensions. The first contribution was originally published in the International Conference on Embedded Computer Systems: Architectures, Modeling and Simulation, SAMOS XV, July 2015, Agios Konstantinos, Greece. It is a binary-to-binary optimization framework where loops vectorized for an older version of the processor SIMD extension are automatically converted to a newer one. It is a lightweight mechanism that does not include a vectorizer, but instead leverages what a static vectorizer previously did. We show that many loops compiled for x86 SSE can be dynamically converted to the more recent and more powerful AVX; as well as, how correctness is maintained with regards to challenges such as data dependencies and reductions. We obtain speedups in line with those of a native compiler targeting AVX. The second contribution is the runtime vectorization of loops in binary codes that were not originally vectorized. For this purpose, we use open source frameworks that we have tuned and integrated to (1) dynamically lift the x86 binary into the Intermediate Representation form of the LLVM compiler, (2) abstract hot loops in the polyhedral model, (3) use the power of this mathematical framework to vectorize them, and (4) finally compile them back into executable form using the LLVM Just-In-Time compiler. In most cases, the obtained speedups are close to the number of elements that can be simultaneously processed by the SIMD unit. The re-vectorizer and auto-vectorizer are implemented inside a dynamic optimization platform; it is completely transparent to the user, does not require any rewriting of the binaries, and operates during program execution.},
  content_type = {Article},
}


@article{springer_10_1007_s11432_015_5422_7,
  title = {A static technique for detecting input validation vulnerabilities in Android apps},
  author = {Fang, Zhejun and Liu, Qixu and Zhang, Yuqing and Wang, Kai and Wang, Zhiqiang and Wu, Qianru},
  journal = {Science China Information Sciences},
  year = {2017},
  volume = {60},
  number = {5},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11432-015-5422-7},
  url = {https://doi.org/10.1007/s11432-015-5422-7},
  abstract = {Input validation vulnerabilities are common in Android apps, especially in inter-component communications. Malicious attacks can exploit this kind of vulnerability to bypass Android security mechanism and compromise the integrity, confidentiality and availability of Android devices. However, so far there is not a sound approach at the source code level for app developers aiming to detect input validation vulnerabilities in Android apps. In this paper, we propose a novel approach for detecting input validation flaws in Android apps and we implement a prototype named EasyIVD, which provides practical static analysis of Java source code. EasyIVD leverages backward program slicing to extract transaction and constraint slices from Java source code. Then EasyIVD validates these slices with predefined security rules to detect vulnerabilities in a known pattern. To detect vulnerabilities in an unknown pattern, EasyIVD extracts implicit security specifications as frequent patterns from the duplicated slices and verifies them. Then EasyIVD semi-automatically confirms the suspicious rule violations and reports the confirmed ones as vulnerabilities. We evaluate EasyIVD on four versions of original Android apps spanning from version 2.2 to 5.0. It detects 58 vulnerabilities including confused deputy attacks and denial of service attacks. Our results prove that EasyIVD can provide a practical defensive solution for app developers.},
  content_type = {Article},
}


@article{springer_10_1007_s00500_016_2357_x,
  title = {A software classification scheme using binary-level characteristics for efficient software filtering},
  author = {Kim, Yesol and Cho, Seong-je and Han, Sangchul and You, Ilsun},
  journal = {Soft Computing},
  year = {2018},
  volume = {22},
  number = {2},
  pages = {595-606},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00500-016-2357-x},
  url = {https://doi.org/10.1007/s00500-016-2357-x},
  abstract = {Software filtering systems can be employed to detect and filter out pirated or counterfeit software on the Web sites and peer-to-peer networks. They determine whether a suspicious program is legal or not by comparing it with original programs in a database or in the market. To identify pirated or counterfeit software, software filtering systems need to measure software similarity when comparing a suspicious program with original ones. In this case, the comparison overhead might be very high because the suspicious program is compared with all programs in the database or market in the worst case. This paper proposes a software classification scheme for efficient software filtering systems. The scheme focuses specifically on the Windows portable executable files which have been prime targets for software pirates. The scheme extracts software characteristics from a suspicious program and classifies it into one of pre-defined categories quickly based on the characteristics. The suspicious program is compared only with the programs in the one of pre-defined categories in most cases; thus, the comparison overhead is reduced. We propose two classification methods. The first one extracts strings from GUI-related resources of a program and computes the relevance of the program to each category based on the pre-computed score of the strings. The second one extracts API call frequency from a program’s execution codes and uses Random Forest technique to classify the program. Experimental results show that the proposed scheme can classify programs effectively and can reduce the comparison overhead significantly.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_02346_0_7,
  title = {Advanced Topics},
  author = {Larsen, Per and Brunthaler, Stefan and Davi, Lucas and Sadeghi, Ahmad-Reza and Franz, Michael},
  booktitle = {Synthesis Lectures on Information Security, Privacy, and Trust},
  year = {2016},
  pages = {59-60},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-02346-0\_7},
  url = {https://doi.org/10.1007/978-3-031-02346-0\_7},
  abstract = {While the security and performance implications of diversified software are well understood, several practical concerns remain to be addressed. In addition, existing research has not fully explored the protective qualities of diversified software nor has it reached consensus on how to evaluate the efficacy of software diversity with respect to the attacker workload.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_49145_5_11,
  title = {Research and Implementation Key Technology of Security Mobile Office},
  author = {Qiu, Feng and Li, Xiaoqian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {105-114},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-49145-5\_11},
  url = {https://doi.org/10.1007/978-3-319-49145-5\_11},
  abstract = {To address the information leakage problems existed in the smartphone mobility office of enterprises and institutions, we propose security mobile office architecture and design application security authentication mechanism, software and hardware resource control mechanism, security storage isolation mechanism, which provide safe protection for sensitive data. To evaluate the propose schemes, we implement them in the android system and cloud service platform. The evaluation results verify the feasibility and effectiveness of the security mobile office technology.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_47121_1_5,
  title = {DroidDelver: An Android Malware Detection System Using Deep Belief Network Based on API Call Blocks},
  author = {Hou, Shifu and Saas, Aaron and Ye, Yanfang and Chen, Lifei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {54-66},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-47121-1\_5},
  url = {https://doi.org/10.1007/978-3-319-47121-1\_5},
  abstract = {Because of the explosive growth of Android malware and due to the severity of its damages, the detection of Android malware has become an increasing important topic in cyber security. Currently, the major defense against Android malware is commercial mobile security products which mainly use signature-based method for detection. However, attackers can easily devise methods, such as obfuscation and repackaging, to evade the detection, which calls for new defensive techniques that are harder to evade. In this paper, resting on the analysis of Application Programming Interface (API) calls extracted from the smali files, we further categorize the API calls which belong to the some method in the smali code into a block. Based on the generated code blocks, we then apply a deep learning framework (i.e., Deep Belief Network) for newly unknown Android malware detection. Using a real sample collection from Comodo Cloud Security Center, a comprehensive experimental study is performed to compare various malware detection approaches. Promising experimental results demonstrate that DroidDelver which integrates our proposed method outperform other alternative Android malware detection techniques.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_39077_2_8,
  title = {A Scalable Cloud-Based Android App Repackaging Detection Framework},
  author = {Li, Jinghua and Liu, Xiaoyan and Zhang, Huixiang and Mu, Dejun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {113-125},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-39077-2\_8},
  url = {https://doi.org/10.1007/978-3-319-39077-2\_8},
  abstract = {The problem of app repackaging has become a huge threat to the security of Android ecosystem. The massive amount of existing and developing apps makes a high demand on scalability of app repackaging detectors. In this paper, we propose a cloud-based app repackaging detection framework. It is designed to analyze and detect repacked Android apps in a large-scale way. The framework consists of three primary components: market monitor, app feature extractor and app similarity computer. Market monitor crawls all new and updated apps in specific alternative app markets periodically. Then, the multi-level features of apps are extracted by app feature extractor. App similarity computer computes the similarity score of two apps based on these features. A prototype system is implemented. The evaluation results demonstrate that the proposed cloud-based framework is highly scalable and effective for large-scale Android app repackaging detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_45477_1_9,
  title = {A High-Assurance, High-Performance Hardware-Based Cross-Domain System},
  author = {Hardin, David and Slind, Konrad and Bortz, Mark and Potts, James and Owens, Scott},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {102-113},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-45477-1\_9},
  url = {https://doi.org/10.1007/978-3-319-45477-1\_9},
  abstract = {Guardol is a domain-specific language focused on the creation of high-assurance cross-domain systems ( i.e. , network guards). The Guardol system generates executable code from Guardol programs while also providing formal property specification and automated verification support. Guardol programs and specifications are translated to higher order logic, then deductively transformed to a form suitable for code generation. Recently, we extended Guardol to support regular expressions; this has enabled the creation of a class of fast and secure hardware guards. We justify the regular expression extension via proof that the extension compiles to the original language while preserving key correctness properties. In this paper, we detail the verified compilation of regular expression guards written in Guardol, producing Ada, Java, ML, and VHDL. We have compiled a regular expression guard written in Guardol to VHDL, then synthesized and tested the guard on a low-SWAP (Size, Weight, And Power) embedded FPGA-based hardware guard platform; performance of the FPGA guard core exceeded the data payload rate for UDP/IP packets on Gigabit Ethernet, while consuming less than 1 \% of FPGA resources.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10710_016_9278_4,
  title = {Online Genetic Improvement on the java virtual machine with ECSELR},
  author = {Yeboah-Antwi, Kwaku and Baudry, Benoit},
  journal = {Genetic Programming and Evolvable Machines},
  year = {2017},
  volume = {18},
  number = {1},
  pages = {83-109},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10710-016-9278-4},
  url = {https://doi.org/10.1007/s10710-016-9278-4},
  abstract = {Online Genetic Improvement embeds the ability to evolve and adapt inside a target software system enabling it to improve at runtime without any external dependencies or human intervention. We recently developed a general purpose tool enabling Online Genetic Improvement in software systems running on the java virtual machine. This tool, dubbed ECSELR, is embedded inside extant software systems at runtime, enabling such systems to self-improve and adapt autonomously online. We present this tool, describing its architecture and focusing on its design choices and possible uses.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_59041_7_7,
  title = {Review of Existing Analysis Tools for SELinux Security Policies: Challenges and a Proposed Solution},
  author = {Eaman, Amir and Sistany, Bahman and Felty, Amy},
  booktitle = {Lecture Notes in Business Information Processing},
  year = {2017},
  pages = {116-135},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-59041-7\_7},
  url = {https://doi.org/10.1007/978-3-319-59041-7\_7},
  abstract = {Access control policy management is an increasingly hard problem from both the security point of view and the verification point of view. SELinux is a Linux Security Module (LSM) implementing a mandatory access control mechanism. SELinux integrates user identity, roles, and type security attributes for stating rules in security policies. As SELinux policies are developed and maintained by security administrators, they often become quite complex, and it is important to carefully analyze them in order to have high assurance of their correctness. There are many existing analysis tools for modeling and analyzing SELinux policies with the goal of answering specific safety and functionality questions. In this paper, we identify and highlight current gaps in these existing tools for SELinux policy analysis, and propose new tools and technologies with the potential to lead to significant improvements. The proposed solution includes adopting a certified access control policy language such as ACCPL (A Certified Access Core Policy Language). ACCPL comes with formal proofs of important properties, and our proposed solution includes adopting it to facilitate various analyses and proof of reasonability properties. ACCPL is general, and our goal is to design a certified domain-specific policy language based on it, specialized to our task.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_10_1536_6_54,
  title = {Examining Performance Issues of GUI Based Android Applications},
  author = {Shin, Jung-Hoon and Abebe, Mesfin and Kim, Suntae and Yoo, Cheol Jung and Jin, Kwang-Yoon},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2016},
  pages = {415-420},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-1536-6\_54},
  url = {https://doi.org/10.1007/978-981-10-1536-6\_54},
  abstract = {Android platform applications are the most dominant technologies in the mobile markets. These applications have a wide range of functionalities such as Game, Business, Education, Entertainment, Shopping, Travel and Weather etc. However, most of these applications have a performance problem in their Graphical User Interfaces (GUIs) since the mobile application GUI testing is daunting and too expensive. In this study, we investigated the severity of the Android applications GUI performance problem by examining a sample of freely downloadable applications from Google Store and analyzed performance issues of the applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_2902_6_10,
  title = {Modules},
  author = {Sharan, Kishori},
  booktitle = {Beginning Java 9 Fundamentals},
  year = {2017},
  pages = {355-394},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2902-6\_10},
  url = {https://doi.org/10.1007/978-1-4842-2902-6\_10},
  abstract = {The code for some examples in this chapter goes through several steps. The source code for this book contains the code used in the final step for those examples. If you want to see those examples in action at every step as you read through this chapter, you need to modify the source code a bit to keep it in sync with the step you are working on.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_1772_6_15,
  title = {Hack, Break, Fix},
  author = {Binnie, Chris},
  booktitle = {Practical Linux Topics},
  year = {2016},
  pages = {143-148},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1772-6\_15},
  url = {https://doi.org/10.1007/978-1-4842-1772-6\_15},
  abstract = {While the security industry is constantly evolving its countering techniques, the categories of attacks suffered since the inception of the Internet have rarely changed. Both White Hats and Black Hats, whether testing with good intentions or nefariously attacking networks and systems respectively, generally only learn about a handful of different categories of attacks.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11432_016_5521_0,
  title = {Accurate and efficient exploit capture and classification},
  author = {Ding, Yu and Wei, Tao and Xue, Hui and Zhang, Yulong and Zhang, Chao and Han, Xinhui},
  journal = {Science China Information Sciences},
  year = {2017},
  volume = {60},
  number = {5},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11432-016-5521-0},
  url = {https://doi.org/10.1007/s11432-016-5521-0},
  abstract = {Software exploits, especially zero-day exploits, are major security threats. Every day, security experts discover and collect numerous exploits from honeypots, malware forensics, and underground channels. However, no easy methods exist to classify these exploits into meaningful categories and to accelerate diagnosis as well as detailed analysis. To address this need, we present SeismoMeter, which recognizes both control-flowhijacking, and data-only attacks by combining approximate control-flow integrity, fast dynamic taint analysis and API sandboxing schemes. Once it detects an exploit incident, SeismoMeter generates a succinct data representation, called an exploit skeleton , to characterize the captured exploit. SeismoMeter then classifies the captured exploits into different exploit families by performing distance computing on the extracted skeletons. To evaluate the efficiency of SeismoMeter, we conduct a field test using exploit samples from public exploit databases, such as Metasploit, as well as wild-captured exploits. Our experiments demonstrate that SeismoMeter is a practical system that successfully detects and correctly classifies all these exploit attacks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_2325_3_12,
  title = {Hacking Mobile Platforms},
  author = {Rahalkar, Sagar Ajay},
  booktitle = {Certified Ethical Hacker (CEH) Foundation Guide},
  year = {2016},
  pages = {153-159},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2325-3\_12},
  url = {https://doi.org/10.1007/978-1-4842-2325-3\_12},
  abstract = {The rise in the use of mobile devices and smartphones has also increased the risk of compromise of sensitive personal data present on these devices. This chapter introduces the two most popular mobile platforms, Android and iOS, along with their security implications.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_27668_7_3,
  title = {MalCore: Toward a Practical Malware Identification System Enhanced with Manycore Technology},
  author = {Kim, Taegyu and Park, Ki Woong},
  booktitle = {Communications in Computer and Information Science},
  year = {2015},
  pages = {31-48},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-27668-7\_3},
  url = {https://doi.org/10.1007/978-3-319-27668-7\_3},
  abstract = {Many conventional control flow matching methods work well, but lead to obstructive latency for the operations as the number of malware variants has soared. Even though many researchers have proposed control flow matching methods, there is still a trade-off between accuracy and performance. To alleviate this trade-off, we present a system called MalCore, which is comprised of the following three novel mechanisms, each of which aims to provide a practical malware identification system: I-Filter for identical structured control flow string matching, table division to exclude unnecessary comparisons with some malware, and cognitive resource allocation for efficient parallelism. Our performance evaluation shows that the total performance improvement is 280.9 times. This work was undertaken on a real manycore computing platform called MN-MATE.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_2592_9_4,
  title = {Module Dependency},
  author = {Sharan, Kishori},
  booktitle = {Java 9 Revealed},
  year = {2017},
  pages = {57-103},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2592-9\_4},
  url = {https://doi.org/10.1007/978-1-4842-2592-9\_4},
  abstract = {The example code in this chapter goes through several steps. The source code for this book contains the code used in the final step. If you want to see those examples in action at every step as you read through this chapter, you need to modify the source code a bit to keep it in sync with the step you are working on.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_11197_1_44,
  title = {Security Analysis and Protection Based on Smali Injection for Android Applications},
  author = {Xu, Junfeng and Li, Shoupeng and Zhang, Tao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {577-586},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-11197-1\_44},
  url = {https://doi.org/10.1007/978-3-319-11197-1\_44},
  abstract = {Smali code and .Dex file can be completely compiled and decompiled reciprocally. Thus any new functions can be injected into an existing android application directly after decompiling it into smali code under the condition of that we needn’t to modify any java code to develop the application. This leads the android applications to be modified and cracked arbitrarily. In order to prevent it from being decompiled and bundled malicious code, we summarized current typical methods of anti-crack and anti-decompilation, then propose two new solutions based on smali injection, which can protect the security of the android applications effectively.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_7299_4_8,
  title = {Botnet Forensics},
  author = {Joshi, R. C. and Pilli, Emmanuel S.},
  booktitle = {Computer Communications and Networks},
  year = {2016},
  pages = {145-165},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-7299-4\_8},
  url = {https://doi.org/10.1007/978-1-4471-7299-4\_8},
  abstract = {Botnet is a network of compromised computers controlled by attackers. In this chapter botnet forensics with relevance to network forensics is discussed. To understand the botnet threat, the architectures, protocols, and life cycle of botnet network are discussed. The standard botnet forensic process and its various investigation techniques are discussed. The botnet forensics consists of acquisition, analysis, and attribution phases. The research challenges related to botnet forensics and its investigation are also discussed.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_12295_3_5,
  title = {Database Program Translation},
  author = {Fong, Joseph Shi Piu},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2015},
  pages = {181-229},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-12295-3\_5},
  url = {https://doi.org/10.1007/978-3-319-12295-3\_5},
  abstract = {The concept of a relational database was first proposed by E.F. Codd in 1970. It was almost instantaneously recognized as a more user friendly model than the previous nonrelational (e.g., hierarchical or network model) database model. However, it was not adopted by the industry until the early 1980s because of its poor performance. Throughout the 1980s, the performance of relational databases improved and gained wider industry acceptance. This created a need to convert existing databases into a relational structure. Yet database conversion is both a costly and time consuming process. The majority of time spent in such conversion projects is spent on the process of program translation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_46681_1_9,
  title = {Android Malware Detection Method Based on Function Call Graphs},
  author = {Ding, Yuxin and Zhu, Siyi and Xia, Xiaoling},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {70-77},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-46681-1\_9},
  url = {https://doi.org/10.1007/978-3-319-46681-1\_9},
  abstract = {With the rapid development of mobile Internet, mobile devices have been widely used in people’s daily life, which has made mobile platforms a prime target for malware attack. In this paper we study on Android malware detection method. We propose the method how to extract the structural features of android application from its function call graph, and then use the structure features to build classifier to classify malware. The experiment results show that structural features can effectively improve the performance of malware detection methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_59439_2_3,
  title = {Detecting Malicious Collusion Between Mobile Software Applications: The Android TM Case},
  author = {Asăvoae, Irina Măriuca and Blasco, Jorge and Chen, Thomas M. and Kalutarage, Harsha Kumara and Muttik, Igor and Nguyen, Hoang Nga and Roggenbach, Markus and Shaikh, Siraj Ahmed},
  booktitle = {Data Analytics},
  year = {2017},
  pages = {55-97},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-59439-2\_3},
  url = {https://doi.org/10.1007/978-3-319-59439-2\_3},
  abstract = {Malware has been a major problem in desktop computing for decades. With the recent trend towards mobile computing, malware is moving rapidly to smartphone platforms. “Total mobile malware has grown 151\% over the past year”, according to McAfee®’s quarterly treat report in September 2016. By design, Android TM is “open” to download apps from different sources. Its security depends on restricting apps by combining digital signatures, sandboxing, and permissions. Unfortunately, these restrictions can be bypassed, without the user noticing, by colluding apps for which combined permissions allow them to carry out attacks. In this chapter we report on recent and ongoing research results from our ACID project which suggest a number of reliable means to detect collusion, tackling the aforementioned problems. We present our conceptual work on the topic of collusion and discuss a number of automated tools arising from it.},
  content_type = {Chapter},
}


@article{springer_10_1007_s13389_016_0132_7,
  title = {Interdiction in practice—Hardware Trojan against a high-security USB flash drive},
  author = {Swierczynski, Pawel and Fyrbiak, Marc and Koppe, Philipp and Moradi, Amir and Paar, Christof},
  journal = {Journal of Cryptographic Engineering},
  year = {2017},
  volume = {7},
  number = {3},
  pages = {199-211},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s13389-016-0132-7},
  url = {https://doi.org/10.1007/s13389-016-0132-7},
  abstract = {As part of the revelations about the NSA activities, the notion of interdiction has become known to the public: the interception of deliveries to manipulate hardware in a way that backdoors are introduced. Manipulations can occur on the firmware or at hardware level. With respect to hardware, FPGAs are particular interesting targets as they can be altered by manipulating the corresponding bitstream which configures the device. In this paper, we demonstrate the first successful real-world FPGA hardware Trojan insertion into a commercial product. On the target device, a FIPS-140-2 level 2 certified USB flash drive from Kingston, the user data are encrypted using AES-256 in XTS mode, and the encryption/decryption is processed by an off-the-shelf SRAM-based FPGA. Our investigation required two reverse-engineering steps, related to the proprietary FPGA bitstream and to the firmware of the underlying ARM CPU. In our Trojan insertion scenario, the targeted USB flash drive is intercepted before being delivered to the victim. The physical Trojan insertion requires the manipulation of the SPI flash memory content, which contains the FPGA bitstream as well as the ARM CPU code. The FPGA bitstream manipulation alters the exploited AES-256 algorithm in a way that it turns into a linear function which can be broken with 32 known plaintext–ciphertext pairs. After the manipulated USB flash drive has been used by the victim, the attacker is able to obtain all user data from the ciphertexts. Our work indeed highlights the security risks and especially the practical relevance of bitstream modification attacks that became realistic due to FPGA bitstream manipulations.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_10_0557_2_52,
  title = {Improve Dynamic Sandbox on the Cloud with Non-QEMU Based OS Through Hooks and Mocks Techniques},
  author = {Chau, Ngoc-Tu and Vu, Long Nguyen and Jung, Souhwan},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2016},
  pages = {523-531},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-10-0557-2\_52},
  url = {https://doi.org/10.1007/978-981-10-0557-2\_52},
  abstract = {In malware analysis, analysis emulators are either the QEMU-based or non-QEMU based. QEMU-baseds, for example: Android Virtual Device – AVD, are developed to provide a test environment for Android developer. They could provide fully emulated mobile device features by using QEMU, a service that can emulate other environments. Non-QEMU based, for example: Android-x86, is faster in comparing with QEMU-based emulator since its purpose is to deploy Android Operating System directly on real architecture devices. However, non-QEMU based only works best on real hardware and could not provide full emulated services because it does not have QEMU service. In order to properly apply QEMU-based emulator and non-QEMU based as malware analysis environment into the cloud, either the performance of QEMU-based emulator should be improved or Android-x86 should support emulated services. Deploying QEMU-based emulator on Cloud is costly. Also, applying existing solution for performance improvement is complicated. Furthermore, applications could use JNI method to check for QEMU existence to identify emulator environment. On the other hand, non-QEMU based sandbox cannot fully emulate mobile device features since it does not have QEMU service. In compare with QEMU-based, problem of non-QEMU based can be solved through software solution and thus reduce deployment cost on Cloud. This paper proposes a combination of Hook and Mock technique as a work-around solution for non-QEMU based sandbox. Hooking technique could mangle the results of API calls and Mock technique could build the emulated Mobile Network environment around non-QEMU sandbox to execute mobile specific actions like unsolicited RIL request for simulating incoming call or incoming SMS.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_39570_8_14,
  title = {Ransomware Steals Your Phone. Formal Methods Rescue It},
  author = {Mercaldo, Francesco and Nardone, Vittoria and Santone, Antonella and Visaggio, Corrado Aaron},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {212-221},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-39570-8\_14},
  url = {https://doi.org/10.1007/978-3-319-39570-8\_14},
  abstract = {Ransomware is a recent type of malware which makes inaccessible the files or the device of the victim. The only way to unlock the infected device or to have the keys for decrypting the files is to pay a ransom to the attacker. Commercial solutions for removing ransomware and restoring the infected devices and files are ineffective, since this malware uses a very robust form of asymmetric cryptography and erases shadow copies and recovery points of the operating system. Literature does not count many solutions for effectively detecting and blocking ransomware and, at the best knowledge of the authors, formal methods were never applied to identify ransomware. In this paper we propose a methodology based on formal methods that is able to detect the ransomware and to identify in the malware’s code the instructions that implement the characteristic instructions of the ransomware. The results of the experimentation are strongly encouraging and suggest that the proposed methodology could be the right way to follow for developing commercial solutions that could successful intercept the ransomware and blocking the infections it provokes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_31875_2_19,
  title = {BurnFit: Analyzing and Exploiting Wearable Devices},
  author = {Kim, Dongkwan and Park, Suwan and Choi, Kibum and Kim, Yongdae},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {227-239},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-31875-2\_19},
  url = {https://doi.org/10.1007/978-3-319-31875-2\_19},
  abstract = {Wearable devices have recently become popular, and more and more people now buy and wear these devices to obtain health-related services. However, as wearable device technology quickly advances, its security cannot keep up with the speed of its development. As a result, it is highly likely for the devices to have severe vulnerabilities. Moreover, because these wearable devices are usually light-weight, they delegate a large portion of their operations as well as permissions to a software gateways on computers or smartphones, which put users at high risk if there are vulnerabilities in these gateways. In order to validate this claim, we analyzed three devices as a case study and found a total 17 vulnerabilities in them. We verified that an adversary can utilize these vulnerabilities to compromise the software gateway and take over a victim’s computers and smartphones. We also suggest possible mitigation to improve the security of wearable devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_51064_4_3,
  title = {Forensic Analysis of Secure Ephemeral Messaging Applications on Android Platforms},
  author = {Azhar, M. A. Hannan Bin and Barton, Thomas Edward Allen},
  booktitle = {Communications in Computer and Information Science},
  year = {2016},
  pages = {27-41},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-51064-4\_3},
  url = {https://doi.org/10.1007/978-3-319-51064-4\_3},
  abstract = {Secure messaging applications have been used for the purposes of major crime, creating the need for forensic research into the area. This paper forensically analyses two secure messaging applications, Wickr and Telegram, to recover artefacts from and then to compare them to reveal the differences between the applications. The artefacts were created on Android platforms by using the secure features of the applications, such as ephemeral messaging, the channel function and encrypted conversations. The results of the experiments documented in this paper give insight into the organisation of the data structures by both Wickr and Telegram, as well as the exploration of mobile digital forensics techniques to recover artefacts removed by the ephemeral functions.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11227_015_1559_9,
  title = {Anti-debugging scheme for protecting mobile apps on android platform},
  author = {Cho, Haehyun and Lim, Jongsu and Kim, Hyunki and Yi, Jeong Hyun},
  journal = {The Journal of Supercomputing},
  year = {2016},
  volume = {72},
  number = {1},
  pages = {232-246},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-015-1559-9},
  url = {https://doi.org/10.1007/s11227-015-1559-9},
  abstract = {The Android application package file, APK file, can be easily decompiled using Android reverse engineering tools. Thus, general apps can be easily transformed into malicious application through reverse engineering and analysis. These repacked apps could be uploaded in general android app market called Google Play Store and redistributed. To prevent theses malicious behaviors such as malicious code injection or code falsifications, many techniques and tools were developed. However, these techniques also can be analyzed using debuggers. Also, analyzed apps can be tampered easily. For example, when applying anti-analysis techniques to android apps using Dexprotector which is commercial tool for protecting android app, it can be seen that these techniques can also be analyzed using debugger. In this paper, to protect the android app from the attack using debugger, we propose anti-debugging techniques for native code debugging and managed code debugging of android apps.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_19066_2_40,
  title = {Mobile Application Recommendations Based on Complex Information},
  author = {Yang, Shuotao and Yu, Hong and Deng, Weiwei and Lai, Xiaochen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {415-424},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-19066-2\_40},
  url = {https://doi.org/10.1007/978-3-319-19066-2\_40},
  abstract = {Due to the huge and still rapidly growing number of mobile applications, it becomes necessary to provide users an application recommending service. In this work we present a recommendation system that recommends new applications for users according to their outdated applications. The recommender assumes that each owned application has complex information containing both descriptions and API information. The proposed approach mines application descriptions from publicly available online specifications and identifies APIs from the downloaded APK(Android PacKage) files. Text mining and incremental diffusive clustering(IDC) algorithm are utilized to generate common features. And APIs are extracted by disassembly technology. Then the complex information of applications can be represented by the features and APIs. In the processing of recommending, the k-Nearest-Neighbor algorithm based on the self-adaptive similarity(SS-KNN) is adopted to generate candidate sets of applications, and then the coverage-weighted similarity is utilized to select the final recommendations from the candidates. Extensive experiments are conducted on different application categories and the experimental results illustrate the effectiveness and efficiency of the approach.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_45931_8_13,
  title = {Fault-Channel Watermarks},
  author = {Samarin, Peter and Skripnik, Alexander and Lemke-Rust, Kerstin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {204-219},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-45931-8\_13},
  url = {https://doi.org/10.1007/978-3-319-45931-8\_13},
  abstract = {We introduce a new approach for securing intellectual property in embedded software implementations by using the response of an implementation to fault injections. In our approach, the implementation serves as its own watermark that is recorded through its fault effects. There is no additional code for the watermark. A simulator that maps the fault injections to the executed instructions aids an automated characterization of program code. We provide a proof-of-concept implementation of our watermarking approach using an 8-bit ATMega163 microcontroller and several assembly implementations of AES encryption. The results show that our method is well-suited for detection of identical software copies. In addition, our method shows robust performance in detection of software copies with a large number of added dummy instructions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_42092_9_12,
  title = {Software Architecture and Software Quality},
  author = {Žemlička, Michal and Král, Jaroslav},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {139-155},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-42092-9\_12},
  url = {https://doi.org/10.1007/978-3-319-42092-9\_12},
  abstract = {Software quality is a crucial but partly subjective concept. Assessment of quality of software systems is typically a two-stage process consisting of the evaluation od related quality aspects and assessment of the quality of the software. If the software architecture discussed in the paper is used, the evaluation of many commonly considered aspects is increased and therefore the assessment of the system quality is enhanced. We show that some known but neglected aspects as well as some new architecture related ones ought to be considered.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_14971_4_13,
  title = {Heterogeneous Architectures: Malware and Countermeasures},
  author = {Lombardi, Flavio and Di Pietro, Roberto},
  booktitle = {Secure System Design and Trustable Computing},
  year = {2016},
  pages = {421-438},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-14971-4\_13},
  url = {https://doi.org/10.1007/978-3-319-14971-4\_13},
  abstract = {Malware is becoming smarter and stealthier and it is increasingly widespread over a large number of heterogeneous platforms. Most often, malicious software is especially built for a given target environment as it leverages its peculiarities. However, many similarities exist among malicious approaches. Such common features can be used to prevent, detect and react to such threat. This chapter discusses the above introduced threat and shows how advanced virtualization technology (quite common on most multicore CPU architectures) can be of help in monitoring, analyzing and protecting heterogeneous software/hardware architectures from malware.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10515_015_0182_6,
  title = {Detecting plagiarized mobile apps using API birthmarks},
  author = {Kim, Daeyoung and Gokhale, Amruta and Ganapathy, Vinod and Srivastava, Abhinav},
  journal = {Automated Software Engineering},
  year = {2016},
  volume = {23},
  number = {4},
  pages = {591-618},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-015-0182-6},
  url = {https://doi.org/10.1007/s10515-015-0182-6},
  abstract = {This paper addresses the problem of detecting plagiarized mobile apps. Plagiarism is the practice of building mobile apps by reusing code from other apps without the consent of the corresponding app developers. Recent studies on third-party app markets have suggested that plagiarized apps are an important vehicle for malware delivery on mobile phones. Malware authors repackage official versions of apps with malicious functionality, and distribute them for free via these third-party app markets. An effective technique to detect app plagiarism can therefore help identify malicious apps. Code plagiarism has long been a problem and a number of code similarity detectors have been developed over the years to detect plagiarism. In this paper we show that obfuscation techniques can be used to easily defeat similarity detectors that rely solely on statically scanning the code of an app. We propose a dynamic technique to detect plagiarized apps that works by observing the interaction of an app with the underlying mobile platform via its API invocations. We propose API birthmarks to characterize unique app behaviors, and develop a robust plagiarism detection tool using API birthmarks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_20810_7_21,
  title = {FPGuard: Detection and Prevention of Browser Fingerprinting},
  author = {FaizKhademi, Amin and Zulkernine, Mohammad and Weldemariam, Komminist},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {293-308},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-20810-7\_21},
  url = {https://doi.org/10.1007/978-3-319-20810-7\_21},
  abstract = {Fingerprinting is an identification method used by enterprises to personalize services for their end-users and detect online fraud or by adversaries to launch targeted attacks. Various tools have been proposed to protect online users from undesired identification probes to enhance the privacy and security of the users. However, we have observed that new fingerprinting methods can easily evade the existing protection mechanisms. This paper presents a runtime fingerprinting detection and prevention approach, called FPGuard. FPGuard relies on the analysis of predefined metrics to identify fingerprinting attempts. While FPGuard’s detection capability is evaluated using the top 10,000 Alexa websites, its prevention mechanism is evaluated against four fingerprinting providers. Our evaluation results show that FPGuard can effectively recognize and mitigate fingerprinting-related activities and distinguish normal from abnormal webpages (or fingerprinters).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_48869_1_5,
  title = {Constructing Semantic Models of Programs with the Software Analysis Workbench},
  author = {Dockins, Robert and Foltzer, Adam and Hendrix, Joe and Huffman, Brian and McNamee, Dylan and Tomb, Aaron},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {56-72},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-48869-1\_5},
  url = {https://doi.org/10.1007/978-3-319-48869-1\_5},
  abstract = {The Software Analysis Workbench (SAW) is a system for translating programs into logical expressions, transforming these expressions, and using external reasoning tools (such as SAT and SMT solvers) to prove properties about them. In the implementation of this translation, SAW combines efficient symbolic execution techniques in a novel way. It has been used most extensively to prove that implementations of cryptographic algorithms are functionally equivalent to referencespecifications, but can also be used to identify inputs to programs that will lead to outputs with particular properties, and prove other properties about programs. In this paper, we describe the structure of the SAW system and present experimental results demonstrating the benefits of its implementation techniques.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_30004_7_2,
  title = {Memory Management},
  author = {Aycock, John},
  booktitle = {Retrogame Archeology},
  year = {2016},
  pages = {17-35},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-30004-7\_2},
  url = {https://doi.org/10.1007/978-3-319-30004-7\_2},
  abstract = {Not only do the memory management techniques used in retrogames underlie those seen in modern operating systems, but memory and its management continues to be an issue, like fitting data into caches and trading space for time.},
  content_type = {Chapter},
}


@article{springer_10_1186_s13173_015_0040_1,
  title = {Testing of aspect-oriented programs: difficulties and lessons learned based on theoretical and practical experience},
  author = {Ferrari, Fabiano C. and P. Cafeo, Bruno B. and Levin, Thiago G. and S. Lacerda, Jésus T. and L. Lemos, Otávio A. and C. Maldonado, José and Masiero, Paulo C.},
  journal = {Journal of the Brazilian Computer Society},
  year = {2015},
  volume = {21},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13173-015-0040-1},
  url = {https://doi.org/10.1186/s13173-015-0040-1},
  abstract = {Background Since the first discussions of new challenges posed by aspect-oriented programming (AOP) to software testing, the real difficulties of testing aspect-oriented (AO) programs have not been properly analysed. Firstly, despite the customisation of traditional testing techniques to the AOP context, the literature lacks discussions on how hard it is to apply them to (even ordinary) AO programs based on practical experience. Secondly, and equally important, due to the cautious AOP adoption focused on concern refactoring, test reuse is another relevant issue that has been overlooked so far. This paper deals with these two issues. It discusses the difficulties of testing AO programs from three perspectives: (i) structural-based testing, (ii) fault-based testing and (iii) test set reuse across paradigms. Methods Perspectives (i) and (ii) are addressed by means of a retrospective of research done by the authors’ group. We analyse the impact of using AOP mechanisms on the testability of programs in terms of the underlying test models, the derived test requirements and the coverage of such requirements. The discussion is based on our experience on developing and applying testing approaches and tools to AspectJ programs at both unit and integration levels. Perspective (iii), on the other hand, consists of recent exploratory studies that analyse the effort to adapt test sets for refactored systems and the quality of such test sets in terms of structural coverage. Results Building test models for AO programs imposes higher complexity when compared to the OO paradigm. Besides this, adapting test suites for OO programs to AO equivalent programs tends to require less effort than doing the other way around, and resulting suites achieve similar quality levels for small-sized aplications. Conclusions The conclusion is that building test models for AO programs, as well as deriving and covering paradigm-specific test requirements, is not straightforward as it has been for procedural and object-oriented (OO) programs at some extent. Once you have test suites in conformance with programs implemented in both paradigms, the quality of such suited in termos of code coverage may vary depending on the size and characteristics of the applications under testing.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_22906_5_8,
  title = {Protecting Android Apps Against Reverse Engineering by the Use of the Native Code},
  author = {Protsenko, Mykola and Müller, Tilo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {99-110},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-22906-5\_8},
  url = {https://doi.org/10.1007/978-3-319-22906-5\_8},
  abstract = {Having about 80 \% of the market share, Android is currently the clearly dominating platform for mobile devices. Application theft and repackaging remains a major threat and a cause of significant losses, affecting as much as 97 \% of popular paid apps. The ease of decompilation and reverse engineering of high-level bytecode, in contrast to native binary code, is considered one of the main reasons for the high piracy rate. In this paper, we address this problem by proposing four static obfuscation techniques: native opaque predicates , native control flow flattening , native function indirection , and native field access indirection . These techniques provide a simple and yet effective way of reducing the task of bytecode reverse engineering to the much harder task of reverse engineering native code. For this purpose, native function calls are injected into an app’s bytecode, introducing artificial dependencies between the two execution domains. The adversary is forced to analyze the native code in order to be able to comprehend the overall app’s functionality and to successfully launch static and dynamic analyses. Our evaluation results of the proposed protection methods witness an acceptable cost in terms of execution time and application size, while significantly complicating the reverse-engineering process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_46681_0_18,
  title = {Insight: An Open Binary Analysis Framework},
  author = {Fleury, Emmanuel and Ly, Olivier and Point, Gérald and Vincent, Aymeric},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {218-224},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-46681-0\_18},
  url = {https://doi.org/10.1007/978-3-662-46681-0\_18},
  abstract = {We present Insight , a framework for binary program analysis and two tools provided with it: CFGRecovery and iii. Insight is intended to be a full environment for analyzing, interacting and verifying executable programs. Insight is able to translate x86 , x86-64 and msp430 binary code to our intermediate representation and execute it symbolically in an abstract domain where each variable (register, memory cell) is substituted by a formula representing all its possible values along the current execution path. CFGRecovery aims at automatically rebuilding the program control flow based only on the executable file. It heavily relies on SMT solvers. iii provides an interactive and a (Python) programmable interface to a coherent set of features from the Insight framework. It behaves like a debugger except that the execution traces that are examined are symbolic and cover a collection of possible concrete executions at once. For example, iii allows to perform an interactive reconstruction of the CFG.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_016_9435_7,
  title = {An empirical study of emergency updates for top android mobile apps},
  author = {Hassan, Safwat and Shang, Weiyi and Hassan, Ahmed E.},
  journal = {Empirical Software Engineering},
  year = {2017},
  volume = {22},
  number = {1},
  pages = {505-546},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-016-9435-7},
  url = {https://doi.org/10.1007/s10664-016-9435-7},
  abstract = {The mobile app market continues to grow at a tremendous rate. The market provides a convenient and efficient distribution mechanism for updating apps. App developers continuously leverage such mechanism to update their apps at a rapid pace. The mechanism is ideal for publishing emergency updates (i.e., updates that are published soon after the previous update). In this paper, we study such emergency updates in the Google Play Store. Examining more than 44,000 updates of over 10,000 mobile apps in the Google Play Store, we identify 1,000 emergency updates. By studying the characteristics of such emergency updates, we find that the emergency updates often have a long lifetime (i.e., they are rarely followed by another emergency update). Updates preceding emergency updates often receive a higher ratio of negative reviews than the emergency updates. However, the release notes of emergency updates rarely indicate the rationale for such updates. Hence, we manually investigate the binary changes of several of these emergency updates. We find eight patterns of emergency updates. We categorize these eight patterns along two categories “Updates due to deployment issues” and “Updates due to source code changes”. We find that these identified patterns of emergency updates are often associated with simple mistakes, such as using a wrong resource folder (e.g., images or sounds) for an app. We manually examine each pattern and document its causes and impact on the user experience. App developers should carefully avoid these patterns in order to improve the user experience.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_29613_5_12,
  title = {AUSPICE: Automatic Safety Property Verification for Unmodified Executables},
  author = {Tan, Jiaqi and Tay, Hui Jun and Gandhi, Rajeev and Narasimhan, Priya},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {202-222},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-29613-5\_12},
  url = {https://doi.org/10.1007/978-3-319-29613-5\_12},
  abstract = {Verification of machine-code programs using program logic has focused on functional correctness, and proofs have required manually-provided program specifications. Fortunately, the verification of shallow safety properties such as memory isolation and control-flow safety can be easier to automate, but past techniques for automatically verifying machine-code safety have required post-compilation transformations, which can change program behavior. In this work, we automatically verify safety properties for unmodified machine-code programs without requiring user-supplied specifications. Our novel logic framework, AUSPICE, for automatic safety property verification for unmodified executables, extends an existing trustworthy Hoare logic for local reasoning, and provides a novel proof tactic for selective composition. We demonstrate our automated proof technique on synthetic and realistic programs. Our verification completes in 6 h for a realistic 533-instruction string search algorithm, demonstrating the feasibility of our approach.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_2181_5_1,
  title = {Hardware and Software},
  author = {Di Cataldo, Giuseppe},
  booktitle = {Stack Frames},
  year = {2016},
  pages = {1-19},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2181-5\_1},
  url = {https://doi.org/10.1007/978-1-4842-2181-5\_1},
  abstract = {This chapter reviews for the reader some basic concepts and focuses on a few topics to provide a better understanding of some of the terms used in the following chapters. All of this should be cultural background you’ve already acquired, since the reader is expected to bring a working knowledge of C and Unix to this book, so there is no need to discuss the topics more deeply. However, two subjects—file and software types—need a more in-depth discussion and a clear definition, as they may lead to some confusion.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_23802_9_32,
  title = {How We Found These Vulnerabilities in Android Applications},
  author = {Ma, Bin},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2015},
  pages = {399-406},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-23802-9\_32},
  url = {https://doi.org/10.1007/978-3-319-23802-9\_32},
  abstract = {With the rapid growth of application markets, many developers now spend their time and money to develop new smartphone applications, bringing ever more intelligent applications to smartphone users. However, the rapid development process of applications without full testing made them neglect the security of the applications. In this paper, I took UC Browser and Mobile QQ as examples to show some vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_53887_6_5,
  title = {Towards Practical Whitebox Cryptography: Optimizing Efficiency and Space Hardness},
  author = {Bogdanov, Andrey and Isobe, Takanori and Tischhauser, Elmar},
  booktitle = {Lecture Notes in Computer Science},
  year = {2016},
  pages = {126-158},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-53887-6\_5},
  url = {https://doi.org/10.1007/978-3-662-53887-6\_5},
  abstract = {Whitebox cryptography aims to provide security for cryptographic algorithms in an untrusted environment where the adversary has full access to their implementation. Typical security goals for whitebox cryptography include key extraction security and decomposition security : Indeed, it should be infeasible to recover the secret key from the implementation and it should be hard to decompose the implementation by finding a more compact representation without recovering the secret key, which mitigates code lifting. Whereas all published whitebox implementations for standard cryptographic algorithms such as DES or AES are prone to practical key extraction attacks, there have been two dedicated design approaches for whitebox block ciphers: ASASA by Birykov et al. at ASIACRYPT’14 and SPACE by Bogdanov and Isobe at CCS’15. While ASASA suffers from decomposition attacks, SPACE reduces the security against key extraction and decomposition attacks in the white box to the security of a standard block cipher such as AES in the standard blackbox setting. However, due to the security-prioritized design strategy, SPACE imposes a sometimes prohibitive performance overhead in the real world as it needs many AES calls to encrypt a single block. In this paper, we address the issue by designing a family of dedicated whitebox block ciphers SPNbox and a family of underlying small block ciphers with software efficiency and constant-time execution in mind. While still relying on the standard blackbox block cipher security for the resistance against key extraction and decomposition, SPNbox attains speed-ups of up to 6.5 times in the black box and up to 18 times in the white box on Intel Skylake and ARMv8 CPUs, compared to SPACE . The designs allow for constant-time implementations in the blackbox setting and meet the practical requirements to whitebox cryptography in real-world applications such as DRM or mobile payments. Moreover, we formalize resistance towards decomposition in form of weak and strong space hardness at various security levels. We obtain bounds on space hardness in all those adversarial models. Thus, for the first time, SPNbox provides a practical whitebox block cipher that features well-understood key extraction security, rigorous analysis towards decomposition security, demonstrated real-world efficiency on various platforms and constant-time implementations. This paves the way to enhancing susceptible real-world applications with whitebox cryptography.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_014_9321_0,
  title = {A large study on the effect of code obfuscation on the quality of java code},
  author = {Ceccato, Mariano and Capiluppi, Andrea and Falcarin, Paolo and Boldyreff, Cornelia},
  journal = {Empirical Software Engineering},
  year = {2015},
  volume = {20},
  number = {6},
  pages = {1486-1524},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-014-9321-0},
  url = {https://doi.org/10.1007/s10664-014-9321-0},
  abstract = {Context : Obfuscation is a common technique used to protect software against malicious reverse engineering. Obfuscators manipulate the source code to make it harder to analyze and more difficult to understand for the attacker. Although different obfuscation algorithms and implementations are available, they have never been directly compared in a large scale study. Aim : This paper aims at evaluating and quantifying the effect of several different obfuscation implementations (both open source and commercial), to help developers and project managers to decide which algorithms to use. Method : In this study we applied 44 obfuscations to 18 subject applications covering a total of 4 millions lines of code. The effectiveness of these source code obfuscations has been measured using 10 code metrics, considering modularity, size and complexity of code. Results : Results show that some of the considered obfuscations are effective in making code metrics change substantially from original to obfuscated code, although this change (called potency of the obfuscation) is different on different metrics. In the paper we recommend which obfuscations to select, given the security requirements of the software to be protected.},
  content_type = {Article},
}


@article{springer_10_1007_s00165_016_0357_3,
  title = {Partial evaluation of string obfuscations for Java malware detection},
  author = {Chawdhary, Aziem and Singh, Ranjeet and King, Andy},
  journal = {Formal Aspects of Computing},
  year = {2017},
  volume = {29},
  number = {1},
  pages = {33-55},
  publisher = {Association for Computing Machinery (ACM)},
  doi = {10.1007/s00165-016-0357-3},
  url = {https://doi.org/10.1007/s00165-016-0357-3},
  abstract = {Abstract The fact that Java is platform independent gives hackers the opportunity to write exploits that can target users on any platform, which has a JVM implementation. Metasploit is a well-known source of Java exploits and to circumvent detection by anti virus (AV) software, obfuscation techniques are routinely applied to make an exploit more difficult to recognise. Popular obfuscation techniques for Java include string obfuscation and applying reflection to hide method calls; two techniques that can either be used together or independently. This paper shows how to apply partial evaluation to remove these obfuscations and thereby improve AV matching. The paper presents a partial evaluator for Jimple, which is an intermediate language for JVM bytecode designed for optimisation and program analysis, and demonstrates how partially evaluated Jimple code, when transformed back into Java, improves the detection rates of a number of commercial AV products.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_26362_5_17,
  title = {AppSpear: Bytecode Decrypting and DEX Reassembling for Packed Android Malware},
  author = {Yang, Wenbo and Zhang, Yuanyuan and Li, Juanru and Shu, Junliang and Li, Bodong and Hu, Wenjun and Gu, Dawu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {359-381},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-26362-5\_17},
  url = {https://doi.org/10.1007/978-3-319-26362-5\_17},
  abstract = {As the techniques for Android malware detection are progressing, malware also fights back through deploying advanced code encryption with the help of Android packers. An effective Android malware detection therefore must take the unpacking issue into consideration to prove the accuracy. Unfortunately, this issue is not easily addressed. Android packers often adopt multiple complex anti-analysis defenses and are evolving frequently. Current unpacking approaches are either based on manual efforts, which are slow and tedious, or based on coarse-grained memory dumping, which are susceptible to a variety of anti-monitoring defenses. This paper conducts a systematic study on existing Android malware which is packed. A thorough investigation on 37,688 Android malware samples is conducted to take statistics of how widespread are those samples protected by Android packers. The anti-analysis techniques of related commercial Android packers are also summarized. Then, we propose AppSpear, a generic and fine-grained system for automatically malware unpacking. Its core technique is a bytecode decrypting and Dalvik executable (DEX) reassembling method, which is able to recover any protected bytecode effectively without the knowledge of the packer. AppSpear directly instruments the Dalvik VM to collect the decrypted bytecode information from the Dalvik Data Struct (DDS), and performs the unpacking by conducting a refined reassembling process to create a new DEX file. The unpacked app is then available for being analyzed by common program analysis tools or malware detection systems. Our experimental evaluation shows that AppSpear could sanitize mainstream Android packers and help detect more malicious behaviors. To the best of our knowledge, AppSpear is the first automatic and generic unpacking system for current commercial Android packers.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10817_016_9377_1,
  title = {A Fully Automatic Theorem Prover with Human-Style Output},
  author = {Ganesalingam, M. and Gowers, W. T.},
  journal = {Journal of Automated Reasoning},
  year = {2017},
  volume = {58},
  number = {2},
  pages = {253-291},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10817-016-9377-1},
  url = {https://doi.org/10.1007/s10817-016-9377-1},
  abstract = {This paper describes a program that solves elementary mathematical problems, mostly in metric space theory, and presents solutions that are hard to distinguish from solutions that might be written by human mathematicians.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_2319_2_6,
  title = {Mapping with Annotations},
  author = {Ottinger, Joseph B. and Linwood, Jeff and Minter, Dave},
  booktitle = {Beginning Hibernate},
  year = {2016},
  pages = {79-113},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-2319-2\_6},
  url = {https://doi.org/10.1007/978-1-4842-2319-2\_6},
  abstract = {Mappings can be created in two different ways: via inline annotations (as we’ve done through the book so far), or as separate XML files in one of two primary formats.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_12295_3_10,
  title = {Conclusion},
  author = {Fong, Joseph Shi Piu},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2015},
  pages = {377-383},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-12295-3\_10},
  url = {https://doi.org/10.1007/978-3-319-12295-3\_10},
  abstract = {As computer technologies evolve, it becomes a necessity for companies to upgrade their information systems. The objective of reengineering is to protect their huge investments and to maintain their competitive edge. However, information systems reengineering is a complicated task that requires much expertise and knowledge. It needs users’ input to recover lost semantics inside the existing database system and/or the existing expert system. It also requires technical expertise to replace the obsolete information systems with newer systems. Very often, due to lack of methodologies and expertise, companies choose to redevelop rather than reengineer when upgrading their information systems. The purpose of this book is to convince these companies that reengineering is a more cost-effective and feasible solution.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_12295_3_1,
  title = {Information Systems Reengineering, Integration and Normalization},
  author = {Fong, Joseph Shi Piu},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2015},
  pages = {1-29},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-12295-3\_1},
  url = {https://doi.org/10.1007/978-3-319-12295-3\_1},
  abstract = {The primary goal of electronic data processing (EDP) in the 1960s and 1970s was the automation of existing business operations in organizations. However, except for the quick availability of more accurate management reporting information, such operations were automated without fundamental changes. During these two decades, data was stored in flat file formats that could be classified into two different forms, namely batch files and online files.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11277_013_1258_x,
  title = {Repackaging Attack on Android Banking Applications and Its Countermeasures},
  author = {Jung, Jin-Hyuk and Kim, Ju Young and Lee, Hyeong-Chan and Yi, Jeong Hyun},
  journal = {Wireless Personal Communications},
  year = {2013},
  volume = {73},
  number = {4},
  pages = {1421-1437},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11277-013-1258-x},
  url = {https://doi.org/10.1007/s11277-013-1258-x},
  abstract = {Although anyone can easily publish Android applications (or apps) in an app marketplace according to an open policy, decompiling the apps is also easy due to the structural characteristics of the app building process, making them very vulnerable to forgery or modification attacks. In particular, users may suffer direct financial loss if this vulnerability is exploited in security-critical private and business applications, such as online banking. In this paper, some of the major Android-based smartphone banking apps in Korea being distributed on either the Android Market or the third party market were tested to verify whether a money transfer could be made to an unintended recipient. The experimental results with real Android banking apps showed that an attack of this kind is possible without having to illegally obtain any of the sender’s personal information, such as the senders public key certificate, the password to their bank account, or their security card. In addition, the cause of this vulnerability is analyzed and some technical countermeasures are discussed.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_1317_9_18,
  title = {Security},
  author = {Jiang, Liangjun},
  booktitle = {iOS eCommerce App Development with Parse},
  year = {2015},
  pages = {185-190},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1317-9\_18},
  url = {https://doi.org/10.1007/978-1-4842-1317-9\_18},
  abstract = {So far, I have discussed all of the features for an e-commerce iPhone app that I want to talk about except one: how secure the implementation is, or how safe it is to use Parse. I will use this chapter to cover the Parse security features and how you could follow some industry-standard best practices to make this iPhone app more secure.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_13257_0_24,
  title = {“To Share or not to Share” in Client-Side Encrypted Clouds},
  author = {Wilson, Duane C. and Ateniese, Giuseppe},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {401-412},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-13257-0\_24},
  url = {https://doi.org/10.1007/978-3-319-13257-0\_24},
  abstract = {With the advent of cloud computing, a number of cloud providers have arisen to provide Storage-as-a-Service (SaaS) offerings to both regular consumers and business organizations. SaaS (different than Software-as-a-Service in this context) refers to an architectural model in which a cloud provider provides digital storage on their own infrastructure. Three models exist amongst SaaS providers for protecting the confidentiality of data stored in the cloud: 1) no encryption (data is stored in plain text), 2) server-side encryption (data is encrypted once uploaded), and 3) client-side encryption (data is encrypted prior to upload). Through a combination of a Network and Source Code Analysis, this paper seeks to identify weaknesses in the third model, as it claims to offer 100\% user data confidentiality throughout all data transactions. The weaknesses we uncovered primarily center around the fact that the cloud providers we evaluated (Wuala, Tresorit, and Spider Oak) were each operating in a Certificate Authority capacity to facilitate data sharing. In this capacity, they assume the role of both certificate issuer and certificate authorizer as denoted in a Public-Key Infrastructure (PKI) scheme - which gives them the ability to view user data contradicting their claims of 100\% data confidentiality. We have collated our analysis and findings in this paper and explore some potential solutions to address these weaknesses in these sharing methods. The solutions proposed are a combination of best practices associated with the use of PKI and other cryptographic primitives generally accepted for protecting the confidentiality of shared information.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_46681_0_19,
  title = {SAM: The Static Analysis Module of the MAVERIC Mobile App Security Verification Platform},
  author = {Armando, Alessandro and Bocci, Gianluca and Chiarelli, Giantonio and Costa, Gabriele and De Maglie, Gabriele and Mammoliti, Rocco and Merlo, Alessio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {225-230},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-46681-0\_19},
  url = {https://doi.org/10.1007/978-3-662-46681-0\_19},
  abstract = {The tremendous success of the mobile application paradigm is due to the ease with which new applications are uploaded by developers, distributed through the application markets (e.g. Google Play), and finally installed by the users. Yet, the very same model is causing serious security concerns, since users have no or little means to ascertain the trustworthiness of the applications they install on their devices. To protect their customers, Poste Italiane has defined the Mobile Application Verification Cluster (MAVERIC), a process for the systematic security analysis of third-party mobile apps that leverage the online services provided by the company (e.g. home banking, parcel tracking). We present SAM, a toolkit that supports this process by automating a number of operations including reverse engineering, privilege analysis, and automatic verification of security properties. We introduce the functionalities of SAM through a demonstration of the platform applied to real Android applications.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00170_015_7339_0,
  title = {Automation in construction scheduling: a review of the literature},
  author = {Faghihi, Vahid and Nejat, Ali and Reinschmidt, Kenneth F. and Kang, Julian H.},
  journal = {The International Journal of Advanced Manufacturing Technology},
  year = {2015},
  volume = {81},
  number = {9-12},
  pages = {1845-1856},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00170-015-7339-0},
  url = {https://doi.org/10.1007/s00170-015-7339-0},
  abstract = {Automating the development of construction schedules has been an interesting topic for researchers around the world for almost three decades. Researchers have approached solving scheduling problems with different tools and techniques. Whenever a new artificial intelligence or optimization tool has been introduced, researchers in the construction field have tried to use it to find the answer to one of their key problems—the “better” construction schedule. Each researcher defines this “better” slightly different. This article reviews the research on automation in construction scheduling from 1985 to 2014. It also covers the topic using different approaches, including case-based reasoning, knowledge-based approaches, model-based approaches, genetic algorithms, expert systems, neural networks, and other methods. The synthesis of the results highlights the share of the aforementioned methods in tackling the scheduling challenge, with genetic algorithms shown to be the most dominant approach. Although the synthesis reveals the high applicability of genetic algorithms to the different aspects of managing a project, including schedule, cost, and quality, it exposed a more limited project management application for the other methods.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_26096_9_13,
  title = {The Lifetime of Android API Vulnerabilities: Case Study on the JavaScript-to-Java Interface},
  author = {Thomas, Daniel R. and Beresford, Alastair R. and Coudray, Thomas and Sutcliffe, Tom and Taylor, Adrian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {126-138},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-26096-9\_13},
  url = {https://doi.org/10.1007/978-3-319-26096-9\_13},
  abstract = {We examine the lifetime of API vulnerabilities on Android and propose an exponential decay model of the uptake of updates after the release of a fix. We apply our model to a case study of the JavaScript-to-Java interface vulnerability. This vulnerability allows untrusted JavaScript in a WebView to break out of the JavaScript sandbox allowing remote code execution on Android phones; this can often then be further exploited to gain root access. While this vulnerability was first publicly disclosed in December 2012, we predict that the fix will not have been deployed to 95\% of devices until December 2017, 5.17 years after the release of the fix. We show how this vulnerability is exploitable in many apps and the role that ad-libraries have in making this flaw so widespread.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_015_9403_7,
  title = {Game of detections: how are security vulnerabilities discovered in the wild?},
  author = {Hafiz, Munawar and Fang, Ming},
  journal = {Empirical Software Engineering},
  year = {2016},
  volume = {21},
  number = {5},
  pages = {1920-1959},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-015-9403-7},
  url = {https://doi.org/10.1007/s10664-015-9403-7},
  abstract = {There is little or no information available on what actually happens when a software vulnerability is detected. We performed an empirical study on reporters of the three most prominent security vulnerabilities: buffer overflow, SQL injection, and cross site scripting vulnerabilities. The goal was to understand the methods and tools used during the discovery and whether the community of developers exploring one security vulnerability differs—in their approach—from another community of developers exploring a different vulnerability. The reporters were featured in the SecurityFocus repository for twelve month periods for each vulnerability. We collected 127 responses. We found that the communities differ based on the security vulnerability they target; but within a specific community, reporters follow similar approaches. We also found a serious problem in the vulnerability reporting process that is common for all communities. Most reporters, especially the experienced ones, favor full-disclosure and do not collaborate with the vendors of vulnerable software. They think that the public disclosure, sometimes supported by a detailed exploit, will put pressure on vendors to fix the vulnerabilities. But, in practice, the vulnerabilities not reported to vendors are less likely to be fixed. Ours is the first study on vulnerability repositories that targets the reporters of the most common security vulnerabilities, thus concentrating on the people involved in the process; previous works have overlooked this rich information source. The results are valuable for beginners exploring how to detect and report security vulnerabilities and for tool vendors and researchers exploring how to automate and fix the process.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_15087_1_8,
  title = {Analyzing Security of Korean USIM-Based PKI Certificate Service},
  author = {Park, Shinjo and Park, Suwan and Yun, Insu and Kim, Dongkwan and Kim, Yongdae},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {95-106},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-15087-1\_8},
  url = {https://doi.org/10.1007/978-3-319-15087-1\_8},
  abstract = {This paper analyzes security of Korean USIM-based PKI certificate service. Korean PKI certificate consists of public key and password encrypted private key on disk. Due to insufficient security provided by single password, Korean mobile operators introduced USIM-based PKI system. We found several vulnerabilities inside the system, including private key’s RSA prime number leakage during certificate installation. We also suggest possible improvments on designing secure authentication system (Preliminary work of this paper was published previously [ 1 ]. This work was responsibly disclosed to the vendor and associated government organizations.).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_27161_3_33,
  title = {Streaming Computing Technology for Android Applications: Design Model and Case Study},
  author = {Mo, Binji and Xu, Yang and Wang, Guojun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {370-381},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-27161-3\_33},
  url = {https://doi.org/10.1007/978-3-319-27161-3\_33},
  abstract = {Android is a mobile operating system released by Google on 2007, which has got strong support from major mobile phone manufacturers and became one of the most popular mobile operating systems quickly. However, the applications which increase explosively occupy a large amount of storage resources and make serious limitation on device’s resources. Moreover, the frequent updating operation of the applications damages the user experience. We propose a new kind of mobile application model named Streaming Application Model based on the concept of Transparent Computing. By modularizing the ordinary application into some independent components and the devices load and launch the components dynamically, we can reduce the consumption of hardware resources and keep the users away from the complex and frequent application update processes, thus improving the user experience of Android devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_28865_9_14,
  title = {Uranine: Real-time Privacy Leakage Monitoring without System Modification for Android},
  author = {Rastogi, Vaibhav and Qu, Zhengyang and McClurg, Jedidiah and Cao, Yinzhi and Chen, Yan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2015},
  pages = {256-276},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-28865-9\_14},
  url = {https://doi.org/10.1007/978-3-319-28865-9\_14},
  abstract = {Mobile devices are becoming increasingly popular. One reason for their popularity is the availability of a wide range of third-party applications, which enrich the environment and increase usability. There are however privacy concerns centered around these applications – users do not know what private data is leaked by the applications. Previous works to detect privacy leakages are either not accurate enough or require operating system changes, which may not be possible due to users’ lack of skills or locked devices. We present Uranine (Uranine is a dye, which finds applications as a flow tracer in medicine and environmental studies.), a system that instruments Android applications to detect privacy leakages in real-time. Uranine does not require any platform modification nor does it need the application source code. We designed several mechanisms to overcome the challenges of tracking information flow across framework code, handling callback functions, and expressing all information-flow tracking at the bytecode level. Our evaluation of Uranine shows that it is accurate at detecting privacy leaks and has acceptable performance overhead.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_17822_6_8,
  title = {Partial Evaluation for Java Malware Detection},
  author = {Singh, Ranjeet and King, Andy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {133-147},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-17822-6\_8},
  url = {https://doi.org/10.1007/978-3-319-17822-6\_8},
  abstract = {The fact that Java is platform independent gives hackers the opportunity to write exploits that can target users on any platform, which has a JVM implementation. To circumvent detection by anti-virus (AV) software, obfuscation techniques are routinely applied to make an exploit more difficult to recognise. Popular obfuscation techniques for Java include string obfuscation and applying reflection to hide method calls; two techniques that can either be used together or independently. This paper shows how to apply partial evaluation to remove these obfuscations and thereby improve AV matching. The paper presents a partial evaluator for Jimple, which is a typed three-address code suitable for optimisation and program analysis, and also demonstrates how the residual Jimple code, when transformed back into Java, improves the detection rates of a number of commercial AV products.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_22689_7_10,
  title = {Processor Rescue},
  author = {Breuer, Peter T. and Bowen, Jonathan P. and Pickin, Simon},
  booktitle = {Communications in Computer and Information Science},
  year = {2015},
  pages = {137-148},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-22689-7\_10},
  url = {https://doi.org/10.1007/978-3-319-22689-7\_10},
  abstract = {What happens if a Mars lander takes a cosmic ray through the processor and thereafter \\(1\\,\\mathtt\{+ \}\\,1=3\\) ? Coping with the fault is feasible but requires the numbers 2 and 3 to be treated as indistinguishable for the purposes of arithmetic, while as memory addresses they continue to access different memory cells. If a program is to run correctly in this altered environment it must be prepared to see address 2 sporadically access data in memory cell 3, which is known as ‘hardware aliasing’. This paper describes a programming discipline that allows software to run correctly in a hardware aliasing context, provided the aliasing is underpinned by hidden determinism.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_0457_3_10,
  title = {Malware and Persistence},
  author = {O’Leary, Mike},
  booktitle = {Cyber Operations},
  year = {2015},
  pages = {367-410},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-0457-3\_10},
  url = {https://doi.org/10.1007/978-1-4842-0457-3\_10},
  abstract = {Chapter 2 shows how attackers can use browsers and software that provide active content for browsers such as Java and Adobe Flash as vectors to get an initial foothold in a network. Another option is malware. Malicious documents, like Word documents, can be used to provide an attacker with an initial shell on a target system.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_27161_3_14,
  title = {Characterization of Android Applications with Root Exploit by Using Static Feature Analysis},
  author = {Hao, Huikang and Li, Zhoujun and He, Yueying and Ma, Jinxin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {153-165},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-27161-3\_14},
  url = {https://doi.org/10.1007/978-3-319-27161-3\_14},
  abstract = {Recently, more and more rootkit tools are provided by some well-known vendors in the mainstream Android markets. Many people are willing to root their phones to uninstall pre-installed applications, flash third-party ROMs and so on. As it is reported, a significant proportion of Android phones are rooted at least one time. However, applications with root exploit bring critical security threat to users. When the phone is rooted, the permission system, which enforces access control to those privacy-related resources in Android phones, could be bypassed. Thus, the phone will be an easy point for malware to launch attacks. What’s more, even the phone is unrooted, permission escalation attacks also can be carried out. Remarkably, an amount of sophisticated Android malware embeds root exploit payloads. Hence, root exploit always suggests high security risk. It is a pressing concern for researchers to characterize and detect applications with root exploit. In this paper, a novel method to extract key features of apps with root exploit is proposed. Contrary to existing works, contrasting the static features between applications with and without root exploit comprehensively are considered at the first time. We complete and evaluate the methodology on two clean apps and two malware dataset, comprising 52, 1859, 463 and 797 applications respectively. Our empirical results suggest the peculiar features can be obtained, which can capture the key differences between applications with and without root exploit to characterize Android root exploit applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_17533_1_26,
  title = {IVDroid: Static Detection for Input Validation Vulnerability in Android Inter-component Communication},
  author = {Fang, Zhejun and Liu, Qixu and Zhang, Yuqing and Wang, Kai and Wang, Zhiqiang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2015},
  pages = {378-392},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-17533-1\_26},
  url = {https://doi.org/10.1007/978-3-319-17533-1\_26},
  abstract = {Input validation vulnerability in Android inter-component communication is a kind of severe vulnerabilities in Android apps. Malicious attacks can exploit the vulnerability to bypass Android security mechanism and compromise the integrity, confidentiality and availability of Android devices. However, so far there is not a sound approach at source code level designed for app developers to detect such vulnerabilities. In this paper we propose a novel approach aiming at detecting input validation flaws in Android apps and implement a prototype named IVDroid, which provides practical static analysis of Java source code. IVDroid leverages backward program slicing to abstract application logic from Java source code. On slice level, IVDroid detects flaws of known pattern by security rule matching and detects flaws of unknown pattern by duplicate validation behavior mining. Then IVDroid semi-automatically confirms the suspicious rule violations and report the confirmed ones as vulnerabilities. We evaluate IVDroid on 3 versions of Android spanning from version 2.2 to 4.4.2 and it detects 37 vulnerabilities including confused deputy and denial of service attack. Our results prove that IVDroid can provide a practical defence solution for app developers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_25546_0_2,
  title = {Background and Evolution of Code-Reuse Attacks},
  author = {Davi, Lucas and Sadeghi, Ahmad-Reza},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2015},
  pages = {7-25},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-25546-0\_2},
  url = {https://doi.org/10.1007/978-3-319-25546-0\_2},
  abstract = {In general, control-flow attacks allow an adversary to subvert the intended execution-flow of a program by exploiting a program error. For instance, a buffer overflow error can be exploited to write data beyond the boundaries of the buffer. As a consequence, an adversary can overwrite critical control-flow information which is located close to the buffer. Since control-flow information guide the program’s execution-flow, an adversary can thereby trigger malicious and unintended program actions such as installing a backdoor, injecting a malware, or accessing sensitive data.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_662_49004_4_5,
  title = {Generation of the Model Equations and Their Solution},
  author = {Damić, Vjekoslav and Montgomery, John},
  booktitle = {Mechatronics by Bond Graphs},
  year = {2015},
  pages = {157-190},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-49004-4\_5},
  url = {https://doi.org/10.1007/978-3-662-49004-4\_5},
  abstract = {In the previous chapters the systematic component-based approach was developed that enables development of mechatronic system models in a formal way. An important part of this is the description of the element constitutive relation symbolically using a relatively simple language.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_23802_9_18,
  title = {A Survey on Mining Program-Graph Features for Malware Analysis},
  author = {Islam, Md. Saiful and Islam, Md. Rafiqul and Kayes, A. S. M. and Liu, Chengfei and Altas, Irfan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2015},
  pages = {220-236},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-23802-9\_18},
  url = {https://doi.org/10.1007/978-3-319-23802-9\_18},
  abstract = {Malware, which is a malevolent software, mostly programmed by attackers for either disrupting the normal computer operation or gaining access to private computer systems. A malware detector determines the malicious intent of a program and thereafter, stops executing the program if the program is malicious. While a substantial number of various malware detection techniques based on static and dynamic analysis has been studied for decades, malware detection based on mining program graph features has attracted recent attention. It is commonly believed that graph based representation of a program is a natural way to understand its semantics and thereby, unveil its execution intent. This paper presents a state of the art survey on mining program-graph features for malware detection. We have also outlined the challenges of malware detection based on mining program graph features for its successful deployment, and opportunities that can be explored in the future.},
  content_type = {Conference paper},
}


@article{springer_10_1134_s0361768814050077,
  title = {Methods and software tools to support combined binary code analysis},
  author = {Padaryan, V. A. and Getman, A. I. and Solovyev, M. A. and Bakulin, M. G. and Borzilov, A. I. and Kaushan, V. V. and Ledovskikh, I. N. and Markin, Yu. V. and Panasenko, S. S.},
  journal = {Programming and Computer Software},
  year = {2014},
  volume = {40},
  number = {5},
  pages = {276-287},
  publisher = {Pleiades Publishing Ltd},
  doi = {10.1134/s0361768814050077},
  url = {https://doi.org/10.1134/s0361768814050077},
  abstract = {Methods and tools for binary code analysis developed in the Institute of System Programming, Russian Academy of Sciences, and their applications in algorithm and data format recovery are considered. The executable code of various general-purpose CPU architectures is analyzed. The analysis is performed given no source codes, debugging information, and specific OS version requirements. The approach implies collecting a detailed machine instruction level execution trace; a method for successively increasing presentation level; extraction of algorithm’s code followed by structuring of both code and data formats it processes. Important results are obtained, viz. an intermediate representation is developed that allows carrying out most preliminary processing tasks and algorithm code extraction without having to focus on specifics of a given machine; and a method and software tool are developed for automated recovery of network message and file formats. The tools are integrated into the unified analysis platform that supports their combined use. The architecture behind the platform is also described. Examples of its application to real programs are given.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_0232_6_3,
  title = {Object Orientation in Scala},
  author = {Layka, Vishal and Pollak, David},
  booktitle = {Beginning Scala},
  year = {2015},
  pages = {33-55},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-0232-6\_3},
  url = {https://doi.org/10.1007/978-1-4842-0232-6\_3},
  abstract = {The essence of OOP is modelling abstractions for handling complexities in software development, by means of classes and objects. Finding right abstractions, however, remains an arduous quest. An object in software is an abstraction of a real-world object, comprising essential properties and behaviors that set it apart from other objects. OOP is successful because object-oriented languages implement a number of principles such as encapsulation, inheritance, and polymorphism that make the software design and construction process much simpler and elegant when compared to other antiquated approaches. To illustrate these principles we concoct an abstraction with the aid of a classic example of shapes:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_54807_9_4,
  title = {Recovery of Class Hierarchies and Composition Relationships from Machine Code},
  author = {Srinivasan, Venkatesh and Reps, Thomas},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {61-84},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-54807-9\_4},
  url = {https://doi.org/10.1007/978-3-642-54807-9\_4},
  abstract = {We present a reverse-engineering tool, called Lego, which recovers class hierarchies and composition relationships from stripped binaries. Lego takes a stripped binary as input, and uses information obtained from dynamic analysis to (i) group the functions in the binary into classes, and (ii) identify inheritance and composition relationships between the inferred classes. The software artifacts recovered by Lego can be subsequently used to understand the object-oriented design of software systems that lack documentation and source code, e.g., to enable interoperability. Our experiments show that the class hierarchies recovered by Lego have a high degree of agreement—measured in terms of precision and recall—with the hierarchy defined in the source code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_6823_9_9,
  title = {Extending Visual Studio},
  author = {Desjardins, Patrick},
  booktitle = {Visual Studio Condensed},
  year = {2014},
  pages = {207-225},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6823-9\_9},
  url = {https://doi.org/10.1007/978-1-4302-6823-9\_9},
  abstract = {This last chapter covers advanced topics that you may not use at first. However, as you work with Visual Studio, you will stumble into some situations where it does not do exactly what you want. Fortunately, Microsoft and Visual Studio do a great job of allowing you to customize their tools.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_06776_6_43,
  title = {Scala \& Java Interoperability},
  author = {Hunt, John},
  booktitle = {A Beginner's Guide to Scala, Object Orientation and Functional Programming},
  year = {2014},
  pages = {479-494},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-06776-6\_43},
  url = {https://doi.org/10.1007/978-3-319-06776-6\_43},
  abstract = {In this chapter we will look at the interoperation of Java and Scala. Both Java and Scala are JVM Byte Code Languages. That is, they both compile to the byte code language that is understood by the JVM. The Byte Code language of the JVM was originally designed to be the compiled form of Java and was what the Java Virtual Machine executed. However, things have evolved such that today the JVM is a virtual environment for executing Byte Code languages. In fact there are now several languages that can be compiled to JVM Byte Codes including Java, Groovy, Clojure, Jruby, Jython, JavaScript, Ada, Pascal as well as Scala.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_03545_1_5,
  title = {Proof Pearl: A Verified Bignum Implementation in x86-64 Machine Code},
  author = {Myreen, Magnus O. and Curello, Gregorio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {66-81},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-03545-1\_5},
  url = {https://doi.org/10.1007/978-3-319-03545-1\_5},
  abstract = {Verification of machine code can easily deteriorate into an endless clutter of low-level details. This paper presents a case study which shows that machine-code verification does not necessitate ghastly low-level proofs. The case study we describe is the construction of an x86-64 implementation of arbitrary-precision integer arithmetic. Compared with closely related work, our proofs are shorter and, more importantly, the reasoning is at a more convenient high level of abstraction, e.g. pointer reasoning is largely avoided. We achieve this improvement as a result of using an abstraction for arrays and previously developed tools, namely, a proof-producing decompiler and compiler. The work presented in this paper has been developed in the HOL4 theorem prover. The case study resulted in 800 lines of verified 64-bit x86 machine code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_6707_2_5,
  title = {Tools},
  author = {Wills, Dean C.},
  booktitle = {C++ 2013 for C\# Developers},
  year = {2014},
  pages = {53-62},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6707-2\_5},
  url = {https://doi.org/10.1007/978-1-4302-6707-2\_5},
  abstract = {■■■},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_10702_8_13,
  title = {Randomised Testing of a Microprocessor Model Using SMT-Solver State Generation},
  author = {Campbell, Brian and Stark, Ian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {185-199},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-10702-8\_13},
  url = {https://doi.org/10.1007/978-3-319-10702-8\_13},
  abstract = {We validate a HOL4 model of the ARM Cortex-M0 microcontroller core by testing the model’s behaviour on randomly chosen instructions against a real chip. The model and our intended application involve precise timing information about instruction execution, but the implementations are pipelined, so checking the behaviour of single instructions would not give us sufficient confidence in the model. Thus we test the model using sequences of randomly chosen instructions. The main challenge is to meet the constraints on the initial and intermediate execution states: we must ensure that memory accesses are in range and that we respect restrictions on the instructions. By careful transformation of these constraints an off-the-shelf SMT solver can be used to find suitable states for executing test sequences.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_014_0260_y,
  title = {Understanding the implemented access control policy of Android system services with slicing and extended static checking},
  author = {Mustafa, Tanveer and Sohr, Karsten},
  journal = {International Journal of Information Security},
  year = {2015},
  volume = {14},
  number = {4},
  pages = {347-366},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-014-0260-y},
  url = {https://doi.org/10.1007/s10207-014-0260-y},
  abstract = {Android is one of the major smartphone platforms today. One reason for this success is that many interesting applications are made available through Google Play. The increasing functionality, however, entails new risks. To defend against attacks, Android provides a sophisticated security architecture based on permissions which must be granted to applications at installation time. Since the Android source code is publicly available, the security community has the chance to assess the security mechanisms of Android. Due to its large code body, a completely manual code review is tedious, and hence, tool support for this task is desirable. As a first step in this direction, we propose to extract the implemented access control policy from the code for Android system services with the help of program slicing. After this abstraction phase, we analyze the extracted policy against the documentation. For this purpose, we use the Java Modeling Language in conjunction with extended static checking. We applied this approach to core system services of Android 4.0.3 and identified some inconsistencies between the documentation and the implementation.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_5858_2_6,
  title = {Security},
  author = {Nolan, Godfrey and Cinar, Onur and Truxall, David},
  booktitle = {Android Best Practices},
  year = {2014},
  pages = {121-146},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-5858-2\_6},
  url = {https://doi.org/10.1007/978-1-4302-5858-2\_6},
  abstract = {In this chapter we will explore recommendations for secure Android development and coding, from a range of industry sources. These different security recommendations represent the best current thinking on the topic, and I've added my own additional measures gathered from hard-earned experience building and deploying leading Android applications.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_6455_2_8,
  title = {Exploring the Basic APIs, Part 2},
  author = {Friesen, Jeff},
  booktitle = {Learn Java for Android Development},
  year = {2014},
  pages = {359-400},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6455-2\_8},
  url = {https://doi.org/10.1007/978-1-4302-6455-2\_8},
  abstract = {There are more basic APIs in the java.lang package and also in java.lang.ref , java.lang.reflect , and java.util to consider for your Android apps. For example, you can add timers to your games.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4249_9_5,
  title = {Decompiler Design},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {151-174},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_5},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_5},
  abstract = {The next two chapters focus on how to create the decompiler, which is in fact a cross-compiler that translates bytecode to source code. I cover the theory behind the relevant design decisions as they arise, but the intention is to provide enough background information to get you going rather than give you a full-blown chapter on compiler theory.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10817_015_9324_6,
  title = {The Reflective Milawa Theorem Prover is Sound (Down to the Machine Code that Runs it)},
  author = {Davis, Jared and Myreen, Magnus O.},
  journal = {Journal of Automated Reasoning},
  year = {2015},
  volume = {55},
  number = {2},
  pages = {117-183},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10817-015-9324-6},
  url = {https://doi.org/10.1007/s10817-015-9324-6},
  abstract = {This paper presents, we believe, the most comprehensive evidence of a theorem prover’s soundness to date. Our subject is the Milawa theorem prover. We present evidence of its soundness down to the machine code. Milawa is a theorem prover styled after NQTHM and ACL2. It is based on an idealised version of ACL2’s computational logic and provides the user with high-level tactics similar to ACL2’s. In contrast to NQTHM and ACL2, Milawa has a small kernel that is somewhat like an LCF-style system. We explain how the Milawa theorem prover is constructed as a sequence of reflective extensions from its kernel. The kernel establishes the soundness of these extensions during Milawa’s bootstrapping process. Going deeper, we explain how we have shown that the Milawa kernel is sound using the HOL4 theorem prover. In HOL4, we have formalized its logic, proved the logic sound, and proved that the source code for the Milawa kernel (1,700 lines of Lisp) faithfully implements this logic. Going even further, we have combined these results with the x86 machine-code level verification of the Lisp runtime Jitawa. Our top-level theorem states that Milawa can never claim to prove anything that is false when it is run on this Lisp runtime.},
  content_type = {Article},
}


@article{springer_10_1007_s10270_014_0441_1,
  title = {Clafer: unifying class and feature modeling},
  author = {Bąk, Kacper and Diskin, Zinovy and Antkiewicz, Michał and Czarnecki, Krzysztof and Wąsowski, Andrzej},
  journal = {Software \& Systems Modeling},
  year = {2016},
  volume = {15},
  number = {3},
  pages = {811-845},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10270-014-0441-1},
  url = {https://doi.org/10.1007/s10270-014-0441-1},
  abstract = {We present Clafer ( cla ss, fe ature, r eference), a class modeling language with first-class support for feature modeling. We designed Clafer as a concise notation for meta-models, feature models, mixtures of meta- and feature models (such as components with options), and models that couple feature models and meta-models via constraints (such as mapping feature configurations to component configurations or model templates). Clafer allows arranging models into multiple specialization and extension layers via constraints and inheritance. We identify several key mechanisms allowing a meta-modeling language to express feature models concisely. Clafer unifies basic modeling constructs, such as class, association, and property, into a single construct, called clafer . We provide the language with a formal semantics built in a structurally explicit way. The resulting semantics explains the meaning of hierarchical models whereby properties can be arbitrarily nested in the presence of inheritance and feature modeling constructs. The semantics also enables building consistent automated reasoning support for the language: To date, we implemented three reasoners for Clafer based on Alloy, Z3 SMT, and Choco3 CSP solvers. We show that Clafer meets its design objectives using examples and by comparing to other languages.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_319_04447_7_12,
  title = {A Method for Resolving Security Vulnerabilities Through the Use of Design Patterns},
  author = {Walker, Nick and Coull, Natalie and Ferguson, Ian and Milne, Allan},
  booktitle = {Cyberpatterns},
  year = {2014},
  pages = {149-155},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-04447-7\_12},
  url = {https://doi.org/10.1007/978-3-319-04447-7\_12},
  abstract = {Most software development companies conduct in-house testing of their code prior to releasing their product, yet software vulnerabilities are still found every single day in the most prevalent of applications. Memory corruption vulnerabilities are amongst the most difficult to detect, but can be the most dangerous. This research presents both an effective taxonomy of these vulnerabilities, which can be used to identify software threats and a methodology to maximize the number of memory corruption vulnerabilities that are identified during software testing. A means of cataloguing such vulnerabilities was required: As design patterns were already familiar to software engineers the use of a pattern language seemed appropriate, particularly as the solution to the vulnerabilities lay in the software engineering domain.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_09265_2_2,
  title = {Mobile Sensor Data Collecting System Based on Smart Phone},
  author = {Zhen, Chen and Qiang, Gao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {8-14},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-09265-2\_2},
  url = {https://doi.org/10.1007/978-3-319-09265-2\_2},
  abstract = {Smart phone applications are widely used with technological development of embedded sensors which bring the functions of sensing, communicating and computing to users. Large sets of sensor data (GPS, Bluetooth, compass, etc.) are exploited to the research of human behaviors and human social activities, but collecting a large scale dataset bears many problems. GPSTracker, a mobile application using embedded GPS module and Bluetooth module to collect mobile and interactive data with server/client architecture, is designed. This data collecting system based on smart phone of Android platform, which gives solutions to major problems of data collecting experiment in the aspects of usability, energy consumption, privacy and incentives for users to keep running it on their device for long-term. The performance analysis after a series of tests shows that GPSTracker is acceptable to users and has a high efficiency of data collection. It’s effective in controlling energy consumption and privacy.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_81_322_1695_7_47,
  title = {Key Security Technologies of Cloud Computing Platforms},
  author = {Junjie, Liang},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2014},
  pages = {411-417},
  publisher = {Springer India},
  doi = {10.1007/978-81-322-1695-7\_47},
  url = {https://doi.org/10.1007/978-81-322-1695-7\_47},
  abstract = {The information systems built on the basis of cloud computing is the current development trend. How to utilize the cloud technology to enhance the security and defense ability is a challenge facing the cloud users. It is also crucial for maintaining the healthy and sustainable development of cloud computing technology. This article first introduces the cloud computing security model. Then, the key security technologies of cloud platforms are briefly illustrated from four aspects: infrastructure security, virtualization security, service security, and data security. The security problems unique to cloud platform are the emphasis of this article. Moreover, the significance of virtualization security technologies, as well as the current status, realization principle, and development trend are also the main concerns.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_33338_5_27,
  title = {Accurate Recovery of Functions in a Retargetable Decompiler(Poster Abstract)},
  author = {Ďurfina, Lukáš and Křoustek, Jakub and Zemek, Petr and Kábele, Břetislav},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {390-392},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-33338-5\_27},
  url = {https://doi.org/10.1007/978-3-642-33338-5\_27},
  abstract = {Introduction. Decompilation is used for translation of executable files into a high-level language (HLL) representation. It is an important mechanism for information forensics and malware analysis. Retargetable decompilation represents a very difficult task because it must handle all the specific features of the target platform. Nevertheless, a retargetable decompiler can be used for any particular target platform and the resulting code is represented in a uniform way.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_08344_5_23,
  title = {Once Root Always a Threat: Analyzing the Security Threats of Android Permission System},
  author = {Zhang, Zhongwen and Wang, Yuewu and Jing, Jiwu and Wang, Qiongxiao and Lei, Lingguang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {354-369},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-08344-5\_23},
  url = {https://doi.org/10.1007/978-3-319-08344-5\_23},
  abstract = {Android permission system enforces access control to those privacy-related resources in Android phones. Unfortunately, the permission system could be bypassed when the phone is rooted. On a rooted phone, processes can run with root privilege and can arbitrarily access any resources without permission. Many people are willing to root their Android phones to uninstall pre-installed applications, flash third party ROMs, backup their phones and so on. People use rootkit tools to root their phones. The mainstream rootkit tools in China are provided by some well-known security vendors. Besides root, these vendors also provide the one-click-unroot function to unroot a phone. The unroot process gives users a feeling that their phones will roll back to the original safe state. In this paper, we present the security threats analysis of permission system on phones rooted once and unrooted later. On these phones, two categories of attacks: tampering data files attack and tampering code files attack are carried out. Also, the attacks’ detection rate, damage degree, influence range, and survivability in the real word are analyzed. Analysis result shows even under Antivirus’ monitoring, these attacks towards permission system can still be carried out and survive after the phone is unrooted. Therefore, the permission system faces a long-term compromise. The potential defense solutions are also discussed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_37119_6_14,
  title = {RESource: A Framework for Online Matching of Assembly with Open Source Code},
  author = {Rahimian, Ashkan and Charland, Philippe and Preda, Stere and Debbabi, Mourad},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {211-226},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-37119-6\_14},
  url = {https://doi.org/10.1007/978-3-642-37119-6\_14},
  abstract = {Software reverse engineering is a fastidious task demanding a strong expertise in assembly coding. Various existing tools may help analyze the functionality of a binary file without executing it and an interesting step would naturally be the search for the original source files. Our tool called RESource considers the extraction of some features in the assembly code so that queries can be triggered to a source repository in a reliable way: either (1) the result is a set of references to the original project files provided they are hosted on the repository or (2) at least some functionalities of the binary file are unleashed. Such an approach is very promising given its proved performances in real assembly code applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_09265_2_12,
  title = {A Static Recognition Mechanism for Indirect Call Based on Static Single Assignment},
  author = {Gao, Shixiang and Zheng, Tao and Zhan, Xun and Tao, Xianping and Zhu, Qiaoming and Xie, Junyuan and Bai, Wenyang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {110-117},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-09265-2\_12},
  url = {https://doi.org/10.1007/978-3-319-09265-2\_12},
  abstract = {By preventing attacks which exploit stack buffer overflow vulnerabilities, address space layout randomization is an effective way for embedded systems protection. However, ASLR will probably suffer exhaustive attacks because the pertinence is not strong. At present only coarse-grained randomization has been implemented because one of the key bottlenecks for fine-grained randomization is the dependencies between functions cannot be constructed completely due to indirect calls. As a result, we give a static inter-procedural backtracking recognition mechanism in this paper by using intermediate code analysis technologies to identify the destination addresses of indirect callings generated by function pointers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_54108_7_12,
  title = {Automated Code Proofs on a Formal Model of the X86},
  author = {Goel, Shilpi and Hunt, Warren A.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {222-241},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-54108-7\_12},
  url = {https://doi.org/10.1007/978-3-642-54108-7\_12},
  abstract = {Analysis of binary programs is important to ensure correct execution of corresponding higher-level programs, especially because it accounts for bugs introduced by compilers. Moreover, source code may not always be available for correctness analysis. Proving correctness of binaries often involves significant user expertise and time-consuming manual effort. We describe an approach to automatically verify some X86 binary programs using symbolic execution on an executable formal model of the X86 instruction set architecture. Our approach can reduce the time and effort involved in the proof development process for complex programs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_54338_8_24,
  title = {A Certification Process for Android Applications},
  author = {Kalutarage, Harsha K. and Krishnan, Padmanabhan and Shaikh, Siraj Ahmed},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {288-303},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-54338-8\_24},
  url = {https://doi.org/10.1007/978-3-642-54338-8\_24},
  abstract = {The last decade has seen the emergence of mobile platform for software applications. An important factor in the remarkable growth in this area is the development of Android and a community of mobile application developers sharing open sourced and free software. While the emphasis for Android has been openness and user control, this brings with it challenges of validating and securing mobile apps. Development of dedicated tools and techniques to test mobile apps for functional and nonfunctional properties has been limited so far. Such an effort is made more difficult given frequent version updates for Android in its short history (over ten in ten years). The need for better security and assurance for mobile apps, on the other hand, is ever so more as apps providing important services such as banking, navigation, and identity management emerge. This paper attempts to converge on current concepts and practices of testing mobile apps. We provide a structured checklist approach to vulnerability assessment and permission mapping of mobile apps, which is underpinned by a set of available tools, and ultimately contribute to a framework for certification of mobile apps. The proposed certification process combines diverse sources and has a focus on automation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_09333_8_58,
  title = {A Data Obfuscation Based on State Transition Graph of Mealy Automata},
  author = {Xie, Xin and Liu, Fenlin and Lu, Bin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {520-531},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-09333-8\_58},
  url = {https://doi.org/10.1007/978-3-319-09333-8\_58},
  abstract = {Mealy automata model can be used to obfuscate constants and strings in programs, as to the obfuscation, the structure of state transition graph of mealy machine is simple and easy to test. To solve this problem, a data obfuscation based on state transition graph of mealy machine is proposed. With iteration of state transition graph of mealy machine, redundant states, transition functions and output functions based on probability are added into the graph, and then constants and strings in programs are obfuscated by the mealy machine. Analysis and experiment validated that redundant states and transition functions can increase the complexity of the structure of state transition graph. Output functions based on probability can increase the randomization of output obfuscated data. Obfuscation can be effective to improve the performance of mealy machine to resist static and dynamic reverse analysis.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_10374_7_7,
  title = {Towards Neural Network Based Malware Detection on Android Mobile Devices},
  author = {Yu, Wei and Ge, Linqiang and Xu, Guobin and Fu, Xinwen},
  booktitle = {Advances in Information Security},
  year = {2014},
  pages = {99-117},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-10374-7\_7},
  url = {https://doi.org/10.1007/978-3-319-10374-7\_7},
  abstract = {Due to the exponential increase in the use of smart mobile devices, malware threats on those devices have been growing and posing security risks. To address this critical issue, we developed an Artificial Neural Network (ANN)-based malware detection system to detect unknown malware. In our system, we consider both permissions requested by applications and system calls associated with the execution of applications to distinguish between benign applications and malware. We used ANN, a representative machine learning technique, to understand the anomaly behavior of malware by learning the characteristic permissions and system calls used by applications. We then used the trained ANN to detect malware. Using real-world malware and benign applications, we conducted experiments on Android devices and evaluated the effectiveness of our developed system.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_11569_6_40,
  title = {On Malware Leveraging the Android Accessibility Framework},
  author = {Kraunelis, Joshua and Chen, Yinjie and Ling, Zhen and Fu, Xinwen and Zhao, Wei},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2014},
  pages = {512-523},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-11569-6\_40},
  url = {https://doi.org/10.1007/978-3-319-11569-6\_40},
  abstract = {The number of Android malware has been increasing dramatically in recent years. Android malware can violate users’ security, privacy and damage their economic situation. Study of new malware will allow us to better understand the threat and design effective anti-malware strategies. In this paper, we introduce a new type of malware exploiting Android’s accessibility framework and describe a condition which allows malicious payloads to usurp control of the screen, steal user credentials and compromise user privacy and security. We implement a proof of concept malware to demonstrate such vulnerabilities and present experimental findings on the success rates of this attack. We show that 100 \% of application launches can be detected using this malware, and 100 \% of the time a malicious Activity can gain control of the screen. Our major contribution is two-fold. First, we are the first to discover the category of new Android malware manipulating Android’s accessibility framework. Second, our study finds new types of attacks and complements the categorization of Android malware by Zhou and Jiang [ 21 ]. This prompts the community to re-think categorization of malware for categorizing existing attacks as well as predicting new attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_4560_26_9_5,
  title = {Malware Analytics for Social Networking},
  author = {Subramanian, Deepak and Loh, Peter Kok Keong},
  booktitle = {Gaming Media and Social Effects},
  year = {2014},
  pages = {71-87},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-4560-26-9\_5},
  url = {https://doi.org/10.1007/978-981-4560-26-9\_5},
  abstract = {In this chapter, Subramanian and Loh present and evaluate a novel behavioural malware analysis technique that could be used in the above scenarios for runtime input validation. They focus on adaptive, behavioural analytics that evaluate and classify malware that could infect social network enterprise platforms during runtime. A customised design framework is also presented and its performance evaluated on actual malware samples found in the real-world scenario. Subramanian and Loh show that the use of adaptive analytics helps improve malware detection on social networks over time.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_37300_8_5,
  title = {ADAM: An Automatic and Extensible Platform to Stress Test Android Anti-virus Systems},
  author = {Zheng, Min and Lee, Patrick P. C. and Lui, John C. S.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {82-101},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-37300-8\_5},
  url = {https://doi.org/10.1007/978-3-642-37300-8\_5},
  abstract = {With the rising threat of smartphone malware, both academic community and commercial anti-virus companies proposed many methodologies and products to defend against smartphone malware. Thus, how to assess the effectiveness of these defense mechanisms against existing and unknown malware becomes important. We propose ADAM , an automated and extensible system that can evaluate, via large-scale stress tests, the effectiveness of anti-virus systems against a variety of malware samples for the Android platform. Specifically, ADAM can automatically transform an original malware sample to different variants via repackaging and obfuscation techniques in order to evaluate the robustness of different anti-virus systems against malware mutation. The transformation and evaluation processes of ADAM are fully automatic , generic , and extensible for different types of malware, anti-virus systems, and malware transformation techniques. We demonstrate the efficacy of ADAM using 222 Android malware samples that we collected in the wild. Using ADAM, we generate different variants based on our collected malware samples, and evaluate the detection of these variants against commercial anti-virus systems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4249_9_6,
  title = {Decompiler Implementation},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {175-227},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_6},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_6},
  abstract = {You’re now at the point where you learn to deal with the individual bytecodes and decompile the opcodes into partial statements and expressions and, ultimately (that’s the plan, anyway), back into complete blocks of source code.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11036_014_0512_0,
  title = {Adaptation of Single-user Multi-touch Components to Support Synchronous Mobile Collaboration},
  author = {Pichiliani, Mauro C. and Hirata, Celso Massaki},
  journal = {Mobile Networks and Applications},
  year = {2014},
  volume = {19},
  number = {5},
  pages = {660-679},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11036-014-0512-0},
  url = {https://doi.org/10.1007/s11036-014-0512-0},
  abstract = {Mobile applications, which include calendars, browsers, and interactive maps, are part of our lives nowadays. Most mobile applications are single user; and they do not enable synchronous collaboration among the users. Mobile collaboration enables multiple users in diverse locations to combine synergistically their contributions in a convenient manner. We investigate the potential to create collaborative applications based on existing single user mobile applications. In this work, we propose an adaptation technique based on the reuse of manufacturers’ SDKs (Software Development Kits) to create multi-user prototype applications. In general, adaptation is made manually; nonetheless, we conjecture that some automation is possible. This paper investigates this possibility. More specifically, we hypothesize that if the target SDK’s components of mobile applications comply with certain design guidelines, automatic adaption can be enhanced. We present a reference model and an automatic process to develop high-fidelity prototype multi-user mobile applications by the conversion of multi-touch user interface found on single-user applications. We discuss two examples that illustrate our proposal and provide a quantitative Lines of Code (LOC) comparison of existing approaches.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_36949_0_46,
  title = {Compiler Help for Binary Manipulation Tools},
  author = {Ince, Tugrul and Hollingsworth, Jeffrey K.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {404-413},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-36949-0\_46},
  url = {https://doi.org/10.1007/978-3-642-36949-0\_46},
  abstract = {Parsing machine code is the first step for most analyses performed on binary files. These analyses build control flow graphs (CFGs). In this work we propose a compilation mechanism that augments binary files with information about where each basic block is located and how they are connected to each other. This information makes it unnecessary to analyze most instructions in a binary during the initial CFG build process. As a result, these binary analysis tools experience dramatically increased parsing speeds - 3.8x on average.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_09770_1_3,
  title = {Android Malware Detection Based on Software Complexity Metrics},
  author = {Protsenko, Mykola and Müller, Tilo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {24-35},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-09770-1\_3},
  url = {https://doi.org/10.1007/978-3-319-09770-1\_3},
  abstract = {In this paper, we propose a new approach for the static detection of Android malware by means of machine learning that is based on software complexity metrics, such as McCabe’s Cyclomatic Complexity and the Chidamber and Kemerer Metrics Suite . The practical evaluation of our approach, involving 20,703 benign and 11,444 malicious apps, witnesses a high classification quality of our proposed method, and we assess its resilience against common obfuscation transformations. With respect to our large-scale test set of more than 32,000 apps, we show a true positive rate of up to 93\% and a false positive rate of 0.5\% for unobfuscated malware samples. For obfuscated malware samples, however, we register a significant drop of the true positive rate, whereas permission-based classification schemes are immune against such program transformations. According to these results, we advocate for our new method to be a useful detector for samples within a malware family sharing functionality and source code. Our approach is more conservative than permission-based classifications, and might hence be more suitable for an automated weighting of Android apps, e.g., by the Google Bouncer.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_02341_5_7,
  title = {Platform Security Research},
  author = {Asokan, N. and Davi, Lucas and Dmitrienko, Alexandra and Heuser, Stephan and Kostiainen, Kari and Reshetova, Elena and Sadeghi, Ahmad-Reza},
  booktitle = {Synthesis Lectures on Information Security, Privacy, and Trust},
  year = {2014},
  pages = {61-80},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-02341-5\_7},
  url = {https://doi.org/10.1007/978-3-031-02341-5\_7},
  abstract = {Recently, various security extensions have been proposed to tackle security and privacy issues of mobile devices. In general, the proposed solutions target different operating systems, platforms, and particularly different layers of the software stack. An abstract view of the different software layers a security extension may target is shown in Figure 7.1: (i) the operating system kernel, (ii) the middleware layer where the core mobile phone OS services reside, and (iii) the application layer with built-in and third-party user applications inside.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_662_45472_5_24,
  title = {On the (In)Security of Mobile Two-Factor Authentication},
  author = {Dmitrienko, Alexandra and Liebchen, Christopher and Rossow, Christian and Sadeghi, Ahmad-Reza},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {365-383},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-45472-5\_24},
  url = {https://doi.org/10.1007/978-3-662-45472-5\_24},
  abstract = {Two-factor authentication (2FA) schemes aim at strengthening the security of login password-based authentication by deploying secondary authentication tokens. In this context, mobile 2FA schemes require no additional hardware (e.g., a smartcard) to store and handle the secondary authentication token, and hence are considered as a reasonable trade-off between security, usability and costs. They are widely used in online banking and increasingly deployed by Internet service providers. In this paper, we investigate 2FA implementations of several well-known Internet service providers such as Google, Dropbox, Twitter and Facebook. We identify various weaknesses that allow an attacker to easily bypass them, even when the secondary authentication token is not under attacker’s control. We then go a step further and present a more general attack against mobile 2FA schemes. Our attack relies on cross-platform infection that subverts control over both end points (PC and a mobile device) involved in the authentication protocol. We apply this attack in practice and successfully circumvent diverse schemes: SMS-based TAN solutions of four large banks, one instance of a visual TAN scheme, 2FA login verification systems of Google, Dropbox, Twitter and Facebook accounts, and the Google Authenticator app currently used by 32 third-party service providers. Finally, we cluster and analyze hundreds of real-world malicious Android apps that target mobile 2FA schemes and show that banking Trojans already deploy mobile counterparts that steal 2FA credentials like TANs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_45472_5_1,
  title = {Digital Check Forgery Attacks on Client Check Truncation Systems},
  author = {Gjomemo, Rigel and Malik, Hafiz and Sumb, Nilesh and Venkatakrishnan, V. N. and Ansari, Rashid},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {3-20},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-45472-5\_1},
  url = {https://doi.org/10.1007/978-3-662-45472-5\_1},
  abstract = {In this paper, we present a digital check forgery attack on check processing systems used in online banking that results in check fraud. Such an attack is facilitated by multiple factors: the use of digital images to perform check transactions, advances in image processing technologies, the use of untrusted client-side devices and software, and the modalities of deposit. We note that digital check forgery attacks offer better chances of success in committing fraud when compared with conventional check forgery attacks. We discuss an instance of this attack and find several leading banks vulnerable to digital check forgery.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_05149_9_9,
  title = {Bifocals: Analyzing WebView Vulnerabilities in Android Applications},
  author = {Chin, Erika and Wagner, David},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {138-159},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-05149-9\_9},
  url = {https://doi.org/10.1007/978-3-319-05149-9\_9},
  abstract = {WebViews allow Android developers to embed a webpage within an application, seamlessly integrating native application code with HTML and JavaScript web content. While this rich interaction simplifies developer support for multiple platforms, it exposes applications to attack. In this paper, we explore two WebView vulnerabilities: excess authorization , where malicious JavaScript can invoke Android application code, and file-based cross-zone scripting , which exposes a device’s file system to an attacker. We build a tool, Bifocals, to detect these vulnerabilities and characterize the prevalence of vulnerable code. We found \\(67\\) applications with WebView-related vulnerabilities ( \\(11\\,\\\%\\) of applications containing WebViews). Based on our findings, we suggest a modification to WebView security policies that would protect over \\(60\\,\\\%\\) of the vulnerable applications with little burden on developers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4249_9_1,
  title = {Laying the Groundwork},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {1-17},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_1},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_1},
  abstract = {To begin, in this chapter I introduce you to the problem with decompilers and why virtual machines and the Android platform in particular are at such risk. Youlearn about the history of decompilers; it may surprise you that they’ve been around almost as long as computers. And because this can be such an emotive topic, I take some time to discuss the legal and moral issues behind decompilation. Finally, you’re introduced to some of options open to you if you want to protect your code.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_6212_1_11,
  title = {Advanced Defense and Forensic Response},
  author = {Wright, Paul},
  booktitle = {Protecting Oracle Database 12c},
  year = {2014},
  pages = {121-143},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6212-1\_11},
  url = {https://doi.org/10.1007/978-1-4302-6212-1\_11},
  abstract = {In order to succeed in defending your organization against a cyber attack, the key skill to have is the ability to control complexity. Protecting assets is often described as “asymmetric” in that the effort of controlling all the internal complexity is much larger than the effort needed to find one issue by an external attacker. If you have worked with Oracle for some time you will have noted that the software is complex, and some administrators do tend to increase the complexity—especially when they are the only ones who know how to work it! This does not bode well for a controlled baseline that is provably and measurably secure to an organization’s standard.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4249_9_2,
  title = {Ghost in the Machine},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {19-55},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_2},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_2},
  abstract = {If you’re trying to understand just how good an obfuscator or decompiler really is, then it helps to be able to see what’s going on inside a DEX file and the corresponding Java class file. Otherwise you’re relying on the word of a third-party vendor or, at best, a knowledgeable reviewer. For most people, that’s not good enough when you’re trying to protect mission-critical code. At the very least, you should be able to talk intelligently about the area of decompilation and ask the obvious questions to understand what’s happening.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_11203_9_10,
  title = {DroidMiner: Automated Mining and Characterization of Fine-grained Malicious Behaviors in Android Applications},
  author = {Yang, Chao and Xu, Zhaoyan and Gu, Guofei and Yegneswaran, Vinod and Porras, Phillip},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {163-182},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-11203-9\_10},
  url = {https://doi.org/10.1007/978-3-319-11203-9\_10},
  abstract = {Most existing malicious Android app detection approaches rely on manually selected detection heuristics, features, and models. In this paper, we describe a new, complementary system, called DroidMiner , which uses static analysis to automatically mine malicious program logic from known Android malware, abstracts this logic into a sequence of threat modalities, and then seeks out these threat modality patterns in other unknown (or newly published) Android apps. We formalize a two-level behavioral graph representation used to capture Android app program logic, and design new techniques to identify and label elements of the graph that capture malicious behavioral patterns (or malicious modalities). After the automatic learning of these malicious behavioral models, DroidMiner can scan a new Android app to ( i ) determine whether it contains malicious modalities, ( ii ) diagnose the malware family to which it is most closely associated, ( iii ) and provide further evidence as to why the app is considered to be malicious by including a concise description of identified malicious behaviors. We evaluate DroidMiner using 2,466 malicious apps, identified from a corpus of over 67,000 third-party market Android apps, plus an additional set of over 10,000 official market Android apps. Using this set of real-world apps, we demonstrate that DroidMiner achieves a 95.3\% detection rate, with only a 0.4\% false positive rate. We further evaluate DroidMiner’s ability to classify malicious apps under their proper family labels, and measure its label accuracy at 92\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_41383_4_2,
  title = {Static Integer Overflow Vulnerability Detection in Windows Binary},
  author = {Deng, Yi and Zhang, Yang and Cheng, Liang and Sun, Xiaoshan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {19-35},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-41383-4\_2},
  url = {https://doi.org/10.1007/978-3-642-41383-4\_2},
  abstract = {In this paper, we present a static binary analysis based approach to detect integer overflow vulnerabilities in windows binary. We first translate the binary to our intermediate representation and perform Sign type analysis to reconstruct sufficient type information, and then use dataflow analysis to collect suspicious integer overflow vulnerabilities. To alleviate the problem that static vulnerability detection has high false positive rate, we use the information how variables which may be affected by integer overflow are used in security sensitive operations to compute priority and rank the suspicious integer overflow vulnerabilities. Finally the weakest preconditions technique is used to validate the suspicious integer overflow vulnerabilities. Our approach is static so that it does not run the software directly in real environment. We implement a prototype called EIOD and use it to analyze real-world windows binaries. Experiments show that EIOD can effectively and efficiently detect integer overflow vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_08509_8_4,
  title = {AndRadar: Fast Discovery of Android Applications in Alternative Markets},
  author = {Lindorfer, Martina and Volanis, Stamatis and Sisto, Alessandro and Neugschwandtner, Matthias and Athanasopoulos, Elias and Maggi, Federico and Platzer, Christian and Zanero, Stefano and Ioannidis, Sotiris},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {51-71},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-08509-8\_4},
  url = {https://doi.org/10.1007/978-3-319-08509-8\_4},
  abstract = {Compared to traditional desktop software, Android applications are delivered through software repositories, commonly known as application markets. Other mobile platforms, such as Apple iOS and BlackBerry OS also use the marketplace model, but what is unique to Android is the existence of a plethora of alternative application markets. This complicates the task of detecting and tracking Android malware. Identifying a malicious application in one particular market is simply not enough, as many instances of this application may exist in other markets. To quantify this phenomenon, we exhaustively crawled 8 markets between June and November 2013. Our findings indicate that alternative markets host a large number of ad-aggressive apps, a non-negligible amount of malware, and some markets even allow authors to publish known malicious apps without prompt action. Motivated by these findings, we present AndRadar, a framework for discovering multiple instances of a malicious Android application in a set of alternative application markets. AndRadar scans a set of markets in parallel to discover similar applications. Each lookup takes no more than a few seconds, regardless of the size of the marketplace. Moreover, it is modular, and new markets can be transparently added once the search and download URLs are known. Using AndRadar we are able to achieve three goals. First, we can discover malicious applications in alternative markets, second, we can expose app distribution strategies used by malware developers, and third, we can monitor how different markets react to new malware. During a three-month evaluation period, AndRadar tracked over 20,000 apps and recorded more than 1,500 app deletions in 16 markets. Nearly 8\% of those deletions were related to apps that were hopping from market to market. The most established markets were able to react and delete new malware within tens of days from the malicious app publication date while other markets did not react at all.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_6668_6_2,
  title = {Simple Program Lifetime Stages},
  author = {Stevanovic, Milan},
  booktitle = {Advanced C and C++ Compiling},
  year = {2014},
  pages = {9-41},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6668-6\_2},
  url = {https://doi.org/10.1007/978-1-4302-6668-6\_2},
  abstract = {In the previous chapter, you obtained a broad insight into aspects of the modern multitasking operating system’s functionality that play a role during program execution. The natural next question that comes to the programmer's mind is what to do, how, and why in order to arrange for the program execution to happen.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4249_9_7,
  title = {Hear No Evil, See No Evil: A Case Study},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {229-253},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_7},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_7},
  abstract = {You’re now almost at the end of your journey. By now you should have a sound understanding of the overall principles of how to decompile and how to make some attempts at protecting your code. Having said that, I’ve found from working with clients and colleagues that even if you understand what decompilation and obfuscation really mean, it doesn’t help you figure out what practical measures you can take to protect your code. A little knowledge can often create more questions than answers.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_12736_1_12,
  title = {Model-Checking for Android Malware Detection},
  author = {Song, Fu and Touili, Tayssir},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {216-235},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-12736-1\_12},
  url = {https://doi.org/10.1007/978-3-319-12736-1\_12},
  abstract = {The popularity of Android devices results in a significant increase of Android malwares. These malwares commonly steal users’ private data or do malicious tasks. Therefore, it is important to efficiently and automatically analyze Android applications and identify their malicious behaviors. This paper introduces an automatic and scalable approach to analyze Android applications and identify malicious applications. Our approach consists of modeling an Android application as a PushDown System (PDS), succinctly specifying malicious behaviors in Computation Tree Logic (CTL) or Linear Temporal Logic (LTL), and reducing the Android malware detection problem to CTL/LTL model-checking for PDSs. We implemented our techniques in a tool and applied it to analyze more than 1260 android applications. We obtained encouraging results. In particular, we discovered ten programs known as benign that are leaking private data.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_6518_4_6,
  title = {Mapping with Annotations},
  author = {Ottinger, Joseph B. and Minter, Dave and Linwood, Jeff},
  booktitle = {Beginning Hibernate},
  year = {2014},
  pages = {81-114},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6518-4\_6},
  url = {https://doi.org/10.1007/978-1-4302-6518-4\_6},
  abstract = {In Chapter 5, we discussed the need to create mappings between the database model and the object model. Mappings can be created in two different ways: via inline annotations (as we’ve done through the book so far), or as separate XML files in one of two primary formats.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_662_44202_9_19,
  title = {Retargetting Legacy Browser Extensions to Modern Extension Frameworks},
  author = {Karim, Rezwana and Dhawan, Mohan and Ganapathy, Vinod},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {463-488},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-44202-9\_19},
  url = {https://doi.org/10.1007/978-3-662-44202-9\_19},
  abstract = {Most modern Web browsers export a rich API allowing third-party extensions to access privileged browser objects that can also be misused by attacks directed against vulnerable ones. Web browser vendors have therefore recently developed new extension frameworks aimed at better isolating extensions while still allowing access to privileged browser state. For instance Google Chrome extension architecture and Mozilla’s Jetpack extension framework. We present Morpheus, a tool to port legacy browser extensions to these new frameworks. Specifically, Morpheus targets legacy extensions for the Mozilla Firefox browser, and ports them to the Jetpack framework. We describe the key techniques used by Morpheus to analyze and transform legacy extensions so that they conform to the constraints imposed by Jetpack and simplify runtime policy enforcement. Finally, we present an experimental evaluation of Morpheus by applying it to port 52 legacy Firefox extensions to the Jetpack framework.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_45284_0_14,
  title = {Reversible Language Extensions and Their Application in Debugging},
  author = {Drey, Zoé and Morales, José F. and Hermenegildo, Manuel V. and Carro, Manuel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {206-221},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-45284-0\_14},
  url = {https://doi.org/10.1007/978-3-642-45284-0\_14},
  abstract = {A range of methodologies and techniques are available to guide the design and implementation of language extensions and domain-specific languages on top of a base language. A simple yet powerful technique to this end is to formulate the extension via source-to-source transformation rules that are interleaved across the different compilation passes of the base language. Despite being a very successful approach, it has the main drawback that the input source code is lost in the process. As a result, during the whole workflow of program development (warning and error reporting, source-level debugging, or even program analysis) the tools involved report in terms of the base language, which is confusing to users. In this paper, we propose an augmented approach to language extensions for Prolog, where symbolic annotations are included in the target program. These annotations allow the selective reversal of the translated code. We illustrate the approach by showing that coupling it with minimal extensions to a generic Prolog debugger allows us to provide users with a familiar, source-level view during the debugging of programs which use a variety of language extensions, such as functional notation, DCGs, or CLP\{Q,R\}.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_38908_5_13,
  title = {A Framework for Evaluating Mobile App Repackaging Detection Algorithms},
  author = {Huang, Heqing and Zhu, Sencun and Liu, Peng and Wu, Dinghao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {169-186},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-38908-5\_13},
  url = {https://doi.org/10.1007/978-3-642-38908-5\_13},
  abstract = {Because it is not hard to reverse engineer the Dalvik bytecode used in the Dalvik virtual machine, Android application repackaging has become a serious problem. With repackaging, a plagiarist can simply steal others’ code violating the intellectual property of the developers. More seriously, after repackaging, popular apps can become the carriers of malware, adware or spy-ware for wide spreading. To maintain a healthy app market, several detection algorithms have been proposed recently, which can catch some types of repackaged apps in various markets efficiently. However, they are generally lack of valid analysis on their effectiveness. After analyzing these approaches, we find simple obfuscation techniques can potentially cause false negatives, because they change the main characteristics or features of the apps that are used for similarity detections. In practice, more sophisticated obfuscation techniques can be adopted (or have already been performed) in the context of mobile apps. We envision this obfuscation based repackaging will become a phenomenon due to the arms race between repackaging and its detection. To this end, we propose a framework to evaluate the obfuscation resilience of repackaging detection algorithms comprehensively. Our evaluation framework is able to perform a set of obfuscation algorithms in various forms on the Dalvik bytecode. Our results provide insights to help gauge both broadness and depth of algorithms’ obfuscation resilience. We applied our framework to conduct a comprehensive case study on AndroGuard, an Android repackaging detector proposed in Black-hat 2011. Our experimental results have demonstrated the effectiveness and stability of our framework.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4249_9_4,
  title = {Tools of the Trade},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {93-149},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_4},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_4},
  abstract = {This chapter looks at some of the tools as well as some simple techniques that hackers use to reverse-engineer the underlying source code from an Android package file (APK). It also takes a brief look at the major open source and commercial obfuscators, because obfuscation is far and away the most popular tool for protecting source code. In addition, the chapter covers the theory behind these obfuscators so you’re better informed about what you’re buying.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4774_6_8,
  title = {Asynchronous Programming with ASP.NET MVC},
  author = {Ciliberti, John},
  booktitle = {ASP.NET MVC 4 Recipes},
  year = {2013},
  pages = {281-319},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4774-6\_8},
  url = {https://doi.org/10.1007/978-1-4302-4774-6\_8},
  abstract = {You have an application that is responsive most of the time but occasionally runs slow and sometimes freezes up entirely. After doing some analysis, you discover a correlation between your application’s slowdowns and the performance of a remote web service that is called by one of your controllers. What seems strange is that even though the remote web service is only used by one part of your application, your entire application is effected by the slowdown. Using Internet Service Manager’s active request report (see Recipe 8–7), you notice many requests stuck in the beginrequest state. You need to understand how to solve this issue.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4614_1746_0_6,
  title = {Dynamic Optimization Techniques},
  author = {Beck, Antonio Carlos Schneider},
  booktitle = {Adaptable Embedded Systems},
  year = {2013},
  pages = {163-210},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-1746-0\_6},
  url = {https://doi.org/10.1007/978-1-4614-1746-0\_6},
  abstract = {As has been emphasized throughout this book, it is necessary a high level of adaptability to cope with the high heterogeneous behavior of recent applications. At the same time, binary code compatibility is mandatory, so the large amount of already existing software can be reused without any kind of modification. In this scenario, this chapter discusses dynamic optimization techniques, how they can be used to improve performance, how they maintain binary compatibility and some case studies. The chapter starts presenting Binary translation. Its main concepts are clarified, as well as the main challenges that a binary translator mechanism must handle to work properly. The section ends with a detailed view of some examples of Binary Translation machines. Then, Reuse is discussed, and diverse types of it are covered: instruction reuse, value prediction, basic block, trace reuse and dynamic trace memoization. Furthermore, according to the discussion made in Chap.3, even though reconfigurable systems present huge potentials in terms of performance and energy, they alone cannot deal with the high heterogeneous behavior of recent applications neither maintain binary compatibility. Therefore, this chapter ends presenting approaches that use reconfigurable architectures together with mechanisms that somehow reassembles the behavior of the dynamic optimization techniques.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_5004_6_3,
  title = {Discovery and Dissemination of Discovering Security Vulnerabilities},
  author = {Maurushat, Alana},
  booktitle = {SpringerBriefs in Cybersecurity},
  year = {2013},
  pages = {21-33},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-5004-6\_3},
  url = {https://doi.org/10.1007/978-1-4471-5004-6\_3},
  abstract = {The method of discovering security vulnerabilities raises separate legal and ethical issues apart from the disclosure of such vulnerabilities. This chapter explains the various methods of discovering and disseminating vulnerabilities (such as the use of a honeynet, youtube concept of proof videos, zero day exploit markets) and provides for an explanation of each method, then uses a case study where possible to introduce legal and ethical issues.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4614_7010_6_34,
  title = {Dynamic USBKEY System on Multiple Verification Algorithm},
  author = {Yao, Yixiang and Gao, Jinghua and Gong, Ying},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2013},
  pages = {297-304},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-7010-6\_34},
  url = {https://doi.org/10.1007/978-1-4614-7010-6\_34},
  abstract = {On account of the closed products and other defective products in the current market, this paper puts forward and carries out the Dynamic USBKEY System. This system is based on Multiple Verification Algorithm and is able to verify the validity of users’ identity in a high-strength dynamic channel. Firstly, the security of the entire system is based on the strength of the random key. The overall design and the adopted algorithm are open. Secondly, it can solve the problems within the channel, the verification method and the program’s self-preservation. Thirdly, the system provides a more secure solution under the rapid programming mode. The developers can apply the system on their own programs through the opened cross-language interface. As a result, the development cycle can be shortened and the security strength of their program can be improved.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_37377_0_18,
  title = {Using Basic RFID-Based Digital Product Memories for Protection against Counterfeit Goods in Manufacturing Plants},
  author = {Neidig, Jörg},
  booktitle = {Cognitive Technologies},
  year = {2013},
  pages = {305-310},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-37377-0\_18},
  url = {https://doi.org/10.1007/978-3-642-37377-0\_18},
  abstract = {This chapter describes an examplary implementation based on digital product memories in the field of protection against counterfeit goods in manufacturing plants in the SemProM project.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_07317_0_7,
  title = {Test Case Generation by Symbolic Execution: Basic Concepts, a CLP-Based Instance, and Actor-Based Concurrency},
  author = {Albert, Elvira and Arenas, Puri and Gómez-Zamalloa, Miguel and Rojas, Jose Miguel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2014},
  pages = {263-309},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-07317-0\_7},
  url = {https://doi.org/10.1007/978-3-319-07317-0\_7},
  abstract = {The focus of this tutorial is white-box test case generation (TCG) based on symbolic execution. Symbolic execution consists in executing a program with the contents of its input arguments being symbolic variables rather than concrete values. A symbolic execution tree characterizes the set of execution paths explored during the symbolic execution of a program. Test cases can be then obtained from the successful branches of the tree. The tutorial is split into three parts: (1) The first part overviews the basic techniques used in TCG to ensure termination, handling heap-manipulating programs, achieving compositionality in the process and guiding TCG towards interesting test cases. (2) In the second part, we focus on a particular implementation of the TCG framework in constraint logic programming (CLP). In essense, the imperative object-oriented program under test is automatically transformed into an equivalent executable CLP-translated program. The main advantage of CLP-based TCG is that the standard mechanism of CLP performs symbolic execution for free. The PET system is an open-source software that implements this approach. (3) Finally, in the last part, we study the extension of TCG to actor-based concurrent programs.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_6002_8_9,
  title = {Extending NuGet},
  author = {Balliauw, Maarten and Decoster, Xavier},
  booktitle = {Pro NuGet},
  year = {2013},
  pages = {259-286},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-6002-8\_9},
  url = {https://doi.org/10.1007/978-1-4302-6002-8\_9},
  abstract = {In the previous chapters, we’ve shown you how you can leverage NuGet in more-advanced scenarios and how NuGet can be the tool of preference for managing external dependencies in your software projects. We’ve even touched on some alternative scenarios, where NuGet can be used to distribute releases and deploy them onto your server infrastructure.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_01604_7_38,
  title = {Infrastructure for Detecting Android Malware},
  author = {Delosières, Laurent and García, David},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2013},
  pages = {389-398},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-01604-7\_38},
  url = {https://doi.org/10.1007/978-3-319-01604-7\_38},
  abstract = {Malware for smartphones have sky-rocketed these last years, particularly for Android platforms. To tackle this threat, services such as Google Bouncer have intended to counter-attack. However, it has been of short duration since the malware have circumvented the service by changing their behaviors. Therefore, we propose a malware taxonomy, a survey of attack vectors to better understand the Android malware, a survey of the modus-operandi of attackers for infecting the smartphones, and the design of components that are responsible for analyzing and detecting Android malware of the NEMESYS infrastructure. This infrastructure aims at understanding and detecting attacks both at the network and smartphone level.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_2909_7_5,
  title = {Static Analysis of Binaries},
  author = {Cesare, Silvio and Xiang, Yang},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2012},
  pages = {41-49},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-2909-7\_5},
  url = {https://doi.org/10.1007/978-1-4471-2909-7\_5},
  abstract = {Static binary analysis is more difficult than if source code is available. In many cases, the analyses are unsound and behaviours are omitted to make problems feasible. Heuristics may be required to separate code and data in a disassembly or pointer behaviour may be weakly modelled to make statically analysing programs feasible. Nevertheless, static analysis of binaries is an important area of research with a number of practical applications including the detection of software theft and the classification and detection of malware. This chapter examines static analysis of binaries with the intent that properties and features of binary programs can be extracted to create useful birthmarks for software similarity and classification.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_45293_2_23,
  title = {An Improved FPGAs-Based Loop Pipeline Scheduling Algorithm for Reconfigurable Compiler},
  author = {Guo, Zhenhua and Wu, Yanxia and Zhang, Guoyin and Sui, Tianxiang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {307-318},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-45293-2\_23},
  url = {https://doi.org/10.1007/978-3-642-45293-2\_23},
  abstract = {Reconfigurable compilers have shown significant promise in the field of reconfigurable computing, and pipeline scheduling algorithms are typically concerned with improving iteration performance or saving the resources. However, the lack of loop pipeline scheduling algorithm for reconfigurable systems hampers the widespread adoption of fine-grained reconfigurable compilers. This paper presents an improved FPGAs-based loop pipeline scheduling algorithm and has realized it in ASCRA (Application-Specific Compiler for Reconfigurable Architecture) compilation framework. In FPGAs-based loop pipeline scheduling algorithm, the adequate consideration of hardware operation logic delay can save the resources of pipelining and ensure the performance of reconfigurable systems. Both of iterations with carried dependencies and without carried dependency have been considered. The preliminary experiment results show that it can economize more than 20\% of the register resources by combining the adjacent pipeline stages without influencing the performance, and the algorithm is feasible for the other fine-grained reconfigurable compilers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_03542_0_22,
  title = {The Proof Assistant as an Integrated Development Environment},
  author = {Benton, Nick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {307-314},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-03542-0\_22},
  url = {https://doi.org/10.1007/978-3-319-03542-0\_22},
  abstract = {We discuss the potential of doing program development, code generation, application-specific modelling, and verification entirely within a proof assistant.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_02624_4_19,
  title = {A Pipeline to Characterize Virulence Factors in Mycobacterium Massiliense Genome},
  author = {Menegói, Guilherme and Raiol, Tainá and de Araújo Oliveira, João Victor and de Oliveira Sandes, Edans Flávius and de Melo, Alba Cristina Magalhães Alves and Maranhão, Andréa Queiroz and Silva-Pereira, Ildinete and Bocca, Anamélia Lorenzetti and Junqueira-Kipnis, Ana Paula and Walter, Maria Emília M. T. and Kipnis, André and de Macedo Brígido, Marcelo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {202-213},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-02624-4\_19},
  url = {https://doi.org/10.1007/978-3-319-02624-4\_19},
  abstract = {Virulence factors represent crucial molecular features for understanding pathogenic mechanisms. Here we describe a pipeline for in silico prediction of virulence factor genes in Mycobacterium massiliense genome that could be easily used in many other bacterial systems. Some few methods for this characterization are described in the literature, however these approaches are usually time-consuming and require information not always readily available. Using the proposed pipeline, the number and the accuracy of predicted ORF annotation were increased, and a broad identification of virulence factors could be achieved. Based on these results, we were able to construct a general pathogenic profile of M. massiliense . Furthermore, two important metabolic pathways, production of siderophores and bacterial secretion systems, both related to M. massiliense ’s pathogenicity, were investigated.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_27585_2_5,
  title = {Efficient and Stealthy Instruction Tracing and Its Applications in Automated Malware Analysis: Open Problems and Challenges},
  author = {Bangerter, Endre and Bühlmann, Stefan and Kirda, Engin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {55-64},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-27585-2\_5},
  url = {https://doi.org/10.1007/978-3-642-27585-2\_5},
  abstract = {Malware is substantial security threat today and most likely in the foreseeable future. The analysis of malware is a key activity in the fight against the threat. Since manual analysis is time consuming and given the extent of the malware threat, malware analysis needs to be automated. Malware analysis sandboxes offer such automation and play already an important role in practice. Yet, they only uncover certain aspects of malware behavior, and still require manual analysis in many cases. This is not a viable way to go, and thus the automation and quality of automated analysis needs to be pushed further. A promising technique towards this goal is instruction tracing combined with analyzes algorithms that uncover malware behavior from an instruction trace. In this position paper, we shall argue that instruction tracing is still in its infancy and point out challenges and open problems of instruction tracing in general. In particular, we shall describe Helios, which is our new instruction tracer that offers a better balance of tracing speed and transparency than existing techniques.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_23141_4_8,
  title = {Design of a Retargetable Decompiler for a Static Platform-Independent Malware Analysis},
  author = {Ďurfina, Lukáš and Křoustek, Jakub and Zemek, Petr and Kolář, Dušan and Hruška, Tomáš and Masařík, Karel and Meduna, Alexander},
  booktitle = {Communications in Computer and Information Science},
  year = {2011},
  pages = {72-86},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-23141-4\_8},
  url = {https://doi.org/10.1007/978-3-642-23141-4\_8},
  abstract = {Together with the massive expansion of smartphones, tablets, and other smart devices, we can notice a growing number of malware threats targeting these platforms. Software security companies are not prepared for such diversity of target platforms and there are only few techniques for platform-independent malware analysis. This is a major security issue these days. In this paper, we propose a concept of a retargetable reverse compiler (i.e. a decompiler), which is in an early stage of development. The retargetable decompiler transforms platform-specific binary applications into a high-level language (HLL) representation, which can be further analyzed in a uniform way. This tool will help with a static platform-independent malware analysis. Our unique solution is based on an exploitation of two systems that were originally not intended for such an application—the architecture description language (ADL) ISAC for a platform description and the LLVM Compiler System as the core of the decompiler. In this study, we show that our tool can produce highly readable HLL code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_33018_6_9,
  title = {Tracking Traitors in Web Services via Blind Signatures},
  author = {Álvarez-Bermejo, J. A. and López-Ramos, J. A.},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2013},
  pages = {87-96},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-33018-6\_9},
  url = {https://doi.org/10.1007/978-3-642-33018-6\_9},
  abstract = {This paper presents a method and its implementation proposal, built on the blind signatures protocol, to trace and report users sharing a valid license illegally when accessing services provided through Internet (Web services, Streaming, etc). The method devised is able to identify the legitimate user from those users who are illegally accessing services with a shared key. This method is robust when detecting licenses built with no authorization. An enhancement of the protocol to identify the last usage of a certain license is also provided, allowing to detect a traitor when an unauthorized copy of a license is used.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4614_4699_6_8,
  title = {Assemblers, Disassemblers, Linkers, and Loaders},
  author = {Grune, Dick and van Reeuwijk, Kees and Bal, Henri E. and Jacobs, Ceriel J. H. and Langendoen, Koen},
  booktitle = {Modern Compiler Design},
  year = {2012},
  pages = {363-384},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-4699-6\_8},
  url = {https://doi.org/10.1007/978-1-4614-4699-6\_8},
  abstract = {An assembler, like a compiler, is a converter from source code to target code, so many of the usual compiler construction techniques are applicable in assembler construction; they include lexical analysis, symbol table management, and backpatching. There are differences too, though, resulting from the relative simplicity of the source format and the relative complexity of the target format.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_319_03783_7_10,
  title = {Efficient Code Obfuscation for Android},
  author = {Kovacheva, Aleksandrina},
  booktitle = {Communications in Computer and Information Science},
  year = {2013},
  pages = {104-119},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-03783-7\_10},
  url = {https://doi.org/10.1007/978-3-319-03783-7\_10},
  abstract = {Recent years have witnessed a steady shift in technology from desktop computers to mobile devices. In the global picture of available mobile platforms, Android stands out as a dominant participant on the market and its popularity continues rising. While beneficial for its users, this growth simultaneously creates a prolific environment for exploitation by vile developers which write malware or reuse software illegally obtained by reverse engineering. A class of programming techniques known as code obfuscation targets prevention of intellectual property theft by parsing an input application through a set of algorithms aiming to make its source code computationally harder and time consuming to recover. This work focuses on the development and application of such algorithms on the bytecode of Android, Dalvik. The main contributions are: (1) a study on samples obtained from the official Android market which shows how feasible it is to reverse a targeted application; (2) a proposed obfuscator implementation whose transformations defeat current popular static analysis tools while maintaining a low level of added time and memory overhead.},
  content_type = {Conference paper},
}


@article{springer_10_1134_s0361768810060046,
  title = {Using information obtained in the course of program execution for improving the quality of data type reconstruction in decompilation},
  author = {Troshina, E. N. and Chernov, A. V.},
  journal = {Programming and Computer Software},
  year = {2010},
  volume = {36},
  number = {6},
  pages = {343-362},
  publisher = {Pleiades Publishing Ltd},
  doi = {10.1134/s0361768810060046},
  url = {https://doi.org/10.1134/s0361768810060046},
  abstract = {Methods of improving the decompilation quality, that is, the reconstruction of a program in a high-level language from a given program in a low-level language, are considered. Decompilation is considered as a reverse engineering problem; problems of decompilation quality are examined, and metrics for assessing this quality are proposed.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_39521_5_13,
  title = {Resource-Bounded Machines are Motivated to be Effective, Efficient, and Curious},
  author = {Steunebrink, Bas R. and Koutník, Jan and Thórisson, Kristinn R. and Nivel, Eric and Schmidhuber, Jürgen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {119-129},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-39521-5\_13},
  url = {https://doi.org/10.1007/978-3-642-39521-5\_13},
  abstract = {Resource-boundedness must be carefully considered when designing and implementing artificial general intelligence (AGI) algorithms and architectures that have to deal with the real world . But not only must resources be represented explicitly throughout its design, an agent must also take into account their usage and the associated costs during reasoning and acting. Moreover, the agent must be intrinsically motivated to become progressively better at utilizing resources. This drive then naturally leads to effectiveness, efficiency, and curiosity. We propose a practical operational framework that explicitly takes into account resource constraints: activities are organized to maximally utilize an agent’s bounded resources as well as the availability of a teacher, and to drive the agent to become progressively better at utilizing its resources. We show how an existing AGI architecture called AERA can function inside this framework. In short, the capability of AERA to perform self-compilation can be used to motivate the system to not only accumulate knowledge and skills faster, but also to achieve goals using less resources, becoming progressively more effective and efficient.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_39218_4_2,
  title = {Screening Smartphone Applications Using Behavioral Signatures},
  author = {Lee, Suyeon and Lee, Jehyun and Lee, Heejo},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2013},
  pages = {14-27},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-39218-4\_2},
  url = {https://doi.org/10.1007/978-3-642-39218-4\_2},
  abstract = {The sharp increase of smartphone malwares has become one of the most serious security problems. The most significant part of the growth is the variants of existing malwares. A legacy approach for malware, the signature matching, is efficient in temporal dimension, but it is not practical because of its lack of robustness against the variants. A counter approach, the behavior analysis to handle the variant issue, takes too much time and resources. We propose a variant detection mechanism using runtime semantic signature. Our key idea is to reduce the control and data flow analysis overhead by using binary patterns for the control and data flow of critical actions as a signature. The flow information is a significant part of behavior analysis but takes high analysis overhead. In contrast to the previous behavioral signatures, the runtime semantic signature has higher family classification accuracy without the flow analysis overhead, because the binary patterns of flow parts is hardly shared by the out of family members. Using the proposed signature, we detect the new variants of known malwares by static matching efficiently and accurately. We evaluated our mechanism with 1,759 randomly collected real-world Android applications including 79 variants of 4 malware families. As the experimental result, our mechanism showed 99.89\% of accuracy on variant detection. We also showed that the mechanism has a linear time complexity as the number of target applications. It is fully practical and advanced performance than the previous works in both of accuracy and efficiency.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_319_03584_0_27,
  title = {Static Detection of Dangerous Behaviors in Android Apps},
  author = {Cheng, Shaoyin and Luo, Shengmei and Li, Zifeng and Wang, Wei and Wu, Yan and Jiang, Fan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {363-376},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-319-03584-0\_27},
  url = {https://doi.org/10.1007/978-3-319-03584-0\_27},
  abstract = {This paper presents a scheme to detect dangerous behaviors in Android apps. In order to identify different kinds of dangerous behaviors, we designed two analysis engines. On the one hand, taint analysis engine mainly detects privacy leak by tracking how user’s sensitive data is used by an app; On the other hand, constant analysis engine focuses on the constant information in an app to identify other dangerous behaviors such as SP services ordering, phone bill consuming, and so on. We have implemented these two engines in a system called ApkRiskAnalyzer which identifies the dangerous behaviors by simulating the running process of an Android app statically. Furthermore, we analyzed 1260 malicious apps and found out dangerous behaviors in 1246 (98.9\%) apps. Then we downloaded 630 normal apps from Google Play and identified dangerous behaviors in 575(91.3\%) apps. These results demonstrate the effectiveness of ApkRiskAnalyzer.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_28756_5_3,
  title = {The Guardol Language and Verification System},
  author = {Hardin, David and Slind, Konrad and Whalen, Michael and Pham, Tuan-Hung},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {18-32},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-28756-5\_3},
  url = {https://doi.org/10.1007/978-3-642-28756-5\_3},
  abstract = {Guardol is a domain-specific language designed to facilitate the construction of correct network guards operating over tree-shaped data. The Guardol system generates Ada code from Guardol programs and also provides specification and automated verification support. Guard programs and specifications are translated to higher order logic, then deductively transformed to a form suitable for a SMT-style decision procedure for recursive functions over tree-structured data. The result is that difficult properties of Guardol programs can be proved fully automatically.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4255_0_39,
  title = {Managing Scripts and Styles},
  author = {Freeman, Adam},
  booktitle = {Pro ASP.NET 4.5 in C\#},
  year = {2013},
  pages = {1075-1098},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4255-0\_39},
  url = {https://doi.org/10.1007/978-1-4302-4255-0\_39},
  abstract = {In this chapter, we show you how the ASP.NET bundles feature works. This feature is new in ASP.NET 4.5, and it can simplify the management and maintenance of the script files and style sheets that an application uses. Bundles can also be used to optimize the requests that a browser has to make in order to get script files and style sheets, which we explain in detail.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4354_0_39,
  title = {Managing Scripts and Styles},
  author = {Mabbutt, Dan and Freeman, Adam and MacDonald, Matthew},
  booktitle = {Pro ASP.NET 4.5 in VB},
  year = {2013},
  pages = {1087-1110},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4354-0\_39},
  url = {https://doi.org/10.1007/978-1-4302-4354-0\_39},
  abstract = {In this chapter we show you how the ASP.NET bundles feature works. This was new in ASP.NET 4.5 and can simplify the management and maintenance of the script files and style sheets that an application uses. Bundles can also be used to optimize requests that a browser has to make in order to get script files and style sheets. We explain how that optimization is done in detail.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_38592_6_20,
  title = {Lintent: Towards Security Type-Checking of Android Applications},
  author = {Bugliesi, Michele and Calzavara, Stefano and Spanò, Alvise},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {289-304},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-38592-6\_20},
  url = {https://doi.org/10.1007/978-3-642-38592-6\_20},
  abstract = {The widespread adoption of Android devices has attracted the attention of a growing computer security audience. Fundamental weaknesses and subtle design flaws of the Android architecture have been identified, studied and fixed, mostly through techniques from data-flow analysis, runtime protection mechanisms, or changes to the operating system. This paper complements this research by developing a framework for the analysis of Android applications based on typing techniques. We introduce a formal calculus for reasoning on the Android inter-component communication API and a type-and-effect system to statically prevent privilege escalation attacks on well-typed components. Drawing on our abstract framework, we develop a prototype implementation of Lintent , a security type-checker for Android applications integrated with the Android Development Tools suite. We finally discuss preliminary experiences with our tool, which highlight real attacks on existing applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_37186_8_7,
  title = {Learning Attack Features from Static and Dynamic Analysis of Malware},
  author = {Ravula, Ravinder R. and Liszka, Kathy J. and Chan, Chien-Chung},
  booktitle = {Communications in Computer and Information Science},
  year = {2013},
  pages = {109-125},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-37186-8\_7},
  url = {https://doi.org/10.1007/978-3-642-37186-8\_7},
  abstract = {Malware detection is a major challenge in today’s software security profession. Works exist for malware detection based on static analysis such as function length frequency, printable string information, byte sequences, API calls, etc. Some works also applied dynamic analysis using features such as function call arguments, returned values, dynamic API call sequences, etc. In this work, we applied a reverse engineering process to extract static and behavioral features from malware based on an assumption that behavior of a malware can be revealed by executing it and observing its effects on the operating environment. We captured all the activities including registry activity, file system activity, network activity, API Calls made, and DLLs accessed for each executable by running them in an isolated environment. Using the extracted features from the reverse engineering process and static analysis features, we prepared two datasets and applied data mining algorithms to generate classification rules. Essential features are identified by applying Weka’s J48 decision tree classifier to 1103 software samples, 582 malware and 521 benign, collected from the Internet. The performance of all classifiers are evaluated by 5-fold cross validation with 80-20 splits of training sets. Experimental results show that Naïve Bayes classifier has better performance on the smaller data set with 15 reversed features, while J48 has better performance on the data set created from the API Call data set with 141 features. In addition, we applied a rough set based tool BLEM2 to generate and evaluate the identification of reverse engineered features in contrast to decision trees. Preliminary results indicate that BLEM2 rules may provide interesting insights for essential feature identification.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_013_0181_8,
  title = {HDM-Analyser: a hybrid analysis approach based on data mining techniques for malware detection},
  author = {Eskandari, Mojtaba and Khorshidpour, Zeinab and Hashemi, Sattar},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2013},
  volume = {9},
  number = {2},
  pages = {77-93},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-013-0181-8},
  url = {https://doi.org/10.1007/s11416-013-0181-8},
  abstract = {Today’s security threats like malware are more sophisticated and targeted than ever, and they are growing at an unprecedented rate. To deal with them, various approaches are introduced. One of them is Signature-based detection, which is an effective method and widely used to detect malware; however, there is a substantial problem in detecting new instances. In other words, it is solely useful for the second malware attack. Due to the rapid proliferation of malware and the desperate need for human effort to extract some kinds of signature, this approach is a tedious solution; thus, an intelligent malware detection system is required to deal with new malware threats. Most of intelligent detection systems utilise some data mining techniques in order to distinguish malware from sane programs. One of the pivotal phases of these systems is extracting features from malware samples and benign ones in order to make at least a learning model. This phase is called “Malware Analysis” which plays a significant role in these systems. Since API call sequence is an effective feature for realising unknown malware, this paper is focused on extracting this feature from executable files. There are two major kinds of approach to analyse an executable file. The first type of analysis is “Static Analysis” which analyses a program in source code level. The second one is “Dynamic Analysis” that extracts features by observing program’s activities such as system requests during its execution time. Static analysis has to traverse the program’s execution path in order to find called APIs. Because it does not have sufficient information about decision making points in the given executable file, it is not able to extract the real sequence of called APIs. Although dynamic analysis does not have this drawback, it suffers from execution overhead. Thus, the feature extraction phase takes noticeable time. In this paper, a novel hybrid approach, HDM-Analyser, is presented which takes advantages of dynamic and static analysis methods for rising speed while preserving the accuracy in a reasonable level. HDM-Analyser is able to predict the majority of decision making points by utilising the statistical information which is gathered by dynamic analysis; therefore, there is no execution overhead. The main contribution of this paper is taking accuracy advantage of the dynamic analysis and incorporating it into static analysis in order to augment the accuracy of static analysis. In fact, the execution overhead has been tolerated in learning phase; thus, it does not impose on feature extraction phase which is performed in scanning operation. The experimental results demonstrate that HDM-Analyser attains better overall accuracy and time complexity than static and dynamic analysis methods.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_29764_9_2,
  title = {Improving the Semantics of a Conceptual Schema of the Human Genome by Incorporating the Modeling of SNPs},
  author = {Pastor, Óscar and van der Kroon, Matthijs and Levin, Ana M. and Celma, Matilde and Casamayor, Juan Carlos},
  booktitle = {Communications in Computer and Information Science},
  year = {2013},
  pages = {23-37},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-29764-9\_2},
  url = {https://doi.org/10.1007/978-3-642-29764-9\_2},
  abstract = {In genetic research, the concept known as SNP, or single nucleotide polymorphism, plays an important role in detection of genes associated with complex ailments and detection of hereditary susceptibility of an individual to a specific trait. Discussing the issue, as it surfaced in the development of a conceptual schema for the human genome, it became clear a high degree of conceptual ambiguity surrounds the term. Solving this ambiguity has lead to the main research question: What makes a genetic variation, classified as a SNP different from genetic variations, not classified as SNP? . For optimal biological research to take place, an unambiguous conceptualization is required. Our main contribution is to show how conceptual modeling techniques applied to human genome concepts can help to disambiguate and correctly represent the relevant concepts in a conceptual schema, thereby achieving a deeper and more adequate understanding of the domain.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_39884_1_12,
  title = {Hey, You, Get Off of My Clipboard},
  author = {Fahl, Sascha and Harbach, Marian and Oltrogge, Marten and Muders, Thomas and Smith, Matthew},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {144-161},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-39884-1\_12},
  url = {https://doi.org/10.1007/978-3-642-39884-1\_12},
  abstract = {Password managers aim to help users manage their ever increasing number of passwords for online authentication. Since users only have to memorise one master secret to unlock an encrypted password database or key chain storing all their (hopefully) different and strong passwords, password managers are intended to increase username/password security. With mobile Internet usage on the rise, password managers have found their way onto smartphones and tablets. In this paper, we analyse the security of password managers on Android devices. While encryption mechanisms are used to protect credentials, we will show that a usability feature of the investigated mobile password managers puts the users’ usernames and passwords at risk. We demonstrate the consequences of our findings by analysing 21 popular free and paid password managers for Android. We then make recommendations how to overcome the current problems and provide an implementation of a secure and usable mobile password manager.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_29166_1_31,
  title = {Automatic Simplification of Obfuscated JavaScript Code (Extended Abstract)},
  author = {Lu, Gen and Coogan, Kevin and Debray, Saumya},
  booktitle = {Communications in Computer and Information Science},
  year = {2012},
  pages = {348-359},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-29166-1\_31},
  url = {https://doi.org/10.1007/978-3-642-29166-1\_31},
  abstract = {Javascript is a scripting language that is commonly used to create sophisticated interactive client-side web applications. It can also be used to carry out browser-based attacks on users. Malicious JavaScript code is usually highly obfuscated, making detection a challenge. This paper describes a simple approach to deobfuscation of JavaScript code based on dynamic analysis and slicing. Experiments using a prototype implementation indicate that our approach is able to penetrate multiple layers of complex obfuscations and extract the core logic of the computation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_35585_1_23,
  title = {A Study on Optimization Techniques for the Smart Virtual Machine Platform},
  author = {Son, YunSik and Lee, YangSun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {167-172},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-35585-1\_23},
  url = {https://doi.org/10.1007/978-3-642-35585-1\_23},
  abstract = {SVM(Smart Virtual Machine) is the virtual machine solution that supports various programming languages and platforms, and its aims are to support programming languages like ISO/IEC C++, Java and Objective-C and smart phone platforms such as Android and iOS. Various contents that developed by supported language on SVM can be execute on Android and iOS platforms at no additional cost, because the SVM has the platform independent characteristic by using SIL(Smart Intermediate Language) as an intermediate language. VM(Virtual Machine) is manufactured to software unlike physical system that consists of hardware, it is conceptual computer that have logical system configuration. But, It can assume that optimization of executed code is very important because act thing which VM is slow than that process by real processor. In this paper, we deal with various optimization techniques to optimize stack based virtual machine called SVM which can execute on various smart devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4249_9_3,
  title = {Inside the DEX File},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Android},
  year = {2012},
  pages = {57-92},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4249-9\_3},
  url = {https://doi.org/10.1007/978-1-4302-4249-9\_3},
  abstract = {It might seem odd that we would need another virtual machine for Android phones and that the Java virtual machine (JVM) wouldn’t be good enough. But for optimization and performance, the Dalvik virtual machine (DVM) is used on all Android phones. It was named after a place in the Icelandic homeland of one the original developers and is considerably different in design from the JVM. Instead of a push-pop stack machine, the DVM uses registers. The corresponding DVM bytecode or DEX files are also a completely different design than Java class files.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_37119_6_13,
  title = {A Novel Obfuscation: Class Hierarchy Flattening},
  author = {Foket, Christophe and De Sutter, Bjorn and Coppens, Bart and De Bosschere, Koen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {194-210},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-37119-6\_13},
  url = {https://doi.org/10.1007/978-3-642-37119-6\_13},
  abstract = {This paper presents class hierarchy flattening, a novel obfuscation technique for programs written in object-oriented, managed programming languages. Class hierarchy flattening strives for maximally removing the inheritance relations from object-oriented programs, thus hiding the overall design of the program from reverse engineers and other attackers. We evaluate the potential of class hierarchy flattening by means of a fully automated prototype tool for Java bytecode. For real-life programs from the DaCapo benchmark suite, we demonstrate that the transformation effectively hinders both human and tool analyses, and that it does so at limited overheads.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_38197_3_12,
  title = {A Framework for Guided Test Case Generation in Constraint Logic Programming},
  author = {Rojas, José Miguel and Gómez-Zamalloa, Miguel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {176-193},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-38197-3\_12},
  url = {https://doi.org/10.1007/978-3-642-38197-3\_12},
  abstract = {Performing test case generation by symbolic execution on large programs becomes quickly impracticable due to the path explosion problem. A common limitation that this problem poses is the generation of unnecessarily large number of possibly irrelevant or redundant test cases even for medium-size programs. Tackling the path explosion problem and selecting high quality test cases are considered major challenges in the software testing community. In this paper we propose a constraint logic programming-based framework to guide symbolic execution and thus test case generation towards a more relevant and potentially smaller subset of paths in the program under test. The framework is realized as a tool and empirical results demonstrate its applicability and effectiveness. We show how the framework can help to obtain high quality test cases and to alleviate the scalability issues that limit most symbolic execution-based test generation approaches.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_40203_6_11,
  title = {AnDarwin: Scalable Detection of Semantically Similar Android Applications},
  author = {Crussell, Jonathan and Gibler, Clint and Chen, Hao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2013},
  pages = {182-199},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-40203-6\_11},
  url = {https://doi.org/10.1007/978-3-642-40203-6\_11},
  abstract = {The popularity and utility of smartphones rely on their vibrant application markets; however, plagiarism threatens the long-term health of these markets. We present a scalable approach to detecting similar Android apps based on their semantic information. We implement our approach in a tool called AnDarwin and evaluate it on 265,359 apps collected from 17 markets including Google Play and numerous thirdparty markets. In contrast to earlier approaches, AnDarwin has four advantages: it avoids comparing apps pairwise, thus greatly improving its scalability; it analyzes only the app code and does not rely on other information - such as the app’s market, signature, or description - thus greatly increasing its reliability; it can detect both full and partial app similarity; and it can automatically detect library code and remove it from the similarity analysis. We present two use cases for AnDarwin: finding similar apps by different developers (“clones”) and similar apps from the same developer (“rebranded”). In ten hours, AnDarwin detected at least 4,295 apps that have been the victims of cloning and 36,106 apps that are rebranded. By analyzing the clusters found by AnDarwin, we found 88 new variants of malware and identified 169 malicious apps based on differences in the requested permissions. Our evaluation demonstrates AnDarwin’s ability to accurately detect similar apps on a large scale.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4614_6859_2_29,
  title = {DSP Instruction Set Simulation},
  author = {Brandner, Florian and Horspool, Nigel and Krall, Andreas},
  booktitle = {Handbook of Signal Processing Systems},
  year = {2013},
  pages = {945-974},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-6859-2\_29},
  url = {https://doi.org/10.1007/978-1-4614-6859-2\_29},
  abstract = {An instruction set simulator is an important tool for system architects and for software developers. However, when implementing a simulator, there are many choices which can be made and that have an effect on the speed and the accuracy of the simulation. They are especially relevant to DSP simulation. This chapter explains the different strategies for implementing a simulator.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_013_9248_x,
  title = {A family of experiments to assess the effectiveness and efficiency of source code obfuscation techniques},
  author = {Ceccato, Mariano and Di Penta, Massimiliano and Falcarin, Paolo and Ricca, Filippo and Torchiano, Marco and Tonella, Paolo},
  journal = {Empirical Software Engineering},
  year = {2013},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-013-9248-x},
  url = {https://doi.org/10.1007/s10664-013-9248-x},
  abstract = {Context: code obfuscation is intended to obstruct code understanding and, eventually, to delay malicious code changes and ultimately render it uneconomical. Although code understanding cannot be completely impeded, code obfuscation makes it more laborious and troublesome, so as to discourage or retard code tampering. Despite the extensive adoption of obfuscation, its assessment has been addressed indirectly either by using internal metrics or taking the point of view of code analysis, e.g., considering the associated computational complexity. To the best of our knowledge, there is no publicly available user study that measures the cost of understanding obfuscated code from the point of view of a human attacker. Aim: this paper experimentally assesses the impact of code obfuscation on the capability of human subjects to understand and change source code. In particular, it considers code protected with two well-known code obfuscation techniques, i.e., identifier renaming and opaque predicates. Method: We have conducted a family of five controlled experiments, involving undergraduate and graduate students from four Universities. During the experiments, subjects had to perform comprehension or attack tasks on decompiled clients of two Java network-based applications, either obfuscated using one of the two techniques, or not. To assess and compare the obfuscation techniques, we measured the correctness and the efficiency of the performed task. Results: —at least for the tasks we considered—simpler techniques (i.e., identifier renaming) prove to be more effective than more complex ones (i.e., opaque predicates) in impeding subjects to complete attack tasks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4471_5514_0_5,
  title = {Translation Semantics and Static Analysis},
  author = {Crespi Reghizzi, Stefano and Breveglieri, Luca and Morzenti, Angelo},
  booktitle = {Texts in Computer Science},
  year = {2013},
  pages = {293-387},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-5514-0\_5},
  url = {https://doi.org/10.1007/978-1-4471-5514-0\_5},
  abstract = {In this chapter we discuss a few translation techniques and the static analysis of programs. After abstractly defining translation as a relation between strings, we present the more operational notions of transliteration and of purely syntactic translation. These notions are defined by means of regular translations and transduction grammars, and are computed by finite or pushdown transducers. We also review the notion of semantic translation, which is modeled by means of functions that operate on the syntactic tree of the source text, and which is realized through attribute grammars. Finally we consider the static analysis of programs: the program is viewed as a finite control-flow graph, and a few important properties concerning its correctness and efficiency are established, through an approach based on writing flow equations and iteratively solving them.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_4156_3_9,
  title = {Real-World Abstract Machines},
  author = {Sestoft, Peter},
  booktitle = {Undergraduate Topics in Computer Science},
  year = {2012},
  pages = {155-174},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-4156-3\_9},
  url = {https://doi.org/10.1007/978-1-4471-4156-3\_9},
  abstract = {This chapter discusses some widely used real-world abstract machines .},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4063_1_9,
  title = {Publishing and Selling Your Apps},
  author = {Gunasekera, Sheran},
  booktitle = {Android Apps Security},
  year = {2012},
  pages = {163-201},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4063-1\_9},
  url = {https://doi.org/10.1007/978-1-4302-4063-1\_9},
  abstract = {You may decide that you want to make some cash by selling the applications that you’ve spent countless hours developing. With the way the mobile space has evolved lately, it is now easier than ever for an individual developer to market, sell, and earn income from his applications. Apple has the iTunes App Store, BlackBerry has AppWorld, and Android has the Market. The process of selling your apps is simple: sign up as an application seller and publish your app on the online store. Once approved, your app will be instantly available for download by Android users. In this chapter, we will examine this process in a bit more detail, and I’ll cover the basics of how you can get your app listed on the Android Market. Along the way, I’ll touch on what steps are involved from the time when you’ve decided your app works well, up until the point you decide to publish it online. I am also going to cover another important point when it comes to selling your apps online: revenue protection. If your app becomes popular on any of the online stores, then it is more than likely that you’re going to attract individuals who want to “crack” and pirate your app. Unless you’ve planned to give out your app for no charge, this could hurt your income. I will spend some time on this topic and explore how you can write good license key and registration routines that will deter piracy. During this section, I will also shed some light on some of the things your app may have to go through if it finds itself in a hostile environment.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_34952_2_3,
  title = {Service Interoperability in the Internet of Things},
  author = {Delgado, Jose},
  booktitle = {Studies in Computational Intelligence},
  year = {2013},
  pages = {51-87},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-34952-2\_3},
  url = {https://doi.org/10.1007/978-3-642-34952-2\_3},
  abstract = {The main service interoperability models (SOA and REST) are currently implemented in the Web with text based technologies (XML, JSON, HTTP), conceived for large grained hypermedia documents. Their extension to the Internet of Things context, involving devices with constrained capabilities and unreliable wireless network protocols, implies using a subset of the features of those technologies and adapting the network and message level protocols. This chapter starts by establishing a layered interoperability framework, from the organizational down to the network protocol levels. Then, it assesses the constraints and limitations of current technologies, establishing goals to solve these problems. Finally, a new interoperability technology is presented, based on a distributed programming language (and its execution platform) that combines platform independence and self-description capabilities, which current data description languages exhibit, with behavior description (not just data), elimination of the need of a separate language for schema or interface description, complete separation of data and metadata (optimizing message transactions) and native support for binary data (eliminating the need for encoding or compression).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_5108_8_4,
  title = {Debugger Internals},
  author = {Blunden, Bill},
  booktitle = {Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code},
  year = {2012},
  pages = {157-213},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-5108-8\_4},
  url = {https://doi.org/10.1007/978-1-4302-5108-8\_4},
  abstract = {In Chapter 2,1 presented a short tutorial on using the GNU debugger. This chapter is dedicated to those curious souls who yearn to look under the hood and see how debuggers actually work. I will begin by discussing the different types of debuggers and then showing you how they perform basic debugging tasks (e.g., breakpoints and single stepping). Later on in the chapter, we will look more closely at symbolic debuggers and I will offer suggestions with regard to how they can be implemented. For those engineers interested in protecting intellectual property, I will end the chapter with a collection of techniques that can be used to thwart reverse-engineering tools.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_2909_7_1,
  title = {Introduction},
  author = {Cesare, Silvio and Xiang, Yang},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2012},
  pages = {1-6},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-2909-7\_1},
  url = {https://doi.org/10.1007/978-1-4471-2909-7\_1},
  abstract = {This chapter introduces the major applications related to software similarity and classification. The applications include malware classification, software theft detection, plagiarism detection and code clone detection. The motivations for these applications are examined and an underlying theory is formalized. This theory is based on extracting signatures from programs, known as birthmarks, that are amenable to approximate matching that tells us how similar those programs are.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_2909_7_4,
  title = {Formal Methods of Program Analysis},
  author = {Cesare, Silvio and Xiang, Yang},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2012},
  pages = {29-39},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-2909-7\_4},
  url = {https://doi.org/10.1007/978-1-4471-2909-7\_4},
  abstract = {Feature extraction is a necessary component to construct a birthmark, show similarity and classify a program as belonging to a particular class. Program analysis is an important component in feature extraction. The analysis reveals information on the syntax, semantics, and behaviour of the program being inspected. This chapter focuses on formal methods of program analysis which can be used for the purpose of property and feature extraction.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4333_5_5,
  title = {Language},
  author = {Mackey, Alex and Tulloch, William and Krishnan, Mahesh},
  booktitle = {Introducing .NET 4.5},
  year = {2012},
  pages = {103-122},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4333-5\_5},
  url = {https://doi.org/10.1007/978-1-4302-4333-5\_5},
  abstract = {One of the dominant themes throughout this release of .NET is the ability to perform work in an asynchronous manner. Each release of .NET has given us new (and easier) ways to write async code such as the Asynchronous Programming Model (APM) and the Task Asynchronous Pattern (TAP) in C\# 4.0. In the latest release, a new model using the new keywords async and await is introduced. Although this book is C\# focused we will also briefly cover the new changes in VB.NET.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_2909_7_7,
  title = {Feature Extraction},
  author = {Cesare, Silvio and Xiang, Yang},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2012},
  pages = {57-61},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-2909-7\_7},
  url = {https://doi.org/10.1007/978-1-4471-2909-7\_7},
  abstract = {In the previous chapters we have examined static and dynamic methods of program analysis. These features must be translated into mathematical representations and birthmarks to be useful. Furthermore, mathematical representations may be embedded in other mathematical types to make birthmarks more amenable to similarity comparisons and for use in classification algorithms. Another approach is to represent features using kernels. This allows for the use of classification algorithms including the support vector machine for complex data types. This chapter examines the mathematical representations that we use to describe program features.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_32469_7_2,
  title = {Automated Extraction of Abstract Behavioural Models from JMS Applications},
  author = {Albert, Elvira and Østvold, Bjarte M. and Rojas, José Miguel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {16-31},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-32469-7\_2},
  url = {https://doi.org/10.1007/978-3-642-32469-7\_2},
  abstract = {Distributed systems are hard to program, understand and analyze. Two key sources of complexity are the many possible behaviors of a system, arising from the parallel execution of its distributed nodes, and the handling of asynchronous messages exchanged between nodes. We show how to systematically construct executable models of publish/subscribe systems based on the Java Messaging Service (JMS). These models, written in the Abstract Behavioural Specification (ABS) language, capture the essentials of the messaging behavior of the original Java systems, and eliminate details not related to distribution and messages. We report on jms2abs , a tool that automatically extracts ABS models from the bytecode of JMS systems. Since the extracted models are formal and executable, they allow us to reason about the modeled JMS systems by means of tools built specifically for the modeling language. For example, we have succeeded to apply simulation, termination and resource analysis tools developed for ABS to, respectively, execute, prove termination and infer the resource consumption of the original JMS applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4419_8849_2_66,
  title = {Analysis of the Web Control Disassembly Code},
  author = {Guan, Quanlong and Zhang, Huanming and Lv, Shuanghuan},
  booktitle = {2011 International Conference in Electrics, Communication and Automatic Control Proceedings},
  year = {2012},
  pages = {521-527},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4419-8849-2\_66},
  url = {https://doi.org/10.1007/978-1-4419-8849-2\_66},
  abstract = {The research on web software security holes is becoming a hot spot. However, the source code of most commercial software is nonopen, which causes great difficulties when it comes to the detection of security holes. The analysis of the disassembly code is often the most effective way to find security holes in nonopen source procedures. In this chapter, we study on the vulnerability mining technique based on the object code, and give a new idea to the analysis of the disassembly code: With the help of the IDA Pro tool we searched for the nonsecurity call, and for the “tagged word” in the function address space derived from the ActiveX controls. After that, we established two important tables: the nonsecurity export function table and the “tagged word” table. Then we used the fuzzer to test the vulnerabilities in the web ActiveX controls. The analysis of the disassembly code in this chapter provides a good foundation for the subsequent test data engine.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_32347_8_29,
  title = {Functional Programs: Conversions between Deep and Shallow Embeddings},
  author = {Myreen, Magnus O.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {412-417},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-32347-8\_29},
  url = {https://doi.org/10.1007/978-3-642-32347-8\_29},
  abstract = {This paper presents a method which simplifies verification of deeply embedded functional programs. We present a technique by which proof-certified equations describing the effect of functional programs (shallow embeddings) can be automatically extracted from their operational semantics. Our method can be used in reverse, i.e. from shallow to deep embeddings, and thus for implementing certifying code synthesis: we have implemented a tool which maps HOL functions to equivalent Lisp functions, for which we have a verified Lisp runtime. A key benefit, in both directions, is that the verifier does not need to understand the operational semantics that gives meanings to the deep embeddings.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_2909_7_2,
  title = {Taxonomy of Program Features},
  author = {Cesare, Silvio and Xiang, Yang},
  booktitle = {SpringerBriefs in Computer Science},
  year = {2012},
  pages = {7-16},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-2909-7\_2},
  url = {https://doi.org/10.1007/978-1-4471-2909-7\_2},
  abstract = {All programs have common features and abstractions which are used to create birthmarks. Features can be divided into syntactic and semantic groups. Syntactic features concern themselves with program structure and program form. Semantic features examine the meaning of the program. In this chapter we examine those syntactic and semantic features of programs. Syntactic Features include: (1) Raw Code, (2) Abstract Syntax Trees, (3) Variables, (4) Pointers, (5) Instructions, (6) Basic Blocks, (7) Procedures, (8) Control Flow Graphs, (9) Call Graphs, and (10) Object Inheritances and Dependencies. Semantic features include: (1) API Calls, (2) Data Flow, (3) Procedure Dependence Graphs, and (4) System Dependence Graphs.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4594_0_18,
  title = {Indexers, Enumerators, and Iterators},
  author = {Gunnerson, Eric},
  booktitle = {A Programmer’s Guide to C\# 5.0},
  year = {2012},
  pages = {165-175},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4594-0\_18},
  url = {https://doi.org/10.1007/978-1-4302-4594-0\_18},
  abstract = {It is sometimes useful to be able to treat an object as if it were an array and access it by index. This can be done by writing an indexer for the object. In the same way that a property looks like a field but has accessors to perform get and set operations, an indexer looks like an array but has accessors to perform array-indexing operations.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4594_0_37,
  title = {Interop},
  author = {Gunnerson, Eric},
  booktitle = {A Programmer’s Guide to C\# 5.0},
  year = {2012},
  pages = {351-360},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4594-0\_37},
  url = {https://doi.org/10.1007/978-1-4302-4594-0\_37},
  abstract = {One of the important capabilities of C\# is being able to intemperate with existing code, whether it is COM-based or in a native DLL. This chapter provides a brief overview of how interop works.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_28798_5_19,
  title = {Automatically Resolving Virtual Function Calls in Binary Executables},
  author = {Wei, Tao and Wu, Runpu and Wang, Tielei and Zhao, Xinjian and Zou, Wei and Zheng, Weihong},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2012},
  pages = {135-140},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-28798-5\_19},
  url = {https://doi.org/10.1007/978-3-642-28798-5\_19},
  abstract = {Call graph plays an important role in interprocedural program analysis methods. However, due to the common exist of function pointers and virtual functions in large programs, call graphs used in current program analysis systems are usually incomplete and imprecise, especially in analysis systems for binary executables. In this paper, we present a scalable and effective approach to automatically resolve virtual-function calls in executables. For the benchmark used in previous studies, our approach resolved almost 100\% of reachable virtual function call-sites, whereas CodeSurfer/x86 resolved about 82\%.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_011_0158_4,
  title = {ARDrone corruption},
  author = {Deligne, Eddy},
  journal = {Journal in Computer Virology},
  year = {2012},
  volume = {8},
  number = {1-2},
  pages = {15-27},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-011-0158-4},
  url = {https://doi.org/10.1007/s11416-011-0158-4},
  abstract = {A drone is a machine which functions either by the remote control of a navigator or pilot or autonomously, that is, as a self-directing entity. Their largest use is within military applications. This machines are smaller than piloted vehicle and so are less visible or invisible (furtive). The goal of our study is to show, on a commercial drone, the effect of the miniaturization. We use the Ardrone by Parrot, and different attacks are performed, from the DOS attack to the illegal takeover of the drone. Attacks are explained and detailed, to allow the readers to replay the attacks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_658_00333_3_17,
  title = {Malware Detection in Ubiquitous Environments},
  author = {García-Cervigón, Manuel and Morales, Roberto},
  booktitle = {ISSE 2012 Securing Electronic Business Processes},
  year = {2012},
  pages = {171-179},
  publisher = {Springer Fachmedien Wiesbaden},
  doi = {10.1007/978-3-658-00333-3\_17},
  url = {https://doi.org/10.1007/978-3-658-00333-3\_17},
  abstract = {Today, almost every environment (e.g. airports, home, office, etc.) are populated with a high number of heterogeneous devices like smart-phones, sensors, laptops, tablets or hotspots. Taking advantage of the different communications capabilities that these devices have, researches have been studying how to make people collaborate in spontaneous or dynamic groups to sharing photos, discuss topics, among others. However, this plethora of devices sharing “something” opens the doors to new potential threats putting in risk important personal data or misuse of device resources. Therefore, these environments require new mechanisms able to ensure that devices are conducted safely, and that are able to detect and inform about any anomalies that might occur during an interaction.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_35362_8_34,
  title = {Portability Evaluation of Cryptographic Libraries on Android Smartphones},
  author = {Braga, Alexandre M. and Nascimento, Erick N.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {459-469},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-35362-8\_34},
  url = {https://doi.org/10.1007/978-3-642-35362-8\_34},
  abstract = {This paper shows the results of an investigation of cryptographic services for mobile devices running Android. The objective of the investigation was to assess the feasibility of sophisticated cryptographic services on modern smartphones running Android. First of all, the portability of cryptographic libraries was evaluated according to its feasibility. Second, performance measurements were taken for some of the libraries successfully ported.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_28038_2_17,
  title = {Dataflow Testing of Java Programs with DFC},
  author = {Bluemke, Ilona and Rembiszewski, Artur},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {215-228},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-28038-2\_17},
  url = {https://doi.org/10.1007/978-3-642-28038-2\_17},
  abstract = {The objective of this paper is to present a tool supporting dataflow coverage testing of Java programs. Code based (”white box”) approach to testing can be divided into two main types: control flow coverage and data flow coverage methods. Dataflow testing was introduced for structural programming languages and later adopted for object languages. Among many tools supporting code based testing of object programs, only JaBUTi and DFC (Data Flow Coverage) support dataflow testing of Java programs. DFC is a tool implemented at the Institute of Computer Science Warsaw University of Technology as an Eclipse plug-in. DFC finds all definition-uses ( def − u ) pairs in tested unit and provides also the def − u graph DUG for methods. After the execution of tests the information which def − u pairs were covered is shown. An example of usage of DFC and the comparison with JaBUTi data flow testing tool of Java program is also presented.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_33392_7_1,
  title = {APEFS: An Infrastructure for Permission-Based Filtering of Android Apps},
  author = {Meurer, Simon and Wismüller, Roland},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2012},
  pages = {1-11},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-33392-7\_1},
  url = {https://doi.org/10.1007/978-3-642-33392-7\_1},
  abstract = {The mobile device market is booming. This gains among others from the growing of application markets for those devices. In Android the applications (apps) are controlled by permissions of what they are allowed to do. The problem here is that many users do not pay attention to these permissions because they are rather complex and the user is informed about them only shortly before installing an app. In this paper we present APEFS , an infrastructure that enables a user to filter apps by permissions before trying to install them. Thereby it simplifies the usage of the permission system by allowing users to think about security and privacy before even searching for an app. We also enhance APEFS to not only filter by permissions but also by possible information flows, using static information flow analysis combined with runtime assertions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_28365_9_10,
  title = {Boosting Single Thread Performance in Mobile Processors via Reconfigurable Acceleration},
  author = {Ndu, Geoffrey and Garside, Jim},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {114-125},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-28365-9\_10},
  url = {https://doi.org/10.1007/978-3-642-28365-9\_10},
  abstract = {Mobile processors, a subclass of embedded processors, are increasingly employing multicore designs to improve performance. This often requires sacrificing resources in each CPU, degrading single thread performance which is still important according to Amdahl’s law. The traditional technique for efficiently boosting serial performance in embedded processors, dedicated hardware acceleration, is unsuitable for modern mobile processors because of the heterogeneity and the diversity of applications they run. This paper proposes ‘general purpose’ accelerators, reconfigured on an application-by-application basis, as a means of increasing single thread performance. These accelerators are placed within the datapath of CPUs and support dynamic compilation. This paper presents the design of an architecture with such accelerators and evaluates the cost/performance implications of the design.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_31128_4_20,
  title = {Pinpointing Malicious Activities through Network and System-Level Malware Execution Behavior},
  author = {Grégio, André Ricardo Abed and Afonso, Vitor Monte and Filho, Dario Simões Fernandes and de Geus, Paulo Lício and Jino, Mario and dos Santos, Rafael Duarte Coelh},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {274-285},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-31128-4\_20},
  url = {https://doi.org/10.1007/978-3-642-31128-4\_20},
  abstract = {Malicious programs pose a major threat to Internet-connected systems, increasing the importance of studying their behavior in order to fight against them. In this paper, we propose definitions to the different types of behavior that a program can present during its execution. Based on those definitions, we define suspicious behavior as the group of actions that change the state of a target system. We also propose a set of network and system-level dangerous activities that can be used to denote the malignity in suspicious behaviors, which were extracted from a large set of malware samples. In addition, we evaluate the malware samples according to their suspicious behavior. Moreover, we developed filters to translate from lower-level execution traces to the observed dangerous activities and evaluated them in the context of actual malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_21437_0_15,
  title = {Validated Compilation through Logic},
  author = {Li, Guodong},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {169-183},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-21437-0\_15},
  url = {https://doi.org/10.1007/978-3-642-21437-0\_15},
  abstract = {To reason about programs written in a language, one needs to define its formal semantics, derive a reasoning mechanism (e.g. a program logic), and maximize the proof automation. Unfortunately, a compiler may involve multiple languages and phases; it is tedious and error prone to do so for each language and each phase. We present an approach based on the use of higher order logic to ease this burden. All the Intermediate Representations (IRs) are special forms of the logic of a prover such that IR programs can be reasoned about directly in the logic. We use this technique to construct and validate an optimizing compiler. New techniques are used to compile-with-proof all the programs into the logic, e.g. a logic specification is derived automatically from the monad interpretation of a piece of assembly code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4024_2_11,
  title = {Code Analysis},
  author = {Ritchie, Stephen D.},
  booktitle = {Pro .NET Best Practices},
  year = {2011},
  pages = {231-264},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4024-2\_11},
  url = {https://doi.org/10.1007/978-1-4302-4024-2\_11},
  abstract = {This chapter provides an overview of many static and dynamic tools, technologies, and approaches, introducing both general technologies and specific tools with an emphasis on improvements they can suggest and how they can provide continuous, automated monitoring.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_34210_3_2,
  title = {Security Add-Ons for Mobile Platforms},
  author = {Adolphi, Benjamin and Langweg, Hanno},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {17-30},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-34210-3\_2},
  url = {https://doi.org/10.1007/978-3-642-34210-3\_2},
  abstract = {We give an overview of existing security software on mobile platforms in form of firewalls and antivirus software. We investigate whether these solutions increase the security on mobile platforms, what limitations the platforms’ security policies present and how current solutions work.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_4192_8_8,
  title = {Extending NuGet},
  author = {Balliauw, Maarten and Decoster, Xavier},
  booktitle = {Pro NuGet},
  year = {2012},
  pages = {207-232},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4192-8\_8},
  url = {https://doi.org/10.1007/978-1-4302-4192-8\_8},
  abstract = {In the previous Chapters, we’ve shown you how you can leverage NuGet in more advanced scenarios and how NuGet can be the tool of preference for managing external dependencies in your software projects. We’ve even touched some alternative scenarios where NuGet can be used to distribute releases and deploy them onto your server infrastructure.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_5108_8_1,
  title = {Preventative Medicine},
  author = {Blunden, Bill},
  booktitle = {Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code},
  year = {2012},
  pages = {1-69},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-5108-8\_1},
  url = {https://doi.org/10.1007/978-1-4302-5108-8\_1},
  abstract = {The role of the maintenance engineer is to exorcise the evil spirits that dwell in legacy software. Day and night, maintenance engineers are beset upon, and spited, as they forge a lonely path through the corporate landscape. Every day, they face the challenge of Repairing bugs Improving performance The first four chapters of this book are devoted to looking at the first task. The final two chapters of this book deal with the second task.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_33167_1_3,
  title = {Attack of the Clones: Detecting Cloned Applications on Android Markets},
  author = {Crussell, Jonathan and Gibler, Clint and Chen, Hao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {37-54},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-33167-1\_3},
  url = {https://doi.org/10.1007/978-3-642-33167-1\_3},
  abstract = {We present DNADroid, a tool that detects Android application copying, or “cloning”, by robustly computing the similarity between two applications. DNADroid achieves this by comparing program dependency graphs between methods in candidate applications. Using DNADroid, we found at least 141 applications that have been the victims of cloning, some as many as seven times. DNADroid has a very low false positive rate — we manually confirmed that all the applications detected are indeed clones by either visual or behavioral similarity. We present several case studies that give insight into why applications are cloned, including localization and redirecting ad revenue. We describe a case of malware being added to an application and show how DNADroid was able to detect two variants of the same malware. Lastly, we offer examples of an open source cracking tool being used in the wild.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_27940_9_18,
  title = {Alternating Control Flow Reconstruction},
  author = {Kinder, Johannes and Kravchenko, Dmitry},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {267-282},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-27940-9\_18},
  url = {https://doi.org/10.1007/978-3-642-27940-9\_18},
  abstract = {Unresolved indirect branch instructions are a major obstacle for statically reconstructing a control flow graph (CFG) from machine code. If static analysis cannot compute a precise set of possible targets for a branch, the necessary conservative over-approximation introduces a large amount of spurious edges, leading to even more imprecision and a degenerate CFG. In this paper, we propose to leverage under-approximation to handle this problem. We provide an abstract interpretation framework for control flow reconstruction that alternates between over- and under-approximation. Effectively, the framework imposes additional preconditions on the program on demand, allowing to avoid conservative over-approximation of indirect branches. We give an example instantiation of our framework using dynamically observed execution traces and constant propagation. We report preliminary experimental results confirming that our alternating analysis yields CFGs closer to the concrete CFG than pure over- or under-approximation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_30921_2_17,
  title = {AndroidLeaks: Automatically Detecting Potential Privacy Leaks in Android Applications on a Large Scale},
  author = {Gibler, Clint and Crussell, Jonathan and Erickson, Jeremy and Chen, Hao},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {291-307},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-30921-2\_17},
  url = {https://doi.org/10.1007/978-3-642-30921-2\_17},
  abstract = {As mobile devices become more widespread and powerful, they store more sensitive data, which includes not only users’ personal information but also the data collected via sensors throughout the day. When mobile applications have access to this growing amount of sensitive information, they may leak it carelessly or maliciously. Google’s Android operating system provides a permissions-based security model that restricts an application’s access to the user’s private data. Each application statically declares the sensitive data and functionality that it requires in a manifest, which is presented to the user upon installation. However, it is not clear to the user how sensitive data is used once the application is installed. To combat this problem, we present AndroidLeaks, a static analysis framework for automatically finding potential leaks of sensitive information in Android applications on a massive scale. AndroidLeaks drastically reduces the number of applications and the number of traces that a security auditor has to verify manually. We evaluate the efficacy of AndroidLeaks on 24,350 Android applications from several Android markets. AndroidLeaks found 57,299 potential privacy leaks in 7,414 Android applications, out of which we have manually verified that 2,342 applications leak private data including phone information, GPS location, WiFi data, and audio recorded with the microphone. AndroidLeaks examined these applications in 30 hours, which indicates that it is capable of scaling to the increasingly large set of available applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_27694_1_10,
  title = {Symbolic Execution of Concurrent Objects in CLP},
  author = {Albert, Elvira and Arenas, Puri and Gómez-Zamalloa, Miguel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {123-137},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-27694-1\_10},
  url = {https://doi.org/10.1007/978-3-642-27694-1\_10},
  abstract = {In the concurrent objects model, objects have conceptually dedicated processors and live in a distributed environment with unordered communication by means of asynchronous method calls. Method callers may decide at runtime when to synchronize with the reply from a call. This paper presents a CLP-based approach to symbolic execution of concurrent OO programs. Developing a symbolic execution engine for concurrent objects is challenging because it needs to combine the OO features of the language, concurrency and backtracking. Our approach consists in, first, transforming the OO program into an equivalent CLP program which contains calls to specific builtins that handle the concurrency model. The builtins are implemented in CLP and include primitives to handle asynchronous calls synchronization operations and scheduling policies, among others. Interestingly, symbolic execution of the transformed programs then relies simply on the standard sequential execution of CLP. We report on a prototype implementation within the PET system which shows the feasibility of our approach.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_12251_4_16,
  title = {Internal Normalization, Compilation and Decompilation for System \$\{\\mathcal F\}\_\{\\beta\\eta\}\$},
  author = {Berardi, Stefano and Tatsuta, Makoto},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {207-223},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-12251-4\_16},
  url = {https://doi.org/10.1007/978-3-642-12251-4\_16},
  abstract = {This paper defines a family of terms of System F which is a decompiler-normalizer for an image of System F by some injective interpretation in System F. We clarify the relationship among these terms, normalization by evaluation, and beta-eta-complete models of F.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3501_9_9,
  title = {Styling Your Application},
  author = {Anderson, Chris},
  booktitle = {Pro Business Applications with Silverlight 5},
  year = {2012},
  pages = {327-346},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3501-9\_9},
  url = {https://doi.org/10.1007/978-1-4302-3501-9\_9},
  abstract = {One of the key features of XAML is that it enables exceptional user interfaces to be designed and implemented in Silverlight. When designing the look and feel of your application however, you don’t want to have to customize each control and user interface element individually. This is where style resources come in—they enable you to maintain a core set of common styles to be used throughout your application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_32211_2_3,
  title = {Resource-Driven CLP-Based Test Case Generation},
  author = {Albert, Elvira and Gómez-Zamalloa, Miguel and Rojas, José Miguel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {25-41},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-32211-2\_3},
  url = {https://doi.org/10.1007/978-3-642-32211-2\_3},
  abstract = {Test Data Generation (TDG) aims at automatically obtaining test inputs which can then be used by a software testing tool to validate the functional behaviour of the program. In this paper, we propose resource-aware TDG, whose purpose is to generate test cases (from which the test inputs are obtained) with associated resource consumption s. The framework is parametric w.r.t. the notion of resource (it can measure memory, steps, etc.) and allows using software testing to detect bugs related to non-functional aspects of the program. As a further step, we introduce resource-driven TDG whose purpose is to guide the TDG process by taking resource consumption into account. Interestingly, given a resource policy , TDG is guided to generate test cases that adhere to the policy and avoid the generation of test cases which violate it.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3501_9_3,
  title = {The Navigation Framework},
  author = {Anderson, Chris},
  booktitle = {Pro Business Applications with Silverlight 5},
  year = {2012},
  pages = {69-92},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3501-9\_3},
  url = {https://doi.org/10.1007/978-1-4302-3501-9\_3},
  abstract = {One of the issues in the early versions of Silverlight was that when you created a new Silverlight project, you were essentially given a blank slate—with no existing user interface structure or framework to help you get started. This created quite a barrier for creating business applications in Silverlight, which typically contain complex user interfaces with numerous views that the user must navigate between. Therefore, to attempt to create a business application of any size in Silverlight 2, you had to start by creating a user interface framework.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_29336_8_5,
  title = {Debugging Tools for MIDP Java Devices},
  author = {Kallioinen, Olli and Mikkonen, Tommi},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2012},
  pages = {80-99},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-29336-8\_5},
  url = {https://doi.org/10.1007/978-3-642-29336-8\_5},
  abstract = {Mobile Java development using CLDC and MIDP can be very restricting, not only because of the more restricted libraries and older Java language, but also because some very basic development tools are not available in many situations. One of the biggest problems when debugging a midlet – a CLDC/MIDP application – is that when running a mobile Java application in a real device, stack traces are not available. Also other tools, like profiling tools, only work in certain emulators. In this paper, a set of improved tools for mobile Java development is introduced. Instrumentation, a well-known technique is used to work around the restrictions of the Java sandbox. Consequently no special support is required from the platform.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3708_2_13,
  title = {Tuning the Application Server},
  author = {Kurtz, David},
  booktitle = {PeopleSoft for the Oracle DBA},
  year = {2012},
  pages = {453-487},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3708-2\_13},
  url = {https://doi.org/10.1007/978-1-4302-3708-2\_13},
  abstract = {Chapters 2 and 12 discussed the underlying architecture of and how to configure the application server. They provide a basis for this chapter, in which I discuss some of the issues that can affect application server performance, including sizing the domain to have an appropriate number of application server processes, setting operating system kernel parameters, and load balancing.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10617_010_9065_z,
  title = {Combining static and dynamic array detection for binary synthesis with multiple memory ports},
  author = {Rotem, Nadav and Asher, Yosi Ben},
  journal = {Design Automation for Embedded Systems},
  year = {2011},
  volume = {15},
  number = {1},
  pages = {1-18},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10617-010-9065-z},
  url = {https://doi.org/10.1007/s10617-010-9065-z},
  abstract = {In High-Level Synthesis, Binary Synthesis is a method for synthesizing compiled applications for which the source code is not available. One of the advantages of FPGAs over processors is the availability of multiple internal and external memory banks. Binary synthesis tools use multiple memory banks if they are able to recover data-structures from the binary. In this work we improve the recovery of data-structures by introducing dynamic memory analysis and combining it with improved static memory analysis. We show that many applications can only be synthesized using dynamic memory analysis. We present two FPGA based architectures for implementing the bound-checking and recovery for the synthesized code. Our experiments show that the proposed technique accelerates the execution of applications which use multiple memory banks concurrently. We demonstrate that many binary applications indeed benefit from this technique.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_3519_4_1,
  title = {Introducing Silverlight},
  author = {Macdonald, Matthew},
  booktitle = {Pro Silverlight 5 in VB},
  year = {2012},
  pages = {1-33},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3519-4\_1},
  url = {https://doi.org/10.1007/978-1-4302-3519-4\_1},
  abstract = {In the introduction, you learned about the design philosophy that underpins Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4135_5_19,
  title = {Security},
  author = {Lee, Henry and Chuvyrov, Eugene},
  booktitle = {Beginning Windows Phone App Development},
  year = {2012},
  pages = {479-512},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4135-5\_19},
  url = {https://doi.org/10.1007/978-1-4302-4135-5\_19},
  abstract = {Because everything about the design and operation of Windows Phone targets consumers, it is only natural that Microsoft has carefully thought through the ways to protect Windows Phone users from both intentional and unintentional harm. Windows Phone ships with a compelling set of built-in security features that strive to accomplish that goal.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4419_7747_2_1,
  title = {Finch: A System for Evolving Java (Bytecode)},
  author = {Orlov, Michael and Sipper, Moshe},
  booktitle = {Genetic and Evolutionary Computation},
  year = {2011},
  pages = {1-16},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4419-7747-2\_1},
  url = {https://doi.org/10.1007/978-1-4419-7747-2\_1},
  abstract = {The established approach in genetic programming (GP) involves the definition of functions and terminals appropriate to the problem at hand, after which evolution of expressions using these definitions takes place. We have recently developed a system, dubbed FINCH ( F ertile Darw in ian Byte c ode H arvester), to evolutionarily improve actual, extant software, which was not intentionally written for the purpose of serving as a GP representation in particular, nor for evolution in general. This is in contrast to existing work that uses restricted subsets of the Java bytecode instruction set as a representation language for individuals in genetic programming. The ability to evolve Java programs will hopefully lead to a valuable new tool in the software engineer’s toolkit.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_28652_0_5,
  title = {A New Method for Program Inversion},
  author = {Hou, Cong and Vulov, George and Quinlan, Daniel and Jefferson, David and Fujimoto, Richard and Vuduc, Richard},
  booktitle = {Lecture Notes in Computer Science},
  year = {2012},
  pages = {81-100},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-28652-0\_5},
  url = {https://doi.org/10.1007/978-3-642-28652-0\_5},
  abstract = {Program inversion has been successfully applied to several areas such as optimistic parallel discrete event simulation (OPDES) and reverse debugging. This paper introduces a new program inversion algorithm for imperative languages, and focuses on handling arbitrary control flows and basic operations. By building a value search graph that represents recoverability relationships between variable values, we turn the problem of recovering previous values into a graph search one. Forward and reverse code is generated according to the search results. We have implemented our algorithm as part of a compiler framework named Backstroke, a C++ source-to-source translator based on ROSE compiler. Backstroke targets optimistic simulation codes and automatically generates a reverse function to recover values modified by a target function. Experimental results show that our method is effective and produces better performance than previously proposed methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4614_4699_6_5,
  title = {Manual Context Handling},
  author = {Grune, Dick and van Reeuwijk, Kees and Bal, Henri E. and Jacobs, Ceriel J. H. and Langendoen, Koen},
  booktitle = {Modern Compiler Design},
  year = {2012},
  pages = {261-296},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4614-4699-6\_5},
  url = {https://doi.org/10.1007/978-1-4614-4699-6\_5},
  abstract = {Although attribute grammars allow us to generate context processing programs automatically, their level of automation has not yet reached that of lexical analyzer and parser generators, and much context processing programming is still done at a lower level, by writing code in a traditional language like C or C++.We will give here two non-automatic methods to collect context information from the AST; one is completely manual and the other uses some reusable software. Whether this collected information is then stored in the nodes (as with an attribute grammar), stored in compiler tables, or consumed immediately is immaterial here: since it is all handy-work, it is up to the compiler writer to decide where to put the information.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_18178_8_16,
  title = {Misleading Malware Similarities Analysis by Automatic Data Structure Obfuscation},
  author = {Xin, Zhi and Chen, Huiyu and Han, Hao and Mao, Bing and Xie, Li},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {181-195},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-18178-8\_16},
  url = {https://doi.org/10.1007/978-3-642-18178-8\_16},
  abstract = {Program obfuscation techniques have been widely used by malware to dodge the scanning from anti-virus detectors. However, signature based on the data structures appearing in the runtime memory makes traditional code obfuscation useless. Laika [2] implements this signature using Bayesian unsupervised learning, which clusters similar vectors of bytes in memory into the same class. We present a novel malware obfuscation technique that automatically obfuscate the data structure layout so that memory similarities between malware programs are blurred and hardly recognized. We design and implement the automatic data structure obfuscation technique as a GNU GCC compiler extension that can automatically distinguish the obfuscability of the data structures and convert part of the unobfuscable data structures into obfuscable. After evaluated by fourteen real-world malware programs, we present that our tool maintains a high proportion of obfuscated data structures as 60.19\% for type and 60.49\% for variable.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10676_010_9229_3,
  title = {A bundle of software rights and duties},
  author = {Douglas, David M.},
  journal = {Ethics and Information Technology},
  year = {2011},
  volume = {13},
  number = {3},
  pages = {185-197},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10676-010-9229-3},
  url = {https://doi.org/10.1007/s10676-010-9229-3},
  abstract = {Like the ownership of physical property, the issues computer software ownership raises can be understood as concerns over how various rights and duties over software are shared between owners and users. The powers of software owners are defined in software licenses, the legal agreements defining what users can and cannot do with a particular program. To help clarify how these licenses permit and restrict users’ actions, here I present a conceptual framework of software rights and duties that is inspired by the terms of various proprietary, open source, and free software licenses. To clarify the relationships defined by these rights and duties, this framework distinguishes between software creators (the original developer), custodians (those who can control its use), and users (those who utilise the software). I define the various rights and duties that can be shared between these parties and how these rights and duties relate to each other. I conclude with a brief example of how this framework can be used by defining the concepts of free software and copyleft in terms of rights and duties.},
  content_type = {Article},
}


@article{springer_10_1007_s11554_011_0212_y,
  title = {A self-adaptive heterogeneous multi-core architecture for embedded real-time video object tracking},
  author = {Happe, Markus and Lübbers, Enno and Platzner, Marco},
  journal = {Journal of Real-Time Image Processing},
  year = {2013},
  volume = {8},
  number = {1},
  pages = {95-110},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11554-011-0212-y},
  url = {https://doi.org/10.1007/s11554-011-0212-y},
  abstract = {Sequential Monte Carlo (SMC) represents a principal statistical method for tracking objects in video sequences by on-line estimation of the state of a non-linear dynamic system. The performance of individual stages of the SMC algorithm is usually data-dependent, making the prediction of the performance of a real-time capable system difficult and often leading to grossly overestimated and inefficient system designs. Also, the considerable computational complexity is a major obstacle when implementing SMC methods on purely CPU-based resource constrained embedded systems. In contrast, heterogeneous multi-cores present a more suitable implementation platform. We use hybrid CPU/FPGA systems, as they can efficiently execute both the control-centric sequential as well as the data-parallel parts of an SMC application. However, even with hybrid CPU/FPGA platforms, determining the optimal HW/SW partitioning is challenging in general, and even impossible with a design time approach. Thus, we need self-adaptive architectures and system software layers that are able to react autonomously to varying workloads and changing input data while preserving real-time constraints and area efficiency. In this article, we present a video tracking application modeled on top of a framework for implementing SMC methods on CPU/FPGA-based systems such as modern platform FPGAs. Based on a multithreaded programming model, our framework allows for an easy design space exploration with respect to the HW/SW partitioning. Additionally, the application can adaptively switch between several partitionings during run-time to react to changing input data and performance requirements. Our system utilizes two variants of a add/remove self-adaptation technique for task partitioning inside this framework that achieve soft real-time behavior while trying to minimize the number of active cores. To evaluate its performance and area requirements, we demonstrate the application and the framework on a real-life video tracking case study and show that partial reconfiguration can be effectively and transparently used for realizing adaptive real-time HW/SW systems.},
  content_type = {Article},
}


@article{springer_10_1007_s11334_010_0125_0,
  title = {Software model checking without source code},
  author = {Chaki, Sagar and Ivers, James},
  journal = {Innovations in Systems and Software Engineering},
  year = {2010},
  volume = {6},
  number = {3},
  pages = {233-242},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11334-010-0125-0},
  url = {https://doi.org/10.1007/s11334-010-0125-0},
  abstract = {We present a framework, called air , for verifying safety properties of assembly language programs via software model checking. air extends the applicability of predicate abstraction and counterexample guided abstraction refinement to the automated verification of low-level software. By working at the assembly level, air allows verification of programs for which source code is unavailable—such as legacy and COTS software—and programs that use features—such as pointers, structures, and object-orientation—that are problematic for source-level software verification tools. In addition, air makes no assumptions about the underlying compiler technology. We have implemented a prototype of air and present encouraging results on several non-trivial examples.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_27204_2_8,
  title = {The Semantic Analysis Using Tree Transformation on the Objective-C Compiler},
  author = {Son, YunSik and Lee, YangSun},
  booktitle = {Communications in Computer and Information Science},
  year = {2011},
  pages = {60-68},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-27204-2\_8},
  url = {https://doi.org/10.1007/978-3-642-27204-2\_8},
  abstract = {Semantic Analysis is a process which analyzes the validity of a meaning created by combining a program’s different constituents, and this process has become indispensable component for producing a compiler. It uses the attribute grammar method or the manual method however such methodology holds limitations in terms of efficiency or automation. In this study, in order to make up for the drawbacks mentioned above, a semantic tree which includes the analyzed information will be defined and a technique to convert the abstract syntax tree used in most compilers – a result of syntax analysis – into a semantic tree will be proposed. The semantic tree transformation technique processes semantic analysis on a semantic node unit level and the semantic analysis process is carried out consistently and efficiently. In addition, the semantic tree transformation makes transformation of data structures and automation very simple.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_23602_0_9,
  title = {RICB: Integer Overflow Vulnerability Dynamic Analysis via Buffer Overflow},
  author = {Wang, Yong and Gu, Dawu and Xu, Jianping and Wen, Mi and Deng, Liwen},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2011},
  pages = {99-109},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-23602-0\_9},
  url = {https://doi.org/10.1007/978-3-642-23602-0\_9},
  abstract = {Integer overflow vulnerability will cause buffer overflow. The research on the relationship between them will help us to detect integer overflow vulnerability. We present a dynamic analysis methods RICB (Run-time Integer Checking via Buffer overflow). Our approach includes decompile execute file to assembly language; debug the execute file step into and step out; locate the overflow points and checking buffer overflow caused by integer overflow. We have implemented our approach in three buffer overflow types: format string overflow, stack overflow and heap overflow. Experiments results show that our approach is effective and efficient. We have detected more than 5 known integer overflow vulnerabilities via buffer overflow.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11554_011_0194_9,
  title = {Real-time GPU color-based segmentation of football players},
  author = {Montañés Laborda, Miguel Angel and Torres Moreno, Enrique F. and Martínez del Rincón, Jesús and Herrero Jaraba, José Elías},
  journal = {Journal of Real-Time Image Processing},
  year = {2012},
  volume = {7},
  number = {4},
  pages = {267-279},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11554-011-0194-9},
  url = {https://doi.org/10.1007/s11554-011-0194-9},
  abstract = {In this paper, we propose a multi-camera application capable of processing high resolution images and extracting features based on colors patterns over graphic processing units ( GPU ). The goal is to work in real time under the uncontrolled environment of a sport event like a football match. Since football players are composed for diverse and complex color patterns, a Gaussian Mixture Models ( GMM ) is applied as segmentation paradigm, in order to analyze sport live images and video. Optimization techniques have also been applied over the C++ implementation using profiling tools focused on high performance. Time consuming tasks were implemented over NVIDIA’s CUDA platform, and later restructured and enhanced, speeding up the whole process significantly. Our resulting code is around 4–11 times faster on a low cost GPU than a highly optimized C++ version on a central processing unit (CPU) over the same data. Real time has been obtained processing until 64 frames per second. An important conclusion derived from our study is the scalability of the application to the number of cores on the GPU .},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_04117_4_31,
  title = {Software Reverse Engineering},
  author = {Cipresso, Teodoro and Stamp, Mark},
  booktitle = {Handbook of Information and Communication Security},
  year = {2010},
  pages = {659-696},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04117-4\_31},
  url = {https://doi.org/10.1007/978-3-642-04117-4\_31},
  abstract = {Software reverse engineering (SRE) is the practice of analyzing a software system, either in whole or in part, to extract design and implementation information. A typical SRE scenario would involve a software module that has worked for years and carries several rules of a business in its lines of code; unfortunately the source code of the application has been lost – what remains is “native” or “binary” code. Reverse engineering skills are also used to detect and neutralize viruses and malware, and to protect intellectual property. Computer programmers proficient in SRE will be needed should software components like these need to be maintained, enhanced, or reused. It became frightfully apparent during the Y2K crisis that reverse engineering skills were not commonly held amongst programmers. Since that time, much research has been under way to formalize just what types of activities fall into the category of reverse engineering, so that these skills could be taught to computer programmers and testers. To help address the lack of SRE education, several peer-reviewed articles on SRE, software re-engineering, software reuse, software maintenance, software evolution, and software security were gathered with the objective of developing relevant, practical exercises for instructional purposes. The research revealed that SRE is fairly well described and all related activities mostly fall into one of two categories: software-development-related and software-security-related. Hands-on reversing exercises were developed in the spirit of these two categories with the goal of providing a baseline education in reversing both Wintel machine code and Java bytecode.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_4459_2_4,
  title = {Garbage Collection},
  author = {Goldshtein, Sasha and Zurbalev, Dima and Flatow, Ido},
  booktitle = {Pro .NET Performance},
  year = {2012},
  pages = {91-144},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-4459-2\_4},
  url = {https://doi.org/10.1007/978-1-4302-4459-2\_4},
  abstract = {In this chapter, we will examine the .NET garbage collector (GC), one of the primary mechanisms affecting the performance of .NET applications. While freeing developers from worrying about memory deallocation, the GC introduces new challenges for constructing deterministically well-behaving programs in which performance is paramount. First, we will review the types of GC available in the CLR, and see how adapting an application to the GC can be very beneficial in terms of overall GC performance and pause times. Next, we’ll see how generations affect GC performance and how to tune applications accordingly. Toward the end of the chapter we will examine the APIs available for controlling the GC directly, as well as the subtleties involved in correctly using nondeterministic finalization.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_24586_2_5,
  title = {Embedded Software Security through Key-Based Control Flow Obfuscation},
  author = {Chakraborty, Rajat Subhra and Narasimhan, Seetharam and Bhunia, Swarup},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {30-44},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-24586-2\_5},
  url = {https://doi.org/10.1007/978-3-642-24586-2\_5},
  abstract = {Protection against software piracy and malicious modification of software is proving to be a great challenge for resource-constrained embedded systems. In this paper, we develop a non-cryptographic, key-based, control flow obfuscation technique, which can be implemented by computationally efficient means, and is capable of operating with minimal hardware support. The scheme is based on matching a series of expected keys in sequence, similar to the unlocking process in a combination lock, and provides high levels of resistance to static and dynamic analyses. It is capable of protecting embedded software against both piracy as well as non-self-replicating malicious modifications. Simulation results on a set of MIPS assembly language programs show that the technique is capable of providing high levels of security at nominal computational overhead and about 10\% code-size increase.},
  content_type = {Conference paper},
}


@article{springer_10_1134_s0361768809020066,
  title = {Automatic reconstruction of data types in the decompilation problem},
  author = {Dolgova, E. N. and Chernov, A. V.},
  journal = {Programming and Computer Software},
  year = {2009},
  volume = {35},
  number = {2},
  pages = {105-119},
  publisher = {Pleiades Publishing Ltd},
  doi = {10.1134/s0361768809020066},
  url = {https://doi.org/10.1134/s0361768809020066},
  abstract = {An algorithm for the automatic reconstruction of data types from the assembler code produced by a C compiler is described. The types of the variables that are placed on the stack and in the static memory are reconstructed using an iterative algorithm that uses a lattice over the properties of the data types. The derived data types are reconstructed by constructing the set of possible offsets of the elements of these types (fields in the case of structures and array elements in the case of arrays). This algorithm is used in the tool for decompiling assembler codes into C that is currently developed by the authors.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_22170_5_18,
  title = {A Framework for Defining Malware Behavior Using Run Time Analysis and Resource Monitoring},
  author = {Zolkipli, Mohamad Fadli and Jantan, Aman},
  booktitle = {Communications in Computer and Information Science},
  year = {2011},
  pages = {199-209},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-22170-5\_18},
  url = {https://doi.org/10.1007/978-3-642-22170-5\_18},
  abstract = {Malware analysis is the process to investigate malware operation in order to learn and understand that malicious intent. Two common techniques that can be used to analyze malware are static analysis and dynamic analysis. Nowadays, many malware writers try to avoid security checking by implement techniques such as anti-reverse engineering, packing and encryption. It was make static analysis difficult to be implemented. In this paper, we propose a new framework to analyze malware by using dynamic approach. This framework will define malware behavior through run time analysis and resource monitoring. The contribution of this study is the new framework for defining malware behavior based on operation and target operation of the malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3910_9_4,
  title = {Touring Language APIs},
  author = {Friesen, Jeff},
  booktitle = {Beginning Java 7},
  year = {2011},
  pages = {227-318},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3910-9\_4},
  url = {https://doi.org/10.1007/978-1-4302-3910-9\_4},
  abstract = {Java’s standard class library provides various language-oriented APIs. Most of these APIs reside in the java.lang package and its subpackages, although a few APIs reside in java.math. Chapter 4 first introduces you to the java.lang/subpackage Math and StrictMath, Package, Primitive Type Wrapper Class, Reference, Reflection, String, StringBuffer and StringBuilder, System, and Threading APIs. This Chapter then introduces you to java.math’s BigDecimal and BigInteger APIs.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10009_011_0188_8,
  title = {SMT solvers: new oracles for the HOL theorem prover},
  author = {Weber, Tjark},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2011},
  volume = {13},
  number = {5},
  pages = {419-429},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10009-011-0188-8},
  url = {https://doi.org/10.1007/s10009-011-0188-8},
  abstract = {This paper describes an integration of Satisfiability Modulo Theories (SMT) solvers with the HOL4 theorem prover. Proof obligations are passed from the interactive HOL4 prover to the SMT solver, which can often prove them automatically. This makes state-of-the-art SMT solving techniques available to users of the HOL4 system, thereby increasing the degree of automation for a substantial fragment of its logic. We compare a translation to Yices’s native input format with a translation to SMT-LIB format.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4419_1539_9_8,
  title = {Specification and Verification of ARM Hardware and Software},
  author = {Fox, Anthony C. J. and Gordon, Michael J. C. and Myreen, Magnus O.},
  booktitle = {Design and Verification of Microprocessor Systems for High-Assurance Applications},
  year = {2010},
  pages = {221-247},
  publisher = {Springer US},
  doi = {10.1007/978-1-4419-1539-9\_8},
  url = {https://doi.org/10.1007/978-1-4419-1539-9\_8},
  abstract = {The ARM verification project started in 2000 with the aim of seeing whether existing mechanised formal specification and verification methods could be applied to a commercial off-the-shelf processor. After succeeding in formally verifying that a model of the ARM6 micro-architecture correctly implemented a model of the ARMv3 instruction set architecture (ISA), the project gradually moved away from processor verification to software verification. Models of relatively recent ISAs were specified, and a code verification methodology is being developed, where the semantics of code execution is given by the processor ISA model. The long-term goal, similar to that of the pioneering CLI stack project, is to create systems on bare metal with as much as possible formally modelled and verified. The current case study is implementing a simple Lisp machine in ARM machine code. This chapter is an overview of the Cambridge ARM project together with some technical highlights that have emerged from the research.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_3211_7_11,
  title = {Advanced Build Techniques},
  author = {King, Chris},
  booktitle = {Advanced BlackBerry 6 Development},
  year = {2011},
  pages = {359-375},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3211-7\_11},
  url = {https://doi.org/10.1007/978-1-4302-3211-7\_11},
  abstract = {Whether you run a one-person programming shop or work for a multinational corporation, your BlackBerry experience will depend on building and maintaining software. In Chapter 10 you saw how applications can grow more complicated as you increase the number and variety of users you target. This chapter looks at the other side of the problem: how to manage your project and run it efficiently.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2484_6_11,
  title = {Flash Security},
  author = {Elrom, Elad},
  booktitle = {AdvancED Flex 4},
  year = {2010},
  pages = {385-404},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2484-6\_11},
  url = {https://doi.org/10.1007/978-1-4302-2484-6\_11},
  abstract = {Flash has become very popular among developers as it is available on many devices, thanks to the Open Screen Project. In fact, some people estimate that there are as many as two million Flash developers as of 2010. Unfortunately, just as with any mainstream technology, it is a big, inviting target for attackers to try to exploit.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_22424_9_6,
  title = {Biting the Hand That Serves You: A Closer Look at Client-Side Flash Proxies for Cross-Domain Requests},
  author = {Johns, Martin and Lekies, Sebastian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {85-103},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-22424-9\_6},
  url = {https://doi.org/10.1007/978-3-642-22424-9\_6},
  abstract = {Client-side Flash proxies provide an interface for JavaScript applications to utilize Flash’s cross-domain HTTP capabilities. However, the subtle differences in the respective implementations of the same-origin policy and the insufficient security architecture of the JavaScript-to-Flash interface lead to potential security problems. We comprehensively explore these problems and conduct a survey of five existing proxy implementation. Furthermore, we propose techniques to avoid the identified security pitfalls and to overcome the untrustworthy interface between the two technologies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_18070_5_7,
  title = {Sawja: Static Analysis Workshop for Java},
  author = {Hubert, Laurent and Barré, Nicolas and Besson, Frédéric and Demange, Delphine and Jensen, Thomas and Monfort, Vincent and Pichardie, David and Turpin, Tiphaine},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {92-106},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-18070-5\_7},
  url = {https://doi.org/10.1007/978-3-642-18070-5\_7},
  abstract = {Static analysis is a powerful technique for automatic verification of programs but raises major engineering challenges when developing a full-fledged analyzer for a realistic language such as Java . Efficiency and precision of such a tool rely partly on low level components which only depend on the syntactic structure of the language and therefore should not be redesigned for each implementation of a new static analysis. This paper describes the Sawja library: a static analysis workshop fully compliant with Java 6 which provides OCaml modules for efficiently manipulating Java bytecode programs. We present the main features of the library, including i) efficient functional data-structures for representing a program with implicit sharing and lazy parsing, ii) an intermediate stack-less representation, and iii) fast computation and manipulation of complete programs. We provide experimental evaluations of the different features with respect to time, memory and precision.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_22863_6_20,
  title = {A Verified Runtime for a Verified Theorem Prover},
  author = {Myreen, Magnus O. and Davis, Jared},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {265-280},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-22863-6\_20},
  url = {https://doi.org/10.1007/978-3-642-22863-6\_20},
  abstract = {Theorem provers, such as ACL2, HOL, Isabelle and Coq, rely on the correctness of runtime systems for programming languages like ML, OCaml or Common Lisp. These runtime systems are complex and critical to the integrity of the theorem provers. In this paper, we present a new Lisp runtime which has been formally verified and can run the Milawa theorem prover. Our runtime consists of 7,500 lines of machine code and is able to complete a 4 gigabyte Milawa proof effort. When our runtime is used to carry out Milawa proofs, less unverified code must be trusted than with any other theorem prover. Our runtime includes a just-in-time compiler, a copying garbage collector, a parser and a printer, all of which are HOL4-verified down to the concrete x86 code. We make heavy use of our previously developed tools for machine-code verification. This work demonstrates that our approach to machine-code verification scales to non-trivial applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_21952_8_16,
  title = {Static Dominance Inference},
  author = {Milanova, Ana and Vitek, Jan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {211-227},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-21952-8\_16},
  url = {https://doi.org/10.1007/978-3-642-21952-8\_16},
  abstract = {Dominance, the property that all paths to a given object must go through another object, is at the heart of ownership type disciplines. While ownership types have received abundant attention, ownership inference remains an open problem, and crucial questions about the practical impact of ownership remain unanswered. We argue that a static program analysis that infers dominance is a crucial first step to ownership types inference. This paper describes an algorithm for statically computing dominance relations and shows that it can be used as part of an ownership inference algorithm.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_19440_5_20,
  title = {Translator Generation Using ART},
  author = {Johnstone, Adrian and Scott, Elizabeth},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {306-315},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-19440-5\_20},
  url = {https://doi.org/10.1007/978-3-642-19440-5\_20},
  abstract = {ART (Ambiguity Resolved Translators) is a new translator generator tool which provides fast generalised parsing based on an extended GLL algorithm and automatic generation of tree traversers for manipulating abstract syntax. The input grammars to ART comprise modular sets of context free grammar rules, enhanced with regular expressions and annotations that describe disambiguation and tree modification operations using the TIF (Tear-Insert-Fold) formalism. ART generates a GLL parser for the input grammar along with an output grammar whose derivation trees are the abstract trees specified by the TIF tree modification operations.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3597_2_19,
  title = {Security},
  author = {Lee, Henry and Chuvyrov, Eugene},
  booktitle = {Beginning Windows Phone 7 Development},
  year = {2011},
  pages = {439-470},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3597-2\_19},
  url = {https://doi.org/10.1007/978-1-4302-3597-2\_19},
  abstract = {Because everything about the design and operation of Windows Phone 7 targets consumers, it is only natural that Microsoft has carefully thought through the ways to protect consumers from both intended and unintentional harm. Windows Phone 7 ships with a compelling set of built-in security features that go towards accomplishing that goal. The capabilities of the Windows Phone 7 platform allow the data to be protected both in transit and on the device. Because of the centralized application certification process, consumers gain confidence that no malicious applications are downloaded and installed on their devices (unlike some competing platforms, which are increasingly becoming infested with malware). And should the phone be lost or stolen, each device comes with a free web-based tool that allows you to remotely control the phone, including locking and wiping all data on that phone.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_20551_4_7,
  title = {Compositional CLP-Based Test Data Generation for Imperative Languages},
  author = {Albert, Elvira and Gómez-Zamalloa, Miguel and Rojas, José Miguel and Puebla, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2011},
  pages = {99-116},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-20551-4\_7},
  url = {https://doi.org/10.1007/978-3-642-20551-4\_7},
  abstract = {Glass-box test data generation (TDG) is the process of automatically generating test input data for a program by considering its internal structure. This is generally accomplished by performing symbolic execution of the program where the contents of variables are expressions rather than concrete values. The main idea in CLP-based TDG is to translate imperative programs into equivalent CLP ones and then rely on the standard evaluation mechanism of CLP to symbolically execute the imperative program. Performing symbolic execution on large programs becomes quickly expensive due to the large number and the size of paths that need to be explored. In this paper, we propose compositional reasoning in CLP-based TDG where large programs can be handled by testing parts (such as components, modules, libraries, methods, etc.) separately and then by composing the test cases obtained for these parts to get the required information on the whole program. Importantly, compositional reasoning also gives us a practical solution to handle native code, which may be unavailable or written in a different programming language. Namely, we can model the behavior of a native method by means of test cases and compositional reasoning is able to use them.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_15057_9_11,
  title = {To Goto Where No Statement Has Gone Before},
  author = {Barnett, Mike and Leino, K. Rustan M.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {157-168},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-15057-9\_11},
  url = {https://doi.org/10.1007/978-3-642-15057-9\_11},
  abstract = {This paper presents a method for deriving an expression from the low-level code compiled from an expression in a high-level language. The input is the low-level code represented as blocks of code connected by goto statements, i.e. , a control flow graph (CFG). The derived expression is in a form that can be used as input to an automatic theorem prover. The method is useful for program verification systems that take as input both programs and specifications after they have been compiled from a high-level language. This is the case for systems that encode specifications in an existing programming language and do not have a special compiler. The method always produces an expression, unlike the heuristics for decompilation which may fail. It is efficient: the resulting expression is linear in the size of the CFG by maintaining all sharing of subgraphs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_21424_0_13,
  title = {Retrofitting Security in COTS Software with Binary Rewriting},
  author = {O’Sullivan, Pádraig and Anand, Kapil and Kotha, Aparna and Smithson, Matthew and Barua, Rajeev and Keromytis, Angelos D.},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2011},
  pages = {154-172},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-21424-0\_13},
  url = {https://doi.org/10.1007/978-3-642-21424-0\_13},
  abstract = {We present a practical tool for inserting security features against low-level software attacks into third-party, proprietary or otherwise binary-only software. We are motivated by the inability of software users to select and use low-overhead protection schemes when source code is unavailable to them, by the lack of information as to what (if any) security mechanisms software producers have used in their toolchains, and the high overhead and inaccuracy of solutions that treat software as a black box. Our approach is based on SecondWrite , an advanced binary rewriter that operates without need for debugging information or other assist. Using SecondWrite, we insert a variety of defenses into program binaries. Although the defenses are generally well known, they have not generally been used together because they are implemented by different (non-integrated) tools. We are also the first to demonstrate the use of such mechanisms in the absence of source code availability. We experimentally evaluate the effectiveness and performance impact of our approach. We show that it stops all variants of low-level software attacks at a very low performance overhead, without impacting original program functionality.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_90_481_3913_2_5,
  title = {Dynamic Detection and Reconfiguration},
  author = {Schneider Beck Fl., Antonio Carlos and Carro, Luigi},
  booktitle = {Dynamic Reconfigurable Architectures and Transparent Optimization Techniques},
  year = {2010},
  pages = {119-130},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-90-481-3913-2\_5},
  url = {https://doi.org/10.1007/978-90-481-3913-2\_5},
  abstract = {As very diverse applications have to be executed in the same computational structure, the pressure for dynamic modifications in the reconfigurable logic increases, since fast adaptability is key to sustain fast execution with the lowest possible power dissipation. This proves that the main strategy to bring reconfigurable systems to be used as mainstream computing is to rely on dynamic optimization techniques, such as the ones already presented. Therefore, in this chapter two approaches that use reconfigurable fabric together with a mechanism that somehow reassembles the behavior of the dynamic optimization techniques are discussed, as well as their basic structure, granularity, communication issues, how the binary translation mechanism works and their potential gains in performance and energy.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4419_8837_9_2,
  title = {M3-SCoPE: Performance Modeling of Multi-Processor Embedded Systems for Fast Design Space Exploration},
  author = {Posadas, Hector and Real, Sara and Villar, Eugenio},
  booktitle = {Multi-objective Design Space Exploration of Multiprocessor SoC Architectures},
  year = {2011},
  pages = {19-50},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4419-8837-9\_2},
  url = {https://doi.org/10.1007/978-1-4419-8837-9\_2},
  abstract = {Design Space Exploration for complex, multi-processor embedded Systems demands new modeling, simulation, performance estimation tools and design methodologies. Recently approved as IEEE 1666 standard, SystemC has proven to be a powerful language for system modeling and simulation. This chapter presents M3-SCoPE: a SystemC framework for platform modeling, SW source-code behavioral simulation and performance estimation of multi-processor embedded systems. Using M3-SCoPE, the application SW running on the different processors of the platform can be simulated efficiently in close interaction with the rest of the platform components. In this way, fast and sufficiently accurate performancemetrics of the system are obtained. These metrics are then delivered to the Design Space Exploration (DSE) tools to evaluate the quality of the different configuration in order to select the best ones.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2526_3_1,
  title = {Application Development},
  author = {Jones, Allen and Freeman, Adam},
  booktitle = {Visual C\# 2010 Recipes},
  year = {2010},
  pages = {1-51},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2526-3\_1},
  url = {https://doi.org/10.1007/978-1-4302-2526-3\_1},
  abstract = {This chapter covers some of the fundamental activities you will need to perform when developing your C\# solutions. The recipes in this chapter describe how to do the following: Use the C\# command-line compiler to build console and Windows Forms applications (recipes 1-1 and 1-2) Create and use code modules and libraries (recipes 1-3 and 1-4) Access command-line arguments from within your applications (recipe 1-5) Use compiler directives and attributes to selectively include code at build time (recipe 1-6) Access program elements built in other languages whose names conflict with C\# keywords (recipe 1-7) Give assemblies strong names and verify strong-named assemblies (recipes 1-8, 1-9, 1-10, and 1-11) Sign an assembly with a Microsoft Authenticode digital signature (recipes 1-12 and 1-13) Manage the shared assemblies that are stored in the global assembly cache (recipe 1-14) Prevent people from decompiling your assembly (recipe 1-15) Manipulate the appearance of the console (recipe 1-16) Create static, anonymous, and dynamically expandable types (recipes 1-17, 1-18, and 1-19) Define automatically implemented properties (recipe 1-20) Overload an operator and implement a custom conversion operator (recipes 1-21 and 1-22) Handle an event with an anonymous function (recipe 1-23) Implement a customer indexer (recipe 1-24)},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_12015_2_7,
  title = {Innovative PLC Programming Systems},
  author = {John, Karl-Heinz and Tiegelkamp, Michael},
  booktitle = {IEC 61131-3: Programming Industrial Automation Systems},
  year = {2010},
  pages = {249-285},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-12015-2\_7},
  url = {https://doi.org/10.1007/978-3-642-12015-2\_7},
  abstract = {This chapter goes beyond the specifications of IEC 61131-3 and outlines further requirements placed on programming systems in the marketplace. These mainly stem from the special conditions to be met in the PLC environment; requirements and solutions are presented based on the IEC 61131-3 programming culture.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_009_0126_4,
  title = {Automatic binary deobfuscation},
  author = {Guillot, Yoann and Gazet, Alexandre},
  journal = {Journal in Computer Virology},
  year = {2010},
  volume = {6},
  number = {3},
  pages = {261-276},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-009-0126-4},
  url = {https://doi.org/10.1007/s11416-009-0126-4},
  abstract = {This paper gives an overview of our research in the automation of the process of software protection analysis. We will focus more particularly on the problem of obfuscation. Our current approach is based on a local semantic analysis, which aims to rewrite the binary code in a simpler (easier to understand) way. This approach has the advantage of not relying on a manual search for “patterns” of obfuscation. This way of manipulating the code is, at the end, quite similar to the optimising stage of most of compilers. We will exhibit concrete results based on the development of a prototype and its application to a test target. Current limitations and future prospects will be discussed in as well.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_90_481_3660_5_18,
  title = {Aspect Modification of an EAR Application a},
  author = {Bluemke, Ilona and Billewicz, Konrad},
  booktitle = {Advanced Techniques in Computing Sciences and Software Engineering},
  year = {2010},
  pages = {105-110},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-90-481-3660-5\_18},
  url = {https://doi.org/10.1007/978-90-481-3660-5\_18},
  abstract = {We propose aspect modification of compiled Java programs for which source code and documentation are not available. Aspect oriented programming is used to trace the program execution and identify points, in which aspects implementing new functionalities should be applied. A special tool for aspect oriented program tracing was designed and implemented. A modification in an real Enterprise Application Archive (EAR), compiled, without source code and documentation is presented in this paper. Advantages and disadvantages of described concepts are pointed out.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_17502_2_12,
  title = {An Analysis of the iKee.B iPhone Botnet},
  author = {Porras, Phillip and Saïdi, Hassen and Yegneswaran, Vinod},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2010},
  pages = {141-152},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-17502-2\_12},
  url = {https://doi.org/10.1007/978-3-642-17502-2\_12},
  abstract = {We present an analysis of the iKee.B (duh) Apple iPhone bot client, captured on November 25, 2009. The bot client was released throughout several countries in Europe, with the initial purpose of coordinating its infected iPhones via a Lithuanian botnet server. This report details the logic and function of iKee’s scripts, its configuration files, and its two binary executables, which we have reverse engineered to an approximation of their C source code implementation. The iKee bot is one of the latest offerings in smartphone malware, in this case targeting jailbroken iPhones. While its implementation is simple in comparison to the latest generation of PC-based malware, its implications demonstrate the potential extension of crimeware to this valuable new frontier of handheld consumer devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3832_4_11,
  title = {Enhancing Security},
  author = {Coffin, David},
  booktitle = {Expert Oracle and Java Security},
  year = {2011},
  pages = {267-328},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3832-4\_11},
  url = {https://doi.org/10.1007/978-1-4302-3832-4\_11},
  abstract = {Every year, the president of my company gives us a pep talk. Generally, he talks about the good things we’ve done throughout the year as a company, and shares an itemized list of our failures or less-than-stellar moments. At the end of the talk, the president recognizes the skills and commitment of the employees and encourages us not only to continue doing what we’re doing, but to do even more, taking on every new challenge.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_17164_2_14,
  title = {Interprocedural Control Flow Reconstruction},
  author = {Flexeder, Andrea and Mihaila, Bogdan and Petter, Michael and Seidl, Helmut},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {188-203},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-17164-2\_14},
  url = {https://doi.org/10.1007/978-3-642-17164-2\_14},
  abstract = {In this paper we provide an interprocedural algorithm for reconstructing the control flow of assembly code in presence of indirect jumps, call instructions and returns. In case that the underlying assembly code is the output of a compiler, indirect jumps primarily originate from high-level switch statements. For these, our methods succeed in resolving indirect jumps with high accuracy. We show that by explicitly handling procedure calls, additional precision is gained at calls to procedures exiting the program as well as through the analysis of side-effects of procedures onto the local state of the caller. Our prototypical implementation applied to real-world examples shows that this approach yields reliable and meaningful results with decent efficiency.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_12015_2_10,
  title = {Contents of CD-ROM and DVD},
  author = {John, Karl-Heinz and Tiegelkamp, Michael},
  booktitle = {IEC 61131-3: Programming Industrial Automation Systems},
  year = {2010},
  pages = {305-307},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-12015-2\_10},
  url = {https://doi.org/10.1007/978-3-642-12015-2\_10},
  abstract = {The DVD and CD-ROM enclosed in this book contain the following information, examples and programs: 1) DVD STEP 7 Professional 2006 SR5 Engineering Software for SIMATIC S7 / M7 / C7 1 as a system for PLC programming with IEC 61131-3 using the languages: IL, KOP, FUP, S7-GRAPH and S7-SCL as well as PLC simulation PLCSIM and the add-on iMAP. The package is completed with the Automation License Manager and electronic manuals; running under Windows XP Professional SP3, Windows Server 2003 SP2 standard edition and Windows Vista 32 Bit Ultimate/Business with/without SP1. 2) CD-ROM: Open PCS , a system (full version) for programming with IEC 61131-3 , running on any standard Windows PC, using the languages: IL, LD, FBD, SFC, ST and CFC2; running under Windows Server 2003, Windows XP SP2 or Windows Vista 32bit. PLC simulation SmartPLC is available for simulating the programs on a PC. The dedicated OPC server SmartPLC/OPC is only required, if additional third-party hardware and/or external OPC clients are connected. 3) CD-ROM: Examples of this book as source files, 4) CD-ROM: Buyer's Guide for IEC 61131-3-compliant programming systems. File README.TXT on the CD contains important information about the installation and use of the files and programs. It shows how to copy the files onto hard disk and gives tips on how to use the examples and the buyer's guide.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_84882_825_4_5,
  title = {Science, Technology, and Reality in The Matrix Online and Tabula Rasa},
  author = {Bainbridge, William Sims},
  booktitle = {Human-Computer Interaction Series},
  year = {2010},
  pages = {57-70},
  publisher = {Springer London},
  doi = {10.1007/978-1-84882-825-4\_5},
  url = {https://doi.org/10.1007/978-1-84882-825-4\_5},
  abstract = {All virtual worlds possess implicit theories of the nature of reality and of the central values of human life, but the The Matrix Online (MxO) and Tabula Rasa (TR) are notable for having especially well-developed philosophical motivations. Extensive participant-observation research in both revealed that they postulate hidden realities beneath the world of appearances, shared a concern over whether technology would liberate or enslave humanity, and offered players distinctive programming languages with which they could empower themselves. Avatars in both were protean, in different ways capable of evolving along multiple lines of development, and operating secondary avatars that provide challenging metaphors of the ways humans exploit each other. MxO draws heavily upon European theories of the social construction of reality and false consciousness, whereas TR draws upon the ideology of the spaceflight social movement and went so far as to transport the avatars to the International Space Station orbiting the real world.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2887_5_7,
  title = {Overview of ASP.NET MVC Projects},
  author = {Sanderson, Steven},
  booktitle = {Pro ASP.NET MVC 2 Framework},
  year = {2010},
  pages = {215-233},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2887-5\_7},
  url = {https://doi.org/10.1007/978-1-4302-2887-5\_7},
  abstract = {You’ve just experienced building a good-sized MVC application, SportsStore, and picked up a lot of ASP.NET MVC development knowledge along the way. However, this was just one example, and it didn’t cover every feature and facility in the MVC Framework. To progress, we’ll now take a more systematic look at each aspect of the framework. In Chapter 8, you’ll learn more about the core routing system. In Chapters 9 and 10, you’ll see what’s on offer as you build controllers and actions. Chapter 11 focuses on the framework’s built-in view engine. Chapter 12 describes what ASP.NET MVC does for your models. The rest of the book considers other common web development tasks and scenarios, including security and deployment.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_15257_3_17,
  title = {A Metric-Based Scheme for Evaluating Tamper Resistant Software Systems},
  author = {Myles, Gideon and Jin, Hongxia},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2010},
  pages = {187-202},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-15257-3\_17},
  url = {https://doi.org/10.1007/978-3-642-15257-3\_17},
  abstract = {The increase use of software tamper resistance techniques to protect software against undesired attacks comes an increased need to understand more about the strength of these tamper resistance techniques. Currently the understanding is rather general. In this paper we propose a new software tamper resistance evaluation technique. Our main contribution is to identify a set of issues that a tamper resistant system must deal with and show why these issues must be dealt with in order to secure a software system. Using the identified issues as criteria, we can measure the actual protection capability of a TRS system implementation and provide guidance on potential improvements on the implementation. We can also enable developers to compare the protection strength between differently implemented tamper resistance systems. While the set of criteria we identified in this paper is by no means complete, our framework allows easy extension of adding new criteria in future.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_11999_6_8,
  title = {Fast and Accurate Strong Termination Analysis with an Application to Partial Evaluation},
  author = {Leuschel, Michael and Tamarit, Salvador and Vidal, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {111-127},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-11999-6\_8},
  url = {https://doi.org/10.1007/978-3-642-11999-6\_8},
  abstract = {A logic program strongly terminates if it terminates for any selection rule. Clearly, considering a particular selection rule|like Prolog’s leftmost selection rule|allows one to prove more goals terminating. In contrast, a strong termination analysis gives valuable information for those applications in which the selection rule cannot be fixed in advance (e.g., partial evaluation, dynamic selection rules, parallel execution). In this paper, we introduce a fast and accurate size-change analysis that can be used to infer conditions for both strong termination and strong quasi-termination of logic programs. We also provide several ways to increase the accuracy of the analysis without sacrificing scalability. In the experimental evaluation, we show that the new algorithm is up to three orders of magnitude faster than the previous implementation, meaning that we can efficiently deal with programs exceeding 25,000 lines of Prolog.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10990_011_9080_1,
  title = {Context-sensitive analysis without calling-context},
  author = {Lakhotia, Arun and Boccardo, Davidson R. and Singh, Anshuman and Manacero, Aleardo},
  journal = {Higher-Order and Symbolic Computation},
  year = {2010},
  volume = {23},
  number = {3},
  pages = {275-313},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10990-011-9080-1},
  url = {https://doi.org/10.1007/s10990-011-9080-1},
  abstract = {Since Sharir and Pnueli, algorithms for context-sensitivity have been defined in terms of ‘valid’ paths in an interprocedural flow graph. The definition of valid paths requires atomic call and ret statements, and encapsulated procedures. Thus, the resulting algorithms are not directly applicable when behavior similar to call and ret instructions may be realized using non-atomic statements, or when procedures do not have rigid boundaries, such as with programs in low level languages like assembly or RTL. We present a framework for context-sensitive analysis that requires neither atomic call and ret instructions, nor encapsulated procedures. The framework presented decouples the transfer of control semantics and the context manipulation semantics of statements. A new definition of context-sensitivity, called stack contexts, is developed. A stack context, which is defined using trace semantics, is more general than Sharir and Pnueli’s interprocedural path based calling-context. An abstract interpretation based framework is developed to reason about stack-contexts and to derive analogues of calling-context based algorithms using stack-context. The framework presented is suitable for deriving algorithms for analyzing binary programs, such as malware, that employ obfuscations with the deliberate intent of defeating automated analysis. The framework is used to create a context-sensitive version of Venable et al.’s algorithm for analyzing x86 binaries without requiring that a binary conforms to a standard compilation model for maintaining procedures, calls, and returns. Experimental results show that a context-sensitive analysis using stack-context performs just as well for programs where the use of Sharir and Pnueli’s calling-context produces correct approximations. However, if those programs are transformed to use call obfuscations, a context-sensitive analysis using stack-context still provides the same, correct results and without any additional overhead.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_00515_2_2,
  title = {Test Data Generation of Bytecode by CLP Partial Evaluation},
  author = {Albert, Elvira and Gómez-Zamalloa, Miguel and Puebla, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {4-23},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-00515-2\_2},
  url = {https://doi.org/10.1007/978-3-642-00515-2\_2},
  abstract = {We employ existing partial evaluation (PE) techniques developed for Constraint Logic Programming (CLP) in order to automatically generate test-case generators for glass-box testing of bytecode. Our approach consists of two independent CLP PE phases. (1) First, the bytecode is transformed into an equivalent (decompiled) CLP program. This is already a well studied transformation which can be done either by using an ad-hoc decompiler or by specialising a bytecode interpreter by means of existing PE techniques. (2) A second PE is performed in order to supervise the generation of test-cases by execution of the CLP decompiled program. Interestingly, we employ control strategies previously defined in the context of CLP PE in order to capture coverage criteria for glass-box testing of bytecode. A unique feature of our approach is that, this second PE phase allows generating not only test-cases but also test-case generators . To the best of our knowledge, this is the first time that (CLP) PE techniques are applied for test-case generation as well as to generate test-case generators.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_2929_2_14,
  title = {Distributing Your Game},
  author = {Dawes, Adam},
  booktitle = {Windows Mobile Game Development},
  year = {2010},
  pages = {385-410},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2929-2\_14},
  url = {https://doi.org/10.1007/978-1-4302-2929-2\_14},
  abstract = {Over the course of this book, we have now covered a wide range of different game programming techniques and technologies, from coping with device diversity through to 3D graphics to using sound and input and lots more. I hope you are now ready and eager to start writing your own games using everything that you have learned.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2520_1_2,
  title = {Reflection},
  author = {Ganz, Carl},
  booktitle = {Pro Dynamic .NET 4.0 Applications},
  year = {2010},
  pages = {29-57},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2520-1\_2},
  url = {https://doi.org/10.1007/978-1-4302-2520-1\_2},
  abstract = {The .NET Reflection classes provide you with the ability to access the various types—classes, methods, properties, fields, attributes, events, and constructors—found within an assembly. Because dynamic programming often requires you to access code that won’t be known to the application at compile time, knowledge of Reflection is vital to creating a data-driven application. This chapter explains how Reflection works and how you can use it in your data-driven projects. You review how to access the class structure of an application, instantiate classes and forms, set properties, and invoke methods—all at runtime.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_14825_5_11,
  title = {Detection of Polymorphic Viruses in Windows Executables},
  author = {Kasina, Abhiram and Suthar, Amit and Kumar, Rajeev},
  booktitle = {Communications in Computer and Information Science},
  year = {2010},
  pages = {120-130},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-14825-5\_11},
  url = {https://doi.org/10.1007/978-3-642-14825-5\_11},
  abstract = {Polymorphic viruses are viruses which unpack themselves at runtime and infect files with a new mutated virus body. Most of the current solutions present blacklist a set of packer. Research has shown many polymorphic viruses to go undetected. This work aims at the problem of detection of such viruses using emulation technique. The main target is to improve the detection rate and reduce false positives. Bochs is a powerful x86-64 emulator and the system has been implemented on Bochs and could successfully detect self-modifying code in test viruses.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_10430_5_14,
  title = {Functional Reverse Engineering for Re-creation Design},
  author = {Tang, Dunbing and Zhu, Renmiao and Chen, Xuling and Zang, Tiegang and Xu, Ronghua},
  booktitle = {Advances in Intelligent and Soft Computing},
  year = {2010},
  pages = {185-195},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-10430-5\_14},
  url = {https://doi.org/10.1007/978-3-642-10430-5\_14},
  abstract = {Reverse engineering has been a common method to glean the design experience and knowledge attached to the existing product. Up to date, most reverse engineers are focusing their work on the geometric reverse engineering; such reverse way cannot obtain the original intrinsic knowledge which actually is located in the function model of the existing product. In this paper, functional reverse engineering is proposed to gain the design intent of the existing product though two folds: (1) A form-to-function mapping framework is presented to figure out the function structure of the existing product; (2) A re-creation design method is given through function operations of the original function model. A case study is offered to illustrate the basic principles of functional reverse engineering.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10639_010_9123_y,
  title = {Designing and implementing an undergraduate program in information systems security},
  author = {Ralevich, Victor and Martinovic, Dragana},
  journal = {Education and Information Technologies},
  year = {2010},
  volume = {15},
  number = {4},
  pages = {293-315},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10639-010-9123-y},
  url = {https://doi.org/10.1007/s10639-010-9123-y},
  abstract = {This paper describes development and delivery of the curriculum for a four-year undergraduate program in applied Information Sciences which comprises all the aspects of information systems security. After the first generation of students graduated in 2008, the program was evaluated by using multiple methods, including an exploration of the challenges and successes the program underwent in the process. By reflecting on the established need for such a program and how it evolved historically, the authors set up a baseline for comparing this program with other related programs in the field as well as with known information systems security curriculum models. While this curriculum continues to be modified in response to requirements from the job market and input from industry experts, some challenges for the program remain, such as scarcity of qualified instructors to ensure seamless program delivery, having students with varied educational backgrounds in the same class, and underrepresentation of females. Program curriculum details and useful experiential conclusions are also provided.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_04062_7_18,
  title = {Exploitation of Secrets Injected in Java Midlets},
  author = {Distefano, Alessandro and Grillo, Antonio and Lentini, Alessandro and Me, Gianluigi and Galbani, Riccardo},
  booktitle = {Communications in Computer and Information Science},
  year = {2009},
  pages = {166-173},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04062-7\_18},
  url = {https://doi.org/10.1007/978-3-642-04062-7\_18},
  abstract = {‘‘The systems relying on hard coded secrets are not actually secured; obscuring a secret with a trivial encoding does not protect the secret and weakens the whole system, since it can represent the ‘‘famous’’weakest link of the security chain. In order to ease the deployment procedure and to speed up the software development lifetime, the software developers can inject secret into Midlets. Due to the Men In The Middle (MITM) threats, related to the Over The Air (OTA) download, this practice could represent a big concern for all the players of the system. This paper presents a preliminary methodology for the security assessment of Midlets based on reverse engineering. Furthermore, it presents a practical application of the methodology to two case studies.’’},
  content_type = {Conference paper},
}


@incollection{springer_10_2991_978_94_91216_33_6_7,
  title = {ReconfigurableMulticore Architectures},
  author = {Abdallah, Abderazek Ben},
  booktitle = {Atlantis Ambient and Pervasive Intelligence},
  year = {2010},
  pages = {127-158},
  publisher = {Atlantis Press},
  doi = {10.2991/978-94-91216-33-6\_7},
  url = {https://doi.org/10.2991/978-94-91216-33-6\_7},
  abstract = {With the proliferation of portable devices, new multimedia-centric applications are continuously emerging on the consumer market. These applications are pushing computer architecture to its limit considering their demanding workloads. In addition, these workloads tend to vary significantly at run time as they are driven by a number of factors such as network conditions, application content, and user interactivity. Most current hardware and software approaches are unable to deliver executable codes and architectures to meet these requirements. There is a strong need for performance-driven adaptive techniques to accommodate these highly dynamic workloads. This chapter shows the potential of these techniques in both software and hardware domains by reviewing early attempts in dynamic binary translation on the software side and FPGA-based reconfigurable architectures on the hardware side. It puts forward a preliminary vision for unifying runtime adaptive techniques in hardware and software to tackle the demands of these new applications. This vision will not be possible to realize unless the notorious reconfiguration bottleneck familiar in FPGAs is addressed. The chapter concludes by pointing several future directions to explore in order to realize the full potential of runtime adaptation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_10847_1_18,
  title = {Researching on Cryptographic Algorithm Recognition Based on Static Characteristic-Code},
  author = {Liu, Tie-Ming and Jiang, Lie-hui and He, Hong-qi and Li, Ji-zhong and Yu, Xian},
  booktitle = {Communications in Computer and Information Science},
  year = {2009},
  pages = {140-147},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-10847-1\_18},
  url = {https://doi.org/10.1007/978-3-642-10847-1\_18},
  abstract = {Recognizing cryptographic algorithm from the binary codes plays an important role in checking the malicious codes and protecting the security of computer systems. This paper firstly introduces the current situation about the algorithm recognition and characteristic-code checking, makes use of the software reverse-engineering technology in order to extract the characteristic-codes from all kinds of the cryptographic algorithms and builds up the static characteristic database about the cryptographic algorithms. Then the paper introduces Boyer-Moore matching algorithm to design a scanning tool for the cryptographic algorithms, tests its efficiency and discusses the corresponding reliability; finally, the paper points out the developmental direction for algorithm recognition and technologies, which will be adopted in the field of software reverse engineering.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_05177_7_24,
  title = {Quo Vadis? Reliable and Practical Rule Extraction from Neural Networks},
  author = {Diederich, Joachim and Tickle, Alan B. and Geva, Shlomo},
  booktitle = {Studies in Computational Intelligence},
  year = {2010},
  pages = {479-490},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-05177-7\_24},
  url = {https://doi.org/10.1007/978-3-642-05177-7\_24},
  abstract = {Rule extraction from neural network algorithms have been investigated for two decades and there have been significant applications. Despite this level of success, rule extraction from neural network methods are generally not part of data mining tools, and a significant commercial breakthrough may still be some time away. This paper briefly reviews the state-of-the-art and points to some of the obstacles, namely a lack of evaluation techniques in experiments and larger benchmark data sets. A significant new development is the view that rule extraction from neural networks is an interactive process which actively involves the user. This leads to the application of assessment and evaluation techniques from information retrieval which may lead to a range of new methods.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_00722_4_2,
  title = {Extensible Proof-Producing Compilation},
  author = {Myreen, Magnus O. and Slind, Konrad and Gordon, Michael J. C.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {2-16},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-00722-4\_2},
  url = {https://doi.org/10.1007/978-3-642-00722-4\_2},
  abstract = {This paper presents a compiler which produces machine code from functions defined in the logic of a theorem prover, and at the same time proves that the generated code executes the source functions. Unlike previously published work on proof-producing compilation from a theorem prover, our compiler provides broad support for user-defined extensions, targets multiple carefully modelled commercial machine languages, and does not require termination proofs for input functions. As a case study, the compiler is used to construct verified interpreters for a small LISP-like language. The compiler has been implemented in the HOL4 theorem prover.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4419_6345_1_24,
  title = {DSP Instruction Set Simulation},
  author = {Brandner, Florian and Horspool, Nigel and Krall, Andreas},
  booktitle = {Handbook of Signal Processing Systems},
  year = {2010},
  pages = {679-705},
  publisher = {Springer US},
  doi = {10.1007/978-1-4419-6345-1\_24},
  url = {https://doi.org/10.1007/978-1-4419-6345-1\_24},
  abstract = {An instruction set simulator is an important tool for system architects and for software developers. However, when implementing a simulator, there are many choices which can be made and that have an effect on the speed and the accuracy of the simulation. They are especially relevant to DSP simulation. This chapter explains the different strategies for implementing a simulator.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_15057_9_10,
  title = {Reusable Verification of a Copying Collector},
  author = {Myreen, Magnus O.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {142-156},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-15057-9\_10},
  url = {https://doi.org/10.1007/978-3-642-15057-9\_10},
  abstract = {Garbage collectors are very hard to implement correctly due to their low-level manipulation of memory. In this paper, we construct a copying garbage collector which we have proved to be functionally correct. Our verification proof is structured as a sequence of refinements to aid clarity and proof reuse; it is the first to map implementations into three different machine languages and, unlike some noteworthy published proofs, our verified implementations of memory allocation handle termination and the ‘out-of-memory’ case properly. The work presented here has been developed in the HOL4 theorem prover.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_15057_9_4,
  title = {A Rely-Guarantee Proof System for x86-TSO},
  author = {Ridge, Tom},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {55-70},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-15057-9\_4},
  url = {https://doi.org/10.1007/978-3-642-15057-9\_4},
  abstract = {Current multiprocessors provide weak or relaxed memory models. Existing program logics assume sequential consistency, and are therefore typically unsound for weak memory. We introduce a novel Rely-Guarantee style proof system for reasoning about x86 assembly programs running against the weak x86-TSO memory model. Interesting features of the logic include processor assertions which can refer to the local state of other processors (including their program counters), and a syntactic operation of closing an assertion under write buffer interference. We use the expressivity of the proof system to construct a new correctness proof for an x86-TSO version of Simpson’s four slot algorithm. Mechanization in the Hol theorem prover provides a flexible tool to support semi-automated verification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_11145_7_26,
  title = {IntFinder: Automatically Detecting Integer Bugs in x86 Binary Program},
  author = {Chen, Ping and Han, Hao and Wang, Yi and Shen, Xiaobin and Yin, Xinchun and Mao, Bing and Xie, Li},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {336-345},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-11145-7\_26},
  url = {https://doi.org/10.1007/978-3-642-11145-7\_26},
  abstract = {Recently, Integer bugs have been increasing sharply and become the notorious source of bugs for various serious attacks. In this paper, we propose a tool, IntFinder, which can automatically detect Integer bugs in a x86 binary program. We implement IntFinder based on a combination of static and dynamic analysis. First, IntFinder decompiles a x86 binary code, and creates the suspect instruction set. Second, IntFinder dynamically inspects the instructions in the suspect set and confirms which instructions are actual Integer bugs with the error-prone input. Compared with other approaches, IntFinder provides more accurate and sufficient type information and reduces the instructions which will be inspected by static analysis. Experimental results are quite encouraging: IntFinder has detected the integer bugs in several practical programs as well as one new bug in slocate-2.7, and it achieves a low false positives and negatives.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_11970_5_6,
  title = {JReq: Database Queries in Imperative Languages},
  author = {Iu, Ming-Yee and Cecchet, Emmanuel and Zwaenepoel, Willy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {84-103},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-11970-5\_6},
  url = {https://doi.org/10.1007/978-3-642-11970-5\_6},
  abstract = {Instead of writing SQL queries directly, programmers often prefer writing all their code in a general purpose programming language like Java and having their programs be automatically rewritten to use database queries. Traditional tools such as object-relational mapping tools are able to automatically translate simple navigational queries written in object-oriented code to SQL. More recently, techniques for translating object-oriented code written in declarative or functional styles into SQL have been developed. For code written in an imperative style though, current techniques are still limited to basic queries. JReq is a system that is able to identify complex query operations like aggregation and nesting in imperative code and translate them into efficient SQL queries. The SQL code generated by JReq exhibits performance comparable with hand-written SQL code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_2992_6_17,
  title = {Packaging and Deploying Silverlight Applications},
  author = {Ghoda, Ashish},
  booktitle = {Introducing Silverlight 4},
  year = {2010},
  pages = {645-674},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2992-6\_17},
  url = {https://doi.org/10.1007/978-1-4302-2992-6\_17},
  abstract = {Silverlight is a client-side technology. This means any server can host a Silverlight application deployment package since there is no dependence on IIS or ASP.NET. For many applications, the only configuration that may be required on the server for the Silverlight application itself is that the MIME type support the Silverlight XAP package. Note that you still have to deploy any resources, custom services, or custom components that are not part of the Silverlight deployment package on the server. While server configuration is straightforward, there remain many aspects to creating and deploying Silverlight applications. We will end the book by exploring in detail parts of Silverlight applications and will discuss Silverlight class assemblies, as well as issues such as versioning and caching.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_16825_3_14,
  title = {A Generic Binary Analysis Method for Malware},
  author = {Izumida, Tomonori and Futatsugi, Kokichi and Mori, Akira},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {199-216},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-16825-3\_14},
  url = {https://doi.org/10.1007/978-3-642-16825-3\_14},
  abstract = {In this paper, we present a novel binary analysis method for malware which combines static and dynamic techniques. In the static phase, the target address of each indirect jump is resolved using backward analysis on static single assignment form of binary code. In the dynamic phase, those target addresses that are not statically resolved are recovered by way of emulation. The method is generic in the sense that it can reveal control flows of self-extracting/ obfuscated code without requiring special assumptions on executables such as compliance with standard compiler models, which is requisite for the conventional methods of static binary analysis but does not hold for many malware samples. Case studies on real-world malware examples are presented to demonstrate the effectiveness of our method.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_14215_4_8,
  title = {Organizing Large Scale Hacking Competitions},
  author = {Childers, Nicholas and Boe, Bryce and Cavallaro, Lorenzo and Cavedon, Ludovico and Cova, Marco and Egele, Manuel and Vigna, Giovanni},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {132-152},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-14215-4\_8},
  url = {https://doi.org/10.1007/978-3-642-14215-4\_8},
  abstract = {Computer security competitions and challenges are a way to foster innovation and educate students in a highly-motivating setting. In recent years, a number of different security competitions and challenges were carried out, each with different characteristics, configurations, and goals. From 2003 to 2007, we carried out a number of live security exercises involving dozens of universities from around the world. These exercises were designed as “traditional” Capture The Flag competitions, where teams both attacked and defended a virtualized host, which provided several vulnerable services. In 2008 and 2009, we introduced two completely new types of competition: a security “treasure hunt” and a botnet-inspired competition. These two competitions, to date, represent the largest live security exercises ever attempted and involved hundreds of students across the globe. In this paper, we describe these two new competition designs, the challenges overcome, and the lessons learned, with the goal of providing useful guidelines to other educators who want to pursue the organization of similar events.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_2992_6_15,
  title = {Security},
  author = {Ghoda, Ashish},
  booktitle = {Introducing Silverlight 4},
  year = {2010},
  pages = {579-612},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2992-6\_15},
  url = {https://doi.org/10.1007/978-1-4302-2992-6\_15},
  abstract = {The growth of the Internet and the World Wide Web has forever changed the way we use computers. As software engineers, we can no longer ignore security as we did when the average computer wasn’t directly connected to a slew of other computers. Silverlight lives online, in users’ browsers and other connected devices. No exploration of Silverlight is complete without understanding both the security features it provides and generally how to ensure your Silverlight application has been developed with security in mind. This chapter will go over Silverlight’s security model and general techniques for understanding how to design for and evaluate security.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2866_0_4,
  title = {WebParts and SharePoint Pages},
  author = {Malik, Sahil},
  booktitle = {Microsoft SharePoint 2010},
  year = {2010},
  pages = {79-112},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2866-0\_4},
  url = {https://doi.org/10.1007/978-1-4302-2866-0\_4},
  abstract = {In Chapters 1 and 2 of this book, you learned some SharePoint basics. In Chapter 3, you learned what every SharePoint developer needs to know—writing features and solutions.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_17164_2_8,
  title = {A Provably Correct Stackless Intermediate Representation for Java Bytecode},
  author = {Demange, Delphine and Jensen, Thomas and Pichardie, David},
  booktitle = {Lecture Notes in Computer Science},
  year = {2010},
  pages = {97-113},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-17164-2\_8},
  url = {https://doi.org/10.1007/978-3-642-17164-2\_8},
  abstract = {The Java virtual machine executes stack-based bytecode. The intensive use of an operand stack has been identified as a major obstacle for static analysis and it is now common for static analysis tools to manipulate a stackless intermediate representation (IR) of bytecode programs. This paper provides such a bytecode transformation, describes its semantic correctness and evaluates its performance. We provide the semantic foundations for proving that an initial program and its IR behave similarly, in particular with respect to object creation and throwing of exceptions. The correctness of this transformation is proved with respect to a relation on execution traces taking into account that the object allocation order is not preserved by the transformation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_3549_1_1,
  title = {Introducing Silverlight},
  author = {MacDonald, Matthew},
  booktitle = {Pro Silverlight 4 in VB},
  year = {2010},
  pages = {1-31},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-3549-1\_1},
  url = {https://doi.org/10.1007/978-1-4302-3549-1\_1},
  abstract = {In the introduction, you learned about the design philosophy that underpins Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2980_3_1,
  title = {Introducing Silverlight},
  booktitle = {Pro Silverlight 4 in C\#},
  year = {2010},
  pages = {1-31},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2980-3\_1},
  url = {https://doi.org/10.1007/978-1-4302-2980-3\_1},
  abstract = {In the introduction, you learned about the design philosophy that underpins Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2836_3_3,
  title = {Flash Builder 4: The programming environment},
  author = {Peeters, Steven},
  booktitle = {Flash Builder and Flash Catalyst},
  year = {2010},
  pages = {71-98},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2836-3\_3},
  url = {https://doi.org/10.1007/978-1-4302-2836-3\_3},
  abstract = {Now that we are up-to-date on the new features of the SDK, let’s take a closer look at how the programming environment has changed since the last version. We’ll start by taking a look at the IDE (Integrated Development Environment) and explore the product from there. Remember that this is not intended to be a book about Flash Builder—I’ll just provide an overview of some of the great new features that were not available in Flex Builder 3.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2851_6_6,
  title = {Mapping with Annotations},
  author = {Linwood, Jeff and Minter, Dave},
  booktitle = {Beginning Hibernate},
  year = {2010},
  pages = {91-131},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2851-6\_6},
  url = {https://doi.org/10.1007/978-1-4302-2851-6\_6},
  abstract = {In Chapter 5, we discussed the need to create mappings between the database model and the object model. Mappings can be created as separate XML files, or as annotations inline with the source code for your POJOs. In this chapter, we discuss the use of annotations, and in the next chapter, we will discuss the use of XML files.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_04117_4_34,
  title = {Viruses and Malware},
  author = {Filiol, Eric},
  booktitle = {Handbook of Information and Communication Security},
  year = {2010},
  pages = {747-769},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04117-4\_34},
  url = {https://doi.org/10.1007/978-3-642-04117-4\_34},
  abstract = {The term computer virus was first used in 1984 and is now well known to the general public. Computers are increasingly pervasive in the workplace and in homes. Most users of the Internet, and more generally any network, have faced the malware risk at least once. However, it appears that in practice, users’ knowledge (in the broadest sense of the term) with respect to computer virology is still contains so flawed that the risk is increased instead of being reduced. The term virus itself is improperly used to designate a more general class of programs that have nothing to do with viruses: worms, Trojans, logic bombs, lures, etc. Viruses, in addition, cover a reality farmore complex. Many sub-categories exist, and many viral techniques relate to them, all involving different risks, which must be known for protection and an effective fight.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2995_7_15,
  title = {Optimizing and Publishing Flash Movies},
  author = {Green, Tom and Dias, Tiago},
  booktitle = {Foundation Flash CS5 for Designers},
  year = {2010},
  pages = {757-808},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2995-7\_15},
  url = {https://doi.org/10.1007/978-1-4302-2995-7\_15},
  abstract = {When it comes to Flash on the Web, a common user experience is sitting around waiting for the movie to start. From your perspective, as the artist who designed the site, this may seem odd. After all, when you tested the movie in the authoring environment, it was seriously fast and played flawlessly. What happened? To be succinct, the Web happened. Your movie may indeed be cool, but you made a fundamental mistake: you fell in love with the technology, not the user. In this chapter, we’ll talk about how to improve the user experience.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_009_0118_4,
  title = {Semi-automatic binary protection tampering},
  author = {Guillot, Yoann and Gazet, Alexandre},
  journal = {Journal in Computer Virology},
  year = {2009},
  volume = {5},
  number = {2},
  pages = {119-149},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-009-0118-4},
  url = {https://doi.org/10.1007/s11416-009-0118-4},
  abstract = {Both on malicious binaries and commercial software like video games, the complexity of software protections, which aim at slowing reverse-engineering, is constantly growing. Analyzing those protections and eventually circumventing them, require more and more elaborated tools. Through two examples, we illustrate some particularly interesting protection families and try to show their limits and how to remove them to recover a binary which is close to the original code. Each of our approaches is based on the use of the binary manipulation framework Metasm .},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_2657_4_11,
  title = {Advanced build techniques},
  author = {King, Chris},
  booktitle = {Advanced BlackBerry Development},
  year = {2009},
  pages = {379-395},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2657-4\_11},
  url = {https://doi.org/10.1007/978-1-4302-2657-4\_11},
  abstract = {Whether you’re running a one-person programming shop or belong to a multinational corporation, building and maintaining software will be an integral part of your BlackBerry experience: You saw in Chapter 10 how applications can grow more complicated as you increase the number and variety of users you target. This chapter looks at the other side of the problem: how you can manage your project and keep it under control.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_03359_9_25,
  title = {Verified LISP Implementations on ARM, x86 and PowerPC},
  author = {Myreen, Magnus O. and Gordon, Michael J. C.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {359-374},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-03359-9\_25},
  url = {https://doi.org/10.1007/978-3-642-03359-9\_25},
  abstract = {This paper reports on a case study, which we believe is the first to produce a formally verified end-to-end implementation of a functional programming language running on commercial processors. Interpreters for the core of McCarthy’s LISP 1.5 were implemented in ARM, x86 and PowerPC machine code, and proved to correctly parse, evaluate and print LISP s-expressions. The proof of evaluation required working on top of verified implementations of memory allocation and garbage collection. All proofs are mechanised in the HOL4 theorem prover.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_03741_2_28,
  title = {DBtk: A Toolkit for Directed Bigraphs},
  author = {Bacci, Giorgio and Grohmann, Davide and Miculan, Marino},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {413-422},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-03741-2\_28},
  url = {https://doi.org/10.1007/978-3-642-03741-2\_28},
  abstract = {We present DBtk , a toolkit for Directed Bigraphs. DBtk supports a textual language for directed bigraphs, the graphical visualization of bigraphs, the calculation of IPO labels, and the calculation of redex matchings. Therefore, this toolkit provides the main functions needed to implement simulators and verification tools.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_04694_0_6,
  title = {State Joining and Splitting for the Symbolic Execution of Binaries},
  author = {Hansen, Trevor and Schachte, Peter and Søndergaard, Harald},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {76-92},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04694-0\_6},
  url = {https://doi.org/10.1007/978-3-642-04694-0\_6},
  abstract = {Symbolic execution can be used to explore the possible run-time states of a program. It makes use of a concept of “state” where a variable’s value has been replaced by an expression that gives the value as a function of program input. Additionally, a state can be equipped with a summary of control-flow history: a “path constraint” keeps track of the class of inputs that would have caused the same flow of control. But even simple programs can have trillions of paths, so a path-by-path analysis is impractical. We investigate a “state joining” approach to making symbolic execution more practical and describe the challenges of applying state joining to the analysis of unmodified Linux x86 executables. The results so far are mixed, with good results for some code. On other examples, state joining produces cumbersome constraints that are more expensive to solve than those generated by normal symbolic execution.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1601_8_1,
  title = {Getting Started with Groovy},
  booktitle = {Groovy and Grails Recipes},
  year = {None},
  pages = {3-15},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1601-8\_1},
  url = {https://doi.org/10.1007/978-1-4302-1601-8\_1},
  abstract = {Let me start by congratulating you for making the decision to learn more about Groovy. Rest assured that the time you spend reading it will repay you well. Groovy is a wonderfully crafted language with great capabilities. When you see how much time and effort Groovy can save you, you will wish you had discovered it earlier. Groovy—some of the best news in the Java community in a long time—can greatly enhance the productivity and efficiency of Java developers and non-Java developers alike.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_02617_1_24,
  title = {A New Approach to Malware Detection},
  author = {Tang, Hongying and Zhu, Bo and Ren, Kui},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {229-238},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-02617-1\_24},
  url = {https://doi.org/10.1007/978-3-642-02617-1\_24},
  abstract = {Malware has become one of the most serious threats to computer users. Early techniques based on syntactic signatures can be easily bypassed using program obfuscation. A promising direction is to combine Control Flow Graph (CFG) with instruction-level information. However, since previous work includes only coarse information, i.e., the classes of instructions of basic blocks, it results in false positives during the detection. To address this issue, we propose a new approach that generates formalized expressions upon assignment statements within basic blocks. Through combining CFG with the functionalities of basic blocks, which are represented in terms of upper variables with their corresponding formalized expressions and system calls (if any), our approach can achieve more accurate malware detection compared to previous CFG-based solutions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_03138_0_23,
  title = {Runtime Adaptive Extensible Embedded Processors — A Survey},
  author = {Huynh, Huynh Phung and Mitra, Tulika},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {215-225},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-03138-0\_23},
  url = {https://doi.org/10.1007/978-3-642-03138-0\_23},
  abstract = {Current generation embedded applications demand the computation engine to offer high performance similar to custom hardware circuits while preserving the flexibility of software solutions. Customizable and extensible embedded processors, where the processor core can be enhanced with application-specific instructions, provide a potential solution to this conflicting requirements of performance and flexibility. However, due to the limited area available for implementation of custom instructions in the datapath of the processor core, we may not be able to exploit all custom instruction enhancements of an application. Moreover, a static extensible processor is fundamentally at odds with highly dynamic applications where the custom instructions requirements vary substantially at runtime. In this context, a runtime adaptive extensible processor that can quickly morph its custom instructions and the corresponding custom functional units at runtime depending on workload characteristics is a promising solution. In this article, we provide a detailed survey of the contemporary architectures that offer such dynamic instruction-set support and discuss compiler and/or runtime techniques to exploit such architectures.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1949_1_9,
  title = {Guy Steele},
  author = {Seibel, Peter},
  booktitle = {Coders at Work},
  year = {2009},
  pages = {325-372},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1949-1\_9},
  url = {https://doi.org/10.1007/978-1-4302-1949-1\_9},
  abstract = {Guy Steele is a true programming polyglot. When I asked him what languages he has used seriously he came up with this list: COBOL, Fortran, IBM 1130 assembly, PDP-10 machine language, APL, C, C++, Bliss, GNAL, Common Lisp, Scheme, Maclisp, S-I Lisp, *Lisp, C*, Java, JavaScript, Tcl, Haskell, FOCAL, BASIC, TECO, and TeX. “Those would be the main ones, I guess,” he added.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4020_9823_9_19,
  title = {FPGA-Rootkits},
  author = {Kucera, Markus and Vetter, Michael},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {None},
  pages = {261-274},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-9823-9\_19},
  url = {https://doi.org/10.1007/978-1-4020-9823-9\_19},
  abstract = {This paper describes the security implications of FPGAs to the Trusted Computing Base of Embedded Systems. It gives an overview of different FPGA architectures and discusses the security measures and shortcoming of modern FPGAs. Furthermore, it shows how an attacker can exploit these shortcomings and integrate rootkit-like code inside the FPGA. After a discussion on possible countermeasures, a description on the different ways a rootkit can be deployed into the FPGA is given.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4020_9789_8_7,
  title = {The Mereology of Digital Copyright},
  author = {Burk, Dan L.},
  booktitle = {International Handbook of Internet Research},
  year = {2009},
  pages = {135-146},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-9789-8\_7},
  url = {https://doi.org/10.1007/978-1-4020-9789-8\_7},
  abstract = {Among the most controversial of current information technology projects on the Internet is the Google Book Search project. Google, owner and operator of a leading Internet search engine, has contracted with a variety of libraries to scan the contents of the books held in these libraries, many of which are under current copyright. From the scanned images, Google uses search engine technology to map the relationship of words in the scanned text to the other words in the text. Access to this index is provided via an online interface. However, Google has not sought the permission of copyright holders, and book publishers through their professional association have sued Google for copyright infringement, charging that the scanning process creates unauthorized digital copies of many copyrighted works. While Google has asserted a defense to these claims under the doctrine of fair use, a far more difficult and more far-reaching issue for database technologies is the legal status of the index created by Google, which maps the positions of the words in the books. This metadata is not technically a “copy” of the books in question, but the books can be recreated from such metadata. The ownership and control of such metadata is becoming an increasingly contested question in database construction, and the resolution of this question presents a difficult but critically important problem of copyright doctrine and policy in the United States and around the world.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2430_3_11,
  title = {Security},
  booktitle = {Accelerated Silverlight 3},
  year = {2009},
  pages = {335-356},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2430-3\_11},
  url = {https://doi.org/10.1007/978-1-4302-2430-3\_11},
  abstract = {The growth of the Internet and the World Wide Web has forever changed the way we use computers. As software engineers, we can no longer ignore security as we did when the average computer wasn’t directly connected to a slew of other computers. Silverlight lives online, in users’ browsers and other connected devices. No exploration of Silverlight is complete without understanding both the security features it provides and generally how to ensure your Silverlight application has been developed with security in mind. This chapter will go over Silverlight’s security model and general techniques for understanding how to design for and evaluate security.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_70545_1_40,
  title = {Jakstab: A Static Analysis Platform for Binaries},
  author = {Kinder, Johannes and Veith, Helmut},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {423-427},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-70545-1\_40},
  url = {https://doi.org/10.1007/978-3-540-70545-1\_40},
  abstract = {For processing compiled code, model checkers require accurate model extraction from binaries. We present our fully configurable binary analysis platform Jakstab , which resolves indirect branches by multiple rounds of disassembly interleaved with dataflow analysis. We demonstrate that this iterative disassembling strategy achieves better results than the state-of-the-art tool IDA Pro.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_0_387_89558_1_15,
  title = {Reconfigurable Acceleration with Binary Compatibility for General Purpose Processors},
  author = {Schneider Beck, Antonio Carlos and Carro, Luigi},
  booktitle = {IFIP – The International Federation for Information Processing},
  year = {2009},
  pages = {1-16},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-89558-1\_15},
  url = {https://doi.org/10.1007/978-0-387-89558-1\_15},
  abstract = {Although transistor scaling keeps following Moore`s law, and more area is available for designers, the clock frequency and ILP rate do not present the same level of growth anymore. This way, new architectural alternatives are necessary. Reconfigurable fabric appears to be one emerging possibility: besides exploiting the parallelism among instructions, it can also accelerate sequences of data dependent ones. However, reconfiguration wide spread usage is still withheld by the need of special tools and compilers, which clearly do not sustain the reuse of legacy code without any kind of modification. Based on all these facts, this work proposes a new Binary Translation algorithm, implemented in hardware and working in parallel to the processor, responsible for transforming sequences of instructions at run-time to be executed on a dynamic coarse-grain reconfigurable array, tightly coupled to a traditional RISC machine. Therefore, we can take advantage of using pure combinational logic to optimize even control-flow oriented code in a totally transparent process, without any modification in the source code or binary. Using the Simplescalar Toolset together with the MIBench embedded benchmark suite, we show performance improvements and area evaluation when comparing against a traditional superscalar architecture.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10766_008_0079_0,
  title = {Scalability and Parallel Execution of Warp Processing: Dynamic Hardware/Software Partitioning},
  author = {Lysecky, Roman},
  journal = {International Journal of Parallel Programming},
  year = {2008},
  volume = {36},
  number = {5},
  pages = {478-492},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10766-008-0079-0},
  url = {https://doi.org/10.1007/s10766-008-0079-0},
  abstract = {Warp processors are a novel architecture capable of autonomously optimizing an executing application by dynamically re-implementing critical kernels within the software as custom hardware circuits in an on-chip FPGA. Previous research on warp processing focused on low-power embedded systems, incorporating a low-end ARM processor as the main software execution resource. We provide a thorough analysis of the scalability of warp processing by evaluating several possible warp processor implementations, from low-power to high-performance, and by evaluating the potential for parallel execution of the partitioned software and hardware. We further demonstrate that even considering a high-performance 1 GHz embedded processor, warp processing provides the equivalent performance of a 2.4 GHz processor. By further enabling parallel execution between the processes and FPGA, the parallel warp processor execution provides the equivalent performance of a 3.2 GHz processor.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_00593_0_9,
  title = {Context-Aware Adaptive Services: The PLASTIC Approach},
  author = {Autili, Marco and Di Benedetto, Paolo and Inverardi, Paola},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {124-139},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-00593-0\_9},
  url = {https://doi.org/10.1007/978-3-642-00593-0\_9},
  abstract = {The near future envisions a pervasive heterogeneous computing infrastructure that makes it possible for mobile users to run software services on a variety of devices, from networks of devices to stand-alone wireless resource-constrained ones. To ensure that users meet their non-functional requirements by experiencing the best Quality of Service according to their needs and specific contexts of use, services need to be context-aware and adaptable. The development and the execution of such services is a big challenge and it is far to be solved. In this paper we present our experience in this direction by describing our approach to context-aware adaptive services within the IST PLASTIC project. The approach makes use of Chameleon , a formal framework for adaptive Java applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_00515_2_9,
  title = {Fast Offline Partial Evaluation of Large Logic Programs},
  author = {Leuschel, Michael and Vidal, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {119-134},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-00515-2\_9},
  url = {https://doi.org/10.1007/978-3-642-00515-2\_9},
  abstract = {In this paper, we present a fast binding-time analysis (BTA) by integrating a size-change analysis, which is independent of a selection rule, into a classical BTA for offline partial evaluation of logic programs. In contrast to previous approaches, the new BTA is conceptually simpler and considerably faster, scaling to medium-sized or even large examples and, moreover, it ensures both the so called local and global termination. We also show that through the use of selective hints, we can achieve both good specialisation results and a fast BTA and specialisation process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1836_4_9,
  title = {Security},
  booktitle = {Pro Flex on Spring},
  year = {2009},
  pages = {241-267},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1836-4\_9},
  url = {https://doi.org/10.1007/978-1-4302-1836-4\_9},
  abstract = {Trust no one; trust no user-based content. That should be your motto when delivering secure software and systems. It is far better to overprepare for a threat than to do nothing about it in the hope that it will never happen. Flex applications can be accessed from the Internet, of course, which makes them wide open to attacks from nefarious software if they are not secured.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_78769_3_3,
  title = {Type-Based Homeomorphic Embedding and Its Applications to Online Partial Evaluation},
  author = {Albert, Elvira and Gallagher, John and Gómez-Zamalloa, Miguel and Puebla, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {23-42},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-78769-3\_3},
  url = {https://doi.org/10.1007/978-3-540-78769-3\_3},
  abstract = {Homeomorphic Embedding ( HEm ) has proven to be very powerful for supervising termination of computations, provided that such computations are performed over a finite signature , i.e., the number of constants and function symbols involved is finite. However, there are situations, for example numeric computations, which involve an infinite (or too large) signature, in which HEm does not guarantee termination. Some extensions to HEm for the case of infinite signatures have been proposed which guarantee termination, but they either do not provide systematic means for generating such extensions or the extensions are too simplistic and do not produce the expected results in practice. We introduce Type-based Homeomorphic Embedding ( TbHEm ) as an extension of the standard, untyped HEm to deal with infinite signatures. In the paper, we show how TbHEm can be used to improve the accuracy of online partial evaluation . For this purpose, we propose an approach to constructing suitable types for partial evaluation automatically based on existing analysis tools for constraint logic programs. We also present useful properties of types which allow us to take full advantage of TbHEm in practice. Experimental results are reported which show that our work improves the state of the practice of online partial evaluation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_2430_3_13,
  title = {Packaging and Deploying Silverlight Applications},
  booktitle = {Accelerated Silverlight 3},
  year = {2009},
  pages = {381-412},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2430-3\_13},
  url = {https://doi.org/10.1007/978-1-4302-2430-3\_13},
  abstract = {Silverlight is a client-side technology. This means any server can host a Silverlight application since there is no dependence on IIS or ASP.NET. For many applications, the only configuration that must be done on the server for the Silverlight application itself is configuring the MIME type. While server configuration is straightforward, there remain many aspects to creating and deploying Silverlight applications. This chapter will explore in detail the parts of Silverlight applications and will discuss Silverlight class assemblies, as well as issues such as versioning and caching.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_03359_9_24,
  title = {Practical Tactics for Separation Logic},
  author = {McCreight, Andrew},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {343-358},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-03359-9\_24},
  url = {https://doi.org/10.1007/978-3-642-03359-9\_24},
  abstract = {We present a comprehensive set of tactics that make it practical to use separation logic in a proof assistant. These tactics enable the verification of partial correctness properties of complex pointer-intensive programs. Our goal is to make separation logic as easy to use as the standard logic of a proof assistant. We have developed tactics for the simplification, rearranging, splitting, matching and rewriting of separation logic assertions as well as the discharging of a program verification condition using a separation logic description of the machine state. We have implemented our tactics in the Coq proof assistant, applying them to a deep embedding of Cminor, a C-like intermediate language used by Leroy’s verified CompCert compiler. We have used our tactics to verify the safety and completeness of a Cheney copying garbage collector written in Cminor. Our ideas should be applicable to other substructural logics and imperative languages.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_02056_8_8,
  title = {Detection and Prevention of Insider Threats in Database Driven Web Services},
  author = {Chumash, Tzvi and Yao, Danfeng},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2009},
  pages = {117-132},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-02056-8\_8},
  url = {https://doi.org/10.1007/978-3-642-02056-8\_8},
  abstract = {In this paper, we take the first step to address the gap between the security needs in outsourced hosting services and the protection provided in the current practice. We consider both insider and outsider attacks in the third-party web hosting scenarios. We present SafeWS , a modular solution that is inserted between server side scripts and databases in order to prevent and detect website hijacking and unauthorized access to stored data. To achieve the required security, SafeWS utilizes a combination of lightweight cryptographic integrity and encryption tools, software engineering techniques, and security data management principles. We also describe our implementation of SafeWS and its evaluation. The performance analysis of our prototype shows the overhead introduced by security verification is small. SafeWS will allow business owners to significantly reduce the security risks and vulnerabilities of outsourcing their sensitive customer data to third-party providers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0564_7_1,
  title = {Introducing Silverlight},
  booktitle = {Pro Silverlight 2 in C\# 2008},
  year = {2009},
  pages = {1-27},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0564-7\_1},
  url = {https://doi.org/10.1007/978-1-4302-0564-7\_1},
  abstract = {In the introduction, you learned about the overall goals and design philosophy that underpin Silverlight. Now, you’re ready to get your hands dirty and create your first Silver light application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_04167_9_7,
  title = {Towards Demonstrably Correct Compilation of Java Byte Code},
  author = {Leuschel, Michael},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {119-138},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-04167-9\_7},
  url = {https://doi.org/10.1007/978-3-642-04167-9\_7},
  abstract = {In this paper we investigate the feasibility of a demonstrably correct compiler for Java bytecode. We first examine the suitability of adapting the existing high assurance compiler DeCCo for the Pascal-like language PASP, based on a Z formalisation of the compiler manually transcribed to Prolog. During the investigation we have uncovered several problematic issues and argue that these can be avoided by formally deriving the code of the compiler from the formal specification, rather than manually transcribing it. We have conducted a case study, developing a compiler for a subset of Java bytecode to an idealised RISC processor using the B-method. We show that refinement is a natural way to model compilation and that the B-method can in principle be used to develop a demonstrably correct compiler. In particular, the tool support for B turned out to be extremely valuable: animation, automated refinement checking, and proof each uncovered a series of mistakes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1603_2_1,
  title = {Introducing Silverlight},
  booktitle = {Pro Silverlight 2 in VB 2008},
  year = {None},
  pages = {1-27},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1603-2\_1},
  url = {https://doi.org/10.1007/978-1-4302-1603-2\_1},
  abstract = {In the introduction, you learned about the overall goals and design philosophy that underpin Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_b104899_6,
  title = {Intellectual Property, Digital Technology and the Developing World},
  author = {Pupillo, Lorenzo Maria},
  booktitle = {Internet Policy and Economics},
  year = {2009},
  pages = {79-98},
  publisher = {Springer US},
  doi = {10.1007/b104899\_6},
  url = {https://doi.org/10.1007/b104899\_6},
  abstract = {This chapter provides an overview of how the converging ICTs are challenging the traditional off-line copyright doctrine and suggests how developing countries should approach issues such as copyright in the digital world, software (Protection, Open Source, Reverse Engineering), and data base protection. The balance of the chapter is organized into three sections. After the introduction, the second section explains how digital technology is dramatically changing the entertainment industry, what are the major challenges to the industry, and what are the approaches that the economic literature suggest to face the structural changes that the digital revolution is bringing forward. Starting from the assumption that IPRs frameworks need to be customized to the countries’ development needs, the third section makes recommendations on how developing countries should use copyright to support access to information and to creative industries.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2382_5_1,
  title = {Introducing Silverlight},
  booktitle = {Pro Silverlight 3 in C\#},
  year = {2009},
  pages = {1-32},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2382-5\_1},
  url = {https://doi.org/10.1007/978-1-4302-2382-5\_1},
  abstract = {In the introduction, you learned about the design philosophy that underpins Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_1641_4_8,
  title = {Managing Application Growth on the dm Server},
  booktitle = {Pro SpringSource dm Server™},
  year = {2009},
  pages = {237-262},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1641-4\_8},
  url = {https://doi.org/10.1007/978-1-4302-1641-4\_8},
  abstract = {In the previous chapters you learned how to develop and migrate applications for the dm Server, familiarizing yourself with topics like OSGi services, application modularity, OSGi versioning, and more specific dm Server topics like platform archives (PARs) and libraries.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_2428_0_1,
  title = {Introducing Silverlight},
  author = {MacDonald, Matthew},
  booktitle = {Pro Silverlight 3 in VB},
  year = {2009},
  pages = {1-31},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-2428-0\_1},
  url = {https://doi.org/10.1007/978-1-4302-2428-0\_1},
  abstract = {In the introduction, you learned about the design philosophy that underpins Silverlight. Now, you’re ready to get your hands dirty and create your first Silverlight application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_00904_4_10,
  title = {Linux Kernel Compaction through Cold Code Swapping},
  author = {Chanet, Dominique and Cabezas, Javier and Morancho, Enric and Navarro, Nacho and De Bosschere, Koen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {173-200},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-00904-4\_10},
  url = {https://doi.org/10.1007/978-3-642-00904-4\_10},
  abstract = {There is a growing trend to use general-purpose operating systems like Linux in embedded systems. Previous research focused on using compaction and specialization techniques to adapt a general-purpose OS to the memory-constrained environment presented by most embedded systems. However, there is still room for improvement: it has been shown that even after application of the aforementioned techniques more than 50\% of the kernel code remains unexecuted under normal system operation. We introduce a new technique that reduces the Linux kernel code memory footprint through on-demand code loading of infrequently executed code, for systems that support virtual memory. In this paper, we describe our general approach, and we study code placement algorithms to minimize the performance impact of the code loading. A code size reduction of 68\% is achieved, with a 2.2\% execution speedup of the system-mode execution time, for a case study based on the MediaBench II benchmark suite.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_1868_5_2,
  title = {Setting up: Developing a Simple Silverlight Application},
  booktitle = {Pro Silverlight for the Enterprise},
  year = {2009},
  pages = {31-78},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1868-5\_2},
  url = {https://doi.org/10.1007/978-1-4302-1868-5\_2},
  abstract = {Before you get a deep-dive detailing of advanced features, design concepts, and implementation approaches of Silverlight and developing an enterprise service-oriented training portal using Silverlight, it is important you understand the key differences between developing an enterprise RIA and developing a quick (by breaking some traditional design rules), but very impressive, rich application using the Silverlight technology. This exercise will also help to demonstrate how easy it is to develop Silverlight applications in a short time, and how Silverlight is scalable and can fulfill the needs of a broad audience ranging from individuals to enterprises.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_71067_7_6,
  title = {A Brief Overview of HOL4},
  author = {Slind, Konrad and Norrish, Michael},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {28-32},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-71067-7\_6},
  url = {https://doi.org/10.1007/978-3-540-71067-7\_6},
  abstract = {The HOLF proof assistant supports specification and proof in classical higher order logic. It is the latest in a long line of similar systems. In this short overview, we give an outline of the HOLF system and how it may be applied in formal verification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1008_5_10,
  title = {Views},
  booktitle = {Pro ASP.NET MVC Framework},
  year = {2009},
  pages = {321-368},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1008-5\_10},
  url = {https://doi.org/10.1007/978-1-4302-1008-5\_10},
  abstract = {Seen from outside, web applications are black boxes that convert requests into responses: URL goes in, HTML comes out. Routing, controllers, and actions are important parts of ASP.NET MVC’s internal machinery, but it would all be for nothing if you didn’t produce some HTML. In MVC architecture, views are responsible for constructing that completed output.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_93900_9_19,
  title = {An Abstract Interpretation-Based Framework for Control Flow Reconstruction from Binaries},
  author = {Kinder, Johannes and Zuleger, Florian and Veith, Helmut},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {214-228},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-93900-9\_19},
  url = {https://doi.org/10.1007/978-3-540-93900-9\_19},
  abstract = {Due to indirect branch instructions, analyses on executables commonly suffer from the problem that a complete control flow graph of the program is not available. Data flow analysis has been proposed before to statically determine branch targets in many cases, yet a generic strategy without assumptions on compiler idioms or debug information is lacking. We have devised an abstract interpretation-based framework for generic low level programs with indirect jumps which safely combines a pluggable abstract domain with the notion of partial control flow graphs. Using our framework, we are able to show that the control flow reconstruction algorithm of our disassembly tool Jakstab produces the most precise overapproximation of the control flow graph with respect to the used abstract domain.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_74061_2_11,
  title = {A New Algorithm for Identifying Loops in Decompilation},
  author = {Wei, Tao and Mao, Jian and Zou, Wei and Chen, Yu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2007},
  pages = {170-183},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-74061-2\_11},
  url = {https://doi.org/10.1007/978-3-540-74061-2\_11},
  abstract = {Loop identification is an essential step of control flow analysis in decompilation. The Classical algorithm for identifying loops is Tarjan’s interval-finding algorithm, which is restricted to reducible graphs. Havlak presents one extension of Tarjan’s algorithm to deal with irreducible graphs, which constructs a loop-nesting forest for an arbitrary flow graph. There’s evidence showing that the running time of this algorithm is quadratic in the worst-case, and not almost linear as claimed. Ramalingam presents an improved algorithm with low time complexity on arbitrary graphs, but it performs not quite well on “real” control flow graphs (CFG). We present a novel algorithm for identifying loops in arbitrary CFGs. Based on a more detailed exploration on properties of loops and depth-first search (DFS), this algorithm traverses a CFG only once based on DFS and collects all information needed on the fly. It runs in approximately linear time and does not use any complicated data structures such as Interval/Derived Sequence of Graphs (DSG) or UNION-FIND sets. To perform complexity analysis of the algorithm, we introduce a new concept called unstructuredness coefficient to describe the unstructuredness of CFGs, and we find that the unstructuredness coefficients of these executables are usually small (<1.5). Such “low-unstructuredness” property distinguishes these CFGs from general single-root connected directed graphs, and it offers an explanation why those algorithms existed perform not quite well on real-world cases. The new algorithm has been applied to 11526 CFGs in 6 typical binary executables on both Linux and Window platforms. Experimental result has validated our theoretical analysis and it shows that our algorithm runs 2-5 times faster than the Havlak-Tarjan algorithm, and 2-8 times faster than the Ramalingam-Havlak-Tarjan algorithm.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_03013_0_2,
  title = {Coinductive Type Systems for Object-Oriented Languages},
  author = {Ancona, Davide and Lagorio, Giovanni},
  booktitle = {Lecture Notes in Computer Science},
  year = {2009},
  pages = {2-26},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-03013-0\_2},
  url = {https://doi.org/10.1007/978-3-642-03013-0\_2},
  abstract = {We propose a novel approach based on coinductive logic to specify type systems of programming languages. The approach consists in encoding programs in Horn formulas which are interpreted w.r.t. their coinductive Herbrand model. We illustrate the approach by first specifying a standard type system for a small object-oriented language similar to Featherweight Java. Then we define an idealized type system for a variant of the language where type annotations can be omitted. The type system involves infinite terms and proof trees not representable in a finite way, thus providing a theoretical limit to type inference of object-oriented programs, since only sound approximations of the system can be implemented. Approximation is naturally captured by the notions of subtyping and subsumption; indeed, rather than increasing the expressive power of the system, as it usually happens, here subtyping is needed for approximating infinite non regular types and proof trees with regular ones.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_008_0084_2,
  title = {Code obfuscation techniques for metamorphic viruses},
  author = {Borello, Jean-Marie and Mé, Ludovic},
  journal = {Journal in Computer Virology},
  year = {2008},
  volume = {4},
  number = {3},
  pages = {211-220},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-008-0084-2},
  url = {https://doi.org/10.1007/s11416-008-0084-2},
  abstract = {This paper deals with metamorphic viruses. More precisely, it examines the use of advanced code obfuscation techniques with respect to metamorphic viruses. Our objective is to evaluate the difficulty of a reliable static detection of viruses that use such obfuscation techniques. Here we extend Spinellis’ result (IEEE Trans. Inform. Theory, 49 (1), 280–284, 2003) on the detection complexity of bounded-length polymorphic viruses to metamorphic viruses. In particular, we prove that reliable static detection of a particular category of metamorphic viruses is an \\(\{\\mathcal\{NP\}\}\\) -complete problem. Then we empirically illustrate our result by constructing a practical obfuscator which could be used by metamorphic viruses in the future to evade detection.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_77368_9_50,
  title = {Design and Implementation of the Decompiler for Virtual Machine Code of the C++ Compiler in the Ubiquitous Game Platform},
  author = {Lee, YangSun and Kim, YoungKeun and Kwon, HyeokJu},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {511-521},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-77368-9\_50},
  url = {https://doi.org/10.1007/978-3-540-77368-9\_50},
  abstract = {The ubiquitous game platform implemented by our team is composed of a C++ compiler, a java translator, and a virtual machine. The EVM (Embedded Virtual Machine) is a stack-based solution that supports object-oriented languages such as C++ and java. It uses the SIL (Standard Intermediate Language) as an intermediate language, which consists of an operation code set for procedural and object-oriented languages. The existing C++ compilers are used to execute programs after translating them into a target machine code. The downside of this method is its low practicality, along with its platform-dependency. To resolve this matter, we developed a C++ compiler that generates virtual machine codes based on platform-independent stacks that are not target machine codes. This paper presents a decompiler system that converts a C++ compiler generated intermediate language, namely SIL, to a representation of a C++ program. This method optimizes the simulation needed for the generation of exacted SIL code, and a solution that can verify the SIL code generation through a C++ program represented in the decompiler. Furthermore, the ease of extracting the meaning of a program, as opposed to assembly-structured SIL codes, allows much more convenience in changing the software structure and correcting it to improve performance.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_71229_9_7,
  title = {Obfuscating Java: The Most Pain for the Least Gain},
  author = {Batchelder, Michael and Hendren, Laurie},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {96-110},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-71229-9\_7},
  url = {https://doi.org/10.1007/978-3-540-71229-9\_7},
  abstract = {Bytecode, Java’s binary form, is relatively high-level and therefore susceptible to decompilation attacks. An obfuscator transforms code such that it becomes more complex and therefore harder to reverse engineer. We develop bytecode obfuscations that are complex to reverse engineer but also do not significantly degrade performance. We present three kinds of techniques that: (1) obscure intent at the operational level; (2) complicate control flow and object-oriented design (i.e. program structure); and (3) exploit the semantic gap between what is legal in source code and what is legal in bytecode. Obfuscations are applied to a benchmark suite to examine their affect on runtime performance, control flow graph complexity and decompilation. These results show that most of the obfuscations have only minor negative performance impacts and many increase complexity. In almost all cases, tested decompilers fail to produce legal source code or crash completely. Those obfuscations that are decompilable greatly reduce the readability of output source.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_88387_6_19,
  title = {CheckSpec: A Tool for Consistency and Coverage Analysis of Assertion Specifications},
  author = {Banerjee, Ansuman and Datta, Kausik and Dasgupta, Pallab},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {228-233},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-88387-6\_19},
  url = {https://doi.org/10.1007/978-3-540-88387-6\_19},
  abstract = {As more and more chip design companies attempt to integrate formal property verification (FPV) and assertion-based verification (ABV) into their pre-silicon validation flows, the main challenge that they face is in the task of expressing the design intent correctly and accurately in terms of formal properties. Incomplete specifications allow bugs to escape detection, while inconsistent specifications lead to the loss of validation effort, since the error lies in the specification itself. In this paper, we present CheckSpec, a tool for automatically checking the consistency and completeness of assertion specifications written in System Verilog Assertions (SVA). CheckSpec comprises of two main engines, namely (a) Certify : that certifies a given assertion suite to be free from inconsistencies and (b) Quantify : that quantifies the completeness of a given assertion suite. On one hand, CheckSpec will help verification teams to avoid significant waste of validation effort arising out of inconsistent specifications. On the other hand, this will provide a first-cut estimate of the comprehensiveness of an assertion specification suite. The adoption of CheckSpec in the mainstream validation flow can significantly increase the productivity of assertion verification technologies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_89275_5_4,
  title = {Huemul – A Smalltalk Implementation},
  author = {Molina, Guillermo Adrián},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {54-73},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-89275-5\_4},
  url = {https://doi.org/10.1007/978-3-540-89275-5\_4},
  abstract = {Huemul is a new implementation of Smalltalk. It is built under the principle of reuse of existing technologies. It aims to be compatible with Smalltalk 80 at the language level. Huemul does not interpret Smalltalk code. It translates methods directly to machine code, and they are kept like that in the image. With this approach, virtual machine code is kept to the bare minimum.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0546_3_14,
  title = {Taming Processes and Services},
  booktitle = {Pro Windows PowerShell},
  year = {None},
  pages = {275-284},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0546-3\_14},
  url = {https://doi.org/10.1007/978-1-4302-0546-3\_14},
  abstract = {Processes are like living organisms that inhabit a running operating system. They are the entities that do all the work—they munch on all the data and pass it to each other. While much work can be done from within PowerShell only, sooner or later we will have to interact with one of the processes on our system. All shells provide facilities for managing running programs and so does PowerShell. Its process and service management facilities can extract information about processes and manipulate process instances by working directly with objects that represent them. We have convenient, object-oriented commands that give us great flexibility when extracting data or modifying state. The combination of the objects representing processes and services with the object pipeline and that pipeline’s advanced iteration and filtering facilities makes expressing complex commands easy.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_68863_1_2,
  title = {Termination Analysis of Java Bytecode},
  author = {Albert, Elvira and Arenas, Puri and Codish, Michael and Genaim, Samir and Puebla, Germán and Zanardini, Damiano},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {2-18},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-68863-1\_2},
  url = {https://doi.org/10.1007/978-3-540-68863-1\_2},
  abstract = {Termination analysis has received considerable attention, traditionally in the context of declarative programming, and recently also for imperative languages. In existing approaches, termination is performed on source programs. However, there are many situations, including mobile code, where only the compiled code is available. In this work we present an automatic termination analysis for sequential Java Bytecode programs. Such analysis presents all of the challenges of analyzing a low-level language as well as those introduced by object-oriented languages. Interestingly, given a bytecode program, we produce a constraint logic program, CLP, whose termination entails termination of the bytecode program. This allows applying the large body of work in termination of CLP programs to termination of Java bytecode. A prototype analyzer is described and initial experimentation is reported.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00165_008_0086_3,
  title = {Slicing communicating automata specifications: polynomial algorithms for model reduction},
  author = {Labbé, Sébastien and Gallois, Jean-Pierre},
  journal = {Formal Aspects of Computing},
  year = {2008},
  volume = {20},
  number = {6},
  pages = {563-595},
  publisher = {Association for Computing Machinery (ACM)},
  doi = {10.1007/s00165-008-0086-3},
  url = {https://doi.org/10.1007/s00165-008-0086-3},
  abstract = {Abstract In the industry, communicating automata specifications are mainly used in fields where the reliability requirements are high, as this formalism allow the use of powerful validation tools. Still, on large scale industrial specifications, formal methods suffer from the combinatorial explosion phenomenon. In our contribution, we suggest to try to bypass this phenomenon, in applying slicing techniques preliminarily to the targeted complex analysis. This analysis can thus be performed a posteriori on a reduced (or sliced ) specification, which is potentially less exposed to combinatorial explosion. The slicing method is based on dependence relations, defined on the specification under analysis, and is mainly founded on the literature on compiler construction and program slicing. A theoretical framework is described, for static analyses of communicating automata specifications. This includes formal definitions for the aforementioned dependence relations, and for a slice of a specification with respect to a slicing criterion . Efficient algorithms are also described in detail, for calculating dependence relations and specification slices. Each of these algorithms has been shown to be polynomial, and sound and complete with respect to its respective definition. These algorithms have also been implemented in a slicing tool, named C arver , that has shown to be operational in specification debugging and understanding. The experimental results obtained in model reduction with this tool are promising, notably in the area of formal validation and verification methods, e.g.model checking, test case generation.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_0604_0_1,
  title = {Application Development},
  booktitle = {Visual Basic 2008 Recipes},
  year = {None},
  pages = {1-50},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0604-0\_1},
  url = {https://doi.org/10.1007/978-1-4302-0604-0\_1},
  abstract = {This chapter covers some of the general features and functionality found in Visual Basic .NET 9.0 and Visual Studio 2008. The recipes in this chapter cover the following: Using the VB .NET command-line compiler to build console and Windows Forms applications (recipes 1-1 and 1-2) Creating and using code modules and libraries (recipes 1-3 and 1-4) Compiling and embedding a string resource file (recipe 1-5) Compiling applications using MSBuild.exe (recipe 1-6) Accessing command-line arguments from within your applications (recipe 1-7) Using compiler directives and attributes to selectively include code at build time (recipe 1-8) Manipulating the appearance of the console (recipe 1-9) Accessing program elements built in other languages whose names conflict with VB .NET keywords (recipe 1-10) Giving assemblies strong names and verifying strong-named assemblies (recipes 1-11, 1-12, 1-13, and 1-14) Signing an assembly with a Microsoft Authenticode digital signature (recipes 1-15 and 1-16) Managing the shared assemblies that are stored in the global assembly cache (recipe 1-17) Making your assembly more difficult to decompile (recipe 1-18) Understanding the basic functionality required to use Language Integrated Query (LINQ) (recipes 1-19, 1-20, 1-21, 1-22, and 1-23)},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_007_0079_4,
  title = {Formal affordance-based models of computer virus reproduction},
  author = {Webster, Matt and Malcolm, Grant},
  journal = {Journal in Computer Virology},
  year = {2008},
  volume = {4},
  number = {4},
  pages = {289-306},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-007-0079-4},
  url = {https://doi.org/10.1007/s11416-007-0079-4},
  abstract = {We present a novel classification of computer viruses using a formalised notion of reproductive models based on Gibson’s theory of affordances. A computer virus reproduction model consists of: a labelled transition system to represent the states and actions involved in that virus’s reproduction; a notion of entities that are active in the reproductive process, and are present in certain states; a sequence of actions corresponding to the means of reproduction of the virus; and a formalisation of the actions afforded by entities to other entities. Informally, an affordance is an action that one entity allows another to perform. For example, an operating system might afford a computer virus the ability to read data from the disk. We show how computer virus reproduction models can be classified according to whether or not any of their reproductive actions are afforded by other entities. We give examples of reproduction models for three different computer viruses, and show how reproduction model classification can be automated. To demonstrate this we give three examples of how computer viruses can be classified automatically using static and dynamic analysis, and show how classifications can be tailored for different types of anti-virus behaviour monitoring software. Finally, we compare our approach with related work, and give directions for future research.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_69485_4_14,
  title = {Weaknesses in BankID, a PKI-Substitute Deployed by Norwegian Banks},
  author = {Gjøsteen, Kristian},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {196-206},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69485-4\_14},
  url = {https://doi.org/10.1007/978-3-540-69485-4\_14},
  abstract = {BankID is a PKI-substitute widely deployed by Norwegian banks to provide digital signatures and identification on the internet. We have performed a reverse-engineering of part of the BankID system and analysed the security protocols and the implementation of certain cryptographic primitives. We have found cryptographic weaknesses that may indicate security problems, protocol flaws facilitating man-in-the-middle attacks, and implementation errors facilitating strong insider attacks. We also note that the system suffers from severe privacy problems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_92188_2_5,
  title = {COSTA: Design and Implementation of a Cost and Termination Analyzer for Java Bytecode},
  author = {Albert, Elvira and Arenas, Puri and Genaim, Samir and Puebla, German and Zanardini, Damiano},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {113-132},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-92188-2\_5},
  url = {https://doi.org/10.1007/978-3-540-92188-2\_5},
  abstract = {This paper describes the architecture of costa , an abstract interpretation based cos t and t ermination a nalyzer for Java bytecode. The system receives as input a bytecode program, (a choice of) a resource of interest and tries to obtain an upper bound of the resource consumption of the program. costa provides several non-trivial notions of cost, as the consumption of the heap, the number of bytecode instructions executed and the number of calls to a specific method. Additionally, costa tries to prove termination of the bytecode program which implies the boundedness of any resource consumption. Having cost and termination together is interesting, as both analyses share most of the machinery to, respectively, infer cost upper bounds and to prove that the execution length is always finite (i.e., the program terminates). We report on experimental results which show that costa can deal with programs of realistic size and complexity, including programs which use Java libraries. To the best of our knowledge, this system provides for the first time evidence that resource usage analysis can be applied to a realistic object-oriented, bytecode programming language.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11760_007_0048_x,
  title = {Non-invasive evaluation of carotid artery wall thickness using improved dynamic programming technique},
  author = {Santhiyakumari, N. and Madheswaran, M.},
  journal = {Signal, Image and Video Processing},
  year = {2008},
  volume = {2},
  number = {2},
  pages = {183-193},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11760-007-0048-x},
  url = {https://doi.org/10.1007/s11760-007-0048-x},
  abstract = {An improved dynamic programming (DP) segmentation technique for detecting the intima-media layer of the far wall of the common carotid artery (CCA) of longitudinal and transversal ultrasound (US) images using optimal search technique is presented here. The algorithm is developed considering the normalization and smoothing for estimating the intima media thickness (IMT) of the normal and abnormal subjects. The segmentation features of different subjects obtained using the proposed technique have been compared with the manual measurements. The results show that an inter-observer error and a coefficient of variation are found as ±0.035 mm and 3.55\%, respectively. The magnitudes of the IMT values have been used to explore the rate of prediction of blockage existing in the cerebrovascular and cardiovascular pathologies, and also hypertension and atherosclerosis.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_1075_7_11,
  title = {Security},
  booktitle = {Accelerated Silverlight 2},
  year = {None},
  pages = {229-249},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1075-7\_11},
  url = {https://doi.org/10.1007/978-1-4302-1075-7\_11},
  abstract = {The growth of the Internet and the World Wide Web has forever changed the way we use computers. As software engineers, we can no longer ignore security as we did when the average computer wasn’t directly connected to a slew of other computers. Silverlight lives online, in users’ browsers and other connected devices. No exploration of Silverlight is complete without understanding both the security features it provides and generally how to ensure your Silverlight application has been developed with security in mind. This chapter will go over Silverlight’s security model and general techniques for understanding how to design for and evaluate security.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4020_6662_7_6,
  title = {Recommendations for stakeholders},
  author = {Ahonen, Pasi and Alahuhta, Petteri and Daskala, Barbara and Delaitre, Sabine and Hert, Paul De and Lindner, Ralf and Maghiros, Ioannis and Moscibroda, Anna and Schreurs, Wim and Verlinden, Michiel},
  booktitle = {The International Library of Ethics, Law and Technology},
  year = {2008},
  pages = {253-265},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-6662-7\_6},
  url = {https://doi.org/10.1007/978-1-4020-6662-7\_6},
  abstract = {Chapter 5 identified safeguards against the threats and vulnerabilities affecting privacy, identity, trust, security and the digital divide in an AmI world. In this chapter, we offer to particular stakeholders several specific recommendations some of which flow from the safeguards identified above.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_69149_5_22,
  title = {WYSINWYX: What You See Is Not What You eXecute},
  author = {Balakrishnan, G. and Reps, T. and Melski, D. and Teitelbaum, T.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {202-213},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69149-5\_22},
  url = {https://doi.org/10.1007/978-3-540-69149-5\_22},
  abstract = {What You See Is Not What You eXecute: computers do not execute source-code programs; they execute machine-code programs that are generated from source code. Not only can the WYSINWYX phenomenon create a mismatch between what a programmer intends and what is actually executed by the processor, it can cause analyses that are performed on source code to fail to detect certain bugs and vulnerabilities. This issue arises regardless of whether one’s favorite approach to assuring that programs behave as desired is based on theorem proving, model checking, or abstract interpretation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_78791_4_1,
  title = {Design Choices in a Compiler Course or How to Make Undergraduates Love Formal Notation},
  author = {Schwartzbach, Michael I.},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {1-15},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-78791-4\_1},
  url = {https://doi.org/10.1007/978-3-540-78791-4\_1},
  abstract = {The undergraduate compiler course offers a unique opportunity to combine many aspects of the Computer Science curriculum. We discuss the many design choices that are available for the instructor and present the current compiler course at the University of Aarhus, the design of which displays at least some decisions that are unusual, novel, or just plain fun.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_74591_4_27,
  title = {Simple Types in Type Theory: Deep and Shallow Encodings},
  author = {Garillot, François and Werner, Benjamin},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {368-382},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-74591-4\_27},
  url = {https://doi.org/10.1007/978-3-540-74591-4\_27},
  abstract = {We present a formal treatment of normalization by evaluation in type theory. The involved semantics of simply-typed λ -calculus is exactly the simply typed fragment of the type theory. This means we have constructed and proved correct a decompilation function which recovers the syntax of a program, provided it belongs to the simply typed fragment. The development runs and is checked in Coq. Possible applications include the formal treatment of languages with binders.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_79104_1_7,
  title = {Towards Tamper Resistant Code Encryption: Practice and Experience},
  author = {Cappaert, Jan and Preneel, Bart and Anckaert, Bertrand and Madou, Matias and De Bosschere, Koen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {86-100},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-79104-1\_7},
  url = {https://doi.org/10.1007/978-3-540-79104-1\_7},
  abstract = {In recent years, many have suggested to apply encryption in the domain of software protection against malicious hosts. However, little information seems to be available on the implementation aspects or cost of the different schemes. This paper tries to fill the gap by presenting our experience with several encryption techniques: bulk encryption, an on-demand decryption scheme, and a combination of both techniques. Our scheme offers maximal protection against both static and dynamic code analysis and tampering. We validate our techniques by applying them on several benchmark programs of the CPU2006 Test Suite. And finally, we propose a heuristic which trades off security versus performance, resulting in a decrease of the runtime overhead.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0200_4_2,
  title = {Building Visual Basic 2008 Applications},
  booktitle = {Pro VB 2008 and the .NET 3.5 Platform},
  year = {None},
  pages = {35-61},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0200-4\_2},
  url = {https://doi.org/10.1007/978-1-4302-0200-4\_2},
  abstract = {As a VB 2008 programmer, you may choose among numerous tools to build your .NET applications. This approach is quite different from the world of VB6, where we had only a single IDE to contend with: Microsoft Visual Basic 6.0. That being said, the point of this chapter is to provide a tour of various .NET development options, including, of course, Visual Studio 2008. The chapter opens, however, with an examination of working with the VB 2008 command-line compiler, vbc.exe, and the simplest of all text editors, Notepad (notepad.exe).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_1062_7_3,
  title = {Getting Started with the NetBeans IDE},
  booktitle = {Beginning Java™ ME Platform},
  year = {None},
  pages = {33-77},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1062-7\_3},
  url = {https://doi.org/10.1007/978-1-4302-1062-7\_3},
  abstract = {Numerous tools are available for building Java ME applications, but the NetBeans integrated development environment (IDE) stands out as providing the best-of-breed support for the platformwhile remaining open for changes and extensions. If you’re just starting out, the NetBeans software development kit (SDK) is the place to begin; if you’re exploring the Java ME platform with thoughts of doing your work in another environment, many of the concepts you’ll learn in this chapter still apply.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_78791_4_2,
  title = {Improved Memory-Access Analysis for x86 Executables},
  author = {Reps, Thomas and Balakrishnan, Gogul},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {16-35},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-78791-4\_2},
  url = {https://doi.org/10.1007/978-3-540-78791-4\_2},
  abstract = {Over the last seven years, we have developed static-analysis methods to recover a good approximation to the variables and dynamically allocated memory objects of a stripped executable, and to track the flow of values through them. It is relatively easy to track the effects of an instruction operand that refers to a global address (i.e., an access to a global variable) or that uses a stack-frame offset (i.e., an access to a local scalar variable via the frame pointer or stack pointer). In our work, our algorithms are able to provide useful information for close to 100\% of such “direct” uses and defs. It is much harder for a static-analysis algorithm to track the effects of an instruction operand that uses a non-stack-frame register. These “indirect” uses and defs correspond to accesses to an array or a dynamically allocated memory object. In one study, our approach recovered useful information for only 29\% of indirect uses and 33\% of indirect defs. However, using the technique described in this paper, the algorithm recovered useful information for 81\% of indirect uses and 90\% of indirect defs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_1062_7_15,
  title = {Securing Java ME Applications},
  booktitle = {Beginning Java™ ME Platform},
  year = {None},
  pages = {413-445},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1062-7\_15},
  url = {https://doi.org/10.1007/978-1-4302-1062-7\_15},
  abstract = {Security plays a big part in the success of today’s mobile marketplace. More so than ever before, consumer devices are being woven into the very infrastructure of electronic commerce. This revolution is being powered by mobile versions of the same security and trust technologies—largely powered by the revolution in cryptography over the last generation—that power electronic commerce on the Internet.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_1583_7_1,
  title = {Introducing Silverlight},
  booktitle = {Silverlight 2 Visual Essentials},
  year = {None},
  pages = {1-48},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-1583-7\_1},
  url = {https://doi.org/10.1007/978-1-4302-1583-7\_1},
  abstract = {Silverlight is a framework for building rich, browser-hosted applications that run on a variety of operating systems. Silverlight works its magic through a browser plug-in . When you surf to a web page that includes some Silverlight content, this browser plug-in runs, executes the code, and renders that content in a specifically designated region of the page. The important part is that the Silverlight plug-in provides a far richer environment than the traditional blend of HTML and JavaScript that powers ordinary web pages. Used carefully and artfully, you can create Silverlight pages that have interactive graphics, use vector animations, and play video and sound files.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_007_0078_5,
  title = {Enhancing web browser security against malware extensions},
  author = {Ter Louw, Mike and Lim, Jin Soon and Venkatakrishnan, V. N.},
  journal = {Journal in Computer Virology},
  year = {2008},
  volume = {4},
  number = {3},
  pages = {179-195},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-007-0078-5},
  url = {https://doi.org/10.1007/s11416-007-0078-5},
  abstract = {In this paper we examine security issues of functionality extension mechanisms supported by web browsers. Extensions (or “plug-ins”) in modern web browsers enjoy unrestrained access at all times and thus are attractive vectors for malware. To solidify the claim, we take on the role of malware writers looking to assume control of a user’s browser space. We have taken advantage of the lack of security mechanisms for browser extensions and implemented a malware application for the popular Firefox web browser, which we call browserSpy , that requires no special privileges to be installed. browserSpy takes complete control of the user’s browser space, can observe all activity performed through the browser and is undetectable. We then adopt the role of defenders to discuss defense strategies against such malware. Our primary contribution is a mechanism that uses code integrity checking techniques to control the extension installation and loading process. We describe two implementations of this mechanism: a drop-in solution that employs JavaScript and a faster, in-browser solution that makes uses of the browser’s native cryptography implementation. We also discuss techniques for runtime monitoring of extension behavior to provide a foundation for defending threats posed by installed extensions.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_70592_5_25,
  title = {Practical Object-Oriented Back-in-Time Debugging},
  author = {Lienhard, Adrian and Gîrba, Tudor and Nierstrasz, Oscar},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {592-615},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-70592-5\_25},
  url = {https://doi.org/10.1007/978-3-540-70592-5\_25},
  abstract = {Back-in-time debuggers are extremely useful tools for identifying the causes of bugs. Unfortunately the “omniscient” approaches that try to remember all previous states are impractical because they consume too much space or they are far too slow. Several approaches rely on heuristics to limit these penalties, but they ultimately end up throwing out too much relevant information. In this paper we propose a practical approach that attempts to keep track of only the relevant data. In contrast to other approaches, we keep object history information together with the regular objects in the application memory. Although seemingly counter-intuitive, this approach has the effect that data not reachable from current application objects (and hence, no longer relevant) is garbage collected. We describe the technical details of our approach, and we present benchmarks that demonstrate that memory consumption stays within practical bounds. Furthermore, the performance penalty is significantly less than with other approaches.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_89862_7_1,
  title = {BitBlaze: A New Approach to Computer Security via Binary Analysis},
  author = {Song, Dawn and Brumley, David and Yin, Heng and Caballero, Juan and Jager, Ivan and Kang, Min Gyung and Liang, Zhenkai and Newsome, James and Poosankam, Pongsin and Saxena, Prateek},
  booktitle = {Lecture Notes in Computer Science},
  year = {2008},
  pages = {1-25},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-89862-7\_1},
  url = {https://doi.org/10.1007/978-3-540-89862-7\_1},
  abstract = {In this paper, we give an overview of the BitBlaze project, a new approach to computer security via binary analysis. In particular, BitBlaze focuses on building a unified binary analysis platform and using it to provide novel solutions to a broad spectrum of different security problems. The binary analysis platform is designed to enable accurate analysis, provide an extensible architecture, and combines static and dynamic analysis as well as program verification techniques to satisfy the common needs of security applications. By extracting security-related properties from binary programs directly, BitBlaze enables a principled, root-cause based approach to computer security, offering novel and effective solutions, as demonstrated with over a dozen different security applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_75390_2_1,
  title = {Rule Extraction from Support Vector Machines: An Introduction},
  author = {Diederich, Joachim},
  booktitle = {Studies in Computational Intelligence},
  year = {2008},
  pages = {3-31},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-75390-2\_1},
  url = {https://doi.org/10.1007/978-3-540-75390-2\_1},
  abstract = {Rule extraction from support vector machines (SVMs) follows in the footsteps of the earlier effort to obtain human-comprehensible rules from artificial neural networks (ANNs) in order to explain “how” a decision was made or “why” a certain...},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0614_9_5,
  title = {Legal Matters},
  booktitle = {From Program to Product},
  year = {None},
  pages = {129-154},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0614-9\_5},
  url = {https://doi.org/10.1007/978-1-4302-0614-9\_5},
  abstract = {Legal matters. It can matter a lot. Yet many software developers, completely obsessed with trying to get their product to the starting line, or selling enough of it to keep the lights on, delay or avoid altogether dealing with legal matters. Many folks would rather get a rectal exam than have a conversation with a lawyer.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_84628_856_2_4,
  title = {Selecting a Reverse Engineering System},
  author = {Keast, John},
  booktitle = {Springer Series in Advanced Manufacturing},
  year = {None},
  pages = {71-98},
  publisher = {Springer London},
  doi = {10.1007/978-1-84628-856-2\_4},
  url = {https://doi.org/10.1007/978-1-84628-856-2\_4},
  abstract = {In recent years, the market for systems to generate geometric representations of physical objects has exploded in size and complexity, as has the number of potential applications. Applications range from scanning the bodies and tracking the motion of actors for computer animated films through surveying buildings, plants, and landscape, medical applications from brain and prenatal scans to rapid prototyping of prosthetic devices and models of the patient for rehearsal of surgery, to the more conventional engineering applications of inspection, reverse engineering of obsolete parts, measurement of deformation on crash testing, and so on. Each application has unique requirements. The common thread in all these applications is that the starting point is the gathering of accurate x-y-z data over the surface of the object, and then from this, the construction of a geometric model in a computer system that can then be used in a variety of ways. Because of the wide variety of systems and applications, finding the right system for a particular application becomes difficult. This chapter offers a structured process for system selection which should lead to a sound system purchase. The different approaches to each stage of the reverse engineering process are classified and discussed, as are the pros and cons of each. Because the author has no links to any particular vendor, the chapter does not attempt to endorse or recommend any one approach or any one system. Each has a realm of application for which, given the constraints of cost, accuracy, and speed, it may be the best solution. The trick is to match the application requirements with the unique set of capabilities of a system!},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4020_6662_7_5,
  title = {Safeguards},
  author = {Ahonen, Pasi and Alahuhta, Petteri and Daskala, Barbara and Delaitre, Sabine and Hert, Paul De and Lindner, Ralf and Maghiros, Ioannis and Moscibroda, Anna and Schreurs, Wim and Verlinden, Michiel},
  booktitle = {The International Library of Ethics, Law and Technology},
  year = {2008},
  pages = {179-251},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-6662-7\_5},
  url = {https://doi.org/10.1007/978-1-4020-6662-7\_5},
  abstract = {The multiplicity of threats and vulnerabilities associated with AmI will require a multiplicity of safeguards to respond to the risks and problems posed by the emerging technological systems and their applications. In some instances, a single safeguard might be sufficient to address a specified threat or vulnerability. More typically, however, a combination of safeguards will be necessary to address each threat and vulnerability. In still other instances, one safeguard might apply to numerous treats and vulnerabilities. One could depict these combinations in a matrix or on a spreadsheet, but the spreadsheet would quickly become rather large and, perhaps, would be slightly misleading. Just as the AmI world will be dynamic, constantly changing, the applicability of safeguards should also be regarded as subject to a dynamic, i.e., different and new safeguards may need to be introduced in order to cope with changes in the threats and vulnerabilities.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_72354_7_12,
  title = {Reverse Engineering Java Card Applets Using Power Analysis},
  author = {Vermoen, Dennis and Witteman, Marc and Gaydadjiev, Georgi N.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2007},
  pages = {138-149},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-72354-7\_12},
  url = {https://doi.org/10.1007/978-3-540-72354-7\_12},
  abstract = {Power analysis on smart cards is widely used to obtain information about implemented cryptographic algorithms. We propose similar methodology for Java Card applets reverse engineering. Because power analysis alone does not provide enough information, we refine our methodology by involving additional information sources. Issues like distinguishing between bytecodes performing similar tasks and reverse engineering of conditional branches and nested loops are also addressed. The proposed methodology is applied to a commercially available Java Card smart card and the results are reported. We conclude that our augmented power analysis can be successfully used to acquire information about the bytecodes executed on a Java Card smart card.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4020_6268_1_45,
  title = {A Study of Software Protection Techniques},
  author = {Memon, Jan M. and Khan, Asma and Baig, Amber and Shah, Asadullah},
  booktitle = {Innovations and Advanced Techniques in Computer and Information Sciences and Engineering},
  year = {None},
  pages = {249-253},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-6268-1\_45},
  url = {https://doi.org/10.1007/978-1-4020-6268-1\_45},
  abstract = {Software piracy and tampering is a well known threat the world is faced with. There have been a lot of attempts to protect software from reverse engineering and tampering. It appears as if there is an ongoing war between software developers and crackers, both parties want to get an upper hand over each other as the time passes. Some of the ample techniques of software protection are reviewed, including multi-block hashing scheme, hardware based solutions, checksums, obfuscation, guards, software aging, cryptographic techniques and watermarking. All of these techniques play their parts imparted on them to protect the software from malicious attacks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10009_007_0043_0,
  title = {Slicing concurrent Java programs using Indus and Kaveri},
  author = {Ranganath, Venkatesh Prasad and Hatcliff, John},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2007},
  volume = {9},
  number = {5-6},
  pages = {489-504},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10009-007-0043-0},
  url = {https://doi.org/10.1007/s10009-007-0043-0},
  abstract = {Program slicing is a program analysis and transformation technique that has been successfully used in a wide range of applications including program comprehension, debugging, maintenance, testing, and verification. However, there are only few fully featured implementations of program slicing that are available for industrial applications or academic research. In particular, very little tool support exists for slicing programs written in modern object-oriented languages such as Java, C\#, or C++. In this paper, we present Indus—a robust framework for analyzing and slicing concurrent Java programs, and Kaveri—a feature-rich Eclipse-based GUI front end for Indus slicing. For Indus, we describe the underlying tool architecture, analysis components, and program dependence capabilities required for slicing. In addition, we present a collection of advanced features useful for effective slicing of Java programs including calling-context sensitive slicing, scoped slicing, control slicing, and chopping. For Kaveri, we discuss the design goals and basic capabilities of the graphical facilities integrated into a Java development environment to present the slicing information. This paper is an extended version of a tool demonstration paper presented at the International Conference on Fundamental Aspects of Software Engineering (FASE 2005). Thus, the paper highlights tool capabilities and engineering issues and refers the reader to other papers for technical details.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_69738_1_1,
  title = {DIVINE: DIscovering Variables IN Executables},
  author = {Balakrishnan, Gogul and Reps, Thomas},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {1-28},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69738-1\_1},
  url = {https://doi.org/10.1007/978-3-540-69738-1\_1},
  abstract = {This paper addresses the problem of recovering variable-like entities when analyzing executables in the absence of debugging information. We show that variable-like entities can be recovered by iterating Value-Set Analysis (VSA), a combined numeric-analysis and pointer-analysis algorithm, and Aggregate Structure Identification , an algorithm to identify the structure of aggregates. Our initial experiments show that the technique is successful in correctly identifying 88\% of the local variables and 89\% of the fields of heap-allocated objects. Previous techniques recovered 83\% of the local variables, but 0\% of the fields of heap-allocated objects. Moreover, the values computed by VSA using the variables recovered by our algorithm would allow any subsequent analysis to do a better job of interpreting instructions that use indirect addressing to access arrays and heap-allocated data objects: indirect operands can be resolved better at 4\% to 39\% of the sites of writes and up to 8\% of the sites of reads. (These are the memory-access operations for which it is the most difficult for an analyzer to obtain useful results.)},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_0_387_44599_1_3,
  title = {A Next-Generation Platform for Analyzing Executables},
  author = {Reps, Thomas and Balakrishnan, Gogul and Lim, Junghee and Teitelbaum, Tim},
  booktitle = {Advances in Information Security},
  year = {None},
  pages = {43-61},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-44599-1\_3},
  url = {https://doi.org/10.1007/978-0-387-44599-1\_3},
  abstract = {In recent years, there has been a growing need for tools that an analyst can use to understand the workings of COTS components, plug-ins, mobile code, and DLLs, as well as memory snapshots of worms and virus-infected code. Static analysis provides techniques that can help with such problems; however, there are several obstacles that must be overcome: For many kinds of potentially malicious programs, symbol-table and debugging information is entirely absent. Even if it is present, it cannot be relied upon. To understand memory-access operations, it is necessary to determine the set of addresses accessed by each operation. This is difficult because While some memory operations use explicit memory addresses in the instruction (easy), others use indirect addressing via address expressions (difficult). Arithmetic on addresses is pervasive. For instance, even when the value of a local variable is loaded from its slot in an activation record, address arithmetic is performed. There is no notion of type at the hardware level, so address values cannot be distinguished from integer values. Memory accesses do not have to be aligned, so word-sized address values could potentially be cobbled together from misaligned reads and writes. We have developed static-analysis algorithms to recover information about the contents of memory locations and how they are manipulated by an executable. By combining these analyses with facilities provided by the IDAPro and Codesurfer toolkits, we have created CodeSurfer/x86, a prototype tool for browsing, inspecting, and analyzing x86 executables. From an x86 executable, CodeSurfer/x86 recovers intermediate representations that are similar to what would be created by a compiler for a program written in a high-level language. CodeSurfer/x86 also supports a scripting language, as well as several kinds of sophisticated pattern-matching capabilities. These facilities provide a platform for the development of additional tools for analyzing the security properties of executables.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11823230_21,
  title = {Analysis of Low-Level Code Using Cooperating Decompilers},
  author = {Chang, Bor-Yuh Evan and Harren, Matthew and Necula, George C.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {318-335},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11823230\_21},
  url = {https://doi.org/10.1007/11823230\_21},
  abstract = {Analysis or verification of low-level code is useful for minimizing the disconnect between what is verified and what is actually executed and is necessary when source code is unavailable or is, say, intermingled with inline assembly. We present a modular framework for building pipelines of cooperating decompilers that gradually lift the level of the language to something appropriate for source-level tools. Each decompilation stage contains an abstract interpreter that encapsulates its findings about the program by translating the program into a higher-level intermediate language. We provide evidence for the modularity of this framework through the implementation of multiple decompilation pipelines for both x86 and MIPS assembly produced by gcc , gcj , and coolc (a compiler for a pedagogical Java-like language) that share several low-level components. Finally, we discuss our experimental results that apply the BLAST model checker for C and the Cqual analyzer to decompiled assembly.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0295_0_1,
  title = {Application Development},
  booktitle = {Visual Basic 2005 Recipes},
  year = {None},
  pages = {1-38},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0295-0\_1},
  url = {https://doi.org/10.1007/978-1-4302-0295-0\_1},
  abstract = {This chapter covers some of the fundamental activities you will need to perform when developing your Visual Basic .NET (VB .NET) solutions. The recipes in this chapter describe how to do the following: Use the VB .NET command-line compiler to build console and Windows Forms applications (recipes 1-1 and 1-2) Create and use code modules and libraries (recipes 1-3 and 1-4) Access command-line arguments from within your applications (recipe 1-5) Use compiler directives and attributes to selectively include code at build time (recipe 1-6) Access program elements built in other languages whose names conflict with VB .NET keywords (recipe 1-7) Give assemblies strong names and verify strong-named assemblies (recipes 1-8,1-9,1-10, and 1-11) Sign an assembly with a Microsoft Authenticode digital signature (recipes 1-12 and 1-13) Manage the shared assemblies that are stored in the global assembly cache (recipe 1-14) Make your assembly more difficult to decompile (recipe 1-15) Manipulate the appearance of the console (recipe 1-16) Compile and embed a string resource file (recipe 1-17)},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_71316_6_32,
  title = {Multi-language Synchronization},
  author = {Ennals, Robert and Gay, David},
  booktitle = {Lecture Notes in Computer Science},
  year = {2007},
  pages = {475-489},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-71316-6\_32},
  url = {https://doi.org/10.1007/978-3-540-71316-6\_32},
  abstract = {We propose multi-language synchronization , a novel approach to the problem of migrating code from a legacy language (such as C) to a new language. We maintain two parallel versions of every source file, one in the legacy language, and one in the new language. Both of these files are fully editable, and the two files are kept automatically in sync so that they have the same semantic meaning and, where possible, have the same comments and layout. We propose non-deterministic language translation as a means to implement multi-language synchronization. If a file is modified in language A, we produce a new version in language B by translating the file into a non-deterministic description of many ways that it could be encoded in language B and then choosing the version that is closest to the old file in language B. To demonstrate the feasibility of this approach, we have implemented a translator that can synchronize files written in a straw-man language, Jekyll, with files written in C. Jekyll is a high level functional programming language that has many of the features found in modern programming languages.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_73614_1_1,
  title = {Extensible Web Browser Security},
  author = {Ter Louw, Mike and Lim, Jin Soon and Venkatakrishnan, V. N.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2007},
  pages = {1-19},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-73614-1\_1},
  url = {https://doi.org/10.1007/978-3-540-73614-1\_1},
  abstract = {In this paper we examine the security issues in functionality extension mechanisms supported by web browsers. Extensions (or “plug-ins”) in modern web browsers enjoy unlimited power without restraint and thus are attractive vectors for malware. To solidify the claim, we take on the role of malware writers looking to assume control of a user’s browser space. We have taken advantage of the lack of security mechanisms for browser extensions and have implemented a piece of malware for the popular Firefox web browser, which we call browserSpy , that requires no special privileges to be installed. Once installed, browserSpy takes complete control of a user’s browser space and can observe all the activity performed through the browser while being undetectable. We then adopt the role of defenders to discuss defense strategies against such malware. Our primary contribution is a mechanism that uses code integrity checking techniques to control the extension installation and loading process. We also discuss techniques for runtime monitoring of extension behavior that provide a foundation for defending threats due to installed extensions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_84800_372_9_9,
  title = {Embedded Computer System Structures},
  booktitle = {Springer Series in Reliability Engineering},
  year = {None},
  pages = {117-242},
  publisher = {Springer London},
  doi = {10.1007/978-1-84800-372-9\_9},
  url = {https://doi.org/10.1007/978-1-84800-372-9\_9},
  abstract = {The purpose of this chapter is to use the model structures analysed in Chapter 8 to develop concrete models that are specific to embedded computer systems. Our approach is based on the functional relations developed by D.L. Parnas in [78, 79, 103]) for requirement specification. His functional relational models describe control systems, but have also been used for information systems [40]. We show in this chapter how this approach is also particularly well suited to the justification of dependability and fits well in our framework. We develop four sets of models which correspond to the levels of decomposition of the initial dependability requirements . These models include descriptions of the assumptions and constraints imposed on the embedded computer system at each level, i.e. those imposed: - by the plant environment, - by the computer and other existing equipment architectures, - by the hardware and software design and technology (in particular any preexisting hardware and software components), - and by the operational controls and procedures in place (e.g. operator controls, maintenance, periodic tests).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4020_6662_7_3,
  title = {Dark scenarios},
  author = {Ahonen, Pasi and Alahuhta, Petteri and Daskala, Barbara and Delaitre, Sabine and Hert, Paul De and Lindner, Ralf and Maghiros, Ioannis and Moscibroda, Anna and Schreurs, Wim and Verlinden, Michiel},
  booktitle = {The International Library of Ethics, Law and Technology},
  year = {2008},
  pages = {33-142},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-1-4020-6662-7\_3},
  url = {https://doi.org/10.1007/978-1-4020-6662-7\_3},
  abstract = {In this chapter, we present four “dark scenarios” that highlight the key socio-economic, legal, technological and ethical risks to privacy, identity, trust, security and inclusiveness posed by new AmI technologies. We call them dark scenarios, because they show things that could go wrong in an AmI world, because they present visions of the future that we do not want to become reality. The scenarios expose threats and vulnerabilities as a way to inform policy-makers and planners about issues they need to take into account in developing new policies or updating existing legislation. Before presenting the four scenarios and our analysis of each, we describe the process of how we created the scenarios as well as the elements in our methodology for analysing the scenarios.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0418_3_8,
  title = {Securing Your Applications},
  booktitle = {Creating Mobile Games},
  year = {None},
  pages = {305-316},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0418-3\_8},
  url = {https://doi.org/10.1007/978-1-4302-0418-3\_8},
  abstract = {Effective security is one of the main selling points of Java. Java offers consumers the assurance that an untrusted program won’t damage their devices or perform any unauthorized actions, and Java offers developers the use of a wide array of security tools that can be easily integrated into an application. The security features offered by Java Micro Edition (Java ME) with MIDP follow the same basic strategies and philosophy as the security features of other Java editions.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf03253255,
  title = {An open framework for distributed biometric authentication in a web environment},
  author = {Otero-Muras, Enrique and González-Agulla, Elisardo and Alba-Castro, José L. and García-Mateo, Carmen and MÁrquez-Flórez, Oscar W.},
  journal = {Annales Des Télécommunications},
  year = {2007},
  volume = {62},
  number = {1-2},
  pages = {177-192},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf03253255},
  url = {https://doi.org/10.1007/bf03253255},
  abstract = {Large-scale deployment of biometric systems for web-based services has to tackle technological issues related to security, interoperability and accuracy, and social issues related to privacy protection and biometric acquisition process acceptance. The variety of biometric traits, capturing devices, targeted populations and working scenarios makes the development of a universal solution for all-purpose deployment quite a difficult task. This paper describes the design, implementation and applicability of an open framework for distributed biometric authentication oriented to access-control in web environment. The open principle makes this framework a novel and practical development tool for testing and integrating biometric algorithms and devices from third parties. Special attention has been paid to security and interoperability standards to ease concurrent integration and testing of biometric trait matchers developed by different laboratories or companies. Finally, in order to demonstrate the versatility and usability of the framework, we describe the construction process for a distributed multibiometric database acquisition tool based on this framework.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_69861_6_18,
  title = {Copy Protection Systems},
  author = {Talstra, Joop},
  booktitle = {Security, Privacy, and Trust in Modern Data Management},
  year = {2007},
  pages = {267-285},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69861-6\_18},
  url = {https://doi.org/10.1007/978-3-540-69861-6\_18},
  abstract = {The bulk of today’s commercial audio and video content is distributed on (optical) media. As this business model is vulnerable to copying, the content is protected with some copy protection system (CPS) or other. In this chapter we look at the historic origins of Copy Protection and the basic technological ingredients of a CPS: media binding, broadcast encryption, and key hierarchies. Attention will also be devoted to auxiliary technologies such as watermarking and secure authenticated channels. We conclude with a review of new CPS components in upcoming protection systems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_74124_4_16,
  title = {A Model for Self-Modifying Code},
  author = {Anckaert, Bertrand and Madou, Matias and De Bosschere, Koen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2007},
  pages = {232-248},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-74124-4\_16},
  url = {https://doi.org/10.1007/978-3-540-74124-4\_16},
  abstract = {Self-modifying code is notoriously hard to understand and therefore very well suited to hide program internals. In this paper we introduce a program representation for this type of code: the state-enhanced control flow graph. It is shown how this program representation can be constructed, how it can be linearized into a binary program, and how it can be used to generate, analyze and transform self-modifying code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0201_1_2,
  title = {Building C\# Applications},
  booktitle = {Pro C\# with .NET 3.0},
  year = {None},
  pages = {33-62},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0201-1\_2},
  url = {https://doi.org/10.1007/978-1-4302-0201-1\_2},
  abstract = {As a C\# programmer, you may choose among numerous tools to build .NET applications. The point of this chapter is to provide a tour of various .NET development options, including, of course, Visual Studio 2005. The chapter opens, however, with an examination of working with the C\# command-line compiler, csc.exe, and the simplest of all text editors, Notepad (notepad.exe). Along the way, you will also learn about the process of debugging .NET assemblies at the command line using cordbg.exe. Once you become comfortable compiling and debugging assemblies “IDE-free,” you will then examine how the TextPad application allows you to edit and compile C\# source code files in a (slightly) more sophisticated manner.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0422_0_2,
  title = {Building C\# Applications},
  author = {Troelsen, Andrew},
  booktitle = {Pro C\# 2008 and the .NET 3.5 Platform},
  year = {2007},
  pages = {35-65},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0422-0\_2},
  url = {https://doi.org/10.1007/978-1-4302-0422-0\_2},
  abstract = {A s a C\# programmer, you may choose among numerous tools to build .NET applications. The point of this chapter is to provide a tour of various .NET development options, including, of course, Visual Studio 2008. The chapter opens, however, with an examination of working with the C\# command-line compiler, csc.exe, and the simplest of all text editors, the Notepad application that ships with the Microsoft Windows OS.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0422_0_14,
  title = {An Introduction to LINQ},
  author = {Troelsen, Andrew},
  booktitle = {Pro C\# 2008 and the .NET 3.5 Platform},
  year = {2007},
  pages = {447-472},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0422-0\_14},
  url = {https://doi.org/10.1007/978-1-4302-0422-0\_14},
  abstract = {T he previous chapter introduced you to numerous C\# 2008 programming constructs. As you have seen, features such as implicitly typed local variables, anonymous types, object initialization syntax, and lambda expressions (examined in Chapter 11) allow us to build very functional C\# code. Recall that while many of these features can be used directly as is, their benefits are much more apparent when used within the context of the Language Integrated Query (LINQ) technology set.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_0_387_44599_1_2,
  title = {Static Disassembly and Code Analysis},
  author = {Vigna, Giovanni},
  booktitle = {Advances in Information Security},
  year = {None},
  pages = {19-41},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-44599-1\_2},
  url = {https://doi.org/10.1007/978-0-387-44599-1\_2},
  abstract = {The classification of an unknown binary program as malicious or benign requires two steps. In the first step, the stream of bytes that constitutes the program has to be transformed (or disassembled) into the corresponding sequence of machine instructions. In the second step, based on this machine code representation, static or dynamic code analysis techniques can be applied to determine the properties and function of the program. Both the disassembly and code analysis steps can be foiled by techniques that obfuscate the binary representation of a program. Thus, robust techniques are required that deliver reliable results under such adverse circumstances. In this chapter, we introduce a disassemble technique that can deal with obfuscated binaries. Also, we introduce a static code analysis approach that can identify high-level semantic properties of code that are difficult to conceal.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_006_0031_z,
  title = {Network-level polymorphic shellcode detection using emulation},
  author = {Polychronakis, Michalis and Anagnostakis, Kostas G. and Markatos, Evangelos P.},
  journal = {Journal in Computer Virology},
  year = {2007},
  volume = {2},
  number = {4},
  pages = {257-274},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-006-0031-z},
  url = {https://doi.org/10.1007/s11416-006-0031-z},
  abstract = {Significant progress has been made in recent years towards preventing code injection attacks at the network level. However, as state-of-the-art attack detection technology becomes more prevalent, attackers are likely to evolve, employing techniques such as polymorphism and metamorphism to defeat these defenses. A major outstanding question in security research and engineering is thus whether we can proactively develop the tools needed to contain advanced polymorphic and metamorphic attacks. While recent results have been promising, most of the existing proposals can be defeated using only minor enhancements to the attack vector. In fact, some publicly-available polymorphic shellcode engines are currently one step ahead of the most advanced publicly-documented network-level detectors. In this paper, we present a heuristic detection method that scans network traffic streams for the presence of previously unknown polymorphic shellcode. In contrast to previous work, our approach relies on a NIDS- embedded CPU emulator that executes every potential instruction sequence in the inspected traffic, aiming to identify the execution behavior of polymorphic shellcode. Our analysis demonstrates that the proposed approach is more robust to obfuscation techniques like self-modifications compared to previous proposals, but also highlights advanced evasion techniques that need to be more closely examined towards a satisfactory solution to the polymorphic shellcode detection problem.},
  content_type = {Article},
}


@incollection{springer_10_1007_0_387_31168_8_13,
  title = {Copyright Management Systems},
  author = {George, Carlisle E.},
  booktitle = {IFIP International Federation for Information Processing},
  year = {None},
  pages = {211-222},
  publisher = {Kluwer Academic Publishers},
  doi = {10.1007/0-387-31168-8\_13},
  url = {https://doi.org/10.1007/0-387-31168-8\_13},
  abstract = {This paper first examines technical and legal issues surrounding Copyright Management Systems (CMS). It then examines the rationale for use of these systems and some accompanying criticisms. It argues that there are compelling economic reasons for controlling access to, and use of copyrighted material, especially in light of digital technology and the Internet. It also argues that CMS have very undesirable qualities which raise concerns about social accountability. They can exert strong control over access to material, invade privacy and deprive the public domain of valuable resources (hence affecting innovation) echoing aspects of eighteenth century Blackstonian ideology. The paper concludes that the present state of affairs in which CMS has increased the power to rights-holders may be detrimental to the development of human society. Technology and the law appear to have colluded to potentially stifle innovation, hence producing no ultimate winners in the future.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_79977_8_5,
  title = {Performance, Scalability, and Parallel Model Execution},
  author = {Fujimoto, Richard M. and Riley, George F. and Perumalla, Kalyan S.},
  booktitle = {Synthesis Lectures on Learning, Networks, and Algorithms},
  year = {2007},
  pages = {35-56},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-79977-8\_5},
  url = {https://doi.org/10.1007/978-3-031-79977-8\_5},
  abstract = {We now turn our attention to issues concerning the performance and scalability of network simulation programs. By performance we mean the execution speed of the network simulator. By scalability we mean the size of the network that can be modeled. Performance and scalability are important issues in network simulation because it is often the case that one would like to model networks that are beyond the capabilities of the available simulation tools. One approach to addressing these concerns is to utilize parallel computation, so a major emphasis of our discussion considers the exploitation of parallel computers to execute the simulation program.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11925071_11,
  title = {Queryll: Java Database Queries Through Bytecode Rewriting},
  author = {Iu, Ming-Yee and Zwaenepoel, Willy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {201-218},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11925071\_11},
  url = {https://doi.org/10.1007/11925071\_11},
  abstract = {When interfacing Java with other systems such as databases, programmers must often program in special interface languages like SQL. Code written in these languages often needs to be embedded in strings where they cannot be error-checked at compile-time, or the Java compiler needs to be altered to directly recognize code written in these languages. We have taken a different approach to adding database query facilities to Java. Bytecode rewriting allows us to add query facilities to Java whose correctness can be checked at compile-time but which don’t require any changes to the Java language, Java compilers, Java VMs, or IDEs. Like traditional object-relational mapping tools, we provide Java libraries for accessing individual database entries as objects and navigating among them. To express a query though, a programmer simply writes code that takes a Collection representing the entire contents of a database, iterates over each entry like they would with a normal Collection, and choose the entries of interest. The query is fully valid Java code that, if executed, will read through an entire database and copy entries into Java objects where they will be inspected. Executing queries in this way is obviously inefficient, but we have a special bytecode rewriting tool that can decompile Java class files, identify queries in the bytecode, and rewrite the code to use SQL instead. The rewritten bytecode can then be run using any standard Java VM. Since queries use standard Java set manipulation syntax, Java programmers do not need to learn any new syntax. Our system is able to handle complex queries that make use of all the basic relational operations and exhibits performance comparable to that of hand-written SQL.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_006_0029_6,
  title = {On the possibility of practically obfuscating programs towards a unified perspective of code protection},
  author = {Beaucamps, Philippe and Filiol, Eric},
  journal = {Journal in Computer Virology},
  year = {2007},
  volume = {3},
  number = {1},
  pages = {3-21},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-006-0029-6},
  url = {https://doi.org/10.1007/s11416-006-0029-6},
  abstract = {Barak et al. gave a first formalization of obfuscation, describing an obfuscator \\(\{\\mathcal\{O\}\}\\) as an efficient, probabilistic “compiler” that takes in input a program P and produces a new program \\(\{\\mathcal\{O\}(P)\}\\) that has the same functionality as P but is unintelligible. This means that any result an obfuscated program can compute is actually computable given only an input/output access (called oracle access) to the program P : we call such results trivial results. On the basis of this informal definition, they suggest a formal definition of obfuscation based on oracle access to programs and show that no obfuscator can exist according to this definition. They also try to relax the definition and show that, even with a restriction to some common classes of programs, there exists no obfuscator. In this work, we show that their definition is too restrictive and lacks a fundamental property, that we formalize by the notion of oracle programs. Oracle programs are an abstract notion which basically refers to perfectly obfuscated programs. We suggest a new definition of obfuscation based on these oracle programs and show that such obfuscators do not exist either. Considering the actual implementations of “obfuscators”, we define a new kind of obfuscators, \\(\{\\tau\}\\) -obfuscators. These are obfuscators that hide non trivial results at least for time \\(\{\\tau\}\\) . By restricting the \\(\{\\tau\}\\) -requirement to deobfuscation (that is outputting an intelligible program when fed with an obfuscated program in input), we show that such obfuscators do exist. Practical \\(\{\\tau\}\\) -obfuscation methods are presented at the end of this paper: we focus more specifically on code protection techniques in a malware context. Based on the fact that a malware may fulfill its action in an amount of time which may be far larger than the analysis time of any automated detection program, these obfuscation methods can be considered as efficient enough to greatly thwart automated analysis and put check on any antivirus software.},
  content_type = {Article},
}


@incollection{springer_10_1007_11909033_9,
  title = {Enhanced CAPTCHAs: Using Animation to Tell Humans and Computers Apart},
  author = {Athanasopoulos, Elias and Antonatos, Spiros},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {97-108},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11909033\_9},
  url = {https://doi.org/10.1007/11909033\_9},
  abstract = {Completely Automated Public Turing Test to tell Computers and Humans Apart (CAPTCHA) is a –rather– simple test that can be easily answered by a human but extremely difficult to be answered by computers. CAPTCHAs have been widely used for practical security reasons, like preventing automated registration in Web-based services. However, all deployed CAPTCHAs are based on the static identification of an object or text. All CAPTCHAs, from simple ones, like typing the distorted text, to advanced ones, like recognizing an object in an image, are vulnerable to the Laundry attack. An attacker may post the test to a malicious site and attract its visitors to solve the puzzle for her. This paper focuses on sealing CAPTCHAs against such attacks by adding a dimension not used so far: animation. Animated CAPTCHAs do not have a static answer, thus even when they are exposed to laundering, unsuspected visitors will provide answers that will be useless on the attacker’s side.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_1_4020_5263_4_52,
  title = {Reverse Engineering Analyze for Microcontrollers’ Assembly language Projects},
  author = {Popa, M. and Macrea, M. and Mihu, L.},
  booktitle = {Advances in Systems, Computing Sciences and Software Engineering},
  year = {None},
  pages = {333-338},
  publisher = {Springer Netherlands},
  doi = {10.1007/1-4020-5263-4\_52},
  url = {https://doi.org/10.1007/1-4020-5263-4\_52},
  abstract = {The problem of reverse engineering assembly language projects for microcontrollers from embedded systems is approached in this paper. A tool for analyzing projects is described which starts from the source files of the project to be analyzed, grouped in a Project Folder and from a Configuration files and generates diagrams for describing the program’s functionality. The tool is useful for the programmer and for the project manager in different phases of a project: code review, design review and development. It is also useful for understanding and documenting older projects.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_69611_7_8,
  title = {Verification of Java Bytecode Using Analysis and Transformation of Logic Programs},
  author = {Albert, Elvira and Gómez-Zamalloa, Miguel and Hubert, Laurent and Puebla, Germán},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {124-139},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69611-7\_8},
  url = {https://doi.org/10.1007/978-3-540-69611-7\_8},
  abstract = {State of the art analyzers in the Logic Programming (LP) paradigm are nowadays mature and sophisticated. They allow inferring a wide variety of global properties including termination, bounds on resource consumption, etc. The aim of this work is to automatically transfer the power of such analysis tools for LP to the analysis and verification of Java bytecode ( jvml ). In order to achieve our goal, we rely on well-known techniques for meta-programming and program specialization. More precisely, we propose to partially evaluate a jvml interpreter implemented in LP together with (an LP representation of) a jvml program and then analyze the residual program. Interestingly, at least for the examples we have studied, our approach produces very simple LP representations of the original jvml programs. This can be seen as a decompilation from jvml to high-level LP source. By reasoning about such residual programs, we can automatically prove in the CiaoPP system some non-trivial properties of jvml programs such as termination, run-time error freeness and infer bounds on its resource consumption. We are not aware of any other system which is able to verify such advanced properties of Java bytecode.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11687061_9,
  title = {abc : An Extensible AspectJ Compiler},
  author = {Avgustinov, Pavel and Christensen, Aske Simon and Hendren, Laurie and Kuzins, Sascha and Lhoták, Jennifer and Lhoták, Ondřej and de Moor, Oege and Sereni, Damien and Sittampalam, Ganesh and Tibble, Julian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {293-334},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11687061\_9},
  url = {https://doi.org/10.1007/11687061\_9},
  abstract = {Research in the design of aspect-oriented programming languages requires a workbench that facilitates easy experimentation with new language features and implementation techniques. In particular, new features for AspectJ have been proposed that require extensions in many dimensions: syntax, type checking and code generation, as well as data flow and control flow analyses. The AspectBench Compiler ( abc ) is an implementation of such a workbench. The base version of abc implements the full AspectJ language. Its front end is built using the Polyglot framework, as a modular extension of the Java language. The use of Polyglot gives flexibility of syntax and type checking. The back end is built using the Soot framework, to give modular code generation and analyses. In this paper, we outline the design of abc , focusing mostly on how the design supports extensibility. We then provide a general overview of how to use abc to implement an extension. We illustrate the extension mechanisms of abc through a number of small, but nontrivial, examples. We then proceed to contrast the design goals of abc with those of the original AspectJ compiler, and how these different goals have led to different design decisions. Finally, we review a few examples of projects by others that extend abc in interesting ways.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11689522_33,
  title = {A Chaos-Based Robust Software Watermarking},
  author = {Liu, Fenlin and Lu, Bin and Luo, Xiangyang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {355-366},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11689522\_33},
  url = {https://doi.org/10.1007/11689522\_33},
  abstract = {In this paper we propose a robust software watermarking based on chaos against several limitations of existing software watermarking. The algorithm combines the anti-reverse engineering technique, chaotic system and the idea of Easter Egg software watermarks. The global protection for the program is provided by dispersing watermark over the whole code of the program with chaotic dispersion coding; the resistance against reverse engineering is improved by using the anti-reverse engineering technique. In the paper, we implement the scheme in the Intel i386 architecture and the Windows operating system, and analyze the robustness and the performance degradation of watermarked program. Analysis indicates that the algorithm resists various types of semantics-preserving transformation attacks and is good tolerance for reverse engineering attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11693024_5,
  title = {Coinductive Big-Step Operational Semantics},
  author = {Leroy, Xavier},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {54-68},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11693024\_5},
  url = {https://doi.org/10.1007/11693024\_5},
  abstract = {This paper illustrates the use of coinductive definitions and proofs in big-step operational semantics, enabling the latter to describe diverging evaluations in addition to terminating evaluations. We show applications to proofs of type soundness and to proofs of semantic preservation for compilers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_69330_7_6,
  title = {Generation of Control and Data Flow Graphs from Scheduled and Pipelined Assembly Code},
  author = {Zaretsky, David C. and Mittal, Gaurav and Dick, Robert and Banerjee, Prith},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {76-90},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-69330-7\_6},
  url = {https://doi.org/10.1007/978-3-540-69330-7\_6},
  abstract = {High-level synthesis tools generally convert abstract designs described in a high-level language into a control and data flow graph (CDFG), which is then optimized and mapped to hardware. However, there has been little work on generating CDFGs from highly pipelined software binaries, which complicate the problem of determining data flow propagation and dependencies. This paper presents a methodology for generating CDFGs from highly pipelined and scheduled assembly code that correctly represents the data dependencies and propagation of data through the program control flow. This process consists of three stages: generating a control flow graph, linearizing the assembly code, and generating the data flow graph. The proposed methodology was implemented in the FREEDOM compiler and tested on 8 highly pipelined software binaries. Results indicate that data dependencies were correctly identified in the designs, allowing the compiler to perform complex optimizations to reduce clock cycles.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11787952_2,
  title = {TIVA: Trusted Integrity Verification Architecture},
  author = {Gomathisankaran, Mahadevan and Tyagi, Akhilesh},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {13-31},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11787952\_2},
  url = {https://doi.org/10.1007/11787952\_2},
  abstract = {We are moving towards the era of pervasive computing. The embedded computing devices are everywhere and they need to interact in many insecure ways. Verifying the integrity of the software running on these devices in such a scenario is an interesting and difficult problem. The problem is simplified if the verifying entity has access to the original binary image. However, the verifier itself may not be trusted with the intellectual property built into the software. Hence an acceptable and practical solution would not reveal the intellectual property (IP) of the verified software, and yet must verify its integrity. We propose one such novel solution, TIVA, in this paper.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11604938_15,
  title = {Software Protection Through Dynamic Code Mutation},
  author = {Madou, Matias and Anckaert, Bertrand and Moseley, Patrick and Debray, Saumya and De Sutter, Bjorn and De Bosschere, Koen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {194-206},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11604938\_15},
  url = {https://doi.org/10.1007/11604938\_15},
  abstract = {Reverse engineering of executable programs, by disassembling them and then using program analyses to recover high level semantic information, plays an important role in attacks against software systems, and can facilitate software piracy. This paper introduces a novel technique to complicate reverse engineering. The idea is to change the program code repeatedly as it executes, thereby thwarting correct disassembly. The technique can be made as secure as the least secure component of opaque variables and pseudorandom number generators.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0162_5_9,
  title = {ClickOnce Tools and Scenarios},
  booktitle = {Deploying .NET Applications},
  year = {None},
  pages = {219-252},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0162-5\_9},
  url = {https://doi.org/10.1007/978-1-4302-0162-5\_9},
  abstract = {In this chapter, we discussed three important tools related to ClickOnce. We talked about the Bootstrapper Manifest Generator (BMG), the Manifest Generation and Editing (MAGE) tool, and MSBuild. All of the discussions in this chapter related to practical problems. For example, we showed how you can use the BMG tool to quickly create the product and package XML files needed to create custom prerequisites. The discussions about the MAGE tools gave four practical scenarios where the MAGE tool can be useful, and the discussion of MSBuild showed how to automate the generation of a ClickOnce deployment. All of these tools will be useful as you work with ClickOnce. The last portion of this chapter talked about some practical ClickOnce scenarios.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11416_005_0005_6,
  title = {New threats of Java viruses},
  author = {Reynaud-Plantey, Daniel},
  journal = {Journal in Computer Virology},
  year = {2005},
  volume = {1},
  number = {1-2},
  pages = {32-43},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-005-0005-6},
  url = {https://doi.org/10.1007/s11416-005-0005-6},
  abstract = {Only two Java viruses are known and have been published as a proof-of-concept: StrangeBrew and BeanHive. Since then the Java programming language has matured and greatly evolved to include a large number of new, sophisticated functionalities. At the same time, no serious study has been conducted to assess the potential viral risk attached to the new Java language. The potential threats have not really been explored yet. This article presents the state-of-the-art of Java viral capabilities and identifies some new techniques specific to the Java features that could be efficiently used by an attacker to spread malicious codes by means of Java classes. While this paper primarily focuses on targeting Java applications and not applets, the latter case will nonetheless be addressed among the different ways an actual attack could be launched by means of Java malicious codes. The protection and cure against such codes are also considered, dealing with the analysis of these programs at the bytecode level},
  content_type = {Article},
}


@incollection{springer_10_1007_11750734_1,
  title = {The Logical Way to Be Artificially Intelligent},
  author = {Kowalski, Robert},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {1-22},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11750734\_1},
  url = {https://doi.org/10.1007/11750734\_1},
  abstract = {Abductive logic programming (ALP) can be used to model reactive, proactive and pre-active thinking in intelligent agents. Reactive thinking assimilates observations of changes in the environment, whereas proactive thinking reduces goals to sub-goals and ultimately to candidate actions. Pre-active thinking generates logical consequences of candidate actions, to help in deciding between the alternatives. These different ways of thinking are compatible with any way of deciding between alternatives, including the use of both decision theory and heuristics. The different forms of thinking can be performed as they are needed, or they can be performed in advance, transforming high-level goals and beliefs into lower-level condition-action rule form, which can be implemented in neural networks. Moreover, the higher-level and lower-level representations can operate in tandem, as they do in dual-process models of thinking. In dual process models, intuitive processes form judgements rapidly, sub-consciously and in parallel, while deliberative processes form and monitor judgements slowly, consciously and serially. ALP used in this way can not only provide a framework for constructing artificial agents, but can also be used as a cognitive model of human agents. As a cognitive model, it combines both a descriptive model of how humans actually think with a normative model of humans can think more effectively.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11790754_8,
  title = {Detecting Self-mutating Malware Using Control-Flow Graph Matching},
  author = {Bruschi, Danilo and Martignoni, Lorenzo and Monga, Mattia},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {129-143},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11790754\_8},
  url = {https://doi.org/10.1007/11790754\_8},
  abstract = {Next generation malware will by be characterized by the intense use of polymorphic and metamorphic techniques aimed at circumventing the current malware detectors, based on pattern matching. In order to deal with this new kind of threat, novel techniques have to be devised for the realization of malware detectors. Recent papers started to address such an issue and this paper represents a further contribution in such a field. More precisely in this paper we propose a strategy for the detection of metamorphic malicious code inside a program P based on the comparison of the control flow graphs of P against the set of control flow graphs of known malware. We also provide experimental data supporting the validity of our strategy.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_1_84628_210_1_37,
  title = {On the Merging of Geometric Models Based on Hierarchical Context},
  author = {Knowlton, J. A. and Wozny, Michael J.},
  booktitle = {Springer Series in Advanced Manufacturing},
  year = {None},
  pages = {451-460},
  publisher = {Springer-Verlag},
  doi = {10.1007/1-84628-210-1\_37},
  url = {https://doi.org/10.1007/1-84628-210-1\_37},
  abstract = {Recently, efforts have been made to define the role of “context” in the Product Realization Process. This paper treats only a small slice of this problem and applies the notion of context to the automatic merging of geometric models created with the computer graphics language OpenGL. Context can be thought of as a set of properties or environmental variables of some entity that constrains or governs the behavior of that entity. The entity in this case is a three-dimensional geometric model and its context is the set of properties for viewing that model: lighting, viewing parameters, material reflective properties, colour. Now suppose a geometric model is made up of a collection of sub-models, each within its own context. If each context is associated with an integer, then the contexts can be ordered hierarchically. Thus the topmost context in the hierarchy becomes the global context for all the sub-models in the collection. Stated in another way, once a contextual hierarchy is defined, then the structure for combining these sub-models is established independently of when and in what individual contexts the sub-models are created. Consequently, context allows a concurrent generation of models within a formalized structure that automatically deals with conflict resolution — albeit in a limited way in this work. This paper describes a compiler in XML that will merge the OpenGL files automatically.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11877028_14,
  title = {The COMPOST, COMPASS, Inject/J and RECODER Tool Suite for Invasive Software Composition: Invasive Composition with COMPASS Aspect-Oriented Connectors},
  author = {Heuzeroth, Dirk and Aßmann, Uwe and Trifu, Mircea and Kuttruff, Volker},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {357-377},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11877028\_14},
  url = {https://doi.org/10.1007/11877028\_14},
  abstract = {Program analyses and transformations are means to support program evolution and bridge architectural mismatches in component composition. The Program Structures Group at the University of Karlsruhe und the FZI Karlsruhe, that we are or have been members of, have developed a suite of program analysis and transformation tools to attack these problems. The basic tool Recoder offers sophisticated source code analyses and a library of common transformations in the form of Java meta programs to perform necessary component and interaction adapations. This library can be extended by the Recoder framework that offers means for implementing custom transformations. A transformation can also be a generator to produce glue code, for example. Inject/J uses Recoder and offers a comfortable scripting language for implementing transformations. The scripting language combines declarative specifications of the program points, where the transformation should be applied, with imperative specifications of the transformation itself. COMPASS is focused on bridging interaction mismatches among software components. It introduces architectural elements like components, ports and aspect-oriented connectors as source code transformations based on the Recoder framework. COMPOST defines the general model of invasive software composition, where the ports of the COMPASS model are just one kind of hooks. Hooks are join points, i.e. part of a component that may be extended or replaced.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11935070_17,
  title = {Watermarking Essential Data Structures for Copyright Protection},
  author = {Albluwi, Qutaiba and Kamel, Ibrahim},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {241-258},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11935070\_17},
  url = {https://doi.org/10.1007/11935070\_17},
  abstract = {Software watermarking is a new research area that aims at providing copyright protection for commercial software. It minimizes software piracy by hiding copyright signatures inside the program code or its runtime state. Prior proposals hide the watermarks in dummy data structures, e.g., linked lists and graphs that are created during the execution of the hosting software for this reason. This makes it vulnerable to subtractive attacks, because the attacker can remove the data structure without altering the operation or the semantic of the software program. In this regard, we argue that hiding watermarks in one or more data structures that are used by the program would make the watermark more robust because removing the watermark would alter the semantic and the operations of the underlying software. However, the challenge is that the insertion of the watermark should have a minimal effect on the operations and performance of the data structure. This paper proposes a novel method for watermarking R-tree data structure and its variants. The proposed watermarking scheme takes advantage of the redundancy in the way the entries within R-tree nodes are ordered. R-trees do not require ordering the entries in a specific way. Node entries are re-ordered in a way to map the watermark. The new order is calculated relative to a “secret” initial order, known only to the software owner, using a technique based on a numbering system that uses variable radix and factorial base. The addition of the watermark in the R-tree data structure neither affects the performance nor increases the size of the R-tree. The paper provides a threat model and analysis to show that the watermarked R-trees are robust and can withstand various types of attacks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10009_004_0174_5,
  title = {Formal change impact analyses for emulated control software},
  author = {Fidge, C. J.},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2006},
  volume = {8},
  number = {4-5},
  pages = {321-335},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10009-004-0174-5},
  url = {https://doi.org/10.1007/s10009-004-0174-5},
  abstract = {Processor emulators are a software tool for allowing legacy computer programs to be executed on a modern processor. In the past emulators have been used in trivial applications such as maintenance of video games. Now, however, processor emulation is being applied to safety-critical control systems, including military avionics. These applications demand utmost guarantees of correctness, but no verification techniques exist for proving that an emulated system preserves the original system’s functional and timing properties. Here we show how this can be done by combining concepts previously used for reasoning about real-time program compilation, coupled with an understanding of the new and old software architectures. In particular, we show how both the old and new systems can be given a common semantics, thus allowing their behaviours to be compared directly.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_0160_1_2,
  title = {Building Visual Basic 2005 Applications},
  booktitle = {Pro VB 2005 and the .NET 2.0 Platform},
  year = {None},
  pages = {31-61},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0160-1\_2},
  url = {https://doi.org/10.1007/978-1-4302-0160-1\_2},
  abstract = {So as you can see, you have many new toys at your disposal! The point of this chapter was to provide you with a tour of the major programming tools a VB 2005 programmer may leverage during the development process. You began the journey by learning how to generate .NET assemblies using nothing other than the free VB 2005 compiler and Notepad. Next, you were introduced to the TextPad application and walked through the process of enabling this tool to edit and compile *.vb code files. You also examined three feature-rich IDEs, starting with the open source SharpDevelop, followed by Microsoft’s Visual Basic 2005 Express and Visual Studio 2005. While this chapter only scratched the surface of each tool’s functionality, you should be in a good position to explore your chosen IDE at your leisure. The chapter wrapped up by describing the role of Microsoft.VisualBasic.dll and examined a number of open source .NET development tools that extend the functionality of your IDE of choice.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11790754_4,
  title = {Network–Level Polymorphic Shellcode Detection Using Emulation},
  author = {Polychronakis, Michalis and Anagnostakis, Kostas G. and Markatos, Evangelos P.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {54-73},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11790754\_4},
  url = {https://doi.org/10.1007/11790754\_4},
  abstract = {As state–of–the–art attack detection technology becomes more prevalent, attackers are likely to evolve, employing techniques such as polymorphism and metamorphism to evade detection. Although recent results have been promising, most existing proposals can be defeated using only minor enhancements to the attack vector. We present a heuristic detection method that scans network traffic streams for the presence of polymorphic shellcode. Our approach relies on a NIDS–embedded CPU emulator that executes every potential instruction sequence, aiming to identify the execution behavior of polymorphic shellcodes. Our analysis demonstrates that the proposed approach is more robust to obfuscation techniques like self-modifications compared to previous proposals, but also highlights advanced evasion techniques that need to be more closely examined towards a satisfactory solution to the polymorphic shellcode detection problem.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11663812_15,
  title = {A Fast Static Analysis Approach to Detect Exploit Code Inside Network Flows},
  author = {Chinchani, Ramkumar and van den Berg, Eric},
  booktitle = {Lecture Notes in Computer Science},
  year = {2006},
  pages = {284-308},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11663812\_15},
  url = {https://doi.org/10.1007/11663812\_15},
  abstract = {A common way by which attackers gain control of hosts is through remote exploits. A new dimension to the problem is added by worms which use exploit code to self-propagate, and are becoming a commonplace occurrence. Defense mechanisms exist but popular ones are signature-based techniques which use known byte patterns, and they can be thwarted using polymorphism, metamorphism and other obfuscations. In this paper, we argue that exploit code is characterized by more than just a byte pattern because, in addition, there is a definite control and data flow. We propose a fast static analysis based approach which is essentially a litmus test and operates by making a distinction between data, programs and program-like exploit code. We have implemented a prototype called styx and evaluated it against real data collected at our organizational network. Results show that it is able to detect a variety of exploit code and can also generate very specific signatures. Moreover, it shows initial promise against polymorphism and metamorphism.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_1_84628_339_6_8,
  title = {Toward GRIDLE: A Way to Build Grid Applications Searching Through an Ecosystem of Components},
  author = {Puppin, Diego and Silvestri, Fabrizio and Orlando, Salvatore and Laforenza, Domenico},
  booktitle = {Grid Computing: Software Environments and Tools},
  year = {None},
  pages = {176-204},
  publisher = {Springer London},
  doi = {10.1007/1-84628-339-6\_8},
  url = {https://doi.org/10.1007/1-84628-339-6\_8},
  abstract = {In this contribution, we presented our vision of a new strategy to design component-based Grid applications. A three-staged approach, driven by graphical tools and accessible to non-expert programmers, should be as follows:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0308_7_3,
  title = {Flash lite 1.1 and your first flash lite application},
  booktitle = {Foundation Flash Applications for Mobile Devices},
  year = {None},
  pages = {43-95},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0308-7\_3},
  url = {https://doi.org/10.1007/978-1-4302-0308-7\_3},
  abstract = {Flash Lite is Adobe’s flagship application in the mobile world. Like its big brother the desktop Flash player, the Flash Lite player provides a feature-rich platform for delivering multimedia experiences over a range of devices from mobile phones to set-top boxes. Although Flash Lite 1.1 doesn’t support all of the functionality of the desktop profile, the same underlying features, including vectors, bitmap graphics, MP3 sound, and a flexible scripting engine, provide more than enough power to create versatile and engaging mobile applications. However, Flash Lite 2 (see Chapter 4) does allow for the use of ActionScript 2 and should prove much less alien to those of you already accustomed to creating Flash content for the Web. It’s important to note that the Flash Lite player, like the desktop player, always plays content created for a previous version, so content authored for Flash Lite 1.1 can be played without any modifications in the Flash Lite 2 player.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0214_1_26,
  title = {Disaster Recovery},
  booktitle = {Pro Oracle Database 10g RAC on Linux},
  year = {None},
  pages = {717-741},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0214-1\_26},
  url = {https://doi.org/10.1007/978-1-4302-0214-1\_26},
  abstract = {Disaster recovery provides continuity of operations in the event of total loss of a site, which may be the result of a natural disaster, such as a hurricane, fire, or flood; terrorism; disruption to the power supply; an industrial dispute; or any other event that might affect the primary data center. A disaster recovery plan will therefore involve at least one secondary site that operations can be transferred to in the event of the loss of the primary site; this process is known as a failover.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11427995_62,
  title = {The Application of PROACT® RCA to Terrorism/Counter Terrorism Related Events},
  author = {Latino, Robert J.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {579-589},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11427995\_62},
  url = {https://doi.org/10.1007/11427995\_62},
  abstract = {Field proven Root Cause Analysis (RCA) from the industrial sector can assist the terrorism community in decompiling terrorist acts to further understand the mentalities that trigger such events to escalate. RCA is a disciplined thought process that is not specific to any industry or given situation, but specific to the human being. We will focus on how to logically breakdown a seemly complex event into it more manageable sub-components.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0007_9_12,
  title = {Malware Code Analysis},
  booktitle = {Honeypots for Windows},
  year = {None},
  pages = {337-361},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0007-9\_12},
  url = {https://doi.org/10.1007/978-1-4302-0007-9\_12},
  abstract = {This chapter discussed disassembling malware to discover its features and functionalities. Disassembling code requires learning assembly language, acquiring a good disassembler like IDA Pro, and learning malware techniques. The payoff is a complete understanding of what the malware or hacker was attempting to do. This concludes Honeypots for Windows , which guided you on a journey where, for once, the good guys always win. Honeypots are our best shot for staying equal with the malicious hacker community, and perhaps even moving ahead. A honeypot is often the best computer security defense tool for the job. As an early warning system, it can alert you when all the other security defenses have failed. Becoming a honeypot administrator is joining a brotherhood of like-minded people who are doing something to improve the world. Thanks for reading my book. Please feel free to send questions, comments, and your real-world experiences to me at roger@banneretcs.com.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_31985_6_19,
  title = {CodeSurfer/x86—A Platform for Analyzing x86 Executables},
  author = {Balakrishnan, Gogul and Gruian, Radu and Reps, Thomas and Teitelbaum, Tim},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {250-254},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-31985-6\_19},
  url = {https://doi.org/10.1007/978-3-540-31985-6\_19},
  abstract = {CodeSurfer/x86 is a prototype system for analyzing x86 executables. It uses a static-analysis algorithm called value-set analysis (VSA) to recover intermediate representations that are similar to those that a compiler creates for a program written in a high-level language. A major challenge in building an analysis tool for executables is in providing useful information about operations involving memory. This is difficult when symbol-table and debugging information is absent or untrusted. CodeSurfer/x86 overcomes these challenges to provide an analyst with a powerful and flexible platform for investigating the properties and behaviors of potentially malicious code (such as COTS components, plugins, mobile code, worms, Trojans, and virus-infected code) using (i) CodeSurfer/x86’s GUI, (ii) CodeSurfer/x86’s scripting language, which provides access to all of the intermediate representations that CodeSurfer/x86 builds for the executable, and (iii) GrammaTech’s Path Inspector, which is a tool that uses a sophisticated pattern-matching engine to answer questions about the flow of execution in a program.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0739_9_5,
  title = {Decompiler Design},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {121-157},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_5},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_5},
  abstract = {For the remainder of this book , I’m going to focus on how you can create your own decompiler, which is, in fact, a cross-compiler that translates bytecode to source code. Although I will be covering the theory behind the relevant design decisions as they arise, my intention is to give you enough background information to get you going rather than to give you a full-blown chapter on compiler theory.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11552451_182,
  title = {Logic Frameworks for Components Integration Process},
  author = {Kim, Haeng-Kon and Han, Deok-Soo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {1317-1324},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11552451\_182},
  url = {https://doi.org/10.1007/11552451\_182},
  abstract = {This research developed the CBD(Component Based Development) logic frameworks for the Integration of components and a tool which supports this. The Integration of components becomes necessary during the process of reusing or assembling components, and this is because the interface of the component is, in many cases, different than the component the developer wishes to assemble. After the iterations of specification modification and verification in terms of knowledge acquisition activities, Logic frameworks are correctly formed. Occasionally, additional attributes may need to be defined in accordance to new requirements. Consequently, the process for component Integration is crucial for the reuse and assembly of components. In order to support the Integration of components, this research proposes an Integration technique dependent upon binary component Integration techniques and Integration components. In addition, a support tool was developed to support an effective Integration process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0739_9_6,
  title = {Decompiler Implementation},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {159-236},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_6},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_6},
  abstract = {We are now at the point where you will learn to actually deal with the individual bytecodes, decompile the opcodes into partial statements and expressions and, ultimately (well that’s the plan anyway), back into complete blocks of source code.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11563228_13,
  title = {A Technique for Fault Tolerance Assessment of COTS Based Systems},
  author = {Alexandersson, Ruben and Chaitanya, D. Krishna and Öhman, Peter and Siraj, Yasir},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {165-178},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11563228\_13},
  url = {https://doi.org/10.1007/11563228\_13},
  abstract = {This paper investigates the feasibility of emulating source code software faults directly in Java byte code. Experimental results show that software defects introduced in source code can be emulated in Java byte code with a high level of confidence. This makes it possible to validate the dependability of Java programs with respect to realistic software defects embedded within the COTS components used without the need to know the source code. It is first investigated with good results how well the fault locations found at the byte code level map to the source code. The behaviors of the byte code level mutants are then compared with the corresponding source code mutant behavior. In a back-to-back comparative study with mutants based on ten representative programming defects, no difference in the program behavior between source and byte code level mutants could be distinguished.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11575467_15,
  title = {A Next-Generation Platform for Analyzing Executables},
  author = {Reps, T. and Balakrishnan, G. and Lim, J. and Teitelbaum, T.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {212-229},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11575467\_15},
  url = {https://doi.org/10.1007/11575467\_15},
  abstract = {In recent years, there has been a growing need for tools that an analyst can use to understand the workings of COTS components, plugins, mobile code, and DLLs, as well as memory snapshots of worms and virus-infected code. Static analysis provides techniques that can help with such problems; however, there are several obstacles that must be overcome: – For many kinds of potentially malicious programs, symbol-table and debugging information is entirely absent. Even if it is present, it cannot be relied upon. – To understand memory-access operations, it is necessary to determine the set of addresses accessed by each operation. This is difficult because While some memory operations use explicit memory addresses in the instruction (easy), others use indirect addressing via address expressions (difficult). Arithmetic on addresses is pervasive. For instance, even when the value of a local variable is loaded from its slot in an activation record, address arithmetic is performed. There is no notion of type at the hardware level, so address values cannot be distinguished from integer values. Memory accesses do not have to be aligned, so word-sized address values could potentially be cobbled together from misaligned reads and writes. We have developed static-analysis algorithms to recover information about the contents of memory locations and how they are manipulated by an executable. By combining these analyses with facilities provided by the IDAPro and CodeSurfer toolkits, we have created CodeSurfer/x86, a prototype tool for browsing, inspecting, and analyzing x86 executables. From an x86 executable, CodeSurfer/x86 recovers intermediate representations that are similar to what would be created by a compiler for a program written in a high-level language. CodeSurfer/x86 also supports a scripting language, as well as several kinds of sophisticated pattern-matching capabilities. These facilities provide a platform for the development of additional tools for analyzing the security properties of executables.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0045_1_9,
  title = {The Logging Framework},
  booktitle = {Pro J2ME Polish},
  year = {None},
  pages = {123-131},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0045-1\_9},
  url = {https://doi.org/10.1007/978-1-4302-0045-1\_9},
  abstract = {In this chapter, you learned how you can use J2ME Polish and simple System.out.println() statements for logging messages. The advantage of the logging framework is that it allows you to assign different log levels to different classes and packages. You can also deactivate the logging completely, so that no traces of the logging remain in your application. Last, but not least, you can use log handlers to store the messages into the RMS. In the next chapter, you will learn how to use other J2ME Polish utilities, such as the Binary Editor and the TextUtil class.},
  content_type = {Chapter},
}


@article{springer_10_1007_s00236_005_0175_1,
  title = {Genericity and the π-calculus},
  author = {Berger, Martin and Honda, Kohei and Yoshida, Nobuko},
  journal = {Acta Informatica},
  year = {2005},
  volume = {42},
  number = {2-3},
  pages = {83-141},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00236-005-0175-1},
  url = {https://doi.org/10.1007/s00236-005-0175-1},
  abstract = {Types in processes delineate specific classes of interactive behaviour in a compositional way. Key elements of process theory, in particular behavioural equivalences, are deeply affected by types, leading to applications in the description and analysis of diverse forms of computing. As one of the examples of types for processes, this paper introduces a second-order polymorphic π-calculus based on duality principles, building on type structures coming from typed π-calculi, Linear Logic and game semantics. Of various extensions of first-order typed π-calculi with polymorphism, the present paper focusses on the linear polymorphic π-calculus, extending its first-order counterpart [46]. Fundamental elements of the theory of linear polymorphic processes are studied, including establishment of their strong normalisability using Girard's “candidates,” introduction of a behavioural theory of polymorphic labelled transitions which strengthens Pierce-Sangiorgi's polymorphic bisimulation via duality, and a fully abstract embedding of System F in polymorphic processes, establishing a precise connection between the universe of polymorphic functions and the universe of polymorphic processes. The proof combines process-theoretic reasoning with techniques from game semantics. The abstract nature of polymorphic labelled transitions plays an essential role in full abstraction, elucidating subtle aspects of polymorphism in functions and interaction.},
  content_type = {Article},
}


@article{springer_10_1007_s11334_005_0009_x,
  title = {Modeling uncertainty in software engineering using rough sets},
  author = {Laplante, Phillip A. and Neill, Colin J.},
  journal = {Innovations in Systems and Software Engineering},
  year = {2005},
  volume = {1},
  number = {1},
  pages = {71-78},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11334-005-0009-x},
  url = {https://doi.org/10.1007/s11334-005-0009-x},
  abstract = {Uncertainty casts a shadow over all facets of software engineering. This negative meta-property is found in every aspect of software including requirement specifications, design, and code. It can also manifest itself in the tools and engineering practices employed, and in the off-the-shelf software incorporated into the final product. Unfortunately, it is often the case that software engineers ignore these sources of uncertainty or abstract them away. Perhaps this is because there is insufficient understanding of this uncertainty, and no universal techniques for handling its many forms. This paper focuses on the issues of uncertainty in software engineering. It further describes a rough set framework for making decisions in the face of such uncertainty and inconsistency. In particular, we show how to induce rule-based decision making from uncertain information in software engineering applications. Moreover, a freely available tool, Rosetta, is employed to automate the decision-making process. NASA has mandated the use of commercial off-the-shelf (COTS) solutions where possible. But in commercial real-time operating systems certain attributes are uncertain, even where published information is available. Therefore, the selection of a commercial real-time operating system for an embedded system is the software engineering problem with which we explain the rough set decision-making process.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4302_0045_1_3,
  title = {Installing J2ME Polish},
  booktitle = {Pro J2ME Polish},
  year = {None},
  pages = {11-17},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0045-1\_3},
  url = {https://doi.org/10.1007/978-1-4302-0045-1\_3},
  abstract = {With the help of this chapter, you have now installed J2ME Polish and maybe even some other useful tools as well.In the next chapter, you will learn how to integrate your J2ME Polish installation into your favorite IDE.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_0_387_26325_x_23,
  title = {Software IP Protection Based on Watermarking Techniques},
  author = {Yarmolik, Vyacheslav and Partsianka, Siarhei},
  booktitle = {Information Processing and Security Systems},
  year = {None},
  pages = {227-234},
  publisher = {Springer-Verlag},
  doi = {10.1007/0-387-26325-x\_23},
  url = {https://doi.org/10.1007/0-387-26325-x\_23},
  abstract = {This paper focuses on software watermarking techniques and analysis of the executable code statistical characteristics as a mean of watermark embedding. As an application, several new approaches for executable code watermarking based on statistical characteristics variations have been proposed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11558859_27,
  title = {Dither Modulation Watermarking of Dynamic Memory Traces},
  author = {Larkin, Alan J. and Balado, Félix and Hurley, Neil J. and Silvestre, Guenolé C. M.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {372-386},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11558859\_27},
  url = {https://doi.org/10.1007/11558859\_27},
  abstract = {We describe a dynamic software watermark embedded in the memory trace of an executing Java program. Our approach is a generalisation of the spread–transform watermarking technique developed for use in the multimedia domain. We show how the spread–transform paradigm enables the embedding of dither modulation watermarks in a Java program and report its robustness to realistic additive noise attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11534310_132,
  title = {Mobile Code Security on Destination Platform},
  author = {Zhu, Changzheng and Yin, Zhaolin and Zhang, Aijuan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {1263-1270},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11534310\_132},
  url = {https://doi.org/10.1007/11534310\_132},
  abstract = {There are some security threats when mobile agent codes are loaded or running on destination host platforms. Those threats are detecting, draining or altering the agent’s intention. In order to protect the code from these attacks, we discuss some measures to assure the original code security with agent code obfuscation, encryption, self-defining classloaders and rebuilding the JVM system classloader in this paper.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_11513988_17,
  title = {Model Checking x86 Executables with CodeSurfer/x86 and WPDS++},
  author = {Balakrishnan, G. and Reps, T. and Kidd, N. and Lal, A. and Lim, J. and Melski, D. and Gruian, R. and Yong, S. and Chen, C. -H. and Teitelbaum, T.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {158-163},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11513988\_17},
  url = {https://doi.org/10.1007/11513988\_17},
  abstract = {This paper presents a toolset for model checking x86 executables. The members of the toolset are CodeSurfer/x86 , WPDS++ , and the Path Inspector . CodeSurfer/x86 is used to extract a model from an executable in the form of a weighted pushdown system . WPDS++ is a library for answering generalized reachability queries on weighted pushdown systems. The Path Inspector is a software model checker built on top of CodeSurfer and WPDS++ that supports safety queries about the program’s possible control configurations.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0045_1_5,
  title = {Getting to Know J2ME Polish},
  booktitle = {Pro J2ME Polish},
  year = {None},
  pages = {29-38},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0045-1\_5},
  url = {https://doi.org/10.1007/978-1-4302-0045-1\_5},
  abstract = {The chapter introduced you to the general architecture of J2ME Polish. You gained an insight in the four main layers: the build framework, client framework, IDE plug-ins, and stand-alone tools. You also learned about the life cycle of wireless Java applications and how J2ME Polish can help you in each phase. In the next chapter, we will take a look at the device database that provides the foundation for almost every module of J2ME Polish.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11431664_4,
  title = {A Rational Deconstruction of Landin’s SECD Machine},
  author = {Danvy, Olivier},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {52-71},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11431664\_4},
  url = {https://doi.org/10.1007/11431664\_4},
  abstract = {Landin’s SECD machine was the first abstract machine for the λ -calculus viewed as a programming language. Both theoretically as a model of computation and practically as an idealized implementation, it has set the tone for the subsequent development of abstract machines for functional programming languages. However, and even though variants of the SECD machine have been presented, derived, and invented, the precise rationale for its architecture and modus operandi has remained elusive. In this article, we deconstruct the SECD machine into a λ -interpreter, i.e., an evaluation function, and we reconstruct λ -interpreters into a variety of SECD-like machines. The deconstruction and reconstructions are transformational: they are based on equational reasoning and on a combination of simple program transformations—mainly closure conversion, transformation into continuation-passing style, and defunctionalization. The evaluation function underlying the SECD machine provides a precise rationale for its architecture: it is an environment-based eval-apply evaluator with a callee-save strategy for the environment, a data stack of intermediate results, and a control delimiter. Each of the components of the SECD machine (stack, environment, control, and dump) is therefore rationalized and so are its transitions. The deconstruction and reconstruction method also applies to other abstract machines and other evaluation functions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30113_4_8,
  title = {Suppression of Redundant Operations in Reverse Compiled Code Using Global Dataflow Analysis},
  author = {Johnstone, Adrian and Scott, Elizabeth},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {92-106},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30113-4\_8},
  url = {https://doi.org/10.1007/978-3-540-30113-4\_8},
  abstract = {We describe an unusual application of dataflow analysis to reverse compilation from assembler source to ANSI-C. Most real architectures support (or more usually, mandate) the use of register-based operands in computations and provide status bits which are set as an implicit side-effect of arithmetic instructions. Naïve translation of these semantics into C yields programs which are dominated by references to registers and the calculation of status results. The target processor for our reverse compiler is particularly prone to these effects since the functional units are surrounded by pipeline registers which must be loaded and unloaded around each computation, but the problem is common to all reverse compilers: how to render the computational core of a low-level algorithm in high level code that is comfortable for a human to read and which maintains the low level semantics. We apply a brute-force dataflow analysis to provide exact use-define information at all program points and then follow the use-define relationships to back-substitute expressions in an effort to remove register references. We also suppress dead status code calculations and perform limited alias analysis for some special purpose registers which can be accessed via more than one name. We show that use of these techniques can significantly reduce the degree to which the underlying architecture ‘shows through’ into the resulting C translation and that the computation times required are manageable for one-off translations.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0739_9_7,
  title = {Case Studies},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {237-245},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_7},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_7},
  abstract = {We are now almost at the end of our journey. By now you should have a sound understanding of the overall principles of how to decompile, and hopefully, how to make some attempts at protecting your code. Having said that, I’ve found from clients and colleagues that even if you understand what decompilation and obfuscation really mean, it still doesn’t help you figure out what practical measures you can take to protect your code. A little knowledge can often create more questions than answers.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0020_8_17,
  title = {Performance Tuning},
  booktitle = {Beginning J2ME: From Novice to Professional},
  year = {None},
  pages = {331-341},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0020-8\_17},
  url = {https://doi.org/10.1007/978-1-4302-0020-8\_17},
  abstract = {MIDP is a small platform. The processor on a MIDP device will probably be much slower than a typical desktop computer processor, and the available memory will be much smaller also. Making your application run fast and lean is important. You’ll need to use memory sparingly, make your application run fast enough to be easily usable, and structure it so that the code itself is as small as it can be.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0739_9_3,
  title = {Tools of the Trade},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {61-77},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_3},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_3},
  abstract = {In the last chapter , you looked at the very heart of a Java classfile. In the next chapter, you’ll perform an in-depth study of all the different ways to protect your code using everything from encryption to obfuscation. After that, you’ll move on to build your own simple decompiler.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0739_9_1,
  title = {Introduction},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {1-16},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_1},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_1},
  abstract = {When corel bought WordPerfect for almost \$200 million from the Novell Corporation in the mid 1990s, nobody would have thought that in a matter of months they would have been giving away the source code free. However, when Corel ported WordPerfect to Java and released it as a beta product, a simple program called Mocha 1 could quickly and easily reverse engineer, or decompile, significant portions of Corel’s Office for Java back into source code.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0739_9_2,
  title = {Ghost in the Machine},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {17-60},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_2},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_2},
  abstract = {If you’re trying to understand just how good an obfuscator or decompiler really is, then it helps to be able to see what’s going on inside a classfile. Otherwise you’re relying on the word of a third-party vendor or, at best, a knowledgeable reviewer. For most people, that’s not good enough when you’re trying to protect mission critical code. At the very least, you should be able to talk intelligently about the area and ask the obvious questions to understand just what’s happening.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_11587514_13,
  title = {Arc3D: A 3D Obfuscation Architecture},
  author = {Gomathisankaran, Mahadevan and Tyagi, Akhilesh},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {184-199},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/11587514\_13},
  url = {https://doi.org/10.1007/11587514\_13},
  abstract = {In DRM domain, the adversary has complete control of the computing node – supervisory privileges along with full physical as well as architectural object observational capabilities. Thus robust obfuscation is impossible to achieve with the existing software only solutions. In this paper, we develop architecture level support for obfuscation with the help of well known cryptographic methods. The three protected dimensions of this architecture Arc3D are address sequencing, contents associated with an address, and the temporal reuse of address sequences such as loops. Such an obfuscation makes the detection of good tampering points infinitesimally likely providing tamper resistance. With the use of already known software distribution model of ABYSS and XOM, we can also ensure copy protection. This results in a complete DRM architecture to provide both copy protection and IP protection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30557_6_17,
  title = {The Program Inverter LRinv and Its Structure},
  author = {Kawabe, Masahiko and Glück, Robert},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {219-234},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30557-6\_17},
  url = {https://doi.org/10.1007/978-3-540-30557-6\_17},
  abstract = {Program inversion is a fundamental concept in programtransformation. We describe the principles behind an automatic program inverter, which we developed for a first-order functional language, and show several inverse programs automatically produced by our system. The examples belong to different application areas, including encoding and decoding, printing and parsing, and bidirectional data conversion. The core of the system uses a stack-based language, local inversion, and eliminates nondeterminism by applying methods from parsing theory.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0739_9_4,
  title = {Protecting Your Source: Strategies for Defeating Decompilers},
  author = {Nolan, Godfrey},
  booktitle = {Decompiling Java},
  year = {2004},
  pages = {79-120},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0739-9\_4},
  url = {https://doi.org/10.1007/978-1-4302-0739-9\_4},
  abstract = {Now that we’ve addressed the problem, you’re probably wondering if there is any way you can protect your code. If you’re at the point of asking why you should be producing Java applets or applications that can be easily circumvented, then this is the chapter for you.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0060_4_2,
  title = {Building C\# Applications},
  booktitle = {Pro C\# 2005 and the .NET 2.0 Platform},
  year = {None},
  pages = {33-62},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0060-4\_2},
  url = {https://doi.org/10.1007/978-1-4302-0060-4\_2},
  abstract = {So as you can see, you have many new toys at your disposal! The point of this chapter was to provide you with a tour of the major programming tools a C\# programmer may leverage during the development process. You began the journey by learning how to generate .NET assemblies using nothing other than the free C\# compiler and Notepad. Next, you were introduced to the TextPad application and walked though the process of enabling this tool to edit and compile *.cs code files. You also examined three feature-rich IDEs, starting with the open source SharpDevelop, followed by Microsoft’s Visual C\# 2005 Express and Visual Studio 2005. While this chapter only scratched the surface of each tool’s functionality, you should be in a good position to explore your chosen IDE at your leisure. The chapter wrapped up by examining a number of open source .NET development tools that extend the functionality of your IDE of choice.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0045_1_16,
  title = {Optimizing Applications},
  booktitle = {Pro J2ME Polish},
  year = {None},
  pages = {325-350},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0045-1\_16},
  url = {https://doi.org/10.1007/978-1-4302-0045-1\_16},
  abstract = {Optimizing your application is the last step for you to create a small, fast, working application. You can optimize for speed, for a reduced memory footprint, and for smaller JAR file sizes. Some optimizations are beneficial for all areas, while others contradict each other. You should consider possible high-level optimizations from the beginning and postpone low-level optimization until the end. In this book’s appendix, you will find details about J2ME Polish and J2ME settings in a condensed format.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_30579_8_23,
  title = {Information Flow Analysis for Java Bytecode},
  author = {Genaim, Samir and Spoto, Fausto},
  booktitle = {Lecture Notes in Computer Science},
  year = {2005},
  pages = {346-362},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30579-8\_23},
  url = {https://doi.org/10.1007/978-3-540-30579-8\_23},
  abstract = {We present a flow and context sensitive compositional information flow analysis for full (mono-threaded) Java bytecode. We base our analysis on the transformation of the Java bytecode into a control-flow graph of basic blocks of code which makes explicit the complex features of the Java bytecode. We represent information flows through Boolean functions and hence implement an accurate and efficient information flow analysis through binary decision diagrams. To the best of our knowledge, it is the first one for full Java bytecode.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30114_1_15,
  title = {Threading Software Watermarks},
  author = {Nagra, Jasvir and Thomborson, Clark},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {208-223},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30114-1\_15},
  url = {https://doi.org/10.1007/978-3-540-30114-1\_15},
  abstract = {We introduce a new dynamic technique for embedding robust software watermarks into a software program using thread contention. We show the technique to be resilient to many semantic-preserving transformations that most existing proposals are susceptible to. We describe the technique for encoding the watermark as a bit string and a scheme for embedding and recognizing the watermark using thread contention. Experimental results with Java bytecode indicate that thread based watermarks have small impact on the size of applications and only a modest effect on their speed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_24591_9_23,
  title = {A Software Fingerprinting Scheme for Java Using Classfiles Obfuscation},
  author = {Fukushima, Kazuhide and Sakurai, Kouichi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {303-316},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-24591-9\_23},
  url = {https://doi.org/10.1007/978-3-540-24591-9\_23},
  abstract = {Embedding a personal identifier as a watermark to Java classfile is effective in order to protect copyrights of them. Monden et al. [1] proposed watermarking scheme that embeds arbitrary character sequence to the target method in a Java classfiles. But the scheme can be only used to embed the same watermark to each user’s classfiles. Therefore, if we apply this scheme for embedding each user’s personal identifier, the watermarks can be specified by comparing two or more users’ Java classfiles. In this paper solve the problem by using “Classfiles Obfuscation” which is our obfuscation scheme for Java sourcecodes. By the scheme, we distribute all the methods among the all the Java classfiles at random. Evrey user’s Java classfiles will have different structures respectively by appling “Clasfiles Obfuscation”. As the result, to specify watermark by compareing classfiles will be difficult.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0047_5_8,
  title = {Protocol Plug-Ins},
  booktitle = {Open Source Messaging Application Development},
  year = {None},
  pages = {267-297},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0047-5\_8},
  url = {https://doi.org/10.1007/978-1-4302-0047-5\_8},
  abstract = {You now understand how network protocols typically work, and how to implement them in C using Gaim’s protocol plug-in system. I’ve offered hints and tips about how to monitor data sent by an unknown protocol, and decipher what it all means. One such hint is that, even in binary protocols, screen names, messages, and other textual elements will always be sent in plain text. However, what is plain text? How does a computer, which understands only 1s and 0s, represent letters and words? In the next chapter, I’ll review the many ways computers can do this. This is a crucial element to working with IM protocols, for if you represent text incorrectly, your friends will not be able to read it. Whereas historical reasons make this less problematic for English speakers, for foreign users this is often problematic. I’ll address localizing your application so that it’s usable by as many people as possible, regardless of where they live. In addition to text encoding, I’ll be discussing translation. I’ll explain how the gettext system is used to provide simple translations for all the text in your application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_30175_2_17,
  title = {Compiling Process Graphs into Executable Code},
  author = {Hauser, Rainer and Koehler, Jana},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {317-336},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30175-2\_17},
  url = {https://doi.org/10.1007/978-3-540-30175-2\_17},
  abstract = {Model-driven architecture envisions a paradigm shift as dramatic as the one from low-level assembler languages to high-level programming languages. In order for this vision to become reality, algorithms are needed that compile models of software systems into deployable and executable implementations. This paper discusses two algorithms that provide such transformations for process graph models in a business process or workflow environment and produce executable programs based on Web services and orchestration languages. The reverse transformations back from executable programs to process graphs are also described.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0784_9_2,
  title = {Investigating Performance},
  author = {Wienholt, Nick},
  booktitle = {Maximizing .NET Performance},
  year = {2004},
  pages = {9-24},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0784-9\_2},
  url = {https://doi.org/10.1007/978-1-4302-0784-9\_2},
  abstract = {Investigating the performance of a particular method, technique, or technology is an interesting challenge. The first step in the investigation is determining what performance aspect is actually being investigated within a particular scenario. The specific performance issue can involve the comparative performance assessment of two or more technologies, system capacity analysis, or the cause of sluggish reaction time within a particular section of an application.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_30144_8_34,
  title = {Detecting Software Theft via Whole Program Path Birthmarks},
  author = {Myles, Ginger and Collberg, Christian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {404-415},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30144-8\_34},
  url = {https://doi.org/10.1007/978-3-540-30144-8\_34},
  abstract = {A software birthmark is a unique characteristic of a program that can be used as a software theft detection technique. In this paper we present and empirically evaluate a novel birthmarking technique — Whole Program Path Birthmarking — which uniquely identifies a program based on a complete control flow trace of its execution. To evaluate the strength of the proposed technique we examine two important properties: credibility and tolerance against program transformations such as optimization and obfuscation. Our evaluation demonstrates that, for the detection of theft of an entire program, Whole Program Path birthmarks are more resilient to attack than previously proposed techniques. In addition, we illustrate several instances where a birthmark can be used to identify program theft even when an embedded watermark was destroyed by program transformation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_24723_4_2,
  title = {Analyzing Memory Accesses in x86 Executables},
  author = {Balakrishnan, Gogul and Reps, Thomas},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {5-23},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-24723-4\_2},
  url = {https://doi.org/10.1007/978-3-540-24723-4\_2},
  abstract = {This paper concerns static-analysis algorithms for analyzing x86 executables. The aim of the work is to recover intermediate representations that are similar to those that can be created for a program written in a high-level language. Our goal is to perform this task for programs such as plugins, mobile code, worms, and virus-infected code. For such programs, symbol-table and debugging information is either entirely absent, or cannot be relied upon if present; hence, the technique described in the paper makes no use of symbol-table/debugging information. Instead, an analysis is carried out to recover information about the contents of memory locations and how they are manipulated by the executable.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30501_9_117,
  title = {Tamper Resistant Software by Integrity-Based Encryption},
  author = {Lee, Jaewon and Kim, Heeyoul and Yoon, Hyunsoo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {608-612},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30501-9\_117},
  url = {https://doi.org/10.1007/978-3-540-30501-9\_117},
  abstract = {There are many situations in which it is desirable to protect a piece of software from illegitimate tampering once it gets distributed to the users. Protecting the software code means some level of assurance that the program will execute as expected even if it encounters the illegitimated modifications. We provide the method of protecting software from unauthorized modification. One important technique is an integrity-based encryption , by which a program, while running, checks itself to verify that it has not been modified and conceals some privacy sensitive parts of program.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_5352_5_23,
  title = {A Script by any Other Name …},
  author = {Rosenthal, Hanaan},
  booktitle = {AppleScript: A Comprehensive Guide to Scripting and Automation on Mac OS X},
  year = {2004},
  pages = {667-675},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-5352-5\_23},
  url = {https://doi.org/10.1007/978-1-4302-5352-5\_23},
  abstract = {While any script you write using AppleScript still looks the same and generally utilizes the same system resources in order to run, there are a few different ways that the Mac makes that AppleScript functionality available to you.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_24691_6_21,
  title = {Software Watermarking Through Register Allocation: Implementation, Analysis, and Attacks},
  author = {Myles, Ginger and Collberg, Christian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {274-293},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-24691-6\_21},
  url = {https://doi.org/10.1007/978-3-540-24691-6\_21},
  abstract = {In this paper we explore the application of the QP watermarking algorithm proposed by G. Qu and M. Potkonjak to software watermarking. The algorithm was originally proposed as a technique for watermarking the graph coloring problem which can be applied to a variety of media such as FPGA designs and software through register allocation. We implemented the algorithm within the SandMark framework, a system that allows the study of watermarking, tamper-proofing, and obfuscation algorithms for Java bytecode. Through the use of this framework we were able to perform an empirical evaluation of the algorithm. In particular we demonstrate that the use of register allocation, while incurring no performance overhead and being stealthy, is in fact vulnerable to attacks such as decompile/recompile. We also demonstrate that the QP algorithm does not allow for accurate watermark recognition without significant modifications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30182_0_94,
  title = {A Survey of Public-Key Cryptography on J2ME-Enabled Mobile Devices},
  author = {Tillich, Stefan and Großschädl, Johann},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {935-944},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30182-0\_94},
  url = {https://doi.org/10.1007/978-3-540-30182-0\_94},
  abstract = {The advent of hand-held devices which incorporate a Java Virtual Machine (JVM) has greatly facilitated the development of mobile and wireless applications. Many of the possible applications, e.g. for e-commerce or e-government, have an inherent need for security which can be satisfied by methods of public-key cryptography. This paper investigates the feasibility of public-key implementations on modern mid-range to high-end devices, with the focus set on Elliptic Curve Cryptography (ECC). We have implemented the Elliptic Curve Digital Signature Algorithm (ECDSA) for both signature generation and verification and we show that both can be done on a J2ME-enabled cell phone—depending on the device—in times of a few seconds or even under a second. We also compare the performance of ECDSA with RSA signatures and provide some key issues for selecting one protocol type for implementation in a constrained device.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_30114_1_14,
  title = {Graph Theoretic Software Watermarks: Implementation, Analysis, and Attacks},
  author = {Collberg, Christian and Huntwork, Andrew and Carter, Edward and Townsend, Gregg},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {192-207},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-30114-1\_14},
  url = {https://doi.org/10.1007/978-3-540-30114-1\_14},
  abstract = {This paper presents an implementation of the novel watermarking method proposed by Venkatesan, Vazirani, and Sinha in their recent paper A Graph Theoretic Approach to Software Watermarking . An executable program is marked by the addition of code for which the topology of the control-flow graph encodes a watermark. We discuss issues that were identified during construction of an actual implementation that operates on Java bytecode. We measure the size and time overhead of watermarking, and evaluate the algorithm against a variety of attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_24723_4_19,
  title = {Integrating the Soot Compiler Infrastructure into an IDE},
  author = {Lhoták, Jennifer and Lhoták, Ondřej and Hendren, Laurie},
  booktitle = {Lecture Notes in Computer Science},
  year = {2004},
  pages = {281-297},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-24723-4\_19},
  url = {https://doi.org/10.1007/978-3-540-24723-4\_19},
  abstract = {This paper presents the integration of Soot, a byte-code analysis and transformation framework, with an integrated development environment (IDE), Eclipse. Such an integrated toolkit is useful for both the compiler developer, to aid in understanding and debugging new analyses, and also for the end-user of the IDE, to aid in program understanding by exposing semantic information gathered by the advanced compiler analyses. The paper discusses these advantages and provides concrete examples of its usefulness. There are several major challenges to overcome in developing the integrated toolkit, and the paper discusses three major challenges and the solutions to those challenges. An overview of Soot and the integrated toolkit is given, followed by a more detailed discussion of the fundamental components. The paper concludes with several illustrative examples of using the integrated toolkit along with a discussion of future plans and research.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_1_4020_8090_5_17,
  title = {Security and Lock-In},
  author = {Lookabaugh, Tom and Sicker, Douglas C.},
  booktitle = {Advances in Information Security},
  year = {None},
  pages = {225-246},
  publisher = {Kluwer Academic Publishers},
  doi = {10.1007/1-4020-8090-5\_17},
  url = {https://doi.org/10.1007/1-4020-8090-5\_17},
  abstract = {The cases of set-top boxes in the U. S. cable industry, video games and their cartridges, and printers and their cartridges all illustrate ways in which security technology can play an enhanced role in lock-in of customers by their suppliers through creation of substantial switching costs. Openness of technology, normally an inhibitor of lock-in, can be argued against in the case of security on the basis of a presumed increase in security by keeping details of the security system secret and proprietary. Whether open or not, security technology can be used to make permissible reverse engineering equivalent to an infeasible problem of breaking a cryptographically strong algorithm. And what might appear to be permissible reverse engineering may be conflated with an effort to enable illegitimate piracy and rendered illegal. The extra potential for security technology as a locus of lock-in raises its importance in the strategic considerations of both customers and vendors and for legislators and regulators. Customers will want to consider how to reduce the effect of lock-in, particularly on access to innovation; vendors will want to consider how to increase lock-in where possible, and policy makers will want to consider where the public interest motivates efforts to intervene to mitigate lock-in.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0726_9_8,
  title = {Generating Code Dynamically},
  author = {Robinson, Simon},
  booktitle = {Expert .NET 1.1 Programming},
  year = {2004},
  pages = {315-343},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0726-9\_8},
  url = {https://doi.org/10.1007/978-1-4302-0726-9\_8},
  abstract = {In this chapter I’ll cover a significant, though often underused, feature that’s offered by the.NET Framework classes—the ability to generate either source code or IL code dynamically. In other words, you can have your code actually write or manipulate code instead of data. Normally, you’d conceptually imagine that the process of producing a software application involves you writing the source code, compiling it, and shipping it—and that’s it. The code and resources your organization wrote constitutes the totality of the shipped product. With dynamic code generation, however, your shipped code can itself actually generate new code to perform additional tasks—this can be useful for performance reasons, among other factors. Alternatively, your code may modify the code in other assemblies (which maybe done, for example, to insert calls to create debugging or profiling information). And obviously, if your product is a developer tool that’s intended to assist developers in writing code, then it may be called on to generate some source code itself.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45937_5_10,
  title = {Decompiling Java Bytecode: Problems, Traps and Pitfalls},
  author = {Miecznikowski, Jerome and Hendren, Laurie},
  booktitle = {Lecture Notes in Computer Science},
  year = {2002},
  pages = {111-127},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45937-5\_10},
  url = {https://doi.org/10.1007/3-540-45937-5\_10},
  abstract = {Java virtual machines execute Java bytecode instructions. Since this bytecode is a higher level representation than traditional object code, it is possible to decompile it back to Java source. Many such decompilers have been developed and the conventional wisdom is that decompiling Java bytecode is relatively simple. This may be true when decompiling bytecode produced directly from a specific compiler, most often Sun’s javac compiler. In this case it is really a matter of inverting a known compilation strategy. However, there are many problems, traps and pitfalls when decompiling arbitrary verifiable Java bytecode. Such bytecode could be produced by other Java compilers, Java bytecode optimizers or Java bytecode obfuscators. Java bytecode can also be produced by compilers for other languages, including Haskell, Eiffel, ML, Ada and Fortran. These compilers often use very different code generation strategies from javac. This paper outlines the problems and solutions we have found in our development of Dava, a decompiler for arbitrary Java bytecode. We first outline the problems in assigning types to variables and literals, and the problems due to expression evaluation on the Java stack. Then, we look at finding structured control flow with a particular emphasis on issues related to Java exceptions and synchronized blocks. Throughout the paper we provide small examples which are not properly decompiled by commonly used decompilers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0788_7_4,
  title = {Debugger Internals},
  author = {Blunden, Bill},
  booktitle = {Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code},
  year = {2003},
  pages = {157-213},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0788-7\_4},
  url = {https://doi.org/10.1007/978-1-4302-0788-7\_4},
  abstract = {In Chapter 2, I presented a short tutorial on using the GNU debugger. This chapter is dedicated to those curious souls who yearn to look under the hood and see how debuggers actually work. I will begin by discussing the different types of debuggers and then showing you how they perform basic debugging tasks (e.g., breakpoints and single stepping). Later on in the chapter, we will look more closely at symbolic debuggers and I will offer suggestions with regard to how they can be implemented. For those engineers interested in protecting intellectual property, I will end the chapter with a collection of techniques that can be used to thwart reverse-engineering tools.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_39920_9_7,
  title = {Reconstructing Control Flow from Predicated Assembly Code},
  author = {Decker, Björn and Kästner, Daniel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {81-100},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-39920-9\_7},
  url = {https://doi.org/10.1007/978-3-540-39920-9\_7},
  abstract = {Predicated instructions are a feature more and more common in contemporary instruction set architectures. Machine instructions are only executed if an individual guard register associated with the instruction evaluates to true. This enhances execution efficiency, but comes at a price: the control flow of a program is not explicit any more. Instead instructions from the same basic block may belong to different execution paths if they are subject to disjoint guard predicates. Postpass tools processing machine code with the purpose of program analyses or optimizations require the control flow graph of the input program to be known. The effectiveness of postpass analyses and optimizations strongly depends on the precision of the control flow reconstruction. If traditional reconstruction techniques are applied for processors with predicated instructions, their precision is seriously deteriorated. In this paper a generic algorithm is presented that can precisely reconstruct control flow from predicated assembly code. The algorithm is incorporated in the Propan system that enables high-quality machine-dependent postpass optimizers to be generated from a concise hardware specification. The control flow reconstruction algorithm is machine-independent, and automatically derives the required hardware-specific knowledge from the machine specification. Experimental results obtained for the Philips TriMedia TM1000 processor show that the precision of the reconstructed control flow is significantly higher than with reconstruction algorithms that do not specifically take predicated instructions into account.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_36377_7_14,
  title = {A Symmetric Approach to Compilation and Decompilation},
  author = {Sig Ager, Mads and Danvy, Olivier and Goldberg, Mayer},
  booktitle = {Lecture Notes in Computer Science},
  year = {2002},
  pages = {296-331},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-36377-7\_14},
  url = {https://doi.org/10.1007/3-540-36377-7\_14},
  abstract = {Just as an interpreter for a source language can be turned into a compiler from the source language to a target language, we observe that an interpreter for a target language can be turned into a compiler from the target language to a source language. In both cases, the key issue is the choice of whether to perform an evaluation or to emit code that represents this evaluation. We substantiate this observation with two source interpreters and two target interpreters. We first consider a source language of arithmetic expressions and a target language for a stack machine, and then the λ- calculus and the SECD-machine language. In each case, we prove that the target-to-source compiler is a left inverse of the source-to-target compiler, i.e., that it is a decompiler. In the context of partial evaluation, the binding-time shift of going from a source interpreter to a compiler is classically referred to as a Futamura projection. By symmetry, it seems logical to refer to the binding-time shift of going from a target interpreter to a compiler as a Futamura embedding.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_39707_6_50,
  title = {OpenGR: A Directive-Based Grid Programming Environment},
  author = {Hirano, Motonori and Sato, Mitsuhisa and Tanaka, Yoshio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {552-563},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-39707-6\_50},
  url = {https://doi.org/10.1007/978-3-540-39707-6\_50},
  abstract = {In order to provide a grid programming environment for RPC-based master-worker type task parallelization of existing sequential application programs, we have designed a set of compiler directives called OpenGR, and been implementing this compiler system based on the Omni OpenMP compiler system and a grid-enabled RPC system, Ninf-G, as a parallel execution mechanism. With OpenGR directives, some existing sequential applications can easily be adapted to the grid environment as master-worker type parallel programs using RPC. Furthermore, using both OpenGR directives and the OpenMP directives enables “Hybrid parallelization” of the sequential programs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_55848_1_5,
  title = {Generation of the Model Equations and Their Solution},
  author = {Damić, Vjekoslav and Montgomery, John},
  booktitle = {Mechatronics by Bond Graphs},
  year = {2003},
  pages = {135-162},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-55848-1\_5},
  url = {https://doi.org/10.1007/978-3-642-55848-1\_5},
  abstract = {In the previous two chapters the systematic component-based approach was developed that enables development of mechatronic system models in a formal way. An important part of this is the description of the element constitutive relation symbolically using a relatively simple language. Thus, not only non-linear relation ships, but also piecewise expressions can be used. This is important in modelling discontinuous mechanical processes and in electronics. This makes simulation of complex systems not only feasible, but also a challenging task. This chapter describes the generation of the system mathematical models and their solution.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_540_39927_8_6,
  title = {Trading-Off Type-Inference Memory Complexity against Communication},
  author = {Hyppönen, Konstantin and Naccache, David and Trichina, Elena and Tchoulkine, Alexei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {60-71},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-39927-8\_6},
  url = {https://doi.org/10.1007/978-3-540-39927-8\_6},
  abstract = {While bringing considerable flexibility and extending the horizons of mobile computing, mobile code raises major security issues. Hence, mobile code, such as Java applets, needs to be analyzed before execution. The byte-code verifier checks low-level security properties that ensure that the downloaded code cannot bypass the virtual machine’s security mechanisms. One of the statically ensured properties is type safety . The type-inference phase is the overwhelming resource-consuming part of the verification process. This paper addresses the RAM bottleneck met while verifying mobile code in memory-constrained environments such as smart-cards. We propose to modify classic type-inference in a way that significantly reduces the memory consumption in the memory-constrained device at the detriment of its distrusted memory-rich environment. The outline of our idea is the following, throughout execution, the memory frames used by the verifier are MAC-ed and exported to the terminal and then retrieved upon request. Hence a distrusted memory-rich terminal can be safely used for convincing the embedded device that the downloaded code is secure. The proposed protocol was implemented on JCOP20 and JCOP30 Java cards using IBM’s JCOP development tool.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_36415_3_26,
  title = {Oblivious Hashing: A Stealthy Software Integrity Verification Primitive},
  author = {Chen, Yuqun and Venkatesan, Ramarathnam and Cary, Matthew and Pang, Ruoming and Sinha, Saurabh and Jakubowski, Mariusz H.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {400-414},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-36415-3\_26},
  url = {https://doi.org/10.1007/3-540-36415-3\_26},
  abstract = {We describe a novel software verification primitive called Oblivious Hashing. Unlike previous techniques that mainly verify the static shape of code, this primitive allows implicit computation of a hash value based on the actual execution (i.e., space-time history of computation) of the code. We also discuss its applications in local software tamper resistance and remote code authentication.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0788_7_1,
  title = {Preventative Medicine},
  author = {Blunden, Bill},
  booktitle = {Software Exorcism: A Handbook for Debugging and Optimizing Legacy Code},
  year = {2003},
  pages = {1-69},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0788-7\_1},
  url = {https://doi.org/10.1007/978-1-4302-0788-7\_1},
  abstract = {The role of the maintenance engineer is to exorcise the evil spirits that dwell in legacy software. Day and night, maintenance engineers are beset upon, and spited, as they forge a lonely path through the corporate landscape. Every day, they face the challenge of Repairing bugs Improving performance},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_36579_6_7,
  title = {Run-Time Type Checking for Binary Programs},
  author = {Burrows, Michael and Freund, Stephen N. and Wiener, Janet L.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {90-105},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-36579-6\_7},
  url = {https://doi.org/10.1007/3-540-36579-6\_7},
  abstract = {Many important software systems are written in the C programming language. Unfortunately, the C language does not provide strong safety guarantees, and many common programming mistakes introduce type errors that are not caught by the compiler. These errors only manifest themselves at run time through unexpected program behavior, and it is often hard to isolate and identify their causes. This paper presents the Hobbes run-time type checker for compiled C programs. Our tool interprets compiled binaries, tracks type information for all memory and register locations, and reports warnings when a variety of type errors occur. Because the Hobbes type checker does not rely on source code, it is effective in many situations where similar tools are not, such as when full source code is not available or when C source is linked with program fragments written in assembly or other languages.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_39927_8_37,
  title = {A Functional Decomposition of Virus and Worm Programs},
  author = {Murthy, J. Krishna},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {405-414},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-39927-8\_37},
  url = {https://doi.org/10.1007/978-3-540-39927-8\_37},
  abstract = {This paper presents a decomposition of virus and worm programs based on their core functional components. The decomposition yields of a catalogue of six functions performed by such malicious programs and a classification of various ways these functions are implemented. The catalogue and classification provide a foundation to improve current reactive technologies for virus detection and to develop new proactive technologies for the same. Current state-of-the-art, reactive technologies identify malicious programs by matching signatures, sequences of bits, collected from previously infected documents. The catalogue presented may be used to train engineers into what to “look for" when studying infected documents to extract signatures, to concisely document how various viruses’ work, and to exchange this information with other engineers, thus speeding up signature discovery. The catalogue may also be used to develop automatic recognizers using program pattern recognition techniques. When generalized these recognizers can identify new, though related viruses, without any new signature.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_39815_8_4,
  title = {Implementing Multi-stage Languages Using ASTs, Gensym, and Reflection},
  author = {Calcagno, Cristiano and Taha, Walid and Huang, Liwen and Leroy, Xavier},
  booktitle = {Lecture Notes in Computer Science},
  year = {2003},
  pages = {57-76},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-39815-8\_4},
  url = {https://doi.org/10.1007/978-3-540-39815-8\_4},
  abstract = {The paper addresses theoretical and practical aspects of implementing multi-stage languages using abstract syntax trees (ASTs), gensym, and reflection. We present an operational account of the correctness of this approach, and report on our experience with a bytecode compiler called MetaOCaml that is based on this strategy. Current performance measurements reveal interesting characteristics of the underlying OCaml compiler, and illustrate why this strategy can be particularly useful for implementing domain-specific languages in a typed, functional setting.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0780_1_3,
  title = {Type Members},
  author = {Allison, Damon and Olsen, Andy and Speer, James},
  booktitle = {Visual Basic .NET Class Design Handbook: Coding Effective Classes},
  year = {2003},
  pages = {42-73},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0780-1\_3},
  url = {https://doi.org/10.1007/978-1-4302-0780-1\_3},
  abstract = {Type members are the fundamental programming constructs used to build types within the.NET Framework. Type members in VB.NET include constants, fields (also, confusingly, known as variables), properties, subroutines, functions, constructors, and events. In this chapter, we’ll see how these type members are mapped into the.NET Framework, and how they are used in each of VB.NET’s programmable types — classes, structures, modules, and so on.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0772_6_17,
  title = {Deploying Your .NET Application},
  author = {Richardson, Chris},
  booktitle = {COBOL and Visual Basic on .NET},
  year = {2003},
  pages = {631-678},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0772-6\_17},
  url = {https://doi.org/10.1007/978-1-4302-0772-6\_17},
  abstract = {It is safe to assume that you have installed software onto a Windows platform. After all, your Microsoft .NET Framework and Visual Studio .NET (VS .NET) toolset required a lengthy installation. The Fujitsu NetCOBOL for .NET software required that you go through an installation procedure as well. Perhaps you have installed other software packages (e.g., Microsoft Office, SQL Server, Adobe Acrobat Reader, and so on). Some of your installations were initiated by simply putting in a CD-ROM. Others required that you locate and click a Setup.exe program.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0815_0_2,
  title = {Creating Great Windows Applications},
  author = {Moore, Karl},
  booktitle = {The Ultimate VB .NET and ASP.NET Code Book},
  year = {2003},
  pages = {21-62},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0815-0\_2},
  url = {https://doi.org/10.1007/978-1-4302-0815-0\_2},
  abstract = {Despite more and more developers moving toward creating Web applications as the solution for many of today’s business problems, the true power of Windows programs remains ever present.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0767_2_5,
  title = {Enhanced Classes and Managed Fields},
  author = {Ezzio, David},
  booktitle = {Using and Understanding Java Data Objects},
  year = {2003},
  pages = {143-183},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0767-2\_5},
  url = {https://doi.org/10.1007/978-1-4302-0767-2\_5},
  abstract = {The application programmer designs and codes the application data classes. The JDO implementation provides an enhancer tool to modify the application data classes. The modifications made during enhancement allow JDO and the application data objects to interact with each other. The JDO metadata, which is contained in an XML file, identifies the application data classes and describes their managed fields.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0846_4_9,
  title = {Protecting Code},
  author = {Bock, Jason and Stromquist, Pete and Fischer, Tom and Smith, Nathan},
  booktitle = {.NET Security},
  year = {2002},
  pages = {289-298},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0846-4\_9},
  url = {https://doi.org/10.1007/978-1-4302-0846-4\_9},
  abstract = {To end this book , I’d like to reverse the course that I’ve followed throughout earlier chapters and show you how to protect your investment by securing your .NET code. I’ll start by briefly covering the basics of the Common Intermediate Language (CIL). Then I’ll explain how you can use this knowledge to reverse-engineer your components. Finally, I’ll discuss techniques that you can use to protect your investments.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4302_0845_7_5,
  title = {Debugging CIL},
  author = {Bock, Jason},
  booktitle = {CIL Programming: Under the Hood™ of .NET},
  year = {2002},
  pages = {149-192},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0845-7\_5},
  url = {https://doi.org/10.1007/978-1-4302-0845-7\_5},
  abstract = {In this chapter, I’ll cover how you can debug your CIL-based applications. I’ll demonstrate how you can create debug builds of your assemblies, the tools that you can use to debug them, and how to get them running in the debugger.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45937_5_21,
  title = {Effective Enhancement of Loop Versioning in Java},
  author = {Mikheev, Vitaly V. and Fedoseev, Stanislav A. and Sukharev, Vladimir V. and Lipsky, Nikita V.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2002},
  pages = {293-306},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45937-5\_21},
  url = {https://doi.org/10.1007/3-540-45937-5\_21},
  abstract = {Run-time exception checking is required by the Java Language Specification (JLS). Though providing higher software reliability, that mechanism negatively affects performance of Java programs, especially those computationally intensive. This paper pursues loop versioning, a simple program transformation which often helps to avoid the checking overhead. Basing upon the Java Memory Model precisely defined in JLS, the work proposes a set of sufficient conditions for applicability of loopv ersioning. Scalable intra- and interprocedural analyses that efficiently check fulfilment of the conditions are also described. Implemented in Excelsior JET, an ahead-of-time compiler for Java, the developed technique results in significant performance improvements on some computational benchmarks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_56005_7_12,
  title = {Software Reengineering for Mission-Critical Applications — Minimizing Business Risks and Reducing Maintenance Costs},
  author = {Schmuck, Joachim},
  booktitle = {Business Continuity},
  year = {2002},
  pages = {189-209},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-56005-7\_12},
  url = {https://doi.org/10.1007/978-3-642-56005-7\_12},
  abstract = {This article describes the risk potential of outmoded software systems for business processes. The relevance for the financial service sector is a result of the exceptionally high dependence of the business processes on the underlying data-processing systems. The reason for software aging, the processes involved in aging and the resultant risks are outlined. Software reengineering is introduced as a business solution to this problem. A discussion of the main success factors facilitates the selection of a useful reengineering approach. Special attention is paid to the sustainability of the effects realized. In addition to risk prevention, the aspect of maintenance cost reduction is elaborated. A case study illustrates how the structural rejuvenation of data processing systems succeeds even under the massive pressure of functional evolution. Special emphasis is placed on the classic combination of COBOL applications and IBM mainframe computers, often found in banking and insurance.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_46088_8_23,
  title = {Secure Distributed Computing in a Commercial Environment},
  author = {Golle, Philippe and Stubblebine, Stuart},
  booktitle = {Lecture Notes in Computer Science},
  year = {2002},
  pages = {289-304},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-46088-8\_23},
  url = {https://doi.org/10.1007/3-540-46088-8\_23},
  abstract = {The recent successes of a number of nonprofit computing projects distributed over the Internet has generated intense interest in the potential commercial applications of distributed computing. In a commercial setting, where participants might be paid for their contributions, it is crucial to define a security framework to address the threat of cheating and offer guarantees that the computation has been correctly executed. This paper defines and analyzes such a security framework predicated on the assumption that participants are motivated by financial gain. We propose a scheme which deters participants from claiming credit for work they have not done, and puts a high cost on attempts to disrupt the computation. We achieve these two goals by integrating an algorithm to assign computations to participants, an algorithm to verify their work, and an algorithm to pay participants.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4302_0827_3_4,
  title = {The Globalization Namespace},
  author = {Symmonds, Nicholas},
  booktitle = {Internationalization and Localization Using Microsoft .NET},
  year = {2002},
  pages = {63-104},
  publisher = {Apress},
  doi = {10.1007/978-1-4302-0827-3\_4},
  url = {https://doi.org/10.1007/978-1-4302-0827-3\_4},
  abstract = {This chapter introduces you to the .NET way of doing things and explains all the classes, interfaces, and important methods involved in localizing a .NET application using the System.Globalization namespace. There is quite a lot to learn in this chapter. The globalization features of .NET are very comprehensive indeed.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_0199_4_8,
  title = {Reflection},
  author = {Craig, Iain},
  booktitle = {The Interpretation of Object-Oriented Programming Languages},
  year = {2002},
  pages = {183-201},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0199-4\_8},
  url = {https://doi.org/10.1007/978-1-4471-0199-4\_8},
  abstract = {The concept of computational reflection has been studied for a long time. In the last few years, in particular since the emergence of object-oriented languages, reflection and the associated concept introspection , have been studied with some intensity. The reason for this is that the two concepts promise to give us more flexible languages which can be extended to suit an application’s needs more closely. They also allow the introduction of new features such as distribution and parallel execution with less disruption than is normal. Furthermore, these two concepts give programmers access to the internals of programs, thus facilitating the construction of debuggers and profilers. Finally, introspection gives access to the execution mechanism itself, thus permitting programs, at least in principle, to adjust the way in which they are executed. It should be noted that the terms reflection and introspection are often used in an interchangeable manner.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45309_1_23,
  title = {Proof-Directed De-compilation of Low-Level Code},
  author = {Katsumata, Shin-ya and Ohori, Atsushi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {352-366},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45309-1\_23},
  url = {https://doi.org/10.1007/3-540-45309-1\_23},
  abstract = {We present a proof theoretical method for de-compiling low-level code to the typed lambda calculus. We first define a proof system for a low-level code language based on the idea of Curry-Howard isomorphism. This allows us to regard an executable code as a proof in intuitionistic propositional logic. As being a proof of intuitionistic logic, it can be translated to an equivalent proof of natural deduction proof system. This property yields an algorithm to translate a given code into a lambda term. Moreover, the resulting lambda term is not a trivial encoding of a sequence of primitive instructions, but reflects the behavior of the given program. This process therefore serves as proof-directed decompilation of a low-level code language to a high-level language. We carry out this development for a subset of Java Virtual Machine instructions including most of its features such as jumps, object creation and method invocation. The proof-directed de-compilation algorithm has been implemented, which demonstrates the feasibility of our approach.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_662_07847_1_7,
  title = {Innovative PLC Programming Systems},
  author = {John, Karl-Heinz and Tiegelkamp, Michael},
  booktitle = {IEC 61131-3: Programming Industrial Automation Systems},
  year = {2001},
  pages = {243-282},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-07847-1\_7},
  url = {https://doi.org/10.1007/978-3-662-07847-1\_7},
  abstract = {This chapter goes beyond the specifications of IEC 61131–3 and outlines the general requirements placed on the new generation of PLC programming systems in the marketplace. These mainly stem from the special conditions to be met in the PLC environment using the new standard-compliant technology.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_44685_0_5,
  title = {Using the Bandera Tool Set to Model-Check Properties of Concurrent Java Software},
  author = {Hatcliff, John and Dwyer, Matthew},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {39-58},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-44685-0\_5},
  url = {https://doi.org/10.1007/3-540-44685-0\_5},
  abstract = {The Bandera Tool Set is an integrated collection of program analysis, transformation, and visualization components designed to facilitate experimentation with model-checking Java source code. Bandera takes as input Java source code and a software requirement formalized in Bandera’s temporal specification language, and it generates a program model and specification in the input language of one of several existing model-checking tools (including Spin [ 16 ], dSpin [ 6 ], SMV [ 3 ], and JPF [ 2 ]). Both program slicing and user extensible abstract interpretation components are applied to customize the program model to the property being checked. When a model-checker produces an error trail, Bandera renders the error trail at the source code level and allows the user to step through the code along the path of the trail while displaying values of variables and internal states of Java lock objects.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s007780100043,
  title = {ObjectGlobe: Ubiquitous query processing on the Internet},
  author = {Braumandl, R. and Keidl, M. and Kemper, A. and Kossmann, D. and Kreutz, A. and Seltzsam, S. and Stocker, K.},
  journal = {The VLDB Journal},
  year = {2001},
  volume = {10},
  number = {1},
  pages = {48-71},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s007780100043},
  url = {https://doi.org/10.1007/s007780100043},
  abstract = {We present the design of ObjectGlobe, a distributed and open query processor for Internet data sources. Today, data is published on the Internet via Web servers which have, if at all, very localized query processing capabilities. The goal of the ObjectGlobe project is to establish an open marketplace in which data and query processing capabilities can be distributed and used by any kind of Internet application. Furthermore, ObjectGlobe integrates cycle providers (i.e., machines) which carry out query processing operators. The overall picture is to make it possible to execute a query with – in principle – unrelated query operators, cycle providers, and data sources. Such an infrastructure can serve as enabling technology for scalable e-commerce applications, e.g., B2B and B2C market places, to be able to integrate data and data processing operations of a large number of participants. One of the main challenges in the design of such an open system is to ensure privacy and security. We discuss the ObjectGlobe security requirements, show how basic components such as the optimizer and runtime system need to be extended, and present the results of performance experiments that assess the additional cost for secure distributed query processing. Another challenge is quality of service management so that users can constrain the costs and running times of their queries.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4615_1467_1_1,
  title = {Security Testing of an Online Banking Service},
  author = {dos Santos, Andra L. M. and Vigna, Giovanni and Kemmerer, Richard A.},
  booktitle = {Advances in Information Security},
  year = {2001},
  pages = {3-15},
  publisher = {Springer US},
  doi = {10.1007/978-1-4615-1467-1\_1},
  url = {https://doi.org/10.1007/978-1-4615-1467-1\_1},
  abstract = {Online banking and electronic commerce have become an everyday reality for millions of users. Almost every large banking institution offers services such as account management, fund transfers, automatic payments, and investments through the Internet. The quality of the provided services has become a driving factor in user selection of a banking institution. Given the critical nature of the services provided, banks and financial institutions are investing substantial resources in the implementation of sophisticated financial applications that are appealing to the end-user. In the design and implementation of these applications developers face a trade-off between user-friendliness and security.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45418_7_2,
  title = {Jakarta: A Toolset for Reasoning about JavaCard},
  author = {Barthe, G. and Dufay, G. and Huisman, M. and de Sousa, S. Melo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {2-18},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45418-7\_2},
  url = {https://doi.org/10.1007/3-540-45418-7\_2},
  abstract = {JavaCard [ 22 ] is a dialect of Java that enables Java technology to run on new generation smart cards and other devices with limited memory. As JavaCard is becomingincr easingly popular, there has been a strong interest, both from academics and industrials, to reason formally about the JavaCard platform.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_45144_7_18,
  title = {Development Tools, Skills and Case Studies},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {188-189},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45144-7\_18},
  url = {https://doi.org/10.1007/3-540-45144-7\_18},
  abstract = {The processes and methodologies which make a discipline practical need to be supported by appropriate tools, and skills on the part of its practitioners. At times, the existing tool set proves to be either inadequate or wholly unsuited to the tasks in hand. The usefulness of any tool becomes clear only as people develop solutions to the perceived problems. The scale and novel applications in the Web arena provide a fertile area for new problems and problem solving. The volatile nature of the technologies associated with the Web virtually guarantee that new problems will crop up constantly and will lead to the fashioning of new tools to solve those problems. The papers in this section focus on the tools and skills that were needed in specific situations and represent but a small amount of the total effort in this area.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_662_07847_1_10,
  title = {Contents of CD-ROM},
  author = {John, Karl-Heinz and Tiegelkamp, Michael},
  booktitle = {IEC 61131-3: Programming Industrial Automation Systems},
  year = {2001},
  pages = {299-300},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-662-07847-1\_10},
  url = {https://doi.org/10.1007/978-3-662-07847-1\_10},
  abstract = {The CD-ROM enclosed in this book contains the following information, examples and programs: 1) STEP 7 Demo Software as a demo version for PLC programming with IEC 61131–3 using the languages: STL, LAD, FBD, S7-GRAPH, S7-SCL, CFC and 57-HiGraph1; running under Windows 95/98 and Windows NT 2) Open PCS as a demo version for PLC programming with IEC 61131–3 using the languages: IL, Ladder, FBD, ST, SFC, a US-conformant Ladder editor (including EN/ENO), as well as Smart PLC; running under Windows 3.x, Windows 95/98 and Windows NT 3) IL examples of this book 4) Buyer’s Guide for IEC 61131–3-compliant programming systems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_44811_x_19,
  title = {Bio-Language for Computing with Membranes},
  author = {Baranda, Angel V. and Castellanos, Juan and Arroyo, Fernando and Luengo, Carmen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {176-185},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-44811-x\_19},
  url = {https://doi.org/10.1007/3-540-44811-x\_19},
  abstract = {This paper presents a bio-language that integrates data structures and processes for a formal computational model from the field of computing with membranes. A bio-language is a new concept extracted from biological behaviour. In order to define such a bio-language, the static and dynamic structures of a Transition P system are formalised.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_45439_x_9,
  title = {DISSECT: DIStribution for SECurity Tool},
  author = {Valdez, Enriquillo and Yung, Moti},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {125-143},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45439-x\_9},
  url = {https://doi.org/10.1007/3-540-45439-x\_9},
  abstract = {A security threat that affects the Java environment (as a typical environment where code is made available to the user machine) is the reverse-engineering and code-understanding of the architecture-neutral bytecode format. A natural protection strategy is to hide parts of the execution in trusted locations (e.g., servers). However, the implementation and automatization of such an approach (beyond the abstract idea) is a challenging problem. In this paper, we present a novel software protection strategy and its automatization (implemented architecture) which materialize the above idea. It is employed in protecting the binary source of Java class files. Our software protection strategy partitions “programmer selected” classes of an application into server classes and client classes. Server classes contain the actual class code and run only on trusted systems (which we call servers but they can be other dedicated machines). Client classes, on the other hand, are assumed to perform most of the task (but the sensitive part) and execute on user systems; they must interact with their corresponding server class in order to execute the sensitive code and provide the behavior of the original class. We propose and implement DISSECT (DIStribution for SECurity Tool), an architecture based on the above partitioning (dissection) strategy, for Java 1.1. The tool relieves the developers from actually writing distributed applications by distributing the application automatically, according to designated sensitivities of application portions. We note that the remote execution of classes may increase the overhead. Thus, we have conducted initial experiments to understand the impact of partitioned classes on performance.We report initial performance results which show the overhead and demonstrate when it is low or non-existing, when it is high, and when we actually gain performance by partitioning.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_0_387_35413_2_3,
  title = {An Integrated Secure Web Architecture For Protected Mobile Code Distribution},
  author = {Jalali-Sohi, Mehrdad and Foka, Rigobert and Hachez, Gaël and Beitlich, Alexander},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2001},
  pages = {25-37},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-35413-2\_3},
  url = {https://doi.org/10.1007/978-0-387-35413-2\_3},
  abstract = {IPR (Intellectual Property Rights) protection is one of the key elements to be considered in the development of mobile code technologies (applets, agents, etc.) due to the mobile nature of this kind of software and the power of servers. The absence of protection would increase the risk of piracy to such a level that the economy of this sector would be weakened, perhaps even destroyed. Complementary to the legal provisions (anti-piracy laws), IPR protection is one of the absolute elements in the development of these new markets. In the course of ESPRIT project FILIGRANE (F1exIbLe IPR for Software AGent ReliANcE), we developed an integrated Web architecture and associated security framework and protocol for the trading of mobile code in Internet. The term mobile code includes all kinds of mobile Java software (applets and agents and Java beans, cardlets, etc.).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45523_x_1,
  title = {Structures and Bio-language to Simulate Transition P Systems on Digital Computers},
  author = {Arroyo, Fernando and Baranda, Angel V. and Castellanos, Juan and Luengo, Carmen and Mingo, Luis F.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {1-15},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45523-x\_1},
  url = {https://doi.org/10.1007/3-540-45523-x\_1},
  abstract = {The aim of this paper is to show that some computational models inspired from biological membranes, such as P systems, can be simulated on digital computers in an efficient manner. To this aim, it is necessary to characterize non-determinism and parallel execution of evolution rules inside regions. Both these issues are formally described here in order to obtain a feasible description in terms of data structures and operations able to be implemented in a functional programming language. Static and dynamic structures of transition P systems are formalised in order to define a bio-language to represent them. Finally, a draft of a language for describing a transition P systems is presented. It will facilitate the description of transition P systems in terms of sentences in a high level programming language; such sentences will define a program. A process of compilation will parse the program to appropriate data structures and will launch the execution of the simulation process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_322_89891_3_6,
  title = {Beyond The Common View: Consideration of Interdisciplinary Aspects},
  author = {Knöll, Heinz-Dieter and Kühl, Lukas W. H. and Kühl, Roland W. A. and Moreton, Robert},
  booktitle = {Optimising Business Performance with Standard Software Systems},
  year = {2001},
  pages = {105-128},
  publisher = {Vieweg+Teubner Verlag},
  doi = {10.1007/978-3-322-89891-3\_6},
  url = {https://doi.org/10.1007/978-3-322-89891-3\_6},
  abstract = {This chapter is concerned with the wider context of Business Process Re-Engineering. The interdisciplinary aspects of BPR arise in the form of practical and organisational issues. These issues can arise at any stage of a project when theoretical concepts are to be implemented. It is obviously not possible to anticipate all potential obstacles. This chapter does not intend to answer these problems, it rather gives an overview of the subject’s scope and the importance of non-technical issues in determining the success or failure of BPR projects.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45165_x_3,
  title = {The PACAP Prototype: A Tool for Detecting Java Card Illegal Flow},
  author = {Bieber, P. and Cazin, J. and Wiels, V. and Zanon, G. and Marouan, El and Girard, P. and Lanet, J.-L.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {25-37},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45165-x\_3},
  url = {https://doi.org/10.1007/3-540-45165-x\_3},
  abstract = {This paper presents some practical issues of a joint project between Gemplus and ONERA. In this approach, a smart card issuer can verify that a new applet securely interacts with already loaded applets. A security policy has been defined that associates levels to applet attributes and methods and defines authorized flows between levels. We propose a technique based on model checking to verify that actual information flows between applets are authorized. In this paper, we focus on the development of the prototype of the analyzer and we present the first results.},
  content_type = {Conference paper},
}


@article{springer_10_1023_a_1018993212326,
  title = {The legal status of reverse engineering of computer software},
  author = {Cifuentes, Cristina and Fitzgerald, Anne},
  journal = {Annals of Software Engineering},
  year = {2000},
  volume = {9},
  number = {1-4},
  pages = {337-351},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1023/a:1018993212326},
  url = {https://doi.org/10.1023/a:1018993212326},
  abstract = {Reverse engineering of computer software has assumed greater importance in recent years because of the need to examine legacy code to remove the year 2000 bug. There are different types of reverse engineering based on the level of abstraction of the code to be reengineered; machine code, assembly code, source code or even CASE code. We describe the different types of reverse engineering and the extent of copyright protection for software. The most common uses of reverse engineering are described. This provides for a comparative overview of the legal standing on reverse engineering at the international level. We propose challenges to the global electronic community in relation to existing and future legislation in the area of reverse engineering and protection of digital works.},
  content_type = {Article},
}


@incollection{springer_10_1007_3_540_45309_1_22,
  title = {Typestate Checking of Machine Code},
  author = {Xu, Zhichen and Reps, Thomas and Miller, Barton P.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2001},
  pages = {335-351},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45309-1\_22},
  url = {https://doi.org/10.1007/3-540-45309-1\_22},
  abstract = {We check statically whether it is safe for untrusted foreign machine code to be loaded into a trusted host system. Our technique works on ordinary machine code, and mechanically synthesizes (and verifies) a safety proof. Our earlier work along these lines was based on a C-like type system, which does not suffice for machine code whose origin is C++ source code. In the present paper, we address this limitation with an improved typestate system and introduce several new techniques, including: summarizing the effects of function calls so that our analysis can stop at trusted boundaries, inferring information about the sizes and types of stack-allocated arrays, and a symbolic range analysis for propagating information about array bounds. These techniques make our approach to safety checking more precise, more efficient, and able to handle a larger collection of real-life code sequences than was previously the case.},
  content_type = {Conference paper},
}


@article{springer_10_1023_a_1026599015809,
  title = {Slicing Software for Model Construction},
  author = {Hatcliff, John and Dwyer, Matthew B. and Zheng, Hongjun},
  journal = {Higher-Order and Symbolic Computation},
  year = {2000},
  volume = {13},
  number = {4},
  pages = {315-353},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1023/a:1026599015809},
  url = {https://doi.org/10.1023/a:1026599015809},
  abstract = {Applying finite-state verification techniques (e.g., model checking) to software requires that program source code be translated to a finite-state transition system that safely models program behavior. Automatically checking such a transition system for a correctness property is typically very costly, thus it is necessary to reduce the size of the transition system as much as possible. In fact, it is often the case that much of a program's source code is irrelevant for verifying a given correctness property. In this paper, we apply program slicing techniques to remove automatically such irrelevant code and thus reduce the size of the corresponding transition system models. We give a simple extension of the classical slicing definition, and prove its safety with respect to model checking of linear temporal logic (LTL) formulae. We discuss how this slicing strategy fits into a general methodology for deriving effective software models using abstraction-based program specialization.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_540_45099_3_11,
  title = {Efficient Inference of Static Types for Java Bytecode},
  author = {Gagnon, Etienne M. and Hendren, Laurie J. and Marceau, Guillaume},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {199-219},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-45099-3\_11},
  url = {https://doi.org/10.1007/978-3-540-45099-3\_11},
  abstract = {In this paper, we present an efficient and practical algorithm for inferring static types for local variables in a 3-address, stackless, representation of Java bytecode. By decoupling the type inference problem from the low level bytecode representation, and abstracting it into a constraint system , we show that there exists verifiable bytecode that cannot be statically typed. Further, we show that, without transforming the program, the static typing problem is NP-hard. In order to get a practical approach we have developed an algorithm that works efficiently for the usual cases and then applies efficient program transformations to simplify the hard cases. We have implemented this algorithm in the Soot framework. Our experimental results show that all of the 17,000 methods used in our tests were successfully typed, 99.8\% of those required only the first stage, 0.2\% required the second stage, and no methods required the third stage.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_10719724_31,
  title = {Protecting Secret Keys in a Compromised Computational System},
  author = {Mitchell, W. P. R.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {448-462},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/10719724\_31},
  url = {https://doi.org/10.1007/10719724\_31},
  abstract = {Software applications which run in a compromised environment and perform sensitive operations, such as providing a secure communication channel between two individuals, require protection in order to prevent them being run by an unauthorised adversary. This paper looks at how to build in some protection against an adversary who wishes to modify an application so that it no longer authenticates the user before running. This protection works against a casual observer, that is someone who has access only to standard debugging tools, visualisation tools, and decompilers. The tricks given in the paper do not work against an all powerful adversary. The paper treats the problem of protecting the code fragments dealing with authentication as equivalent to encrypting plaintext without revealing the secret key.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_44456_4_13,
  title = {Towards a Practical Secure Framework for Mobile Code Commerce},
  author = {Hachez, Gaël and Den Hollander, Laurent and Jalali, Mehrdad and Jean-Jacques, Quisquater and Vasserot, Christophe},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {164-178},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-44456-4\_13},
  url = {https://doi.org/10.1007/3-540-44456-4\_13},
  abstract = {Securingthe mobile code commerce is not an easy task at all. We propose in this paper a framework to tackle this problem. In a first step, we analyse the general issues that must be addressed. In a second step we list the possible techniques that can be used for that purpose. In a third step, we build a framework based on the analysis done. This framework has been implemented to show its validity.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_45046_7_8,
  title = {OpenJIT Frontend System: An Implementation of the Reflective JIT Compiler Frontend},
  author = {Ogawa, Hirotaka and Shimura, Kouya and Matsuoka, Satoshi and Maruyama, Fuyuhiko and Sohda, Yukihiko and Kimura, Yasunori},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {135-154},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45046-7\_8},
  url = {https://doi.org/10.1007/3-540-45046-7\_8},
  abstract = {OpenJIT is an open-ended, reflective JIT compiler framework for Java being researched and developed in a joint project by Tokyo Inst. Tech. and Fujitsu Ltd. Although in general self-descriptive systems have been studied in various contexts such as reflection and interpreter/compiler bootstrapping, OpenJIT is a first system we know to date that offers a stable, full-fledged Java JIT compiler that plugs into existing monolithic JVMs, and offer competitive performance to JITs typically written in C or C++. We propose an architecture for a reflective JIT compiler on a monolithic VM, and describe the details of its frontend system. And we demonstrate how reflective JITs could be useful class-or application specific customization and optimization by providing an important reflective “hook” into a Java system. We will focus on the Frontend portion of the OpenJIT system for this article; the details of the backend is described in [ 20 ].},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_45102_1_18,
  title = {OpenJIT: An Open-Ended, Reflective JIT Compiler Framework for Java},
  author = {Ogawa, Hirotaka and Shimura, Kouya and Matsuoka, Satoshi and Maruyama, Fuyuhiko and Sohda, Yukihiko and Kimura, Yasunori},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {362-387},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45102-1\_18},
  url = {https://doi.org/10.1007/3-540-45102-1\_18},
  abstract = {OpenJIT is an open-ended, reflective JIT compiler framework for Java being researched and developed in a joint project by Tokyo Inst. Tech. and Fujitsu Ltd. Although in general self-descriptive systems have been studied in various contexts such as reflection and interpreter/compiler bootstrapping, OpenJIT is a first system we know to date that offers a stable, full-fledged Java JIT compiler that plugs into existing monolithic JVMs, and offer competitive performance to JITs typically written in C or C++. This is in contrast to previous work where compilation did not occur in the execution phase, customized VMs being developed ground-up, performance not competing with existing optimizing JIT compilers, and/or only a subset of the Java language being supported. The main contributions of this paper are, 1) we propose an architecture for a reflective JIT compiler on a monolithic VM, and identify the technical challenges as well as the techniques employed, 2) We define an API that adds to the existing JIT compiler APIs in “classic” JVM to allow reflective JITs to be constructed, 3) We show detailed benchmarks of run-time behavior of OpenJIT to demonstrate that, while being competitive with existing JITs the time- and space-overheads of compiler metaobjects that exist in the heap are small and manageable. Being an object-oriented compiler framework, OpenJIT can be configured to be small and portable or fully-fledged optimizing compiler framework in the spirit of SUIF. It is fully JCK compliant, and runs all large Java applications we have tested to date including HotJava. We are currently distributing OpenJIT for free to foster further research into advanced compiler optimization, compile-time reflection, advanced run-time support for languages, as well as other areas such as embedded computing, metacomputing, and ubiquitous computing.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_10719724_25,
  title = {Robust Object Watermarking: Application to Code},
  author = {Stern, Julien P. and Hachez, Gaël and Koeune, François and Quisquater, Jean-Jacques},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {368-378},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/10719724\_25},
  url = {https://doi.org/10.1007/10719724\_25},
  abstract = {In this paper, we focus on a step of the watermarking process whose importance has been disregarded so far. In this perspective, we introduce the vector extraction paradigm which is the transformation between digital data and an abstract vector representation of these data. As an application, we propose a new, robust technique in order to insert watermarks in executable code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_44467_x_14,
  title = {Practical Experiences with Java Compilation},
  author = {Smith, Todd and Srinivas, Suresh and Tomsich, Philipp and Park, Jinpyo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {149-157},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-44467-x\_14},
  url = {https://doi.org/10.1007/3-540-44467-x\_14},
  abstract = {The Java programming language and the underlying virtual machine model have introduced new complexities for compilation. Various approaches ranging from just in time (JIT) compilation to ahead of time (AOT) compilation are being explored with the aim of improving the performance of Java programs. The hurdles facing the achievement of high performance in Java and the strengths and weaknesses of different approaches to Java compilation are addressed in this paper, specifically within the context of SGI’s effort to provide a high-performance Java execution environment for its computing platforms. The SGI JIT compiler and prototype AOT compiler are described, and performance results are presented and discussed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_49099_x_14,
  title = {Type-Based Decompilation (or Program Reconstruction via Type Reconstruction)},
  author = {Mycroft, Alan},
  booktitle = {Lecture Notes in Computer Science},
  year = {1999},
  pages = {208-223},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-49099-x\_14},
  url = {https://doi.org/10.1007/3-540-49099-x\_14},
  abstract = {We describe a system which decompiles (reverse engineers) C programs from target machine code by type-inference techniques. This extends recent trends in the converse process of compiling high-level languages whereby type information is preserved during compilation. The algorithms remain independent of the particular architecture by virtue of treating target instructions as register-transfer specifications. Target code expressed in such RTL form is then transformed into SSA form (undoing register colouring etc.); this then generates a set of type constraints. Iteration and recursion over data-structures causes synthesis of appropriate recursive C structs; this is triggered by and resolves occurs-check constraint violation. Other constraint violations are resolved by C’s casts and unions. In the limit we use heuristics to select between equally suitable C code — a good GUI would clearly facilitate its professional use.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_40891_6_25,
  title = {SIMATIC S7-400F/FH: Safety-Related Programmable Logic Controller},
  author = {Schenk, Andreas},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {286-293},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-40891-6\_25},
  url = {https://doi.org/10.1007/3-540-40891-6\_25},
  abstract = {SIMATIC S7-400F/FH is a fail-safe and fault-tolerant programmable logic controller which achieves safety integrity level 3 (SIL 3) with one standard SIMATIC CPU module and distributed failsafe input and output (I/O) modules. This paper shows the underlying safety principles.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_3389_6_8,
  title = {Reflection},
  author = {Craig, Iain},
  booktitle = {The Interpretation of Object-Oriented Programming Languages},
  year = {2000},
  pages = {183-201},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3389-6\_8},
  url = {https://doi.org/10.1007/978-1-4471-3389-6\_8},
  abstract = {The concept of computational reflection has been studied for a long time. In the last few years, in particular since the emergence of object-oriented languages, reflection and the associated concept introspection , have been studied with some intensity. The reason for this is that the two concepts promise to give us more flexible languages which can be extended to suit an application’s needs more closely. They also allow the introduction of new features such as distribution and parallel execution with less disruption than is normal. Furthermore, these two concepts give programmers access to the internals of programs, thus facilitating the construction of debuggers and profilers. Finally, introspection gives access to the execution mechanism itself, thus permitting programs, at least in principle, to adjust the way in which they are executed. It should be noted that the terms reflection and introspection are often used in an interchangeable manner.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_45350_4_12,
  title = {Pragmatic Aspects of Reusable Program Generators Position Paper},
  author = {Ramsey, Norman},
  booktitle = {Lecture Notes in Computer Science},
  year = {2000},
  pages = {149-171},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45350-4\_12},
  url = {https://doi.org/10.1007/3-540-45350-4\_12},
  abstract = {When writing a program generator requires considerable intellectual effort,it is pleasant to amortize that effort by using the generator to build more than one application. When a program generator serves multiple clients,however, the implementor must address pragmatic questions that implementors of single-use program generators can ignore. In how many languages should generated code be written? How should code be packaged? What should the interfaces to the client code look like? How should a user control variations? This paper uses exam- ples from SLED, λ-RTL, and ASDL to elaborate on these questions. It is hoped that the paper will stimulate discussion and the development of better techniques. Most urgently needed is a simple, clear way to control interfaces to generated code.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf02997768,
  title = {Development of complex communications protocols using Estelle},
  author = {Catrina, Octavian and BORCOCI, Eugen},
  journal = {Annales Des Télécommunications},
  year = {2000},
  volume = {55},
  number = {1-2},
  pages = {4-19},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf02997768},
  url = {https://doi.org/10.1007/bf02997768},
  abstract = {During the decade that has elapsed since its standardisation by ISO, the Estelle formal description technique has been successfully applied to the development of various communications protocols. We present in this paper a protocol engineering methodology that has resulted from the use of Estelle in several projects, involving the specification, validation, performance analysis and implementation of real-life, complex protocols. The methodology is based on the support offered by the Estelle development toolset (edt). It gradually evolved, in parallel with the continuous enhancement of edt, aiming to provide a protocol engineering environment that consistently supports the entire development process. We outline in the paper the principles of the methods and illustrate them with examples of their application to the development of an innovative transport protocol with multicast and multimedia capabilities.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4471_0463_6_6,
  title = {Prolog III and Real-Time System Engineering},
  author = {Attoui, Ammar},
  booktitle = {Practitioner Series},
  year = {2000},
  pages = {239-305},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0463-6\_6},
  url = {https://doi.org/10.1007/978-1-4471-0463-6\_6},
  abstract = {The aim of formal specifications is to support software development, and gradually reduce their cost and production time. They also enable program maintenance by providing precise and automatically analysable interfaces.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_48912_6_16,
  title = {Induction as Pre-processing},
  author = {Wu, Xindong},
  booktitle = {Lecture Notes in Computer Science},
  year = {1999},
  pages = {114-122},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-48912-6\_16},
  url = {https://doi.org/10.1007/3-540-48912-6\_16},
  abstract = {In most data mining applications where induction is used as the primary tool for knowledge extraction, it is difficult to precisely identify a complete set of relevant attributes. The real world database from which knowledge is to be extracted usually contains a combination of relevant, noisy and irrelevant attributes. Therefore, pre-processing the database to select relevant attributes becomes a very important task in knowledge discovery and data mining. This paper starts with two existing induction systems, C4.5 and HCV, and uses one of them to select relevant attributes for the other. Experimental results on 12 standard data sets showtha t using HCV induction for C4.5 attribute selection is generally useful.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_47018_2_16,
  title = {Type-Directed Partial Evaluation},
  author = {Danvy, Olivier},
  booktitle = {Lecture Notes in Computer Science},
  year = {1999},
  pages = {367-411},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-47018-2\_16},
  url = {https://doi.org/10.1007/3-540-47018-2\_16},
  abstract = {Type-directed partial evaluation uses a normalization function to achieve partial evaluation. These lecture notes review its background, foundations, practice, and applications. Of specific interest is the modular technique of offline and online type-directed partial evaluation in Standard ML of New Jersey.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_540_48765_4_42,
  title = {Using Cases for Process Modelling: An Example from the Water Supply Industry},
  author = {Saward, Guy},
  booktitle = {Lecture Notes in Computer Science},
  year = {1999},
  pages = {382-387},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-540-48765-4\_42},
  url = {https://doi.org/10.1007/978-3-540-48765-4\_42},
  abstract = {This paper describes the use of cases as a process representation technique and shows how case base reasoning can be used to navigate through, or execute a complex control process. The work is based on a prototype decision support application for a UK water utility company in which two processes were modelled – one diagnostic and one operational. A brief description is given of how processes are represented as cases and how those cases are are used to animate the business process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_0523_7_15,
  title = {Formal Verification in Railways},
  author = {Borälv, Arne and Stålmarck, Gunnar},
  booktitle = {Industrial-Strength Formal Methods in Practice},
  year = {1999},
  pages = {329-350},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0523-7\_15},
  url = {https://doi.org/10.1007/978-1-4471-0523-7\_15},
  abstract = {The motive for adopting a formal method is an improved development process with resource savings, a reduced number of errors, and reduced time-to-market. That formal methods potentially can give these benefits is not very controversial since formal methods consider software construction just like construction in any other traditional engineering discipline: by model building and model analysis before construction and production takes place. A model is an abstraction of a system to be constructed with the advantage that it can be analysed thoroughly for its intended, and also unintended, design characteristics. This prior-to construction analysis is used in many traditional engineering disciples, e.g., in mechanics of materials in order to establish the solidity of constructions. It seems very likely that, with the appropriate methodology and tool support, prior-to construction analysis based on mathematics and logic is equally beneficial to use in software development as related methods are in traditional engineering disciplines.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_0819_1_2,
  title = {The NIST Design Repository Project},
  author = {Szykman, Simon and Sriram, Ram D. and Bochenek, Christophe and Racz, Janusz},
  booktitle = {Advances in Soft Computing},
  year = {1999},
  pages = {5-19},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0819-1\_2},
  url = {https://doi.org/10.1007/978-1-4471-0819-1\_2},
  abstract = {Modern engineering industry is relying more and more on the use of knowledge in product development. This paper advocates design repositories as a natural progression from traditional design databases to systems that are created to more actively support knowledge-based design. In contrast to traditional design databases, design repositories serve not only as archives, but as repositories of heterogeneous information that are designed to enable representation, capture, sharing, and reuse of corporate design knowledge. This paper describes the NIST Design Repository Project, an ongoing project within the Engineering Design Technologies Group at the National Institute of Standards and Technology (NIST). The project objectives are to develop a computational framework for the creation of design repositories, and a proof-of-concept prototype to demonstrate their benefits. A number of research issues associated with the envisioned role of design repositories in industry are addressed. The current state of the project and its implementation are presented.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_94_017_1901_8_10,
  title = {Towards the inclusion of process related knowledge into very high level modeling entities},
  author = {Horváth, Imre and Bremer, Aad P. and Vergeest, Joris S. M. and van der Vegte, Wilfred and Kuczogi, György},
  booktitle = {Integration of Process Knowledge into Design Support Systems},
  year = {1999},
  pages = {129-142},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-017-1901-8\_10},
  url = {https://doi.org/10.1007/978-94-017-1901-8\_10},
  abstract = {This paper summarizes the results of our research in a comprehensive methodology for handling design concepts. The main objectives are: (i) to understand the semantics of design concepts, (ii) to formalize the content and connections of design concepts, (iii) to provide a unified representation for the object-aspect and the process-aspect. Our approach relies on the ontology theory. First, an overview on the fundamentals and advantages of the ontological foundation is given. Design concepts are formalized based on the entity-situation-phenomenon scheme. A situation is decomposed into views which make corresponding object-oriented and process-oriented chunks of knowledge explicit. Details of structural, morphological and functional specifications of a design ontology are also presented.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_48294_6_1,
  title = {A Formal Study of Slicing for Multi-threaded Programs with JVM Concurrency Primitives},
  author = {Hatcliff, John and Corbett, James and Dwyer, Matthew and Sokolowski, Stefan and Zheng, Hongjun},
  booktitle = {Lecture Notes in Computer Science},
  year = {1999},
  pages = {1-18},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-48294-6\_1},
  url = {https://doi.org/10.1007/3-540-48294-6\_1},
  abstract = {Previous work has shown that program slicing can be a useful step in model-checking software systems. We are interested in applying these techniques to construct models of multi-threaded Java programs. Past work does not address the concurrency primitives found in Java, nor does it provide the rigorous notions of slice correctness that are necessary for reasoning about programs with non-deterministic behaviour and potentially infinite computation traces. In this paper, we define the semantics of a simple multi-threaded language with concurrency primitives matching those found in the Java Virtual Machine, we propose a bisimulation-based notion of correctness for slicing in this setting, we identify notions of dependency that are relevant for slicing multi-threaded Java programs, and we use these dependencies to specify a program slicer for the language presented in the paper. Finally, we discuss how these dependencies can be refined to take into account common programming idioms of concurrent Java software.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_0_387_35565_8_9,
  title = {An Overview of CORBA 3},
  author = {Siegel, Jon},
  booktitle = {Distributed Applications and Interoperable Systems II},
  year = {1999},
  pages = {119-132},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-35565-8\_9},
  url = {https://doi.org/10.1007/978-0-387-35565-8\_9},
  abstract = {Already the architecture of choice for distributed enterprise applications, CORBA takes a major step in capability and ease-of-use with the addition of new features labeled, collectively, CORBA 3. The new abilities group into three areas: Java and Internet Integration: Two URL formats for the CORBA object reference provide access to CORBA services and objects over the internet or on remote hosts in your enterprise. A Java-to-IDL mapping automatically defines IDL interfaces for objects programmed in Java. A binary stub standard removes a possible barrier to portability. And, a Firewall specification enhances enterprise access to CORBA over the internet. Quality of Service Management: An enhancement to OMG’s standard IIOP protocol brings the reliability and flexibility of messaging to your CORBA installation. Asynchronous invocation modes can now be used with stub-based invocations. Quality of Service can be specified for both synchronous and asynchronous invocations, in a number of ways. Minimal CORBA (for embedded systems), realtime CORBA, and fault-tolerant CORBA specifications are either complete or nearly so. Distributed Components: Perhaps the most exciting of the new developments, the CORBAcomponents specification defines a container which packages the capabilities that enterprise applications rely upon: persistence, transactionality, security, and event handling. Compatible with Enterprise Java Beans, the system extends component technology to C++ and the other CORBA programming languages. Also provided are interface navigation, connection of interfaces supplied and required by the components in an assembly, and a multi-platform software distribution format and installer which enable a CORBA component marketplace.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4615_5161_4_7,
  title = {Verilog Procedural Interface (PLI2.0)},
  author = {Mittra, Swapnajit},
  booktitle = {Principles of Verilog PLI},
  year = {1999},
  pages = {257-320},
  publisher = {Springer US},
  doi = {10.1007/978-1-4615-5161-4\_7},
  url = {https://doi.org/10.1007/978-1-4615-5161-4\_7},
  abstract = {This chapter introduces the Verilog Procedural Interface (VPI) machanism of Verilog PLI. VPI is the first major revision of the existing PLI methodology and is now a part of IEEE Std. 1364–1995. The primary objective of VPI is to introduce a consistent interface throughout the domain of the language. This chapter starts with investigating why a new version was required. To illustrate how to use this new interface, we will write a small example program using VPI. Although the individual components of a program written using this new interface are conceptually similar to that of PLI1.0, they differ in syntax. Perhaps the most visible difference between the two methodologies is the way they handle the data access. VPI follows an object oriented approach for the data access associating a set of properties and relationships with each design object. Our discussion in this chapter concludes with a list of such properties and relationships for each defined object.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_0841_2_5,
  title = {Realisations for Strict Languages},
  author = {Kluge, Werner},
  booktitle = {Research Directions in Parallel Functional Programming},
  year = {1999},
  pages = {121-148},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0841-2\_5},
  url = {https://doi.org/10.1007/978-1-4471-0841-2\_5},
  abstract = {The Church-Rosser property shows that functional program terms that are not contained in each other may be evaluated (rewritten) in any order without affecting the determinacy of results. Thus they can also be evaluated non-sequentially 2 , under the control of individual processes (or tasks ), in a system of several processing sites. All it takes to do so are some means to partition a program into concurrently executable (sub-)terms, and to compose, in reverse order, an evaluated program from evaluated (sub-)terms.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_3431_2_6,
  title = {Real-Time and Safety-Critical Systems},
  author = {Ostroff, Jonathan and Gerhart, Susan and Craigen, Dan and Ralston, Ted and Leveson, Nancy G. and Bowen, Jonathan and Stavridou, Victoria},
  booktitle = {High-Integrity System Specification and Design},
  year = {1999},
  pages = {359-528},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3431-2\_6},
  url = {https://doi.org/10.1007/978-1-4471-3431-2\_6},
  abstract = {A system is one in which the timing of the output is significant [195]. Such a system accepts inputs from the ‘real world’ and must respond with outputs in a timely manner (typically within milliseconds — a response time of the same order of magnitude as the time of computation — otherwise, for example, a payroll system could be considered ‘real-time’ since employees expect to be paid at the end of each month). Many real-time systems are embedded systems, where the fact that a computer is involved may not be immediately obvious (e.g., a washing machine). Real-time software often needs to be of high integrity [10].},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_0_387_35350_0_8,
  title = {Java in high performance networking applications},
  author = {Azbel, I. and Wynne, A. and Cook, D. and MacGregor, K.},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {1998},
  pages = {100-113},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-35350-0\_8},
  url = {https://doi.org/10.1007/978-0-387-35350-0\_8},
  abstract = {The acceptance of Java and its growth as a programming language is unparalleled. Since its inception, it has been used for a diverse range of applications. However the area that Java claims superiority over normal application development languages is that of networking. This paper describes the experiences gained in 8 man-years of development using Java in two networking applications. A detailed explanation of the experiences gained and the implementation issues are provided coupled with a discussion of problems encountered. A number of important issues have been discussed with regard to the performance of Java as well as its integration with C. The results indicate that Java can be used to implement high performance networking applications, however there are a number of issues with respect to the class libraries and the VM implementation which need to be addressed before it can be regarded as completely satisfactory for network applications.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4615_5627_5_5,
  title = {Implementation Issues},
  author = {Mezini, Mira},
  booktitle = {Variational Object-Oriented Programming Beyond Classes and Inheritance},
  year = {1998},
  pages = {163-190},
  publisher = {Springer US},
  doi = {10.1007/978-1-4615-5627-5\_5},
  url = {https://doi.org/10.1007/978-1-4615-5627-5\_5},
  abstract = {In this chapter, a prototype realization of RONDO by extending the explicit metalevel of Smalltalk-80 was presented. Our goal in providing this first prototype implementation of RONDO was to demonstrate its feasibility with the minimal effort possible rather than to provide an efficient implementation for practical use. In this context, Smalltalk with its elaborated metalevel has proven to be an excellent implementation environment.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_bfb0033848,
  title = {Reflections on reflections},
  author = {Barthel, Gilles and Hatcliff, John and Sørensen, Morten Heine},
  booktitle = {Lecture Notes in Computer Science},
  year = {1997},
  pages = {241-258},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/bfb0033848},
  url = {https://doi.org/10.1007/bfb0033848},
  abstract = {In the functional programming literature, compiling is often expressed as a translation between source and target program calculi. In recent work, Sabry and Wadler proposed the notion of a reflection as a basis for relating the source and target calculi. A reflection elegantly describes the situation where there is a kernel of the source language that is isomorphic to the target language. However, we believe that the reflection criteria is so strong that it often excludes the usual situation in compiling where one is compiling from a higher-level to a lower-level language. We give a detailed analysis of several translations commonly used in compiling that fail to be reflections. We conclude that, in addition to the notion of reflection, there are several relations weaker a reflection that are useful for characterizing translations. We show that several familiar translations (that are not naturally reflections) form what we call a reduction correspondence . We introduce the more general notion of a ( R 1, R 2, R 3, R 4)-correspondence as a framework for describing relations between source and target calculi.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_0997_6_1,
  title = {Software-based Safety-critical Systems: a Taxonomy},
  author = {Papini, Hélène and Simon, Frangois},
  booktitle = {Safe Comp 97},
  year = {1997},
  pages = {3-13},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-0997-6\_1},
  url = {https://doi.org/10.1007/978-1-4471-0997-6\_1},
  abstract = {Railway control systems are designed to ensure the safe behaviour of the Railway systems. While any existing railway control system has to ensure safety, each system is different from others, by difference of architecture, and difference of development process. This paper proposes a general presentation of safety related/critical systems based on software. It presents a classification of the development processes, and a classification of the architectures, and qualifies architectures and development processes. Each architecture has a set of undetectable errors that constitutes its weakness. And each development process is oriented towards a set of avoided faults. The use of a development process associated to an architecture is a way to reduce as far as possible the set of undetectable errors (through fault avoidance). This analysis leads to associate to each architecture the required development process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_bfb0052347,
  title = {Reinventing the travois: Encryption/MAC in 30 ROM bytes},
  author = {Yuval, Gideon},
  booktitle = {Lecture Notes in Computer Science},
  year = {1997},
  pages = {205-209},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/bfb0052347},
  url = {https://doi.org/10.1007/bfb0052347},
  abstract = {By using a large number of round, we hope to be able to scrounge an Sbox out of nowhere, in an environment for which even TEA and the SAFERs are gross overdesign.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4612_4064_8_5,
  title = {Duty of Care},
  author = {Rosenoer, Jonathan},
  booktitle = {CyberLaw},
  year = {1997},
  pages = {161-166},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4612-4064-8\_5},
  url = {https://doi.org/10.1007/978-1-4612-4064-8\_5},
  abstract = {Negligence is “conduct which falls below a standard established by the law for the protection of others against unreasonable risk of harm.” 227 A negligence claim may be brought where there exists a legal duty of care, and breach of that duty to a person injured as a result. 228 The “duty” is based upon a relationship between the actor and the injured party giving rise to a legal obligation on the actor’s part for the benefit of the injured person. 229 That relationship may be created by contract, statute, judicial decision, or “the interdependent relationship of human society.” 230},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_60746_2_11,
  title = {The Harmonisation of Copyright and Related Rights},
  author = {Gaster, Jens},
  booktitle = {Exploring the Limits},
  year = {1997},
  pages = {203-218},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-60746-2\_11},
  url = {https://doi.org/10.1007/978-3-642-60746-2\_11},
  abstract = {The convergence of the 15 EU Member States’ legislation in the field of copyright and related rights is not only of considerable political and legal significance but relates to a sector which is of utmost commercial importance. The turnover of the so-called copyright and related rights “industries” (print media, arts, music and sound recordings, films, broadcasting, computer programmes, databases and other types of multimedia works) is currently estimated at roughly 5\% of the European Union’s GDP. The rapid growth of the information technology and entertainment industries contributes to the widespread dissemination of cultural, educational and otherwise useful goods and services. Intellectual property has thus become a particularly valuable resource in modern societies.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_63141_0_27,
  title = {On implementations and semantics of a concurrent programming language},
  author = {Sewell, Peter},
  booktitle = {Lecture Notes in Computer Science},
  year = {1997},
  pages = {391-405},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-63141-0\_27},
  url = {https://doi.org/10.1007/3-540-63141-0\_27},
  abstract = {The concurrency theory literature contains many proposals for models of process algebras. We consider an example application of the π -calculus, the programming language Pict of Pierce and Turner, primarily in order to see how far it is possible to argue, from facts about the application, that some model is the most appropriate. We discuss informally the sense in which the semantics of Pict relates to the behaviour of actual implementations. Based on this we give an operational model of the interactions between a Pict implementation (considered as the abstract behaviour of a C program) and its environment (modelling an operating system and user). We then give a class of abstract machines and a definition of abstract machine correctness, using an adapted notion of testing, and prove that a sample abstract machine is indeed correct. We briefly discuss the standard of correctness appropriate for program transformations and the induced precongruence. Many of the semantic choices do indeed turn out to be determined by facts about Pict.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_61053_7_55,
  title = {Structuring decompiled graphs},
  author = {Cifuentes, Cristina},
  booktitle = {Lecture Notes in Computer Science},
  year = {1996},
  pages = {91-105},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-61053-7\_55},
  url = {https://doi.org/10.1007/3-540-61053-7\_55},
  abstract = {A structuring algorithm for arbitrary control flow graphs is presented. Graphs are structured into functional, semantical and structural equivalent graphs, without code replication or introduction of new variables. The algorithm makes use of a set of generic high-level language structures that includes different types of loops and conditionals. Gotos are used only when the graph cannot be structured with the structures in the generic set. This algorithm is adequate for the control flow analysis required when decompiling programs, given that a pure binary program does not contain information on the high-level structures used by the initial high-level language program (i.e. before compilation). The algorithm has been implemented as part of the dec decompiler, an i80286 decompiler of DOS binary programs, and has proved successful in its aim of structuring decompiled graphs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_63531_9_27,
  title = {Cryptographic verification of test coverage claims},
  author = {Devanbu, Prem and Stubblebine, Stuart G.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1997},
  pages = {395-413},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-63531-9\_27},
  url = {https://doi.org/10.1007/3-540-63531-9\_27},
  abstract = {The market for software components is growing, driven on the “demand side” by the need for rapid deployment of highly functional products, and on the “supply side” by distributed object standards. As components and component vendors proliferate, there is naturally a growing concern about quality, and the effectiveness of testing processes. White box testing, particularly the use of coverage criteria, is a widely used method for measuring the “thoroughness” of testing efforts. High levels of test coverage are used as indicators of good quality control procedures. Software vendors who can demonstrate high levels of test coverage have a credible claim to high quality. However, verifying such claims involves knowledge of the source code, test cases, build procedures etc. In applications where reliability and quality are critical, it would be desirable to verify test coverage claims without forcing vendors to give up valuable technical secrets. In this paper, we explore cryptographic techniques that can be used to verify such claims. Our techniques have some limitations; however, if such methods can be perfected and popularized, they can have an important “leveling” effect on the software market place: small, relatively unknown software vendors with limited resources can provide credible evidence of high-quality processes, and thus compete with much larger corporations.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_349_14003_9_3,
  title = {Programmable logic devices},
  author = {Seals, R. C. and Whapshott, G. F.},
  booktitle = {Programmable Logic: PLDs and FPGAs},
  year = {1997},
  pages = {63-101},
  publisher = {Macmillan Education UK},
  doi = {10.1007/978-1-349-14003-9\_3},
  url = {https://doi.org/10.1007/978-1-349-14003-9\_3},
  abstract = {In the development of integrated circuits the programmable logic devices are positioned between the standard logic gates and custom or semi-custom designed circuits. All programmable logic devices have a similar architecture consisting of an array of AND gates and an array of OR gates as described in chapter 1. However, in order to enhance the performance of programmable logic devices, a number of additional features are added to the basic structure. The use of registers and feedback circuits in programmable logic devices enables them to be used in the designs of state machines and sequential logic circuits. Additionally, the inclusion of macrocells in programmable logic devices provides the opportunity to emulate the output structure of many existing devices. The internal configuration between the inputs and outputs create the different types of PLDs which will be described in this chapter. Generally, the programmable logic devices provide cost-effective solutions to digital problems as they replace a large number of combinational logic families.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4615_5907_8_5,
  title = {Programming and Coding},
  author = {Sheu, Phillip C.-Y.},
  booktitle = {Software Engineering and Environment},
  year = {1997},
  pages = {93-128},
  publisher = {Springer US},
  doi = {10.1007/978-1-4615-5907-8\_5},
  url = {https://doi.org/10.1007/978-1-4615-5907-8\_5},
  abstract = {Chapter 5 discusses some fundamentals of object-oriented programming languages (Section 5.1) and distributed programming languages (Section 5.4). It also specifically summarizes the major features of two object-oriented programming languages: c ++ (Section 5.2) and SMALLTALK (Section 5.3), and one distributed programming language, namely, OCCAM and its predecessor CSP (Section 5.5). Although there are other object-oriented languages (e.g., ACTOR 1 and EFFEL 2 and distributed programming languages (see Section 5.4), these three languages are chosen to illustrate some basic ideas behind object-oriented programming and distributed programming. It is assumed that the reader is familiar with c .},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_3588_3_9,
  title = {Second-Language Help for Windows Applications},
  author = {Weir, George R. S. and Lepouras, Giorgos and Sakellaridis, Ulysses},
  booktitle = {People and Computers XI},
  year = {1996},
  pages = {129-138},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3588-3\_9},
  url = {https://doi.org/10.1007/978-1-4471-3588-3\_9},
  abstract = {This paper describes an approach to the second-language problem for user-support in the context of existing MS-Windows applications. We outline a methodology for deriving foci for support, and present guidelines for the addition of second-language enhancements. Finally, we detail our procedure for implementing such help facilities with examples of enhanced Chinese and Greek second-language support.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_0_387_34979_4_16,
  title = {Intellectual Property Protection for IT Developments — The Debate Continues},
  author = {Webber, D. B.},
  booktitle = {Advanced IT Tools},
  year = {1996},
  pages = {137-144},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-34979-4\_16},
  url = {https://doi.org/10.1007/978-0-387-34979-4\_16},
  abstract = {The level of intellectual property protection which should be afforded to IT developments has been the subject of debate in both legal and scientific circles for the past 15 years. The extent to which third parties should be allowed to use the work of a developer raises conflicting public policy and commercial issues. The paper addresses those issues, the current intellectual property regime and in particular recent developments in the U.S. and Australia which have seen a considerable expansion in the use of patents and an evolving role for the protection provided by copyright.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf00126960,
  title = {Pattern matching for clone and concept detection},
  author = {Kontogiannis, K. A. and Demori, R. and Merlo, E. and Galler, M. and Bernstein, M.},
  journal = {Automated Software Engineering},
  year = {1996},
  volume = {3},
  number = {1-2},
  pages = {77-108},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf00126960},
  url = {https://doi.org/10.1007/bf00126960},
  abstract = {A legacy system is an operational, large-scale software system that is maintained beyond its first generation of programmers. It typically represents a massive economic investment and is critical to the mission of the organization it serves. As such systems age, they become increasingly complex and brittle, and hence harder to maintain. They also become even more critical to the survival of their organization because the business rules encoded within the system are seldom documented elsewhere. Our research is concerned with developing a suite of tools to aid the maintainers of legacy systems in recovering the knowledge embodied within the system. The activities, known collectively as “program understanding”, are essential preludes for several key processes, including maintenance and design recovery for reengineering. In this paper we present three pattern-matching techniques: source code metrics, a dynamic programming algorithm for finding the best alignment between two code fragments, and a statistical matching algorithm between abstract code descriptions represented in an abstract language and actual source code. The methods are applied to detect instances of code cloning in several moderately-sized production systems including tcsh, bash, and CLIPS. The programmer's skill and experience are essential elements of our approach. Selection of particular tools and analysis methods depends on the needs of the particular task to be accomplished. Integration of the tools provides opportunities for synergy, allowing the programmer to select the most appropriate tool for a given task.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_0_387_34988_6_10,
  title = {Two approaches linking a test generation tool with verification techniques},
  author = {Clatin, Marylène and Groz, Roland and Phalippou, Marc and Thummel, Richard},
  booktitle = {Protocol Test Systems VIII},
  year = {1996},
  pages = {151-166},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-34988-6\_10},
  url = {https://doi.org/10.1007/978-0-387-34988-6\_10},
  abstract = {This paper presents two methods implemented in a test generation tool to compute significant feasible test paths including parameter values for input-output events. The first method is a kind of symbolic execution. The second method consists in linking the test generation tool with a tool permitting sophisticated types of reachability analysis. Preliminary results on non-trivial protocols are commented.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf02943578,
  title = {Research on decompiling technology},
  author = {Liu, Zongtian and Chen, Fuan},
  journal = {Journal of Computer Science and Technology},
  year = {1994},
  volume = {9},
  number = {4},
  pages = {311-319},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf02943578},
  url = {https://doi.org/10.1007/bf02943578},
  abstract = {Decompiling, as a means of analysing and understanding software, has great practical value. This paper presents a kind of decompiling method offered by the authors, in which the techniques of library-function pattern recognition, intermediate language, symbolic execution, rule-based data type recovery, program transformation, and knowledge engineering are separately applied to different phases of decompiling. Then it is discussed that the techniques of developing expert systems are adopted to build a decompiling system shell independent of the knowledge of language and program running environment. The shell will become a real decompiler, as long as the new knowledge of application environment is interactively acquired.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_0_585_27477_5_4,
  title = {Pattern Matching for Clone and Concept Detection},
  author = {Kontogiannis, K. A. and Demori, R. and Merlo, E. and Galler, M. and Bernstein, M.},
  booktitle = {Reverse Engineering},
  year = {None},
  pages = {77-108},
  publisher = {Springer US},
  doi = {10.1007/978-0-585-27477-5\_4},
  url = {https://doi.org/10.1007/978-0-585-27477-5\_4},
  abstract = {A legacy system is an operational, large-scale software system that is maintained beyond its first generation of programmers. It typically represents a massive economic investment and is critical to the mission of the organization it serves. As such systems age, they become increasingly complex and brittle, and hence harder to maintain. They also become even more critical to the survival of their organization because the business rules encoded within the system are seldom documented elsewhere. Our research is concerned with developing a suite of tools to aid the maintainers of legacy systems in recovering the knowledge embodied within the system. The activities, known collectively as “program understanding”, are essential preludes for several key processes, including maintenance and design recovery for reengineering. In this paper we present three pattern-matching techniques: source code metrics, a dynamic programming algorithm for finding the best alignment between two code fragments, and a statistical matching algorithm between abstract code descriptions represented in an abstract language and actual source code. The methods are applied to detect instances of code cloning in several moderately-sized production systems including tcsh, bash, and CLIPS. The programmer’s skill and experience are essential elements of our approach. Selection of particular tools and analysis methods depends on the needs of the particular task to be accomplished. Integration of the tools provides opportunities for synergy, allowing the programmer to select the most appropriate tool for a given task.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf03259390,
  title = {Specification, Verification and Prototyping of an Optimized Compiler},
  author = {Jifeng, He and Bowen, Jonathan},
  journal = {Formal Aspects of Computing},
  year = {1994},
  volume = {6},
  number = {6},
  pages = {643-658},
  publisher = {Association for Computing Machinery (ACM)},
  doi = {10.1007/bf03259390},
  url = {https://doi.org/10.1007/bf03259390},
  abstract = {Abstract This paper generalizes an algebraic method for the design of a correct compiler to tackle specification and verification of an optimized compiler. The main optimization issues of concern here include the use of existing contents of registers where possible and the identification of common expressions. A register table is introduced in the compiling specification predicates to map each register to an expression whose value is held by it. We define different kinds of predicates to specify compilation of programs, expressions and Boolean tests. A set of theorems relating to these predicates, acting as a correct compiling specification, are presented and an example proof within the refinement algebra of the programming language is given. Based on these theorems, a prototype compiler in Prolog is produced.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_0_387_34880_3_9,
  title = {Framework and Multi-Formalism: the ASAR Project},
  author = {Asar, P.},
  booktitle = {Electronic Design Automation Frameworks},
  year = {1995},
  pages = {89-98},
  publisher = {Springer US},
  doi = {10.1007/978-0-387-34880-3\_9},
  url = {https://doi.org/10.1007/978-0-387-34880-3\_9},
  abstract = {The main concern of the research project ASAR is to build a multi-formalism framework oriented towards Architectural Synthesis. This paper describes the Centaur system, used to build this framework, and the common intermediate data-flow format GC, that will be the common denominator of the different formalisms and tools available in that framework.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_3054_3_35,
  title = {The Verification of Compiled Code},
  author = {Jennings, T. and Taylor, P.},
  booktitle = {Safe Comp 95},
  year = {1995},
  pages = {504-513},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3054-3\_35},
  url = {https://doi.org/10.1007/978-1-4471-3054-3\_35},
  abstract = {For safety critical applications it is desirable to have a procedure for positive validation of the correctness of the compiler employed to generate object code from high level source code. Confidence in a compiler is usually based upon comprehensive testing and experience of its use but more formal approaches are possible.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_94_011_0549_1_4,
  title = {Legislation and liability},
  author = {Smith, David J.},
  booktitle = {Achieving Quality Software},
  year = {1995},
  pages = {29-37},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-011-0549-1\_4},
  url = {https://doi.org/10.1007/978-94-011-0549-1\_4},
  abstract = {The introduction of laws concerning product liability, and the development of legislation concerning safety and major industrial hazards, has had a considerable impact on the software designer. Failures and their consequences, arising from software errors, are covered by such regulations as much as those from any other cause.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_58468_4_183,
  title = {Distributed implementation of SIGNAL: Scheduling \& graph clustering},
  author = {MaffeÏs, Olivier and Guernic, Paul},
  booktitle = {Lecture Notes in Computer Science},
  year = {1994},
  pages = {547-566},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-58468-4\_183},
  url = {https://doi.org/10.1007/3-540-58468-4\_183},
  abstract = {This paper introduces the scheduling strategy and some key tools which have been designed for the distributed implementation of SIGNAL, a real-time synchronous dataflow language. First, we motivate a scheduling strategy with respect to the reactivity and time-predictability requirements bound to real-time computing. Then, several key tools to implement this scheduling strategy are described. These tools are acting on the concept of Synchronous-Flow Dependence Graph (SFD Graph) which defines a generalization of Directed Acyclic Graph and constitutes the abstract representation of SIGNAL programs. The tools presented in this paper are: (a) the abstraction of SFD graphs which enables grain-size tuning according to the target architecture, (b) the notion of scheduling over SFD graphs and (c) qualitative clustering tools based on the notion of Compositional Deadlock Consistency .},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_3225_7_18,
  title = {Deductive and Active Databases: Two Paradigms or Ends of a Spectrum?},
  author = {Widom, Jennifer},
  booktitle = {Workshops in Computing},
  year = {1994},
  pages = {306-315},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3225-7\_18},
  url = {https://doi.org/10.1007/978-1-4471-3225-7\_18},
  abstract = {This position paper considers several existing relational database rule languages with a focus on exploring the fundamental differences between deductive and active databases. We find that deductive and active databases do not form two discernible classes, but rather they delineate two ends of a spectrum of database rule languages. We claim that this spectrum also corresponds to a notion of abstraction level, with deductive rule languages at a higher level and active rule languages at a lower level.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf02939474,
  title = {Inductive learning},
  author = {Xindong, Wu},
  journal = {Journal of Computer Science and Technology},
  year = {1993},
  volume = {8},
  number = {2},
  pages = {118-132},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf02939474},
  url = {https://doi.org/10.1007/bf02939474},
  abstract = {Machine learning (ML) is a major subfield of artificial intelligence (AF). It has been seen as a feasible way of avoiding the knowledge bottleneck problem in knowledge based systems development. research on ML has concentrated in the main on inductive learning, a paradigm for inducing rules from unordered sets of exmaples. AQ11 and ID3, the two most widespread algorithms in ML, are both inductive. This paper first summarizes AQ11, ID3 and the newly-developed extension matrix approach based HCV algorithm, and then reviews the recent development of inductive learning and automatic knowledge acquisition from data bases.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_77927_5_26,
  title = {Second Generation Expert System Explanation},
  author = {Wick, Michael R.},
  booktitle = {Second Generation Expert Systems},
  year = {1993},
  pages = {614-640},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-77927-5\_26},
  url = {https://doi.org/10.1007/978-3-642-77927-5\_26},
  abstract = {Explanation has long been cited as one of the key advantages of the expert system methodology. Most current approaches to expert system explanation view explanation as an “add-on” to the expert system’s domain problem solving. This is in direct conflict with findings on human explanation. For humans, explanation is a complex problem-solving process of reconstructing an explanation based on a partial memory of the problem-solving episodes. Further, this process of explanation is at the same level as the original domain problem solving; working on the current state to reconstruct a plausible explanation. Recently, a new direction has emerged in expert systems, namely the study of second generation expert systems. These new expert systems view domain problem solving as an interaction and combination of several explicit reasoning processes or representations (i.e., causal, heuristic, planning). This chapter discusses two related projects that investigate the natural role of explanation in such second generation expert systems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_7091_4009_3_11,
  title = {Dependable Computing for Railway Control Systems},
  author = {Mongardi, Giorgio},
  booktitle = {Dependable Computing and Fault-Tolerant Systems},
  year = {1993},
  pages = {255-277},
  publisher = {Springer Vienna},
  doi = {10.1007/978-3-7091-4009-3\_11},
  url = {https://doi.org/10.1007/978-3-7091-4009-3\_11},
  abstract = {This paper deals with a dependable microprocessor system applied to control equipment and train movements in a railway station. First, application general requirements are outlined and basic principles and adopted techniques for dependability are shown; hardware and software vital architecture are described. Then some details about application special features are given, in order to present a suitable software verification and validation environment and to explain procedures and tools for system design. At last, some hints about first installations and relevant results are given.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_57186_8_69,
  title = {A debugging model for functional logic programs},
  author = {Hanus, Michael and Josephs, Berthold},
  booktitle = {Lecture Notes in Computer Science},
  year = {1993},
  pages = {28-43},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-57186-8\_69},
  url = {https://doi.org/10.1007/3-540-57186-8\_69},
  abstract = {This paper presents a box-oriented debugging model for the functional logic language ALF. Due to the sophisticated operational semantics of ALF which is based on innermost basic narrowing with simplification, the debugger must reflect the application of the different computation rules during program execution. Hence our debugging model includes not only one box type as in Byrd's debugging model for logic programs but several different kinds of boxes corresponding to the various computation rules of the functional logic language (narrowing, simplification etc.). Moreover, additional box types are introduced in order to allow skips over (sometimes) uninteresting program parts like proofs of the condition in a conditional equation. Since ALF is a genuine amalgamation of functional and logic languages, our debugging model subsumes operational aspects of both kinds of languages. As a consequence, it can be also used for pure logic languages, pure functional languages with eager evaluation, or functional logic languages with a less sophisticated operational semantics like SLOG or eager BABEL.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_57253_8_46,
  title = {Knowledge acquisition in dynamic systems: How can logicism and situatedness go together?},
  author = {Boy, Guy},
  booktitle = {Lecture Notes in Computer Science},
  year = {1993},
  pages = {23-44},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-57253-8\_46},
  url = {https://doi.org/10.1007/3-540-57253-8\_46},
  abstract = {This paper presents an investigation of knowledge acquisition in dynamic systems. The nature of dynamic systems is analyzed. A first ontology of the domain is proposed. Various distinctions are presented such as the agent perspective, the perception of temporal progression, and the notions of conseqences and expertise in dynamic systems. We use Rasmussen's model to characterize ways knowledge can be acquired in dynamic systems. Procedures are shown to be essential knowledge entities in interactions with dynamic systems. An emphasis on logicism and situatedness is presented and discussed around the situation recognition and analytical reasoning model. The knowledge block representation is introduced as a mediating representation for knowledge acquisition in dynamic systems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_3421_3_16,
  title = {An Introduction to Gödel},
  author = {Bowers, A. and Hill, P. M.},
  booktitle = {Workshops in Computing},
  year = {1993},
  pages = {299-343},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3421-3\_16},
  url = {https://doi.org/10.1007/978-1-4471-3421-3\_16},
  abstract = {The logic programming language Gödel is a new language with functionality and expressiveness similar to Prolog, but greatly improved declarative semantics compared with Prolog. Facilities provided by Gödel include types, meta-programming, control annotations, modules, and input/output. This paper is an introduction and tutorial for Gödel.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_3501_2_10,
  title = {From Programs to Object Code using Logic and Logic Programming},
  author = {Bowen, Jonathan},
  booktitle = {Workshops in Computing},
  year = {1992},
  pages = {173-192},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-3501-2\_10},
  url = {https://doi.org/10.1007/978-1-4471-3501-2\_10},
  abstract = {A compiler may be specified by a description of how each construct of the source language is translated into a sequence of object code instructions. If the machine that interprets the object code is specified in the source language itself, then the compiler may be verified using algebraic laws about the programming language constructs. By adopting a subset of the programming language occam, we can benefit from the large number of existing laws which have already been proved for this language. The compiling specification theorems are all Horn clauses in general. Thus it is possible to produce an executable compiler prototype almost directly from this specification in the form of a logic program. The target object code for the transputer has variable-length instruction sequences. Thus in some cases it is necessary to transform the theorems into a form which can be more efficiently executed by avoiding unnecessary backtracking, particularly when there are jumps in the code. However the relational nature of logic programming allows a number of solutions to be returned if desired.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf01228709,
  title = {Federated databases and systems: Part I?A tutorial on their data sharing},
  author = {Hsiao, David K.},
  journal = {The VLDB Journal},
  year = {1992},
  volume = {1},
  number = {1},
  pages = {127-179},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf01228709},
  url = {https://doi.org/10.1007/bf01228709},
  abstract = {The issues and solutions for the interoperability of a class of heterogeneous databases and their database systems are expounded in two parts. Part I presents the data-sharing issues in federated databases and systems. Part II, which will appear in a future issue, explores resource-consolidation issues. Interoperability in this context refers to data sharing among heterogeneous databases, and to resource consolidation of computer hardware, system software, and support personnel. Resource consolidation requires the presence of a database system architecture which supports the heterogeneous system software, thereby eliminating the need for various computer hardware and support personnel. The class of heterogeneous databases and database systems expounded herein is termed federated , meaning that they are joined in order to meet certain organizational requirements and because they require their respective application specificities, integrity constraints, and security requirements to be upheld. Federated databases and systems are new. While there are no technological solutions, there has been considerable research towards their development. This tutorial is aimed at exposing the need for such solutions. A taxonomy is introduced in our review of existing research undertakings and exploratory developments. With this taxonomy, we contrast and compare various approaches to federating databases and systems.},
  content_type = {Article},
}


@incollection{springer_10_1007_3_540_55963_9_41,
  title = {Integrating research, reuse, and integration into software engineering courses},
  author = {Offutt, A. Jefferson and Untch, Roland H.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1992},
  pages = {88-98},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-55963-9\_41},
  url = {https://doi.org/10.1007/3-540-55963-9\_41},
  abstract = {This paper discusses a method for incorporating several important software engineering concepts that have been traditionally hard to teach into courses at both the undergraduate and graduate level. We have created a project template that can be instantiated in many ways to be tailored to the level of a particular course, the number of students, the quality of students, and the goals of the course. We consider a “large” software project to be one in which each programmer's contribution represents a small part of the overall project (less than 10\%). Our project template is a completed software system, which, although too large for a semester project in its complete form, can be easily divided into coherent subsystems. The students are provided with some subsystems, and asked to derive requirements for, design, implement, and test the remaining subsystems. This approach allows the students to work in a large-project environment, reuse existing code, maintain old code, and perform an integration of a significant system. This project has been successfully used in undergraduate and graduate courses that have completely diverging goals and purposes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_1774_2_8,
  title = {Network Viruses: The Worms},
  author = {Ferbrache, David},
  booktitle = {A Pathology of Computer Viruses},
  year = {1992},
  pages = {193-220},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-1774-2\_8},
  url = {https://doi.org/10.1007/978-1-4471-1774-2\_8},
  abstract = {The rapid expansion in wide area and local area networking has led to the establishment of a global internetwork linking millions of systems. Through this network, which interlinks many diverse hardware architectures, a limited range of basic network functions are available — normally restricted to electronic mail and file transfer. The component networks within the global internetwork often use standardised protocols and architectures (thus avoiding the extensive protocol conversion carried out by gateway systems). Within these networks many “closely” coupled services are available. Such services include remote login, remote execution of code and transparent file systems across numerous machines.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4471_1774_2_5,
  title = {Management of PC Viruses},
  author = {Ferbrache, David},
  booktitle = {A Pathology of Computer Viruses},
  year = {1992},
  pages = {91-151},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-1774-2\_5},
  url = {https://doi.org/10.1007/978-1-4471-1774-2\_5},
  abstract = {In Chapter 4 we painted a bleak picture of the wide range of camouflage techniques and replication strategies adopted by PC viruses. In this chapter, methods to prevent, contain and recover from computer virus infection will be discussed. Together, these methods provide comprehensive protection from significant damage to vital programs and data from virus (and trojan horse) activity.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_55606_0_13,
  title = {Towards an epistemology for Guided Discovery Tutoring: The Popperian connection},
  author = {Lamontagne, Claude and Bourdeau, Jacqueline},
  booktitle = {Lecture Notes in Computer Science},
  year = {1992},
  pages = {92-102},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-55606-0\_13},
  url = {https://doi.org/10.1007/3-540-55606-0\_13},
  abstract = {The GDT approach proposed by Elsom-Cook for merging the Learning Environments (LE) and Intelligent Tutoring Systems (ITS) approaches is set against the background of Karl Popper's epistemology. Popper's distinction between World 1 (the world of physical objects), World 2 (the world of psychological “production”), and World 3 (the world of the “products” of thought, or “objective knowledge”) is used to contrast the trends involved. The resulting picture is one which suggests that merging LE and ITS might be far more difficult to achieve than expected, and that GDT's tutor/student/environment “trinity” might benefit from being reformulated in the light of the Popperian Worldl/World2/World3 “trinity”.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_53669_8_76,
  title = {PAGODE: A back end generator using attribute abstract syntaxes and term rewritings},
  author = {Despland, Annie and Mazaud, Monique and Rakotozafy, Raymond},
  booktitle = {Lecture Notes in Computer Science},
  year = {1991},
  pages = {86-105},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-53669-8\_76},
  url = {https://doi.org/10.1007/3-540-53669-8\_76},
  abstract = {A major problem in deriving a compiler from a formal definition is the production of correct and efficient object code. We propose a solution to this problem in the framework of a compiler writing system where the compilation process may be viewed as successive translations from an attributed abstract syntax to another abstract syntax. The code-generator generator needs two kinds of specifications : an attributed abstract syntax (AAS) of the target machine : it is the description of the I.R. given as input to the code-generator. a target machine description where the basic concepts are hierarchically described by tree-patterns. These tree patterns are terms of the target abstract syntax. The code generation process is divided into two steps : the instructions selection process and the register allocation one. The instruction selection process applies a set of rewriting rules driven by tree templates derived from the target machine specification to the I.R. term. The register allocation process consists of several evaluation passes of an attributed grammar derived automatically from the target machine specification. The first one sets the constraints on temporaries according to the whole context, the second one does life-time analysis and packing on temporaries, the last one assigns effective resources to temporaries.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_84542_0_8,
  title = {Implementation Issues},
  author = {Puccetti, Armand},
  booktitle = {The Programming and Proof System ATES},
  year = {1991},
  pages = {258-293},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-84542-0\_8},
  url = {https://doi.org/10.1007/978-3-642-84542-0\_8},
  abstract = {In the present chapter is given an overview of the internal implementation of the ATES system. The implementation on a computer of a large programming and proof system requires lots of efforts (about 100 man x months of work) and the use of a certain number of advanced techniques in the field of compiler design, software environment design and theorem proving.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4613_1523_0_1,
  title = {Decompiling Problem-Solving Experience to Elucidate Representational Distinctions},
  author = {Schlimmer, Jeffrey C.},
  booktitle = {The Kluwer International Series in Engineering and Computer Science},
  year = {1990},
  pages = {1-18},
  publisher = {Springer US},
  doi = {10.1007/978-1-4613-1523-0\_1},
  url = {https://doi.org/10.1007/978-1-4613-1523-0\_1},
  abstract = {General, domain-independent problem-solving methods are highly flexible if inefficient. Recent work addressing the utility of learned knowledge improves efficiency, but flexibility is greatly compromised. In this paper I discuss an alternative that extracts relevant distinctions from problem-solving traces and creates explicit representational terms for them. The new terms are seamlessly integrated into declarative knowledge and are effectively utilized in subsequent problem solving.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf03037471,
  title = {Lazy debugging of lazy functional programs},
  author = {Snyder, Robin M.},
  journal = {New Generation Computing},
  year = {1990},
  volume = {8},
  number = {2},
  pages = {139-161},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf03037471},
  url = {https://doi.org/10.1007/bf03037471},
  abstract = {The debugging of fully lazy functional programs can require searching a very large reduction-history space containing many delayed computations. A debugger should provide a means to obtain a source level representation of the computation, which can be large, and a means to select the appropriate part of the computation to investigate, which can be difficult. A method is presented to compile functional programs to combinator code such that a source-like representation of any part of a computation graph can be efficiently reconstructed at run-time. Other less efficient methods require excessive compile-time guidance as to the specific part of the computation to be investigated. Reconstruction, forward reduction, and a history-rollback mechanism combine to make the entire source-like reduction-history space dynamically available at run-time. The deferring of debugging decisions until run-time is called lazy dubugging. Once the computation-sequence is meaningfully and efficiently available, the problem of debugging becomes that of localizing the search for the error. Some searching issues are discussed with respect to graph browsing and user-interface design. The method shows promise as a programmer tool to debug programs and to informally reason about the time and space behavior of fully lazy functional programs, a nonintuitive process due to the subtleness of sharing and delayed computations.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_94_009_0643_3_59,
  title = {The MetaNet Network Environment for the Development of Modular Neural Networks},
  author = {Murre, Jacob M. J. and Kleynenberg, Steven E.},
  booktitle = {International Neural Network Conference},
  year = {1990},
  pages = {717-720},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-009-0643-3\_59},
  url = {https://doi.org/10.1007/978-94-009-0643-3\_59},
  abstract = {The MetaNet network environment allows users to build and examine modular neural networks, and to specify and run complex simulations. It consists of a graphical editor, a network compiler and a graphical (de)compiler, a network specification language ( MetaNet ), and hardware drivers. Its requirements are based on experiences with a text based network environment, which has been in use at our department since early 1988. Using the environment requires minimal programming experience. Currently, the system is implemented only on PCs. Off-loading of calculation processes to other machines is achieved through hardware drivers. It is possible to convert MetaNet code into ANSI C for direct compilation to stand-alone applications on any machine.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_349_12443_5_4,
  title = {Controversies Over Software Protection},
  author = {Congress of the United States Office of Technology Assessment},
  booktitle = {Computer Software \& Intellectual Property},
  year = {1990},
  pages = {11-16},
  publisher = {Palgrave Macmillan UK},
  doi = {10.1007/978-1-349-12443-5\_4},
  url = {https://doi.org/10.1007/978-1-349-12443-5\_4},
  abstract = {Legal protection for computer hardware is usually provided by patent or trade secret; this combination served fairly well to protect major hardware advances, as well as more-incremental developments. Protection for computer programs does not fit neatly within the traditional forms of intellectual property. 1 As a result, the process by which software developers and users, the courts, and policymakers have attempted to determine what should or should not be protected, and what is or is not protected, has been controversial.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_0_387_34805_0_6,
  title = {UNIX Password Security - Ten Years Later},
  author = {Feldmeier, David C. and Karn, Philip R.},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {44-63},
  publisher = {Springer New York},
  doi = {10.1007/0-387-34805-0\_6},
  url = {https://doi.org/10.1007/0-387-34805-0\_6},
  abstract = {Passwords in the UNIX operating system are encrypted with the crypt algorithm and kept in the publicly-readable file /etc/passwd. This paper examines the vulnerability of UNIX to attacks on its password system. Over the past 10 years, improvements in hardware and software have increased the crypts/second/dollar ratio by five orders of magnitude. We reexamine the UNIX password system in light of these advances and point out possible solutions to the problem of easily found passwords. The paper discusses how the authors built some high-speed tools for password cracking and what elements were necessary for their success. These elements are examined to determine if any of them can be removed from the hands of a possible system infiltrator, and thus increase the security of the system. We conclude that the single most important step that can be taken to improve password security is to increase password entropy.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_51635_2_54,
  title = {The internet worm incident},
  author = {Spafford, Eugene H.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1989},
  pages = {446-468},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-51635-2\_54},
  url = {https://doi.org/10.1007/3-540-51635-2\_54},
  abstract = {On the evening of 2 November 1988, someone “infected” Internet with a worm program. That program exploited flaws in utility programs in systems based on BSD-derived versions of Unix . The flaws allowed the program to break into those machines and copy itself, thus infecting those systems. This program eventually spread to thousands of machines, and disrupted normal activities and Internet connectivity for many days. This paper explains why this program was a worom (as opposed to a virus), and provides a brief chronology of both the spread and eradication of the program. That is followed by discussion of some specific issues raised by the community's reaction and subsequent discussion of the event. Included are some interesting lessons learned from the incident.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_83991_7_5,
  title = {An Industrial First Generation Kbs (Expert System): Delta/Cats},
  author = {Bonissone, Piero P.},
  booktitle = {Lecture Notes in Engineering},
  year = {1989},
  pages = {80-89},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-83991-7\_5},
  url = {https://doi.org/10.1007/978-3-642-83991-7\_5},
  abstract = {Since the early eighties, General Electric Company’s Corporate Research and Development has developed expert system technology and applied to a variety of problems. The first application addressed the problem of troubleshooting and repairing diesel electric locomotives in railroad running repair shops . In such shops, railroad maintenance personnel had to detect and repair a large variety of faults that partially disabled a diesel electric locomotive. The expert system used production rules and an inference engine to diagnose multiple problems with the locomotive and to suggest repair procedures to maintenance personnel. In 1982, a prototype system was implemented in FORTH, running on a Digital Equipment PDP 11/73 under RSX-11M. This system contained approximately 620 rules (roughly 420 rules for the Troubleshooting System, and 200 rules for the Help System), partially representing the knowledge of a Senior Field Service Engineer. The inference engine used a mixed-mode configuration, capable of running in either the forward or backward mode. The Help System provided the operator with assistance by displaying textual information, CAD diagrams or repair sequences from a video disk. The rules were written in a representation language consisting of nine predicate functions, eight verbs, and five utility functions. Two copies of the first field prototype expert system, designated CATS (Computer-Aided Troubleshooting System), were delivered in July 1983 for field evaluation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4613_9614_7_8,
  title = {Producing Software Using Tools in a Workstation Environment},
  author = {Sherman, Mark and Drysdale, Robert L.},
  booktitle = {Issues in Software Engineering Education},
  year = {1989},
  pages = {93-119},
  publisher = {Springer New York},
  doi = {10.1007/978-1-4613-9614-7\_8},
  url = {https://doi.org/10.1007/978-1-4613-9614-7\_8},
  abstract = {We discuss how we taught students to build and use translation, interpretive, editing and monitoring tools in an undergraduate software engineering course. Students used these tools on low-cost workstations (Macintoshes) to build large, group projects. The students’ projects used all available features of workstation environments, including graphics, windows, fonts, mice, networks and sound generators. We found that 1) the use of tools increased student productivity, 2) a shift in data structure and algorithm topics is needed to cover material relevant for workstation environments, 3) new topics in system design are required for a workstation environment, 4) traditional material can be easily illustrated with a workstation environment and 5) students enjoyed being able to manipulate the advanced features of workstations in their work, which in turn increased their motivation for and concentration on the course material.},
  content_type = {Conference paper},
}


@article{springer_10_1023_a_1022693717366,
  title = {A Heuristic Approach to the Discovery of Macro-Operators},
  author = {Iba, Glenn A.},
  journal = {Machine Learning},
  year = {1989},
  volume = {3},
  number = {4},
  pages = {285-317},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1023/a:1022693717366},
  url = {https://doi.org/10.1023/a:1022693717366},
  abstract = {This paper describes a heuristic approach to the discovery of useful macro-operators (macros) in problem solving. The approach has been implemented in a program, MACLEARN, that has three parts: macro-proposer, static filter, and dynamic filter. Learning occurs during problem solving, so that performance improves in the course of a single problem trial. Primitive operators and macros are both represented within a uniform representational framework that is closed under composition. This means that new macros can be defined in terms of others, which leads to a definitional hierarchy. The representation also supports the transfer of macros to related problems. MACLEARN is embedded in a supporting system that carries out best-first search. Experiments in macro learning were conducted for two classes of problems: peg solitaire (generalized “Hi-Q puzzle”), and tile sliding (generalized “Fifteen puzzle”). The results indicate that MACLEARN'S filtering heuristics all improve search performance, sometimes dramatically. When the system was given practice on simpler training problems, it learned a set of macros that led to successful solutions of several much harder problems.},
  content_type = {Article},
}


@article{springer_10_1007_bf00116836,
  title = {A heuristic approach to the discovery of macro-operators},
  author = {Iba, Glenn A.},
  journal = {Machine Learning},
  year = {1989},
  volume = {3},
  number = {4},
  pages = {285-317},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf00116836},
  url = {https://doi.org/10.1007/bf00116836},
  abstract = {This paper describes a heuristic approach to the discovery of useful macro-operators (macros) in problem solving. The approach has been implemented in a program, Maclearn , that has three parts: macro-proposer, static filter, and dynamic filter. Learning occurs during problem solving, so that performance unproves in the course of a single problem trial. Primitive operators and macros are both represented within a uniform representational framework that is closed under composition. This means that new macros can be defined in terms of others, which leads to a definitional hierarchy. The representation also supports the transfer of macros to related problems. Maclearn is embedded in a supporting system that carries out best-first search. Experiments in macro learning were conducted for two classes of problems: peg solitaire (generalized “Hi-Q puzzle”), and tile sliding (generalized “Fiteen puzzle”). The results indicate that Maclearn 's filtering heuristics all improve search performance, sometimes dramatically. When the system was given practice on simpler training problems, it learned a set of macros that led to successful solutions of several much harder problems.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_83739_5_11,
  title = {Tutors, Instructions and Helps},
  author = {Möbus, Claus and Thole, Heinz-J.},
  booktitle = {Informatik-Fachberichte},
  year = {1989},
  pages = {336-385},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-83739-5\_11},
  url = {https://doi.org/10.1007/978-3-642-83739-5\_11},
  abstract = {The goals of this paper are threefold. First we want to present a review of the literature on Computer assisted Instruction, second we want to discuss the quality of instructions in some texts and human-computer dialogs concerning Computer programming. Third we want to demonstrate the cognitive-science-based development of our programming environment ABSYNT. This includes the construction of iconic Instructions and helps which promise to be superior to verbal instractions and helps when properly designed. This paper consists of three parts. In the first part (1.-3.) we give a short introduction to Computer aided instruction (CAI), intelligent Computer aided instruction (ICAI) and a special variant, namely intelligent tutoring Systems (ITS). One of the most underestimated problems in the development of an ITS is the proper design of instruction. We prefer to discuss this problem not on an abstract but on a rather concrete level. So the second part (4.) documents two examples of instractions and helps typically given in textbooks and intelligent tutoring Systems concerning Computer science education. These examples show that at present the construction of instractions is more art than science. They are an uncontrolled source for errors and misconceptions of the students. This causes severe problems in CAI and ICAI, especially for the design of help components. In the third pan (5.) we warn to demonstrate how to derive instructions and helps for a problem solving monitor (PSM) presently under construction. This approach rests on production based learning theory (ANDERSON. 1983.1987a; ANDERSON, GREENO, KLINE \& NEVES, 1981; ANDERSON. KLINE \& BEASLEY. 1980; EGAN \& GREENO, 1974; SIMON \& LEA, 1974; VanLEHN, 1987a,b). We used rule sets to formalize the knowledge about the operational semantics of a graphical virtual machine, which is driven by graphical programs in the ABSYNT language (ABstract SYNtax Trees). Abstract facts and rule sets, which can be conceived as a runnable specification of the virtual machine, are related to concrete counterparts: icons and iconic rules. Thus diagrammatic information forms the core of our instructional and help system.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_45910_3_13,
  title = {The Implementation of a Distributed Smalltalk},
  author = {Schelvis, Marcel and Bledoeg, Eddy},
  booktitle = {Lecture Notes in Computer Science},
  year = {1988},
  pages = {212-232},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-45910-3\_13},
  url = {https://doi.org/10.1007/3-540-45910-3\_13},
  abstract = {This paper describes DistributedSmalltalk, which consists of a number of cooperating Smalltalk virtual machines distributed over a network, that provide complete distribution transparency to the image level, including transparent message passing across machine boundaries. As a result no modifications are necessary at the image level and e.g. the standard Smalltalk debugger can be used for system wide debugging. Transparent I/O is provided by means of a concept called “home objects”. The performance degradation is acceptable, due to replication and the home object concept. Replication is transparent and replication consistency is guaranteed, so e.g. for replicated class objects no compatibility checking is needed. Distributed garbage, whether containing cycles or not, is collected incrementally without any synchronization being necessary.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4471_1616_5_9,
  title = {A Network Database Language},
  author = {Yannakoudakis, E. J.},
  booktitle = {The Architectural Logic of Database Systems},
  year = {1988},
  pages = {214-237},
  publisher = {Springer London},
  doi = {10.1007/978-1-4471-1616-5\_9},
  url = {https://doi.org/10.1007/978-1-4471-1616-5\_9},
  abstract = {In Chapter 3, we discussed three major data models whereby the relationships of the data elements within an organisation can be captured and represented effectively. These are the hierarchic, the network, and the relational models. DBMSs today are often classified according to the type of data model which can be defined using a Data Definition Language (DDL) and then processed by an appropriate Data Manipulation Language (DML).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4613_2017_3_1,
  title = {Introduction},
  author = {Tick, Evan},
  booktitle = {The Kluwer International Series in Engineering and Computer Science},
  year = {1988},
  pages = {1-17},
  publisher = {Springer US},
  doi = {10.1007/978-1-4613-2017-3\_1},
  url = {https://doi.org/10.1007/978-1-4613-2017-3\_1},
  abstract = {The main reason that current computer applications in symbolic processing fail to meet speed constraints on current machines is the gap between the applications and the languages and architectures in which they are implemented. Applications such as natural language understanding and symbolic equation solving, as compared with conventional applications such as numerical modeling and simulation, are further removed from conventional procedural/functional languages such as Pascal and Lisp and their corresponding numeric/scientific processor architectures. This is because these ambitious new applications must, in a sense, be written as meta-level interpreters . A meta-level interpreter is a program which performs additional levels of interpretation to implement features not present in the host language, e.g., nondeterminate execution for parsing or a reduction mechanism for theorem proving.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_19072_4_6,
  title = {Translating between programming languages},
  booktitle = {Lecture Notes in Computer Science},
  year = {1988},
  pages = {118-143},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-19072-4\_6},
  url = {https://doi.org/10.1007/3-540-19072-4\_6},
  abstract = {In this chapter we have shown how AG inversion can be used in a source-to-source translation system. By using invertible grammars in this context, one is provided with a framework in which to reason about the complexities of bi-directional translators, as well as a tool to perform much of the work. By phrasing the problem as one of finding a canonical form in which to represent all source language programs and writing invertible AGs to and from this canonical form, many of the real difficulties of the translation problem become immediately apparent. This chapter has also related our experience in using the inversion approach to source-to-source translation in writing translators between C and Pascal. This experiment demonstrated that invertible AGs are a satisfactory tool for describing much of the translators, although the complete system needs to incorporate other modules as well. In conclusion, AG inversion promises to be a useful tool in facilitating source-to-source translations.},
  content_type = {Chapter},
}


@article{springer_10_1007_bf00130012,
  title = {Does AI have a methodology which is different from software engineering?},
  author = {Partridge, D. and Wilks, Y.},
  journal = {Artificial Intelligence Review},
  year = {1987},
  volume = {1},
  number = {2},
  pages = {111-120},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf00130012},
  url = {https://doi.org/10.1007/bf00130012},
  abstract = {This paper argues that the conventional methodology of software engineering is inappropriate to AI, but that the failure of many in AI to see this is producing a Kuhnian paradigm ‘crisis’. The key point is that classic software engineering methodology (which we call SPIV : Specify-Prove-Implement-Verify) requires that the problem be capable of being circumscribed or surveyed in a way that it is not, for areas of AI, like natural language processing. In addition, it also requires that a program be open to formal proof of correctness. We contrast this methodology with a weaker form complete Specification And Testability ( SAT — where the last term is used in a strong sense: every execution of the program gives decidably correct/incorrect results) which captures both the essence of SPIV and the key assumptions in practical software engineering. We argue that failure to recognize the inability to apply the SAT methodology to areas of AI has prevented development of a disciplined methodology (which is unique to AI and which we call RUDE : Run-Understand-Debug-Edit) that will accommodate the peculiarities of AI and also yield robust, reliable, comprehensible, and hence maintainable AI software.},
  content_type = {Article},
}


@incollection{springer_10_1007_3_540_17189_4_120,
  title = {Organizing programming knowledge into syntax-directed experts},
  author = {Wile, David S.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1986},
  pages = {551-565},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-17189-4\_120},
  url = {https://doi.org/10.1007/3-540-17189-4\_120},
  abstract = {Programming environments of the future are certain to be "knowledge-based." Succinct statements of expertise, currently applied implicitly by programmers, will be available for explicit application by future programmers as well as opportunistic application by the environment itself. Considerable tension will exist between the desire to represent knowledge in a flat, decomposed form, and the desire for the efficiency available in compiled representations of this knowledge, as used in automatic processors, such as compilers, simplifiers, and code analyzers. I advocate specifying programming knowledge uniformly but organizing the knowledge into experts which solve "syntax-directed" problems, problems whose solution decomposition resembles the structure of the input data itself. This organization allows the efficiency of current ad hoc representations to be obtained and the resulting experts can coexist-in fact, cooperate-with more sophisticated problem solvers, including people.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_47891_4_1,
  title = {Deltatalk: An Empirically and Aesthetically Motivated Simplification of the Smalltalk-80 Language},
  author = {Borning, Alan and O’Shea, Tim},
  booktitle = {Lecture Notes in Computer Science},
  year = {1987},
  pages = {1-10},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-47891-4\_1},
  url = {https://doi.org/10.1007/3-540-47891-4\_1},
  abstract = {The Smalltalk-80 system offers a language with a small and elegant conceptual core, and a highly interactive programming environment. We believe, however, that it could be made more learnable and usable by a relatively small set of changes. In this paper, we present the results of a series of empirical studies on learnability, and also some informal studies of large implementation projects. Based on these studies, we suggest a number of changes to the Smalltalk-80 language and system.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_642_83095_2_6,
  title = {User Interfaces},
  author = {Ellis, Clarence A. and Naffah, Najah},
  booktitle = {Surveys in Computer Science},
  year = {1987},
  pages = {134-149},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-83095-2\_6},
  url = {https://doi.org/10.1007/978-3-642-83095-2\_6},
  abstract = {In previous chapters, we have explored the technology underlying office systems, and some primitives and tools available. On top of these layers, the application design and implementation layer can also usefully be divided into a sub-layer that implements the user interface, and a sub-layer that implements the application functionality. This chapter is concerned with user interface design. User interface design issues are concerned with techniques for easy, effective communication between a person (office system user) and a computer (office system,) which may in turn be the vehicle for convenient communication among individuals (e.g. electronic mail.) The user interface is an extremely important topic within the office information systems area because the majority of users here are nontechnical people who have no training nor desire for training in computer science. This is in contrast to most areas of computer science such as programming languages or data processing where the primary users of the system or the writer of the programs are trained computer people whose primary job function is technical computer work.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_bfb0039608,
  title = {Some structural aspects of hypergraph languages generated by hyperedge replacement},
  author = {Habel, Annegret and Kreowski, Hans-Jörg},
  booktitle = {Lecture Notes in Computer Science},
  year = {None},
  pages = {207-219},
  publisher = {Springer-Verlag},
  doi = {10.1007/bfb0039608},
  url = {https://doi.org/10.1007/bfb0039608},
  abstract = {Hyperedge replacement systems are introduced as a device for generating hypergraph languages including graph languages and string languages (where the strings are uniquely represented as certain graphs). Our concept combines a context-free type of rewriting with a comparatively large generative power. The former is indicated, for example, by a pumping lemma, the latter by the examples (among them you find the refinement of Petri nets, the analysis of flow diagrams, the structural description of molecules and some typical non-context-free string languages).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_16492_8_116,
  title = {Fast decompilation of compiled Prolog clauses},
  author = {Buettner, Kevin A.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1986},
  pages = {663-670},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-16492-8\_116},
  url = {https://doi.org/10.1007/3-540-16492-8\_116},
  abstract = {Serious Prolog implementations in recent years have been primarily compiler-based, nearly all of which are founded on the abstract instruction set of Warren [1983]. The performance achieved by such implementations greatly outstrips that attainable in interpreter-based systems. Unfortunately, the sophistication of these compiler-based environments is often inferior to environments of interpreter-based systems to the extent that a “compatible” interpreter is often required for serious software development. Among the deficiencies of these environments, database operations such as assert, retract, and clause seem to be particularly afflicted. In addition, the ability to debug compiled code has been either non-existent or at best, very constrained. Unlike compiler technology of many traditional languages, there is little reason for this to be the case in Prolog. An efficient implementation of retract, listing, and clause by decompilation of compiled clause code is the subject of this paper. Techniques used in the implementation of the decompilation process have also proven useful in the implementation of the standard four port debugger found in many Prolog systems.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf01988526,
  title = {Engineering artificial intelligence software},
  author = {Partridge, D.},
  journal = {Artificial Intelligence Review},
  year = {1986},
  volume = {1},
  number = {1},
  pages = {27-41},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf01988526},
  url = {https://doi.org/10.1007/bf01988526},
  abstract = {Artificial Intelligence (AI) software is a reality, but only for limited classes of problems. In general, AI problems are significantly different from those of conventional software engineering. The differences suggest a different program development methodology for AI problems: one that does not readily yield programs with the desiderata of practical software (reliability, robustness, etc.). In addition, the problem of machine learning must be solved (to some degree) before the full potential of AI can be realized, but the resultant self-adaptive software is likely to further aggravate the software crisis. Realization of the full potential of AI in practical software awaits some prerequisite breakthroughs in both basic AI problems and an appropriate AI software development methodology.},
  content_type = {Article},
}


@incollection{springer_10_1007_3_540_16492_8_114,
  title = {The design and implementation of a high-speed incremental portable Prolog compiler},
  author = {Bowen, Kenneth A. and Buettner, Kevin A. and Cicekli, Ilyas and Turk, Andrew K.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1986},
  pages = {650-656},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-16492-8\_114},
  url = {https://doi.org/10.1007/3-540-16492-8\_114},
  abstract = {The design and implementation of a relatively portable Prolog compiler achieving 12K LIPS on the standard benchmark is described. The compiler is incremental and uses decompilation to implement retract, clause, and listing, as well as support the needs of its four-port debugger. The system supports modules, garbage collection, database pointers, and a full range of built-ins.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf00936468,
  title = {The intermediary language for multilanguage translation},
  author = {Zarechnak, Michael},
  journal = {Computers and Translation},
  year = {1986},
  volume = {1},
  number = {2},
  pages = {83-91},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf00936468},
  url = {https://doi.org/10.1007/bf00936468},
  abstract = {This paper discusses some basic notions involved in designing, developing, and implementing the Intermediary Language (IL) for Machine Translation applied to a set of languages. The stages for the design of the IL would include the independent analysis and synthesis of each language in its own terms. Then each could be mapped once into the IL dictionary and grammar, creating the IL text. From the IL text the transfer routine would synthesize the target text for a particular language. It is assumed that the IL text would have algebraic representation of the variables to be instantiated in the target language on the basis of the IL text information. The IL should contain all the information occurring in the set of languages plus such generalizations as might be justified on the basis of inductive implications and/or deductively oriented postulates to be verified by adding new languages for testing the capacity of the IL. Given five languages spoken by more than a hundred million people, if N equals 5 for the pairwise translation (say, into English), N 2 −N, we get 20 programs, and for the IL translation 2N+1, we can manage with eleven programs, yielding a significant gain. The IL metalanguage, ideally, should have the capacity to function as an algebraic representation of both paradigmatic units (the selection axis) and their relationships (the contiguity axis). Both should be correlated with the extralinguistic fragments in terms of determiners, quantifiers, and classifiers. The structure of the IL grammar contains four components: dictionary, context-free information providing the nonterminal dictionary (i.e., classification), parser/synthesizer, and the initial string.},
  content_type = {Article},
}


@incollection{springer_10_1007_3_540_17162_2_130,
  title = {Galois connections and computer science applications},
  author = {Melton, A. and Schmidt, D. A. and Strecker, G. E.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1986},
  pages = {299-312},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-17162-2\_130},
  url = {https://doi.org/10.1007/3-540-17162-2\_130},
  abstract = {We have presented an existence theorem and some important properties of Galois connections. We have also shown how data structures problems can be simplified and better understood when Galois insertions are used. In particular, the proof of correctness of an implementation follows simply from the construction of a Galois insertion. We plan further applications of Galois connections theory to computing-related problems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_3_540_15198_2_18,
  title = {Decompilation of control structures by means of graph transformations},
  author = {Lichtblau, Ulrike},
  booktitle = {Lecture Notes in Computer Science},
  year = {1985},
  pages = {284-297},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-15198-2\_18},
  url = {https://doi.org/10.1007/3-540-15198-2\_18},
  abstract = {Decompilation denotes the translation from lower level into higher level programming languages. Here we deal with the aspect of detecting higher level control structures, including loops with any number of exits, in line-oriented programs. The detection is carried out on the control flow graph of the source program by means of so called wellstructuring transformations. We show that the iteration of these transformations always terminates in a time linearly depending on the number of vertices of the underlying control flow graph.},
  content_type = {Conference paper},
}


@article{springer_10_1007_bf03037102,
  title = {Developing expert systems builders in logic programming},
  author = {Oliveira, Eugenio},
  journal = {New Generation Computing},
  year = {1984},
  volume = {2},
  number = {2},
  pages = {187-194},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf03037102},
  url = {https://doi.org/10.1007/bf03037102},
  abstract = {We intend to develop a set of kits to build Expert Systems using Prolog. Two principal modules, a Knowledge Base acquisition and consultation subsystems are now presented. Several knowledge representation structures and mixed inference mechanisms are proposed for the sake of system efficiency. Finally some explanation capabilities derived accordingly with used inference methods are also implemented and presented.},
  content_type = {Article},
}


@article{springer_10_1007_bf03037050,
  title = {A prological definition of HASL a purely functional language with unification based conditional binding expressions},
  author = {Abramson, Harvey},
  journal = {New Generation Computing},
  year = {1984},
  volume = {2},
  number = {1},
  pages = {3-35},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/bf03037050},
  url = {https://doi.org/10.1007/bf03037050},
  abstract = {We present a definition in Prolog of a new purely funtional (applicative) language HASL ( HA rvey’s Static L anguage). HASL is a descendant of Turner’s SASL and differs from the latter in several significant points: it includes Abramson’s unification based conditional binding constructs; it restricts each clause in a definition of a HASL function to have the same arity, thereby complicating somewhat the compilation of clauses to combinators, but simplifying considerably the HASL reduction machine; and it includes the single element domain \{fail\} as a component of the domain of HASL data structures. It is intended to use HASL to express the functional dependencies in a translator writing system based on denotational semantics, and to study the feasibility of using HASL as a functional sublanguage of Prolog or some other logic programming language. Regarding this latter application we suggest that since a reduction mechanism exists for HASL, it may be easier to combine it with a logic programming language than it was for Robinson and Siebert to combine LISP and LOGIC into LOGLISP: in that case a fairly complex mechanism had to be invented to reduce uninterpreted LOGIC terms to LISP values. The definition is divided into four parts. The first part defines the lexical structure of the language by means of a simple Definite Clause Grammar which relates character strings to “token” strings. The second part defines the syntactic structure of the language by means of a more complex Definite Clause Grammar and relates token strings to a parse tree. The third part is semantic in nature and translates the parse tree definitions and expressions to a variable-free string of combinators and global names. The fourth part of the definition consists of a set of Prolog predicates which specifies how strings of combinators and global names are reduced to “values”, ie., integers, truth values, characters, lists, functions, fail, and has an operational flavour: one can think of this fourth part as the definition of a normal order reduction machine.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_642_61807_9_9,
  title = {Conclusion. Programming as an Evolutionary Process},
  author = {Bauer, Friedrich L. and Wössner, Hans and Partsch, H. and Pepper, P.},
  booktitle = {Algorithmic Language and Program Development},
  year = {1982},
  pages = {451-458},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-61807-9\_9},
  url = {https://doi.org/10.1007/978-3-642-61807-9\_9},
  abstract = {In order to solve a complicated problem, two extreme approaches may be adopted: a sufficiently complicated machine is used with the prospect of finding a “simple” solution, or a simple machine is used and we have to expect a “complicated” solution.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_642_67091_6_1,
  title = {Design of a programming language for a program transformation system},
  author = {Bauer, F. L.},
  booktitle = {Informatik-Fachberichte},
  year = {1978},
  pages = {1-28},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/978-3-642-67091-6\_1},
  url = {https://doi.org/10.1007/978-3-642-67091-6\_1},
  abstract = {The late sixties and early seventies — twenty-five years after the classical work of Zuse and von Neumann — have seen the first crisis in the proud development of computing: large software systems showed alarming deficiencies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_3_540_07131_8_25,
  title = {APLGOL a structured programming language for APL},
  author = {Kolsky, Harwood G.},
  booktitle = {Lecture Notes in Computer Science},
  year = {1975},
  pages = {161-191},
  publisher = {Springer Berlin Heidelberg},
  doi = {10.1007/3-540-07131-8\_25},
  url = {https://doi.org/10.1007/3-540-07131-8\_25},
  abstract = {APLGOL is a language providing interstatement control structure for APL. It permits programs to be written using the power and conciseness of standard APL expressions in conjunction with structured programming concepts to emphasize more of the overall program control flow, rather than the details of individual statements. The APLGOL System described consists of three parts: an Editor, an APLGOL-to-APL compiler and an APL-to-APLGOL reverse compiler. All three parts are themselves written in APL.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00521_024_10735_9,
  title = {Single-pass end-to-end neural decompilation using copying mechanism},
  author = {Szalay, Gergő and Poór, Máté Bálint and Pintér, Balázs and Gregorics, Tibor},
  journal = {Neural Computing and Applications},
  year = {2025},
  volume = {37},
  number = {7},
  pages = {5309-5323},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-024-10735-9},
  url = {https://doi.org/10.1007/s00521-024-10735-9},
  abstract = {Traditional decompilers utilize countless hardcoded rules written by subject matter experts, making them inflexible. Some recent systems address this using deep learning. The current consensus is that these systems have to include considerable domain knowledge and iterative heuristic components to solve parts of the decompilation problem, particularly the problem of predicting identifiers and literals. In this paper, we present a single-pass end-to-end neural decompilation system that utilizes copying mechanism . The copying mechanism is able to copy the literals and (offsets of) variables directly from the assembly code, in a single step , as part of the single forward pass through the model. Additionally, we take a further step toward decompiling real-world code by addressing important programming constructs like switch statements, function definitions, and function calls. We compile a dataset of real-world programming competition code and evaluate our model on it. The method achieves a program accuracy of 73\% on the hardest complexity level of our generated dataset and 51\% on the real-world examples without any additional error correction (EC) techniques, which surpasses the results of previous works without EC.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_96_4731_6_16,
  title = {Attention-Based Decompilation Through Neural Machine Translation},
  author = {Liang, Ruigang and Cao, Ying and Hu, Peiwei and Chen, Kai},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {319-339},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-4731-6\_16},
  url = {https://doi.org/10.1007/978-981-96-4731-6\_16},
  abstract = {Decompilation transforms low-level program languages (PL) (e.g., binary code) into high-level PLs (e.g., C/C++ ). It has been widely used when analysts perform security analysis on software (systems) whose source code is unavailable, such as vulnerability search and malware analysis. However, current decompilation tools usually need lots of experts’ efforts, even for years, to generate the rules for decompilation, which also requires long-term maintenance as the syntax of high-level PL or low-level PL changes. Also, an ideal decompiler should concisely generate high-level PL with similar functionality to the source low-level PL. In this paper, we propose a novel neural decompilation approach to translate low-level PL into accurate high-level PL. We design a transformer-based neural network model, including a data dependency-based masked self-attention scheme and an instruction embedding scheme that accurately learns the mapping rules between low-level PLs and high-level PLs. We also propose a new intermediate language representation to bridge the information asymmetry between high-level and low-level PL. Furthermore, we implement the proposed approach called ANDE . Evaluations of four real-world applications show that ANDE has an average accuracy of 94.41\%, much better than prior neural machine translation (NMT) models.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_9849_3_19,
  title = {ARMQwen2: Enhancing C Language Decompilation on ARM Platform Using Large Language Model},
  author = {Liu, Jiahan and Lin, Jian and Liu, Haoran and Wang, Yonghao and Jing, Jing},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {221-234},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-9849-3\_19},
  url = {https://doi.org/10.1007/978-981-96-9849-3\_19},
  abstract = {Decompilation technology has long been a pivotal tool in the field of computer software reverse engineering. Traditional decompilation methods frequently result in code that is structurally incomplete, semantically incoherent, and of low readability. With the advent of Large Language Models (LLMs) and their application to decompilation tasks, the field of decompilation research has witnessed notable advancements. Nevertheless, the performance of these models in decompiling C language programs on ARM platforms remains less than optimal. In this paper, we propose an inlined data processing algorithm to address the prevalent phenomenon of inlined data in ARM architecture, thereby enhancing the quality of the training dataset. Leveraging this, we have developed ARMQwen2, the first LLM that significantly improves the decompilation output quality of C programs on the ARM platform through fine-tuning techniques. We evaluate it under two test benchmarks and two different optimization levels, and the experimental results demonstrate that ARMQwen2 attains a re-executablility rate of up to 55\%, which is more than twice as high as Ghidra, the current state-of-the-art decompiler, and 20\% higher than the advanced large language model GPT-4o-mini. In terms of re-compilability and edit similarity, ARMQwen2 achieves an average of 90\% and 60\% respectively.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_022_10281_9,
  title = {Android decompiler performance on benign and malicious apps: an empirical study},
  author = {Kargén, Ulf and Mauthe, Noah and Shahmehri, Nahid},
  journal = {Empirical Software Engineering},
  year = {2023},
  volume = {28},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-022-10281-9},
  url = {https://doi.org/10.1007/s10664-022-10281-9},
  abstract = {Abstract Decompilers are indispensable tools in Android malware analysis and app security auditing. Numerous academic works also employ an Android decompiler as the first step in a program analysis pipeline. In such settings, decompilation is frequently regarded as a “solved” problem, in that it is simply expected that source code can be accurately recovered from an app. On the other hand, it is known that, e.g, obfuscation can negatively impact a decompiler’s effectiveness. Therefore, in order to better understand potential failure modes of, e.g., automated analysis pipelines involving decompilation, it is important to characterize the performance of decompilers on both benign and malicious apps. To this end, we have performed what is, to the best of our knowledge, the first large-scale study of Android decompilation failure rates, using three sets of apps; namely, 3,018 open-source apps, 13,601 apps crawled from Google Play, and an existing collection of 24,553 malware samples. In addition to the state-of-the-art Dalvik bytecode decompiler Jadx, we also studied the performance of three popular Java decompilers. Furthermore, this paper also presents the findings from a follow-up study on 54,945 malware apps, where we additionally performed an analysis of the reasons for decompilation failures. Our study revealed that decompilers generally have very low failure rates, and that few failures on benign apps appear to be related to obfuscation. On malware, however, obfuscation appears to be a more prominent cause of failures, although the vast majority of malicious apps could still be fully decompiled by an ensemble of decompilers.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_94448_2_6,
  title = {Is This the Same Code? A Comprehensive Study of Decompilation Techniques for WebAssembly Binaries},
  author = {Wu, Wei-Cheng and Yan, Yutian and Egilsson, Hallgrimur David and Park, David and Chan, Steven and Hauser, Christophe and Wang, Weihang},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2026},
  pages = {108-130},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-94448-2\_6},
  url = {https://doi.org/10.1007/978-3-031-94448-2\_6},
  abstract = {WebAssembly (abbreviated WASM) is a low-level bytecode language designed for client-side execution in web browsers. As WASM continues to gain widespread adoption and its security concerns, the need for decompilation techniques that recover high-level source code from WASM binaries has grown. However, little research has been done to assess the quality of decompiled code from WASM. This paper aims to fill this gap by conducting a comprehensive comparative analysis between decompiled C code from WASM binaries and state-of-the-art native binary decompilers. To achieve this goal, we presented a novel framework for empirically evaluating C-based decompilers from various aspects, thus assessing the proficiency of WASM decompilers in generating readable and correct code when compared to native binary decompilers. Specifically, we evaluated the decompiled code’s correctness , readability , and structural similarity with the original code from current WASM decompilers. We validated the proposed metrics’ practicality in decompiler assessment and provided insightful observations regarding the characteristics and constraints of existing decompiled code. By encouraging improvements in these tools, we seek to enhance their use in critical tasks such as auditing and sandboxing third-party libraries. This, in turn, contributes to bolstering the security and reliability of software systems that rely on WASM and native binaries.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_71602_7_3,
  title = {Neural Decompiling of Tracr Transformers},
  author = {Thurnherr, Hannes and Riesen, Kaspar},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {25-36},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-71602-7\_3},
  url = {https://doi.org/10.1007/978-3-031-71602-7\_3},
  abstract = {Recently, the transformer architecture has enabled substantial progress in many areas of pattern recognition and machine learning. However, as with other neural network models, there is currently no general method available to explain their inner workings. The present paper represents a first step towards this direction. We utilize Transformer Compiler for RASP (Tracr) to generate a large dataset of pairs of transformer weights and corresponding RASP programs. Based on this dataset, we then build and train a model, with the aim of recovering the RASP code from the compiled model. We demonstrate that the simple form of Tracr compiled transformer weights is interpretable for such a decompiler model. In an empirical evaluation, our model achieves exact reproductions on more than 30\% of the test objects, while the remaining 70\% can generally be reproduced with only few errors. Additionally, more than 70\% of the programs, produced by our model, are functionally equivalent to the ground truth, and therefore a valid decompilation of the Tracr compiled transformer weights.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_49266_2_18,
  title = {Automatic Fixation of Decompilation Quirks Using Pre-trained Language Model},
  author = {Kaichi, Ryunosuke and Matsumoto, Shinsuke and Kusumoto, Shinji},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {259-266},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-49266-2\_18},
  url = {https://doi.org/10.1007/978-3-031-49266-2\_18},
  abstract = {Decompiler is a system for recovering the original code from bytecode. A critical challenge in decompilers is that the decompiled code contains differences from the original code. These differences not only reduce the readability of the source code but may also change the program’s behavior. In this study, we propose a deep learning-based quirk fixation method that adopts grammatical error correction. One advantage of the proposed method is that it can be applied to any decompiler and programming language. Our experimental results show that the proposed method removes 55\% of identifier quirks and 91\% of structural quirks. In some cases, however, the proposed method injected a small amount of new quirks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_8703_0_13,
  title = {A Perfect Knife—Bulk Decompilation and Preprocessing Tool},
  author = {Dorotik, Ladislav and Kincl, Jan and Oulehla, Milan and Šenkeřík, Roman and Komínková Oplatková, Zuzana},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2024},
  pages = {153-164},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-8703-0\_13},
  url = {https://doi.org/10.1007/978-981-99-8703-0\_13},
  abstract = {Due to its vast popularity, the Android operating system has quickly become the main target of mobile malware creators. Consequently, there is a huge need for intensive efforts in the research of Android malware applications to identify malware features and thus be able to create an efficient method for malware detection. One of the main issues related to malware research is obtaining reliable datasets. Malware datasets could be obtained from various sources. Not only that they can tally up to thousands of individual applications, but also can contain damaged, corrupted, or otherwise invalid files. A large number of applications in a dataset is nearly impossible to be processed manually, invalid files can also jeopardize the process of analysis. For the results to be reproducible there needs to be a way how to specify which dataset was used and that it contained only valid files. This work introduces a tool, Perfect Knife, created by our research team for automatised decompilation, dataset validation, unification, and preparation for further research purposes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97620_9_14,
  title = {Quantifying and Mitigating the Impact of Obfuscations on Machine-Learning-Based Decompilation Improvement},
  author = {Dramko, Luke and Bölöni-Turgut, Deniz and Le Goues, Claire and Schwartz, Edward},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {244-266},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97620-9\_14},
  url = {https://doi.org/10.1007/978-3-031-97620-9\_14},
  abstract = {Decompilers are tools that reverse the process of compilation, converting executable binaries into a high-level language like C. They are useful in situations where the original source code is unavailable, such as when analyzing malware, doing vulnerability research, and patching legacy software. Unfortunately, decompilation is necessarily incomplete, because the compiler discards many of the abstractions that make source code readable, like identifier names and types. A large body of existing work uses machine learning to predict missing names, types, and other abstractions in decompiled code. However, little of this work considers obfuscations : semantics-preserving transformations that obscure the functionality and design of a program. At the same time, obfuscations are common in practice, especially in malware. In this work, we perform a quantitative analysis of the impact that obfuscations have on decompiled code. Further, we investigate the degree to which training on obfuscated code mitigates the impact of obfuscations. We perform our experiments on three different models from the literature: DIRTY, HexT5, and VarBERT. We find that obfuscations do negatively impact machine learning models, but training on obfuscations can partially help recover lost accuracy.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_94_024_2308_2_7,
  title = {Reverse Engineering and Cyber Security},
  author = {Maravić Čisar, Sanja and Pinter, Robert and Čisar, Petar and Szedmina, Livia},
  booktitle = {NATO Science for Peace and Security Series C: Environmental Security},
  year = {2025},
  pages = {99-115},
  publisher = {Springer Netherlands},
  doi = {10.1007/978-94-024-2308-2\_7},
  url = {https://doi.org/10.1007/978-94-024-2308-2\_7},
  abstract = {Reverse engineering is a critical tool in modern cybersecurity, enabling the detection of vulnerabilities, the analysis of malicious code, and the enhancement of defense mechanisms. This paper examines key techniques such as code decompilation, binary analysis, and dynamic behavior monitoring, highlighting their applications in securing IoT devices, traditional software, and mobile applications. A practical example involving the analysis of an Android application demonstrates the steps and tools used in reverse engineering, offering insights into real-world challenges and solutions. Additionally, the paper explores the legal and ethical considerations of reverse engineering, emphasizing the importance of responsible practices. By addressing both technical and ethical aspects, this research underscores the importance of reverse engineering in creating resilient cybersecurity solutions for complex digital systems.},
  content_type = {Conference paper},
}


@article{springer_10_3103_s0146411623080060,
  title = {Analysis of Decompiled Program Code Using Abstract Syntax Trees},
  author = {Gribkov, N. A. and Ovasapyan, T. D. and Moskvin, D. A.},
  journal = {Automatic Control and Computer Sciences},
  year = {2023},
  volume = {57},
  number = {8},
  pages = {958-967},
  publisher = {Allerton Press},
  doi = {10.3103/s0146411623080060},
  url = {https://doi.org/10.3103/s0146411623080060},
  abstract = {This article proposes a method for preprocessing fragments of binary program codes for subsequent detection of their similarity using machine learning methods. The method is based on the analysis of pseudocode obtained as a result of decompiling fragments of binary codes. The analysis is performed using attributed abstract syntax trees (AASTs). As part of the study, testing and comparative analysis of the effectiveness of the developed method are carried out. This method makes it possible to increase the efficiency of detecting functionally similar fragments of program code, compared to analogs, by using the semantic context of vertices in abstract syntax trees.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_45933_7_15,
  title = {Decompilation Based Deep Binary-Source Function Matching},
  author = {Wang, Xiaowei and Yuan, Zimu and Xiao, Yang and Wang, Liyan and Yao, Yican and Chen, Haiming and Huo, Wei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {244-260},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-45933-7\_15},
  url = {https://doi.org/10.1007/978-3-031-45933-7\_15},
  abstract = {Binary and source matching is vital for vulnerability detection or program comprehension. Most existing works focus on library matching (coarse-grained) by utilizing some simple features. However, they are so coarse-grained that high false positives occur since developers tend to reuse source code library partly. These shortcomings drive us to perform fine-grained matching (i.e., binary and source function matching). At the same time, due to the enormous differences between the form of binary and source functions, function matching (fine-grained) meets huge challenges. In this work, inspired by the decompilation technique and advanced neural networks, we propose tool, a D ecompilation based deep B inary- S ource function M atching framework. Specifically, we take the triplet features from both binary pseudo-code and source code functions as input, which are extracted from code property graph and can represent both the syntactic and semantic information. In this way, the binary and source functions are represented in the same feature space so to ease the matching model to learn function similarity. For the matching model, we adopt a self-attention based siamese network with contrastive loss. Experiments on two datasets, R 0 and R 3, show that our tool achieves consistent improvements than other methods, which demonstrate the effectiveness of our self-attention based matching model, and our triplets features can well capture the two kinds of code functions. Our work improves the accuracy of binary and source code matching, which in turn enables us to better address security issues such as vulnerability detection and program comprehension.},
  content_type = {Conference paper},
}


@article{springer_10_1134_s0361768825700288,
  title = {About Methods for Extracting Algorithms from Binary Code},
  author = {Kulagin, I. I. and Padaryan, V. A. and Koshkin, V. A.},
  journal = {Programming and Computer Software},
  year = {2025},
  volume = {51},
  number = {6},
  pages = {415-428},
  publisher = {Pleiades Publishing Ltd},
  doi = {10.1134/s0361768825700288},
  url = {https://doi.org/10.1134/s0361768825700288},
  abstract = {This paper proposes an iterative method for extracting algorithms from binary code and constructing their high-level representation. The construction of algorithms by using the proposed method is implemented as an analysis of dynamic slices. The method is based on an algorithm for data flow tracking in forward and backward directions. Two levels of representation of the extracted algorithms are proposed: a slice functional diagram and an algorithm execution diagram. The slice functional diagram is a structured slice representation; as compared to the algorithm execution diagram, it is a lower-level representation. The algorithm execution diagram is a representation that consists only of function summaries and function parameters. The proposed method for constructing algorithms and methods for their representation make it possible to increase the analyst’s productivity in solving problems of code security analysis, as well as improve the quality of the results. The developed algorithm representation methods can be used to implement algorithms for automated code security analysis. In addition, the paper overviews some other approaches to extraction of algorithms from binary code and considers their representations in static analysis tools, including some of their flaws and limitations.},
  content_type = {Article},
}


@article{springer_10_1186_s42400_021_00070_0,
  title = {Neutron: an attention-based neural decompiler},
  author = {Liang, Ruigang and Cao, Ying and Hu, Peiwei and Chen, Kai},
  journal = {Cybersecurity},
  year = {2021},
  volume = {4},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-021-00070-0},
  url = {https://doi.org/10.1186/s42400-021-00070-0},
  abstract = {Abstract Decompilation aims to analyze and transform low-level program language (PL) codes such as binary code or assembly code to obtain an equivalent high-level PL. Decompilation plays a vital role in the cyberspace security fields such as software vulnerability discovery and analysis, malicious code detection and analysis, and software engineering fields such as source code analysis, optimization, and cross-language cross-operating system migration. Unfortunately, the existing decompilers mainly rely on experts to write rules, which leads to bottlenecks such as low scalability, development difficulties, and long cycles. The generated high-level PL codes often violate the code writing specifications. Further, their readability is still relatively low. The problems mentioned above hinder the efficiency of advanced applications (e.g., vulnerability discovery) based on decompiled high-level PL codes.In this paper, we propose a decompilation approach based on the attention-based neural machine translation (NMT) mechanism, which converts low-level PL into high-level PL while acquiring legibility and keeping functionally similar. To compensate for the information asymmetry between the low-level and high-level PL, a translation method based on basic operations of low-level PL is designed. This method improves the generalization of the NMT model and captures the translation rules between PLs more accurately and efficiently. Besides, we implement a neural decompilation framework called Neutron. The evaluation of two practical applications shows that Neutron’s average program accuracy is 96.96\%, which is better than the traditional NMT model.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_77941_1_4,
  title = {JaxDecompiler: Redefining Gradient-Informed Software Design},
  author = {Pochelu, Pierrick},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {41-50},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-77941-1\_4},
  url = {https://doi.org/10.1007/978-3-031-77941-1\_4},
  abstract = {Among numerical libraries capable of computing gradient descent optimization, JAX stands out by offering more features, accelerated by an intermediate representation known as Jaxpr language. However, editing the Jaxpr code is not directly possible. This article introduces JaxDecompiler, a tool that transforms any JAX function into an editable Python code, especially useful for editing the JAX function generated by the gradient function. JaxDecompiler simplifies the processes of reverse engineering, understanding, customizing, and interoperability of software developed by JAX. We highlight its capabilities, emphasize its practical applications especially in deep learning and more generally gradient-informed software, and demonstrate that the decompiled code speed performance is similar to the original.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_3543_9_9,
  title = {No Place to Hide: An Efficient and Accurate Backdoor Detection Tool for Ethereum ERC-20 Smart Contracts},
  author = {Zhou, Shouchen and Zhou, Lu and Tao, Yu},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {159-177},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-3543-9\_9},
  url = {https://doi.org/10.1007/978-981-95-3543-9\_9},
  abstract = {Ethereum ERC-20 smart contracts are now widely utilized in various domains for trust and transparent transaction process. However, ERC-20 contracts face significant security risks, particularly backdoors that can lead to severe incidents. In backdoor attacks, malicious actors can exploit these vulnerabilities to perform unauthorized transactions, steal funds, or manipulate token balances, resulting in substantial financial losses and damaging trust of blockchain system. This paper introduces MDetector, a tool for efficiently detecting backdoors in ERC-20 contracts through static analysis. Firstly, MDetector defines 9 basic and 3 complex types of backdoors, covering existing potential risks. Based on these definitions, MDetector runs corresponding detection logic via datalog analysis. Secondly, MDetector is compatible with Solidity versions 0.4 to 0.8.24 and can be deployed on Linux, Windows and Android. Thirdly, MDetector initiates a high-performance decompilation engine to disassemble and convert contract bytecode into intermediate code. The experimental results demonstrate its high precision and reliability, achieving an accuracy of 94.0\% in an average of just 1.3 s. This represents a significant improvement over the most advanced scientific tools currently available, achieving approximately 1.55 \\(\\times \\) greater accuracy and 6.17 \\(\\times \\) faster processing speed.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_024_10609_7,
  title = {UPC sentinel: An accurate approach for detecting upgradeability proxy contracts in Ethereum},
  author = {Ebrahimi, Amir M. and Adams, Bram and Oliva, Gustavo A. and Hassan, Ahmed E.},
  journal = {Empirical Software Engineering},
  year = {2025},
  volume = {30},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-024-10609-7},
  url = {https://doi.org/10.1007/s10664-024-10609-7},
  abstract = {Software applications that run on a blockchain platform are known as DApps. DApps are built using smart contracts, which are immutable after deployment. Just like any real-world software system, DApps need to receive new features and bug fixes over time in order to remain useful and secure. However, Ethereum lacks native solutions for post-deployment smart contract maintenance, requiring developers to devise their own methods. A popular method is known as the upgradeability proxy contract (UPC), which involves implementing the proxy design pattern (as defined by the Gang of Four). In this method, client calls first hit a proxy contract, which then delegates calls to a certain implementation contract. Most importantly, the proxy contract can be reconfigured during runtime to delegate calls to another implementation contract, effectively enabling application upgrades. For researchers, the accurate detection of UPCs is a strong requirement in the understanding of how exactly real-world DApps are maintained over time. For practitioners, the accurate detection of UPCs is crucial for providing application behavior transparency and enabling auditing. In this paper, we introduce UPC Sentinel, a novel three-layer algorithm that utilizes both static and dynamic analysis of smart contract bytecode to accurately detect active UPCs. We evaluated UPC Sentinel using two distinct ground truth datasets. In the first dataset, our method demonstrated a near-perfect accuracy of 99\%. The evaluation on the second dataset further established our method’s efficacy, showing a perfect precision rate of 100\% and a near-perfect recall of 99.3\%, outperforming the state of the art. Finally, we discuss the potential value of UPC Sentinel in advancing future research efforts.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_25803_9_7,
  title = {A Formal Semantics for P-Code},
  author = {Naus, Nico and Verbeek, Freek and Walker, Dale and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {111-128},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-25803-9\_7},
  url = {https://doi.org/10.1007/978-3-031-25803-9\_7},
  abstract = {Abstract Decompilation is currently a widely used tool in reverse engineering and exploit detection in binaries. Ghidra, developed by the National Security Agency, is one of the most popular decompilers. It decompiles binaries to high P-Code, from which the final decompilation output in C code is generated. Ghidra allows users to work with P-Code, so users can analyze the intermediate representation directly. Several projects make use of this to build tools that perform verification, decompilation, taint analysis and emulation, to name a few. P-Code lacks a formal semantics, and its documentation is limited. It has a notoriously subtle semantics, which makes it hard to do any sort of analysis on P-Code. We show that P-Code, as-is, cannot be given an executable semantics. In this paper, we augment P-Code and define a complete, executable, formal semantics for it. This is done by looking at the documentation and the decompilation results of binaries with known source code. The development of a formal P-Code semantics uncovered several issues in Ghidra, P-Code, and the documentation. We show that these issues affect projects that rely on Ghidra and P-Code. We evaluate the executability of our semantics by building a P-Code interpreter that directly uses our semantics. Our work uncovered several issues in Ghidra and allows Ghidra users to better leverage P-Code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_4245_8_31,
  title = {Metaverse Security and Forensics: VR Devices as an Example},
  author = {Su, Fu and Liang, Guangjun and Ni, Xueli and Zhang, Qinrui and Chen, Pu and Liu, Jianning and Li, Xiang and Du, Hongtian},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2025},
  pages = {352-364},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-4245-8\_31},
  url = {https://doi.org/10.1007/978-981-96-4245-8\_31},
  abstract = {VR devices are a rapidly emerging type of sensory terminal device in the context of the metaverse, with its immersive use effects attracting a large number of users to experience. However, with the continuous development of virtual reality technology, an increasing number of criminal incidents in the virtual world have raised concerns. VR devices are developed based on the Android system but have their unique security mechanisms. Therefore, how to securely extract and preserve data from VR devices is a crucial concern for digital forensic practitioners. This paper first proposes a method for application data extraction and analysis in a non root environment within the VR ecosystem based on the Linux shared user id mechanism. This method utilizes Edge Developer Tools to debug Vuplex 3D Webview, enabling the extraction of internal storage data from embedded web pages within the application. Subsequently, a combination of decompilation and packet capture techniques is used to analyze the data transmission methods and data interaction logic of applications in the VR ecosystem. Finally, based on the experimental results, a comprehensive assessment of the security of VR devices is conducted in the paper. Data extraction from VR devices is an indispensable part of digital forensics in the era of the metaverse. The research on methods for extracting and analyzing application data in the VR ecosystem in this paper provides valuable reference for future forensic work on VR devices.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_10759_6_8,
  title = {Bitcoin+: Cheap Support for Complex Spending Conditions in a UTXO Ledger},
  author = {Kaner, Yaron and Moran, Tal},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {122-139},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-10759-6\_8},
  url = {https://doi.org/10.1007/978-3-032-10759-6\_8},
  abstract = {Cryptocurrencies can be used merely to transfer value between identities, but many of the more interesting uses of cryptocurrencies require contracts, e.g., “a transfer of X coins from party S to party R is permitted only if conditions A and B hold”. Bitcoin (and related cryptocurrencies) place strict limits on the language in which these conditions can be phrased. In particular, conditions have limited length and may not contain loops. In this work, we show how to augment the Bitcoin scripting language with a single “innocuous” operation to allow us to create “meta conditions” with much more expressive power (e.g., as defined by arbitrarily-sized circuits). We construct a protocol to compile such meta-conditions into a set of (augmented) Bitcoin transactions. We then show how to use this compiler to realize a full “meta-ledger” functionality, which we show is secure in the universal composability framework.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_9239_3_36,
  title = {Design and Implementation of an Automated APK Analysis System for Practical Forensics},
  author = {Li, Yicheng and Liang, Guangjun and Tang, Keyan and Teng, Yijia and Ruan, Haoran and Mo, Zixi},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2024},
  pages = {365-377},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-9239-3\_36},
  url = {https://doi.org/10.1007/978-981-99-9239-3\_36},
  abstract = {In order to cope with the widespread emergence of malicious APK in the application market and the increasingly rampant situation of mobile malware, as well as to meet the needs of the actual forensics work, this paper, based on the analysis of Android security mechanisms and their security problems, analyses and summarises the methodological principles, main technologies and functional flaws of existing APK automated analysis tools, and proposes an APK automated analysis system for actual forensics. Compared with traditional systems, the system is easy to operate and has a higher recognition accuracy rate. Besides, it will perform machine learning on the analysis results and calculate the similarity through the model to effectively assist the forensic work and fill the demand for APK analysis in the field of combat.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_21333_5_105,
  title = {Android Malware Detection Through a Pre-trained Model for Code Understanding},
  author = {García-Soto, Eva and Martín, Alejandro and Huertas-Tato, Javier and Camacho, David},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {1055-1060},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-21333-5\_105},
  url = {https://doi.org/10.1007/978-3-031-21333-5\_105},
  abstract = {Despite the large number of approaches proposed for detecting malicious applications targeting platforms such as Android, malware continuously evolves in order to avoid its detection and reach the users. Likewise, malware detection engines are continuously improved, trying to detect the most modern malware. Most of these detection tools employ signatures or machine learning models, trained on thousands of features, such as API calls, permissions or using taint analysis, among many others, and using machine learning classification algorithms such as decision trees, ensemble methods or deep learning. However, the use of these features leads to biased models due to the use of limited datasets, without considering the real semantics (goals and intentions) of the malicious sample. In this paper, we conduct an initial study of the use of context and semantic aware embeddings generated with the CodeT5 pre-trained language model for a better representation of the behaviour of Android applications. After decompiling a sample to Java, it is possible to generate embeddings from chunks of the source code, generating a rich representation of the sample. We show how these embeddings can be used to train a recurrent neural network for malware detection tasks, evidencing promising results.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_95764_2_18,
  title = {OCEAN: Open-World Contrastive Authorship Identification},
  author = {Mächtle, Felix and Serr, Jan-Niclas and Loose, Nils and Sander, Jonas and Eisenbarth, Thomas},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {459-486},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-95764-2\_18},
  url = {https://doi.org/10.1007/978-3-031-95764-2\_18},
  abstract = {In an era where cyberattacks increasingly target the software supply chain, the ability to accurately attribute code authorship in binary files is critical to improving cybersecurity measures. We propose OCEAN , a contrastive learning-based system for function-level authorship attribution. OCEAN is the first framework to explore code authorship attribution on compiled binaries in an open world and extreme scenario, where two code samples from unknown authors are compared to determine if they are developed by the same author. To evaluate OCEAN, we introduce new realistic datasets: Conan , to improve the performance of authorship attribution systems in real-world use cases, and Snoopy , to increase the robustness of the evaluation of such systems. We use Conan to train our model and evaluate on Snoopy , a fully unseen dataset, resulting in an AUROC score of 0.86 even when using high compiler optimizations. We further show that Conan improves performance by 7\% compared to the previously used Google Code Jam dataset. Additionally, OCEAN outperforms previous methods in their settings, achieving a 10\% improvement over state-of-the-art SCS-Gan in scenarios analyzing source code. Furthermore, OCEAN can detect code injections from an unknown author in a software update, underscoring its value for securing software supply chains.},
  content_type = {Conference paper},
}


@article{springer_10_1038_s42256_023_00668_8,
  title = {A neural machine code and programming framework for the reservoir computer},
  author = {Kim, Jason Z. and Bassett, Dani S.},
  journal = {Nature Machine Intelligence},
  year = {2023},
  volume = {5},
  number = {6},
  pages = {622-630},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1038/s42256-023-00668-8},
  url = {https://doi.org/10.1038/s42256-023-00668-8},
  abstract = {Abstract From logical reasoning to mental simulation, biological and artificial neural systems possess an incredible capacity for computation. Such neural computers offer a fundamentally novel computing paradigm by representing data continuously and processing information in a natively parallel and distributed manner. To harness this computation, prior work has developed extensive training techniques to understand existing neural networks. However, the lack of a concrete and low-level machine code for neural networks precludes us from taking full advantage of a neural computing framework. Here we provide such a machine code along with a programming framework by using a recurrent neural network—a reservoir computer—to decompile, code and compile analogue computations. By decompiling the reservoir’s internal representation and dynamics into an analytic basis of its inputs, we define a low-level neural machine code that we use to program the reservoir to solve complex equations and store chaotic dynamical systems as random-access memory. We further provide a fully distributed neural implementation of software virtualization and logical circuits, and even program a playable game of pong inside of a reservoir computer. Importantly, all of these functions are programmed without requiring any example data or sampling of state space. Finally, we demonstrate that we can accurately decompile the analytic, internal representations of a full-rank reservoir computer that has been conventionally trained using data. Taken together, we define an implementation of neural computation that can both decompile computations from existing neural connectivity and compile distributed programs as new connections.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_82826_3_4,
  title = {Malware in the Connected World: Advanced Detection Techniques Using System Calls and Graph Analysis},
  author = {Surendran, Roopak and Thomas, Tony},
  booktitle = {Securing the Connected World},
  year = {2025},
  pages = {115-134},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-82826-3\_4},
  url = {https://doi.org/10.1007/978-3-031-82826-3\_4},
  abstract = {Android smartphones play a vital role in managing Internet of Things (IoT) devices through various applications. However, some of these applications are maliciously repackaged versions of legitimate apps, posing significant security risks. Machine learning (ML) classifiers are now widely used for malware detection, requiring relevant static and dynamic features to accurately identify malicious behavior. This chapter examines the limitations of current static and dynamic malware detection methods and suggests system call sequence analysis techniques to address these challenges. Since an application’s malicious actions are often reflected in its system call sequences, these sequences are considered optimal features for ML-based malware detection. However, many existing system call-based methods face several issues, including high feature vector dimensionality, complex classifier training, large dataset requirements, and limited ability to detect unknown, obfuscated, and adversarial malware samples. This chapter explores recent advances in malware detection, presenting innovative mechanisms that combine system call subsequence analysis with graph feature analysis to improve detection accuracy and efficiency. These approaches address limitations in traditional methods by using system call patterns and graph-based features, which together capture key indicators of malicious behavior, enhance classifier performance, and reduce computational demands, making them highly effective in detecting diverse types of malware in IoT and Android applications.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_96_3531_3_21,
  title = {Revisiting Binary Code Authorship Analysis},
  author = {Alrabaee, Saed and Al-kfairy, Mousa and Taha, Mohammad Bany and Alfandi, Omar and Taher, Fatma and Tang, Jie},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {428-449},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-3531-3\_21},
  url = {https://doi.org/10.1007/978-981-96-3531-3\_21},
  abstract = {Binary authorship analysis is a crucial step in malware reverse engineering, but the volume and complexity of the code exacerbate the challenge of this manually intensive task. Consequently, efforts have been made to develop reliable automated tools to facilitate malware authorship analysis; however, many challenges are associated with automated approaches. For instance, the compilation process may remove stylistic features present in the source code. This paper evaluates the features used in existing approaches by utilizing various datasets, including programs written for the Google Code Jam programming competition, student projects from programming courses at multiple universities, and content from GitHub repositories. Additionally, we examined the impact of statistical features on precision, recall, and the false positive rate of these methodologies. The evaluation results reveal that the accuracy of these approaches varies across different application domains and datasets, and some of the selected features appear unrelated to the author’s style, indicating that careful consideration is needed when applying this approach. Finally, using statistical features enhanced the precision and recall of existing approaches while reducing the false positive rate by 10–15\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_1157_8_55,
  title = {Intelligent Vulnerability Association Algorithm Based on Association Rule Mining},
  author = {Jin, Xin and Li, Hongyan and Liu, Hengwang and Wang, Wen and Sun, Xin},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2023},
  pages = {455-462},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-1157-8\_55},
  url = {https://doi.org/10.1007/978-981-99-1157-8\_55},
  abstract = {In this paper, we propose a method of vulnerability mining using data association rules mining. This method first decompiles the target file, build an abstract syntax tree (AST) of the function on the basis of decompilation, design an algorithm to extract the reverse association information of key variables, and then apply the extracted information to vulnerability mining. The experimental results show that the decompilation results of Hex Rays recover some variable information, and the program structure is clear, on this basis, the work of vulnerability mining has great advantages. The method proposed by the author is used to process the decompilation results, on the basis of the pattern matching detection results, the preliminary detection results are filtered with the help of the association between data, to some extent, it reduces the false positives caused by using simple pattern matching. It proves that this method has obvious advantages in non source code vulnerability mining, it can effectively discover the suspicious points of buffer overflow vulnerabilities in software, and improve the efficiency and automation of vulnerability mining.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s42400_022_00121_0,
  title = {Unleashing the power of pseudo-code for binary code similarity analysis},
  author = {Zhang, Weiwei and Xu, Zhengzi and Xiao, Yang and Xue, Yinxing},
  journal = {Cybersecurity},
  year = {2022},
  volume = {5},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-022-00121-0},
  url = {https://doi.org/10.1186/s42400-022-00121-0},
  abstract = {Abstract Code similarity analysis has become more popular due to its significant applicantions, including vulnerability detection, malware detection, and patch analysis. Since the source code of the software is difficult to obtain under most circumstances, binary-level code similarity analysis (BCSA) has been paid much attention to. In recent years, many BCSA studies incorporating AI techniques focus on deriving semantic information from binary functions with code representations such as assembly code, intermediate representations, and control flow graphs to measure the similarity. However, due to the impacts of different compilers, architectures, and obfuscations, binaries compiled from the same source code may vary considerably, which becomes the major obstacle for these works to obtain robust features. In this paper, we propose a solution, named UPPC (Unleashing the Power of Pseudo-code), which leverages the pseudo-code of binary function as input, to address the binary code similarity analysis challenge, since pseudo-code has higher abstraction and is platform-independent compared to binary instructions. UPPC selectively inlines the functions to capture the full function semantics across different compiler optimization levels and uses a deep pyramidal convolutional neural network to obtain the semantic embedding of the function. We evaluated UPPC on a data set containing vulnerabilities and a data set including different architectures (X86, ARM), different optimization options (O0-O3), different compilers (GCC, Clang), and four obfuscation strategies. The experimental results show that the accuracy of UPPC in function search is 33.2\% higher than that of existing methods.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_95_3701_3_24,
  title = {Mobile App Security Assessment Using Forensic Analysis of APK Files},
  author = {Eldho, Basil and Salmani, Sakina},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2026},
  pages = {369-381},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-3701-3\_24},
  url = {https://doi.org/10.1007/978-981-95-3701-3\_24},
  abstract = {In the last few years, mobiles and mobile-based tools and applications have become so widespread that mobile apps are used in all phases of life such as messaging, entertainment, healthcare, and all kinds of financial transactions. Further, as more applications are moved to mobile apps (e.g., Android and iOS), the security has become a major issue. As mobile applications transition to cloud-based platforms and necessitate remote access, the spectrum of potential attacks has broadened. The increase in security vulnerabilities and threats poses a significant challenge for organizations in terms of management and mitigation. Consequently, it is crucial for both organizations and individuals to enhance their security measures. It is imperative that scientists and engineers allocate more time to the detection, verification, and mitigation of security vulnerabilities on a grand scale. This encompasses the code base, infrastructure, and corporate assets. A variety of security tools for detection and reporting are available in the market. Nevertheless, these systems often generate a high number of false positives that subsequently require manual verification by security engineers. To deal with these challenges, in this study a mobile app security assessment model called Mobile App Security Assessment Tool (MASAT) is developed in Python language. In the model, we assess the Android Application Package (APK) files and try to detect the security vulnerabilities through forensic analysis. The model was tested for a number of APK files and found to be working satisfactory. The model developed will aid in the verification of security vulnerabilities by security scanners, reducing false positives and ensuring the reproducibility of security vulnerabilities at scale.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42514_025_00270_x,
  title = {The new compiler stack: a survey on the synergy of LLMs and compilers},
  author = {Zhang, Shuoming and Zhao, Jiacheng and Yu, Qiuchu and Xia, Chunwei and Wang, Zheng and Feng, Xiaobing and Cui, Huimin},
  journal = {CCF Transactions on High Performance Computing},
  year = {2026},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42514-025-00270-x},
  url = {https://doi.org/10.1007/s42514-025-00270-x},
  abstract = {This survey has provided a systematic overview of the emerging field of LLM-enabled compilation by addressing several key research questions. We first answered how LLMs are being integrated by proposing a comprehensive, multi-dimensional taxonomy that categorizes works based on their Design Philosophy (Selector, Translator, Generator), LLM Methodology, their operational Level of Code Abstraction, and the specific Task Type they address. In answering what advancements these approaches offer, we identified three primary benefits: the democratization of compiler development, the discovery of novel optimization strategies, and the broadening of the compiler’s traditional scope. Finally, in addressing the field’s challenges and opportunities, we highlighted the critical hurdles of ensuring correctness and achieving scalability, while identifying the development of hybrid systems as the most promising path forward. By providing these answers, this survey serves as a foundational roadmap for researchers and practitioners, charting the course for a new generation of LLM-powered, intelligent, adaptive and synergistic compilation tools.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_95_4142_3_1,
  title = {Zero-Shot Detection of Bytecode-Level Ponzi Contract Using LLM},
  author = {Xu, Zhenyong and Lan, Tian and Liu, Leyan and Zhu, Yihua and Zhang, Ruiheng and Chen, Wei},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {3-14},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-4142-3\_1},
  url = {https://doi.org/10.1007/978-981-95-4142-3\_1},
  abstract = {Smart contracts on Ethereum have driven the development of decentralized financial applications, but they have also become a breeding ground for fraudulent activities, particularly Ponzi schemes. These schemes often obscure the flow of funds and the relationships among participants, making their true nature difficult to detect–especially when only the contract’s bytecode is publicly available. Conventional detection methods largely depend on access to source code or large-scale labeled datasets to train supervised learning models. However, in real-world blockchain environments, only compiled bytecode is typically accessible on-chain, and obtaining labeled data is costly and often impractical. To address this challenge, we propose a novel approach to identify Ponzi schemes directly from Ethereum bytecode, without relying on source code or labeled data. Under a zero-shot setting, we utilize large language models to interpret and assess critical code fragments extracted from the contract, aiming to judge whether their functionality matches typical Ponzi-like fund behaviors. Our method first decompiles the bytecode into an intermediate form that preserves key semantic information, then constructs a data flow graph to represent data dependencies and control flow relationships within the contract. Based on this graph, we apply a set of manually defined rules to locate and extract code segments that are strongly related to fund transfer logic. These segments are then provided to the language model for further reasoning and judgment. By integrating bytecode analysis with LLM-based interpretation, our method can detect suspicious fund flow patterns even when the original source code is not available.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_01823_6_11,
  title = {HatMob: An All-Encompassing Mobile Pentesting Suite},
  author = {Jia Jing, Caleb Lee and Haiqi, He and Balachandran, Vivek},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {179-184},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-01823-6\_11},
  url = {https://doi.org/10.1007/978-3-032-01823-6\_11},
  abstract = {This work aims to develop a comprehensive toolkit designed to streamline the environment setup for mobile application security analysts. The toolkit will focus on providing a pre-configured and easily deployable virtual machine (VM) that consolidates a set of essential security tools, enabling analysts to quickly and efficiently begin their work. By automating the setup process and incorporating a variety of mobile security tools, the toolkit allows analysts to spend less time on configuring their environment and more time on critical tasks such as identifying Indicators of Compromise (IOCs) and developing effective remediation strategies. The ultimate goal is to enhance the productivity and efficiency of mobile security analysts, reduce manual setup complexity, and provide a cohesive, unified platform for mobile application security assessment. Through this project, we aim to simplify the process of mobile security analysis and empower professionals to better defend against the evolving landscape of mobile threats.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_025_10779_y,
  title = {Immutable in principle, upgradeable by design: exploratory study of smart contract upgradeability},
  author = {Qasse, Ilham and Hamdaqa, Mohammad and Jónsson, Björn Þór},
  journal = {Empirical Software Engineering},
  year = {2026},
  volume = {31},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10779-y},
  url = {https://doi.org/10.1007/s10664-025-10779-y},
  abstract = {Smart contracts, known for their immutable nature to ensure trust via automated enforcement, have evolved to necessitate upgradeability due to unforeseen vulnerabilities and the need for feature enhancements post-deployment. This inherent contradiction between immutability and the necessity for modifications has prompted the development of upgradeable smart contracts. These contracts are immutable in principle yet upgradeable by design, allowing for future updates without altering the underlying data or state, thus preserving the contract’s original intent while accommodating necessary improvements. This empirical study aims to bridge the gap in understanding the practical application and implications of upgradeable smart contracts on the Ethereum blockchain. By introducing a comprehensive dataset that catalogs the versions and evolutionary trajectories of smart contracts, the research explores several key dimensions: the prevalence and adoption patterns of upgrade mechanisms, the likelihood and actual occurrences of contract upgrades, the nature of modifications post-upgrade, and their impact on user engagement and contract activity. Through a detailed empirical analysis, this study systematically identifies upgradeable contracts and examines their upgrade history to uncover trends, preferences, and the practical challenges associated with applying such modifications. The empirical evidence gathered from the analysis of over 44 million contracts shows that a mere 3\% embody upgradeable characteristics, with only 0.34\% of the 3\% undergoing subsequent upgrades. This finding underscores a cautious approach by developers towards contract modifications, possibly due to the complexity of upgrade processes or a preference for maintaining the original contract stability. Furthermore, the study demonstrates that upgrades are predominantly aimed at feature enhancement and vulnerability mitigation, particularly when the contracts’ source codes are accessible. However, the relationship between contract upgrades and user activity is intricate, suggesting that additional factors significantly affect the utilization of smart contracts beyond their mere functional evolution.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_64171_8_1,
  title = {Exceptional Interprocedural Control Flow Graphs for x86-64 Binaries},
  author = {Bockenek, Joshua and Verbeek, Freek and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {3-22},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64171-8\_1},
  url = {https://doi.org/10.1007/978-3-031-64171-8\_1},
  abstract = {Standard control flow graphs (CFGs) extracted from binaries by state-of-the-art disassembly/decompilation tools do not include information about exception-related control flow. However, such information is useful when statically analyzing programs that utilize structured exceptions. To fill that gap, we propose the concept of Exceptional Interprocedural Control Flow Graphs (EICFGs) . These graphs extend traditional CFGs by adding edges for stack unwinding, frame cleanup, and try/catch behavior caused by thrown exceptions. We provide an approach for generating EICFGs from x86-64 binaries featuring C++ exceptions. The approach is based on symbolically executing an abstract semantics that includes binary-level exception-related function calls. We validated our abstract semantics by generating concrete test cases that were then evaluated using real binaries. We applied an implementation of our approach to 341 off-the-shelf x86-64 binaries compiled from C++ as well as C and Fortran source code. From those binaries, we identified 2574 unique throws and successfully resolved the exceptional control flow for every one of them. We show that resolving throws leads to increased instruction reachability and uncovers edges not found by state-of-the-art tools such as Ghidra.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_025_10748_5,
  title = {An empirical study on the effectiveness of large language models for binary code understanding},
  author = {Shang, Xiuwei and Fu, Zhenkan and Cheng, Shaoyin and Chen, Guoqiang and Li, Gangyang and Hu, Li and Zhang, Weiming and Yu, Nenghai},
  journal = {Empirical Software Engineering},
  year = {2026},
  volume = {31},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10748-5},
  url = {https://doi.org/10.1007/s10664-025-10748-5},
  abstract = {Binary code analysis plays a pivotal role in the field of software security and is widely used in tasks such as software maintenance, malware detection, software vulnerability discovery, patch analysis, etc. However, unlike source code, reverse engineers face significant challenges in understanding binary code due to the lack of intuitive semantic information. Although traditional reverse tools can convert binary code into C-like pseudo code, the lack of code comments and symbolic information such as function names still makes code understanding difficult. In recent years, two groups of techniques have shown promising prospects: (1) Deep learning-based techniques have demonstrated competitive results in tasks related to binary code understanding, furthermore, (2) Large Language Models (LLMs) have been extensively pre-trained at the source-code level for tasks such as code understanding and generation. This has left participants wondering about the capabilities of LLMs in binary code understanding. To this end, this work proposes a benchmark to evaluate the effectiveness of LLMs in real-world reverse engineering scenarios, which covers two key binary code understanding tasks, i.e., function name recovery and binary code summarization. To more comprehensively evaluate, we include binaries with multiple target architectures as well as different optimization options. We gain valuable insights into the capabilities and limitations through extensive empirical studies of popular LLMs using our benchmark. Our evaluations reveal that existing LLMs can understand binary code to a certain extent, thereby improving the efficiency of binary code analysis. Our results highlight the great potential of the LLMs in advancing the field of binary code understanding, and provide new directions for binary code analysis techniques.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_37963_5_22,
  title = {J-Parallelio: Automatic Parallelization Framework for Java Virtual Machine},
  author = {Listkiewicz, Piotr and Stuglik, Krzysztof and Kulczyk, Mateusz and Pietron, Marcin},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {307-320},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-37963-5\_22},
  url = {https://doi.org/10.1007/978-3-031-37963-5\_22},
  abstract = {Manual translation of the algorithms from sequential version to its parallel counterpart is time consuming and can be done only with the specific knowledge of hardware accelerator architecture, parallel programming or programming environment. The automation of this process makes porting the code much easier and faster. The key aspect in this case is how efficient the generated parallel code will be. The paper describes J-Parallelio, the framework for automatic analysis of the bytecode source codes and its parallelisation on multicore processors. The process consists of a few steps. First step is a process of decompilation of JVM and its translation to internal abstract syntax tree, the dependency extraction and memory analysis is performed. Finally, the mapping process is performed which consists of a set of rules responsible for translating the input virtual machine source code to its parallel version. The main novelty is that it can deal with pure java virtual machine and can generate parallel code for multicore processors. This makes the system portable and it can work with different languages based on JVM after some small modifications. The efficiency of automatically translated source codes were compared with their manually written counterparts on chosen benchmarks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_81342_9_13,
  title = {Smali Code-Based Fake Application Detection},
  author = {Anand, Abhishek and Shivam and Manhas, Tejas and Gupta, Smriti},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {145-160},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-81342-9\_13},
  url = {https://doi.org/10.1007/978-3-031-81342-9\_13},
  abstract = {The digitization of government departments and the automation of administrative processes have resulted in a popularity of mobile applications that request crucial information from users. However, this surge has also given rise to a multitude of counterfeit applications introduced by malicious actors. These deceptive apps primarily target users’ personal and sensitive data, posing a direct threat to privacy and potentially leading to financial harm. This paper introduces an innovative approach for detecting these fraudulent applications amidst the genuine ones. The primary goal is to develop a model that can differentiate between genuine and counterfeit applications by analyzing the assembly-level code in Smali files. A series of experiments have been conducted to achieve the highest accuracy, resulting in a notable rate of 76.92\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_82362_6_1,
  title = {Feasibility Study for Supporting Static Malware Analysis Using LLM},
  author = {Fujii, Shota and Yamagishi, Rei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {5-28},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-82362-6\_1},
  url = {https://doi.org/10.1007/978-3-031-82362-6\_1},
  abstract = {Large language models (LLMs) are becoming more advanced and widespread and have shown their applicability to various domains, including cybersecurity. Static malware analysis is one of the most important tasks in cybersecurity; however, it is time-consuming and requires a high level of expertise. Therefore, we conducted a demonstration experiment focusing on whether an LLM can be used to support static analysis. First, we evaluated the ability of the LLM to explain malware functionality. The results showed that the LLM can generate descriptions that cover functions with an accuracy of up to 90.9\%. In addition, we asked six static analysts to perform a pseudo static analysis task using LLM explanations to verify that the LLM can be used in practice. Through subsequent questionnaires and interviews with the participants, we also demonstrated the practical applicability of LLMs. Lastly, we summarized the problems and required functions when using an LLM as static analysis support, as well as recommendations for future research opportunities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_74776_2_17,
  title = {BinSub: The Simple Essence of Polymorphic Type Inference for Machine Code},
  author = {Smith, Ian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {425-450},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-74776-2\_17},
  url = {https://doi.org/10.1007/978-3-031-74776-2\_17},
  abstract = {Recovering high-level type information in binaries is a key task in reverse engineering and binary analysis. Binaries contain very little explicit type information. The structure of binary code is incredibly flexible allowing for ad-hoc subtyping and polymorphism. Prior work has shown that precise type inference on binary code requires expressive subtyping and polymorphism. Implementations of these type system features in a binary type inference algorithm have thus-far been too inefficient to achieve widespread adoption. Recent advances in traditional type inference have achieved simple and efficient principal type inference in an ML like language with subtyping and polymorphism through the framework of algebraic subtyping. BinSub, a new binary type inference algorithm, recognizes the connection between algebraic subtyping and the type system features required to analyze binaries effectively. Using this connection, BinSub achieves simple, precise, and efficient binary type inference. We show that BinSub maintains a similar precision to prior work, while achieving a 63x improvement in average runtime for 1568 functions. We also present a formalization of BinSub and show that BinSub’s type system maintains the expressiveness of prior work.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_10486_1_15,
  title = {Influence of External Dependency Retrieval and Prompt Engineering in Test Case Generation Using LLMs},
  author = {Lenke, David and Ferrer, Javier and Chicano, Francisco},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {150-162},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-10486-1\_15},
  url = {https://doi.org/10.1007/978-3-032-10486-1\_15},
  abstract = {The recent rise of large language models (LLMs) has enabled the generation of higher-quality test cases by leveraging the semantics of the methods under test. However, existing LLM-based approaches still struggle to achieve high coverage levels. To mitigate this issue, we present two complementary techniques in this work: Prompt Engineering and External Dependency Retrieval for context enrichment. We evaluated our improvements through an ablation study on three open-source and four proprietary projects, encompassing 261 distinct methods. For each method, we generated test suites under four implementations and performed ten independent runs, yielding a total of 10,440 executions. Our combined approach yields an average coverage increase of 12\% on industrial software, with statistically significant gains over all other variants studied in this paper. Although our enhancements increase the context (the number of input tokens rises by 66.3\%), this is partially compensated by a reduction in output tokens due to fewer repair attempts, so that the overall cost overhead remains moderate at about 16\%. As future work, we aim to identify the minimal necessary context that still yields significant improvements in test coverage, which could help to further reduce costs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_64171_8_5,
  title = {Modularizing Directed Greybox Fuzzing for Binaries over Multiple CPU Architectures},
  author = {Benahmed, Sofiane and Qasem, Abdullah and Lounis, Anis and Debbabi, Mourad},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {84-103},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64171-8\_5},
  url = {https://doi.org/10.1007/978-3-031-64171-8\_5},
  abstract = {Directed Greybox Fuzzing has proven effective in vulnerability detection areas such as bug reproduction and patch testing. However, existing directed fuzzers are often difficult to customize, lack modularity and have limited binary support. This constrains their usability on complex software or when the source code is unavailable; a challenge encountered when fuzzing embedded systems. This article addresses these limitations by introducing the Directed Fuzzing Toolkit (DRIFT) as a platform for directed fuzzing within the modular framework LibAFL. DRIFT modularizes techniques from the state-of-the-art directed fuzzer AFLGo and adapts them for binary applications thereby augmenting LibAFL’s highly customizable fuzzers with directed fuzzing capabilities. Additionally, by leveraging Ghidra’s analysis, DRIFT achieves architecture agnostic static analysis, opening doors for DGF to tackle previously challenging scenarios. Our evaluation of DRIFT shows a 90\% correlation in static analysis metrics over binary compared to its source-code counterpart. Fuzzing performance was also notable despite operating over emulation. In benchmarks, DRIFT’s performance exceeds the original fuzzer with up to doubled bug discovery rates and 9–40 \\(\\times \\) faster exploitation times of target bugs. These results are attributed to the toolkit’s modular design and its integration with LibAFL. Additionally, DRIFT includes a profiling platform for DGF metrics and is incorporated with the Magma benchmark. Together, these features position DRIFT as a practical advancement in directed fuzzing within LibAFL.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_1331_4_34,
  title = {Android Malware Detection Method Based on Multi-feature Extraction and SPP-Net},
  author = {Chen, Wen and Li, Huafeng and Song, Le},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {399-408},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-1331-4\_34},
  url = {https://doi.org/10.1007/978-981-95-1331-4\_34},
  abstract = {With the rapid development of network technology, malware has become an increasingly serious threat to network security. The Android platform has become the main target of malware attacks due to its openness and wide application. At the same time, the number and complexity of Android malware are increasing, which has a serious impact on user privacy protection, data security and normal operation of devices. The development of deep learning and computer vision technology has provided new ideas for Android malware detection, but the existing methods have certain limitations. On the one hand, relying solely on a single type of feature extraction is prone to information loss; on the other hand, the limitation on the size of feature images will further aggravate information loss, making it difficult to cope with the rapidly evolving Android malware. Therefore, this paper proposes an Android malware detection method (SAMD) based on multi-feature extraction and SPP-net. This method extracts API calls, permissions, and opcode sequence features from classes.dex, AndroidManifest.xml, and smali files, respectively, and generates corresponding feature grayscale images to fully retain the key information of Android malware. Then, the feature images are input into the classification model based on SPP-net for Android malware detection. Experimental results on the CIC MalDroid 2020 and Google Play Store datasets show that SAMD demonstrates good performance in the Android malware detection task, with an accuracy of 95.56\%.},
  content_type = {Conference paper},
}


@article{springer_10_3103_s0005105525700207,
  title = {Automated System for Numerical Similarity Evaluation of Android Applications},
  author = {Petrov, V. V.},
  journal = {Automatic Documentation and Mathematical Linguistics},
  year = {2024},
  volume = {58},
  number = {S3},
  pages = {S131-S142},
  publisher = {Allerton Press},
  doi = {10.3103/s0005105525700207},
  url = {https://doi.org/10.3103/s0005105525700207},
  abstract = {This paper is devoted to the design and development of a system for automating numerical similarity assessment of Android applications. The task of the evaluation of application similarity is reduced to the similarity evaluation of sets of control flow graphs constructed based on code from classes.dex files of applications. The similarity value was calculated based on the similarity matrix. The algorithms of graph editing and Levenshtein distance were used to compare control flow graphs. The application similarity criteria were formulated, and their representation forms were investigated. Types of Android application models and methods of their construction are presented. A prototype of the system for automating the numerical evaluation of Android-applications similarity is developed. Optimization of the software solution is performed with the help of parallel programming tools. Experiments are carried out, and a conclusion is drawn concerning the ability of the developed system to detect similarities between Android applications.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_2397_5_18,
  title = {Source Code Anti-Plagiarism: A C\# Implementation Using the Routing Approach},
  author = {d’Amore, Fabrizio and Zarfati, Lorenzo},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {181-189},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-2397-5\_18},
  url = {https://doi.org/10.1007/978-981-19-2397-5\_18},
  abstract = {Despite the approaches proposed so far, software plagiarism is still a problem which has not been solved entirely yet. The approach introduced throughout this paper is about a source code anti-plagiarism technique which aims at rendering the source code incomprehensible to a possible plagiarist and at the same time preventing source code modifications. The proposal is based on the concept of Router and makes use of both symmetric encryption and cryptographic hashing functions to provide such guarantees.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00500_023_08559_1,
  title = {Automated program improvement with reinforcement learning and graph neural networks},
  author = {Sukur, Nataša and Milošević, Nemanja and Pracner, Doni and Budimac, Zoran},
  journal = {Soft Computing},
  year = {2024},
  volume = {28},
  number = {3},
  pages = {2593-2604},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00500-023-08559-1},
  url = {https://doi.org/10.1007/s00500-023-08559-1},
  abstract = {Automated software transformations and the process of automated program repair and improvement are an important aspect of modern software engineering practices. In this paper, we describe a system which uses a graph-based deep learning model that can be trained to automatically transform and improve computer programs. By operating on language-agnostic, universal graph-like structures easily extractable from source code files (abstract syntax trees), the deep learning agent learns which transformations should be effectively applied to various structures recognized in the source code in order to improve it. By defining a metric which we want to improve and introducing an optimization task—a reinforcement learning setting, an agent learns to automatically apply a chain of transformations to the program, drastically improving it. While similar program improvement processes exist, they exclusively use exhaustive search algorithms to try all the possible code transformations which is a long process susceptible to local optimum issues. Our solution aims to model and embed structural knowledge about the programs being transformed which greatly helps the agent to choose best possible code transformations to apply. Elements of the approach we present in this paper are further applicable not just to automatic software improvement tasks, but also to other code-related tasks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_1459_9_5,
  title = {Static Adversarial Method},
  author = {Niu, Weina and Zhang, Xiaosong and Yan, Ran and Gong, Jiacheng},
  booktitle = {Android Malware Detection and Adversarial Methods},
  year = {2024},
  pages = {97-128},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1459-9\_5},
  url = {https://doi.org/10.1007/978-981-97-1459-9\_5},
  abstract = {As Android systems become targets of malicious software attacks, researchers and developers are exploring methods to prevent malware infiltration into Android devices. To counter researchers’ security measures and further increase the spread and penetration of malware, malicious authors use static obfuscation techniques to evade detection. This chapter first introduces three static obfuscation techniques: code obfuscation, resource obfuscation, and manifest file obfuscation. Code obfuscation increases code complexity and ambiguity by modifying identifiers and removing unused code. Resource obfuscation increases the difficulty of decompilation by randomizing resource file names and directories. Manifest file obfuscation enhances app security by replacing component names, permission names, and metadata. Static obfuscation techniques effectively prevent attacks, such as APK decompilation, injection, and tampering, but may impact app performance and user experience and increase app complexity and maintenance costs. Then, common APK static obfuscation tools are presented, including Obfuscapk, ProGuard, DexGuard, Allatori, DashO, Bangcle, and Arxan. These tools were originally designed to protect app security by obfuscating the code to prevent reverse engineering, tampering, and piracy. However, they are also used by malicious software developers to achieve static evasion. To combat malware that uses static obfuscation techniques, researchers have begun using new detection strategies. They explore more difficult-to-obfuscate static features, such as user interface perceptual hashes and grayscale images, to identify malicious software. They also combine dynamic analysis or machine learning to counter the impact of static obfuscation on analysis. Finally, the chapter summarizes some research work related to static obfuscation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_49269_3_8,
  title = {Enhancing Code Obfuscation Techniques: Exploring the Impact of Artificial Intelligence on Malware Detection},
  author = {Catalano, Christian and Specchia, Giorgia and Totaro, Nicolò G.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {80-88},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-49269-3\_8},
  url = {https://doi.org/10.1007/978-3-031-49269-3\_8},
  abstract = {Code obfuscation techniques serve to obscure proprietary code, and there are several types. Various tools, such as reverse engineering, are used to reconstruct obfuscated code. To make the analysis and decoding of obfuscated code more difficult, obfuscation techniques can be combined in cascades. Artificial Intelligence (AI) can be used to recombine old codes with each other and make it more difficult to decrypt them. In this paper, the focus is precisely on the increased complexity of the process of reconstructing proprietary code if it is generated with the aid of AI, and consequently on the increasing difficulty for antiviruses in detecting this new type of malware.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_022_00626_2,
  title = {Malicious code detection in android: the role of sequence characteristics and disassembling methods},
  author = {Balikcioglu, Pinar G. and Sirlanci, Melih and A. Kucuk, Ozge and Ulukapi, Bulut and Turkmen, Ramazan K. and Acarturk, Cengiz},
  journal = {International Journal of Information Security},
  year = {2023},
  volume = {22},
  number = {1},
  pages = {107-118},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-022-00626-2},
  url = {https://doi.org/10.1007/s10207-022-00626-2},
  abstract = {Abstract The acceptance and widespread use of the Android operating system drew the attention of both legitimate developers and malware authors, which resulted in a significant number of benign and malicious applications available on various online markets. Since the signature-based methods fall short for detecting malicious software effectively considering the vast number of applications, machine learning techniques in this field have also become widespread. In this context, stating the acquired accuracy values in the contingency tables in malware detection studies has become a popular and efficient method and enabled researchers to evaluate their methodologies comparatively. In this study, we wanted to investigate and emphasize the factors that may affect the accuracy values of the models managed by researchers, particularly the disassembly method and the input data characteristics. Firstly, we developed a model that tackles the malware detection problem from a Natural Language Processing (NLP) perspective using Long Short-Term Memory (LSTM). Then, we experimented with different base units (instruction, basic block, method, and class) and representations of source code obtained from three commonly used disassembling tools (JEB, IDA, and Apktool) and examined the results. Our findings exhibit that the disassembly method and different input representations affect the model results. More specifically, the datasets collected by the Apktool achieved better results compared to the other two disassemblers.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_95_0129_8_27,
  title = {NLP-Based Detecting Privacy Policy and Behavior Inconsistencies in Android Apps},
  author = {Yu, Cheng and Yuan, Xinyu and Tian, Xin and Wan, Xiangyu},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {372-383},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-0129-8\_27},
  url = {https://doi.org/10.1007/978-981-95-0129-8\_27},
  abstract = {With the rapid development of mobile internet and the increasing number of smartphone users, various applications have become easily accessible. Although most mobile applications publish corresponding privacy policies before being re-leased on app markets, there persists a critical issue of inconsistency between declared privacy policies and actual application behaviors, leading to user privacy breaches. This makes the detection and analysis of privacy leakage behaviors in Android applications and their third-party libraries an urgent research challenge. Natural Language Processing (NLP), which focuses on enabling effective human-machine interaction through natural language, proves particularly suitable for analyzing decompiled Android bytecode as an inspection medium. By employing NLP-based semantic analysis for static code examination, this research addresses privacy leakage detection in Android applications. This paper presents an NLP-based system for detecting consistency between application privacy policies and behaviors. The system utilizes NLP techniques to extract and process privacy-related declarations from policy documents and sensitive behaviors from applications. Through static analysis, it distinguishes actual sensitive behaviors and private data handling between core applications and third-party libraries. The system establishes a correlation model by mapping permission requirements with privacy information disclosures, ultimately achieving consistency verification. For experimental validation, we selected 100 Chinese mobile applications and their third-party libraries. Experimental results reveal that approximately 80\% of applications exhibited inconsistencies between documented policies and actual behaviors (including third-party components).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_72322_3_4,
  title = {LEARNT: A Neural Machine Translation Framework for Accurate Binary Lifting to High-Level Representation},
  author = {Baasantogtokh, Duulga and Yoon, Yoseob and Batzorig, Munkhdelgerekh and Sahlabadi, Mahdi and Yim, Kangbin},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2024},
  pages = {33-44},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-72322-3\_4},
  url = {https://doi.org/10.1007/978-3-031-72322-3\_4},
  abstract = {In binary analysis, performing static analyses on architecture-agnostic intermediate representation is efficient and strongly demanded. Sound and accurate Low-Level Virtual Machine Intermediate Representation (LLVM IR) lifted from binary could make the reuse of dozens of existing analysis programs of the LLVM ecosystem possible. However, current binary lifters lack the resources to improve manually developed lifting rules and develop more of them. This work aims to solve the problem of lifting low-level language to sound high-level Intermediate Representation (IR) as a formal language translation problem, enabling automatic learning of binary lifting. Therefore, we propose a neural machine translation-based binary lifting framework named LEARNT with a parallel corpus generation method leveraging a compiler. The evaluation results show that LEARNT’s average translation accuracy is 93\%, which proves that translation rules automatically learned by LEARNT are sound.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_08243_5_34,
  title = {Malware Analysis and Detection},
  author = {Yadav, Rajesh and Merugu, Suresh and Nikoukar, Yasamin and Perianayagam, Herbert Raj and Sathishkumar, V. E.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2026},
  pages = {383-395},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-08243-5\_34},
  url = {https://doi.org/10.1007/978-3-032-08243-5\_34},
  abstract = {The threat of malware is increasing rapidly now a days. It is a program that enters our computer system with a harmful intention to badly affect various operations of our system. It is difficult for engineers to handle malware as they are in large number and have different structures also, therefore security researchers are working in the direction of developing various techniques which are both accurate as well as effective for detection of various malware. This paper involves a deep analysis work that delves into the threats posed by two different samples with primary focus on understanding their behavior and minimizing their impact. Employing a blend of dynamic and static analysis techniques, our research work scrutinizes the real-world ramifications of these malware strains while dissecting their underlying code and structure. The main objective of this research on BlackCat and WhisperGate malware is to analyze their behavior, attack mechanisms, and evolving tactics to enhance the understanding of modern cybersecurity threats. This analysis aims to inform the development of more effective detection strategies and defense mechanisms, addressing gaps in current approaches to combating advanced malware threats},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_0555_2_5,
  title = {Forensics Training},
  author = {Beuran, Razvan},
  booktitle = {Cybersecurity Education and Training},
  year = {2025},
  pages = {73-95},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-0555-2\_5},
  url = {https://doi.org/10.1007/978-981-96-0555-2\_5},
  abstract = {This chapter discusses in detail the forensics training form of cybersecurity training. An overview of the forensics training methodology is provided first, focusing on the interdependency with respect to the other forms of cybersecurity training, namely attack and defense training. The two main forensics training types, fundamental forensics training and forensic methodology training, are presented next, examining in detail the various methods used to teach or learn basic forensic skills, as well as the actual forensics process. A set of additional resources is also provided, such as forensic methodology guidelines by NIST and ISO/IEC, as well as forensics training tools (ExifTools, Ghidra, Volatility, Wireshark) and platforms. Finally, the main advantages of forensics training, as well as potential issues that may arise, are discussed, both from the trainee and organizer perspectives.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_98167_8_10,
  title = {LOC-Based Instruction Selection for Statistical Root Cause Analysis},
  author = {Bui, Duc Anh and Dinh, Thanh Le},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {131-143},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-98167-8\_10},
  url = {https://doi.org/10.1007/978-3-031-98167-8\_10},
  abstract = {Root-Cause Analysis (RCA) is crucial for finding software security flaws from fuzzing results. However, automating this process is considered challenging. In particular, it is well known that statistical RCA techniques are quite slow, frequently requiring hours to thoroughly examine a crash. In this paper, we propose a LOC-based instruction selection method for statistical root cause analysis. Our method improves both the effectiveness and the efficiency of AURORA, a novel binary-only method for automated RCA. LOC-based outperforms AURORA on most of the targets. Especially, our LOC-based method is much faster and more effective than AURORA on all complex, time-consuming targets.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_0143_1_11,
  title = {Malware Detection and Analysis in Android Applications with Mobile Security Framework (MobSF) Using a Permission-Based Approach},
  author = {Kizito, Mark and Homayounvala, Elaheh and Kazemian, Hassan and Araujo, Istteffanny},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2025},
  pages = {131-143},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-0143-1\_11},
  url = {https://doi.org/10.1007/978-981-96-0143-1\_11},
  abstract = {This paper examines security concerns in Android applications arising from violations to the principle of least privilege. Using mobile security framework (MobSF), static and dynamic analysis techniques were used in evaluating how non-essential permission groups that are not core to application functions greatly increase risks of unauthorized system access by attackers, data breaches and privacy concerns, enlarged attack surfaces, and hijacking system resources among others. A permission-based approach systematically identifies malware and highlights dangerous permission groups that magnify security risks. The findings of this research study emphasis on meticulous auditing of permissions to prevent security threats in Android applications and to safeguard user-sensitive data. The conducted experiments compared essential core permissions to non-essential ones regarding application functionality and overall system security. It was also noted that background permissions potentially pose a great deal of risk to security when granted without proper rationale as this increases attack surfaces within the application itself.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00500_025_10489_z,
  title = {Robust security risk estimation for android apps using nearest neighbor approach and hamming distance},
  author = {Deypir, Mahmood and Zoughi, Toktam},
  journal = {Soft Computing},
  year = {2025},
  volume = {29},
  number = {2},
  pages = {593-611},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00500-025-10489-z},
  url = {https://doi.org/10.1007/s00500-025-10489-z},
  abstract = {Nowadays, Android-based devices such as smart phones, tablets, smart watches, and virtual reality headsets have found increasing use in our daily lives. Along with the development of various applications for these devices, new malicious apps are released by intruders, which are more difficult to identify and deal with because they exploit more sophisticated techniques. Although methods have been provided to calculate the security risk and identify malicious apps in Android operating system, but with the expansion of the level and depth of the threats, the need for more effective methods in this context is still required. In this paper, we have devised a new algorithm to calculate the security risk of Android apps, which can be used to identify malicious apps from benign ones. In this algorithm, to estimate the security risk of an unknown input app, its nearest neighbors to malicious apps and its nearest neighbors to normal apps are computed separately using Hamming distance. Then, the security risk of the input app can be computed using a simple formulation. After implementing this algorithm, its parameter for the number of neighbors using various real datasets is adjusted. The extensive experiments conducted on these data show the superiority of the proposed method over the previously proposed ones in terms of detection rate. Our additional experimentations show the robustness of the proposed algorithm in adversarial situations.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_6914_5_12,
  title = {Decompiling and Disassembling Android Applications},
  author = {Stevenson, James},
  booktitle = {Android Software Internals Quick Reference},
  year = {2021},
  pages = {153-157},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-6914-5\_12},
  url = {https://doi.org/10.1007/978-1-4842-6914-5\_12},
  abstract = {This chapter discusses how applications are compiled, assembled, decompiled, and disassembled. In addition to this the chapter also discusses how applications can be pulled off running Android devices and subsequently decompiled.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_032_05892_8_5,
  title = {Firmware Security and Update Mechanism Analysis of IVI System},
  author = {Ganbold, Purevbaatar and Park, Kyungbin and Batzorig, Munkhdelgerekh and Yim, Kangbin},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2026},
  pages = {41-51},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-05892-8\_5},
  url = {https://doi.org/10.1007/978-3-032-05892-8\_5},
  abstract = {As vehicles evolve into intelligent and connected system platform, in-vehicle infotainment (IVI) system is becoming indispensable part by delivering enhanced user experiences like media control, navigation and integration with vehicle functions. However, its increasing complexity introduces more critical security challenges, particularly firmware update mechanism. This paper presents a comprehensive analysis of firmware security in two generations of IVI systems deployed in commercially available vehicles released between 2016 and 2019. The analysis begins by analyzing update packages to understand system structures, encryption schemes, and verification workflows. This research uncovers vulnerabilities in hash verification, key management, and privilege enforcement. Practical methods are utilized for bypassing firmware integrity checks, decrypting update packages, and modifying system partitions. The findings highlight the absence of consistent secure update standards across vehicle generations and emphasize the urgent need for stronger firmware authentication, robust encryption, and hardened system-level protections in future automotive platforms.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97623_0_9,
  title = {Red Light for Security: Uncovering Auto Feature Check and Access Control Gaps in AAOS},
  author = {Jumana and Vyas, Parjanya and Aafer, Yousra},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {147-166},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97623-0\_9},
  url = {https://doi.org/10.1007/978-3-031-97623-0\_9},
  abstract = {The Android Automotive Operating System (AAOS) is a specialized version of the Android OS designed for in-vehicle infotainment and system control. Prominent automakers such as Honda, General Motors (GM), Volvo, and Ford have already adopted it in their latest vehicles. Despite its popularity, the security of AAOS integration has hardly been evaluated, particularly at the framework layer, where auto feature and access control anomalies are likely to arise. To bridge the gap, we perform the first security evaluation of automotive entry points in AAOS. Our study is enabled by AutoAcRaptor , an automated pipeline that leverages static analysis to identify automotive entry points, generate their access control and auto feature specifications, and analyze them for potential security risks. Our evaluation of AutoAcRaptor on two AOSP and eight automaker AAOS images demonstrates that it is able to identify 23 auto feature and access control anomalies, on average per ROM. We report ten cases to the corresponding automakers. At the time of writing, five have been acknowledged while the rest are pending verification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_8612_5_46,
  title = {RIPDroid: Android Malware Detection Based on Permissions and IP Reputation Model},
  author = {Prashanth, P. Ashwin and Amritha, P. P. and Sethumadhavan, M.},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2024},
  pages = {563-572},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-8612-5\_46},
  url = {https://doi.org/10.1007/978-981-99-8612-5\_46},
  abstract = {A ndroid phones contain a lot of sensitive and private data, making them a target for hackers or other bad actors, protecting one’s privacy has become crucial to handling security for these devices. These individuals intend to build various forms of malware to take advantage of such users. Repackaging the application or designing programmes that reroute to harmful sources are some typical methods used to produce malware programmes. Therefore, we propose RIPDroid, a framework, which will identify applications based on their permissions and the IP addresses involved. Our proposed model uses permissions requested by the application and the network traffic captured during runtime to develop the overall model for the detection of android malware. The IP reputation model helps in identifying the communications made by application and the permission model aids in checking the maliciousness of the application. Our evaluation includes an overall accuracy of 95.8\% for the permission-based model and an F-1 score of 90.56\% for the IP reputation model.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10462_025_11452_y,
  title = {Androbank: the impact of API levels on mobile malware detection},
  author = {Oulehla, Milan and Dorotík, Ladislav and Oplatková, Zuzana Komínková},
  journal = {Artificial Intelligence Review},
  year = {2025},
  volume = {59},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10462-025-11452-y},
  url = {https://doi.org/10.1007/s10462-025-11452-y},
  abstract = {Android is the most widely used operating system, making it a prime target for mobile malware, leading to data breaches and financial losses (e.g., Dark Herring). To address these issues, AI-based forensic tools are crucial for investigating security incidents, but their accuracy depends on high-quality mobile malware datasets. While dynamic analysis has limitations, recent research has shifted towards static analysis and AI-based methods for malware detection. However, there are three key challenges: lack of reproducibility, low dataset quality, and bias in AI datasets. This paper focuses on an overlooked bias—the incorrect API Level distribution in malware datasets. Such bias skews AI detection results, making them appear effective in tests but less applicable in real-world scenarios. To highlight the importance of dataset quality, three case studies on API Level Analysis were conducted, showing how biased datasets can distort detection results. To address this, the paper introduces methods and terms like Delayed Interception, Dataset of guaranteed quality, API Milestones, AndroBank, and Sample Unification, which aim to enhance dataset reliability and improve AI-based mobile malware detection.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_90528_6_11,
  title = {Technical Countermeasures Against Drone Communication Vulnerabilities},
  author = {Park, Wonhyung and Lee, Hoo-Ki},
  booktitle = {Studies in Computational Intelligence},
  year = {2022},
  pages = {119-129},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90528-6\_11},
  url = {https://doi.org/10.1007/978-3-030-90528-6\_11},
  abstract = {With the Fourth Industrial Revolution, the use of drones is rapidly expanding into various fields; drones are now available to a variety of consumers in the agricultural, industrial, security, firefighting, and private sectors. However, along with the proliferation of various types of drones, there has been an upsurge in hacking resulting from a lack of security guidelines governing drone communication. In particular, the malicious hacking of airborne drones can escalate through extortions or crashes . Although many attempts at hacking drones have been scuttled, there are no clear guidelines on how to respond in such situations. In this study, we examine countermeasures against drone communication (Wi-Fi, Bluetooth, and GPS) vulnerabilities.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_89360_5_9,
  title = {AnGSL: Graph-Based Android Malware Detection Method},
  author = {Zhao, Guodong and Luktarhan, Nurbol and Mei, Yihe and Meng, Yi and Yang, Xiaotong},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2025},
  pages = {146-161},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-89360-5\_9},
  url = {https://doi.org/10.1007/978-3-031-89360-5\_9},
  abstract = {In the era of widespread use of smartphones, researchers have been exploring new detection methods to cope with the threat of constantly upgrading Android malware. With the emergence of graphical neural networks, people’s interest in using this technology to detect Android malware has surged. However, external connections between Android malware are often overlooked, and the graph structure is filled with redundant information. To address these challenges, this article introduces AnGSL, a graph based method designed specifically for Android malware detection. This method first uses the MTF-IDF algorithm to extract feature entities, and then calculates the Euclidean distance between the feature vectors of two Android applications to determine whether there are edges between them. Subsequently, two subgraphs were constructed using the K-nearest neighbor and diffusion matrix algorithms, and optimized and merged to obtain the final graph structure. Finally, by minimizing the cross entropy loss between the subgraph and the optimized graph, a contrastive learning method is used to train the model. Experimental evaluations conducted on publicly available Android datasets showed a detection accuracy of 98.24\%. Research has shown that compared with previous model methods, the method proposed in this paper has a certain degree of performance improvement, indicating that graph based Android malware detection has broad potential and prospects in the research field.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_58768_0_14,
  title = {Sound C Code Decompilation for a Subset of x86-64 Binaries},
  author = {Verbeek, Freek and Olivier, Pierre and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {247-264},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-58768-0\_14},
  url = {https://doi.org/10.1007/978-3-030-58768-0\_14},
  abstract = {We present FoxDec: an approach to C code decompilation that aims at producing sound and recompilable code. Formal methods are used during three phases of the decompilation process: control flow recovery, symbolic execution, and variable analysis. The use of formal methods minimizes the trusted code base and ensures soundness: the extracted C code behaves the same as the original binary. Soundness and recompilablity enable C code decompilation to be used in the contexts of binary patching, binary porting, binary analysis and binary improvement, with confidence that the recompiled code’s behavior is consistent with the original program. We demonstrate that FoxDec can be used to improve execution speed by recompiling a binary with different compiler options, to patch a memory leak with a code transformation tool, and to port a binary to a different architecture. FoxDec can also be leveraged to port a binary to run as a unikernel, a minimal and secure virtual machine usually requiring source access for porting.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_025_00565_1,
  title = {REcover: towards recovering object files from stripped binary executables},
  author = {Karamitas, Chariton and Kehagias, Athanasios},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2025},
  volume = {21},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-025-00565-1},
  url = {https://doi.org/10.1007/s11416-025-00565-1},
  abstract = {Abstract Reverse engineering complex proprietary software is a tedious and time consuming task. A fair amount of the overall effort is usually devoted to locating those software components which are responsible for the functionality of interest (e.g., a proprietary encryption algorithm). To aid this process, several tools, available in the public domain, can be used, implementing sophisticated algorithms for control-flow recovery, stack frame recovery, data type inference, decompilation etc. However, the important problem of decomposing a binary executable to its constituent object files (or compile-units) has not been, in our opinion, sufficiently studied. In this paper we present novel techniques for estimating the number, as well as the boundaries, of compile-units in binary executables. We present algorithms which recover information that improves the precision degree in reverse engineering tasks. In addition, our algorithms can be used to reduce the effort of locating, recovering and understanding specific functionalities of closed-source software. We evaluate our algorithms on the public DeepBinDiff ELF dataset, consisting of \$\$\\approx\$\$ 2000 binaries, as well as two larger executables of GNU GDB, built for ARM and AArch64 and show that they consistently approach the ground-truth, with an average recovery precision close to 75\%. Furthermore, we show how our research can aid in binary diffing applications, by comparing the recovered compile-unit structure of a pair of Microsoft Windows kernel images. We make our prototype implementation, written in Python and named REcover , publicly available for further evaluation by the reverse engineering community.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_57259_3_15,
  title = {First Steps towards Deductive Verification of LLVM IR},
  author = {van Oorschot, Dré and Huisman, Marieke and Şakar, Ömer},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {290-303},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-57259-3\_15},
  url = {https://doi.org/10.1007/978-3-031-57259-3\_15},
  abstract = {Abstract Over the last years, deductive program verifiers have substantially improved, and their applicability on non-trivial applications has been demonstrated. However, a major bottleneck is that for every new programming language, a new deductive verifier has to be built. This paper describes the first steps in a project that aims to address this problem, by language-agnostic support for deductive verification: Rather than building a deductive program verifier for every programming language, we develop deductive program verification technology for a widely-used intermediate representation language (LLVM IR), such that we eventually get verification support for any language that can be compiled into the LLVM IR format. Concretely, this paper describes the design of VCLLVM, a prototype tool that adds LLVM IR as a supported language to the VerCors verifier. We discuss the challenges that have to be addressed to develop verification support for such a low-level language. Moreover, we also sketch how we envisage to build verification support for any specified source program that can be compiled into LLVM IR on top of VCLLVM.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_4717_1_22,
  title = {A Survey on Smart Contract Vulnerabilities Including Auditing Tools},
  author = {Das, Sayan and Arsh, Aditya and Pattanaik, Chinmaya Bikram and Kar, Nirmalya},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2023},
  pages = {237-246},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-4717-1\_22},
  url = {https://doi.org/10.1007/978-981-99-4717-1\_22},
  abstract = {Ethereum is an open-source global computing peer-to-peer network that lets users code and executes Smart Contracts. Security incidents involving smart contracts have caused significant monetary losses. Attacks have increased since Cryptocurrencies have become accessible to the general public. In this chapter, we present a comprehensive report on the kind of attacks possible in Smart Contracts. Also, we give best practices while coding Smart Contracts and discuss possible solutions to these vulnerabilities. The rise of Smart Contract coding exploits has been the motivation behind this survey. The development of Auditing Tools for Smart Contracts has attracted the attention of many researchers. We have discussed several of these auditing tools which successfully detect and prevent vulnerabilities in Smart Contracts.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_022_00434_1,
  title = {Application of the SAMA methodology to Ryuk malware},
  author = {Masid, Ander Granado and Higuera, Javier Bermejo and Higuera, Juan-Ramón Bermejo and Montalvo, Juan Antonio Sicilia},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2022},
  volume = {19},
  number = {2},
  pages = {165-198},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-022-00434-1},
  url = {https://doi.org/10.1007/s11416-022-00434-1},
  abstract = {Malware analysis is an essential discipline for understanding the nature, attack vectors, and weaknesses of systems to combat the threats that emerge every day in the IT security world. To this end, a malware analysis methodology can facilitate and improve an otherwise complex, chaotic, and relatively inefficient process, optimising the results obtained and the productivity of the analysis. To prove the effectiveness of a malware analysis methodology, it is necessary to test it on relevant specimens. The aim of this paper is, on one hand, to test and demonstrate the value of the SAMA methodology as a systematic process for analysing malware with a real and significant use case and, on the other hand, to show, explain and put into practice several actual malware analysis techniques and tools using a real and relevant use case. The analysis process carried out with the methodology shows its ability to guide a malware analysis process as well as its flexibility to adapt the techniques according to the findings obtained during the process.},
  content_type = {Article},
}


@article{springer_10_1007_s10515_025_00531_7,
  title = {Enhancing search-based testing with LLMs for finding bugs in system simulators},
  author = {Dakhama, Aidan and Even-Mendoza, Karine and Langdon, W. B and Menéndez, Héctor D. and Petke, Justyna},
  journal = {Automated Software Engineering},
  year = {2025},
  volume = {32},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-025-00531-7},
  url = {https://doi.org/10.1007/s10515-025-00531-7},
  abstract = {Abstract Despite the wide availability of automated testing techniques such as fuzzing, little attention has been devoted to testing computer architecture simulators. We propose a fully automated approach for this task. Our approach uses large language models (LLM) to generate input programs, including information about their parameters and types, as test cases for the simulators. The LLM’s output becomes the initial seed for an existing fuzzer, , which has been enhanced with three mutation operators, targeting both the input binary program and its parameters. We implement our approach in a tool called . We use it to test the system simulator. discovered 21 new bugs in , 14 where ’s software prediction differs from the real behaviour on actual hardware, and 7 where it crashed. New defects were uncovered with each of the 6 LLMs used.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_97087_1_3,
  title = {Assessing the Robustness of an Image-Based Malware Classifier with Smali Level Perturbations Techniques},
  author = {Iadarola, Giacomo and Martinelli, Fabio and Santone, Antonella and Mercaldo, Francesco},
  booktitle = {Advances in Information Security},
  year = {2022},
  pages = {69-84},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-97087-1\_3},
  url = {https://doi.org/10.1007/978-3-030-97087-1\_3},
  abstract = {Signature-based approaches adopted by current antimalware have well-known problems. Although they can provide relatively fast and reliable detection of previously known threats, they are not able to catch new malware and also generalize their knowledge to different variants of the same known malware. Deep learning approaches have been adopted to address this problem, and one of the most promising attempts is based on the representation of malware as images. In order to understand whether these approaches can be effectively adopted in a real-world situation, we trained an image-based malware detector and evaluate its resilience when morphed samples are considered. The experiments were conducted on 16384 real-world Android Malware, and the experimental analysis demonstrates that standard image-based malware classifiers are vulnerable to simple perturbations attacks.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_35251_5_13,
  title = {Generative Adversarial Networks for IoT Devices and Mobile Applications Security},
  author = {Chhaybi, Akram and Lazaar, Saiida and Hassine, Mohammed},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {145-151},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-35251-5\_13},
  url = {https://doi.org/10.1007/978-3-031-35251-5\_13},
  abstract = {With the rise in popularity of the Internet of Things (IoT) devices and smartphones, the number of mobile applications (apps) is rapidly increasing due to many factors like the low price of smartphones contributing significantly to the high acquisition rate, the capability for consumers to download and install a vast number of applications, tools etc. However, mobile applications present a whole world of security vulnerabilities, making them a prime target for hackers to spread malwares rapidly on smartphones and execute a variety of attacks. Therefore, mobile applications vulnerability detection and prevention solutions are becoming more advanced based on cover preventative techniques like static and dynamic analysis of the mobile applications and effective detection that uses new models of machine and deep learning techniques such as Generative Adversarial Networks (GANs) which are well suited for this type of problems. In this work, we will discuss the top ten mobile applications vulnerabilities with a focus on the main security challenges facing smartphone apps. We will present some solutions for securing the mobile applications based on GANs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_5974_7_28,
  title = {Review on the Static Analysis Techniques Used for Privacy Leakage Detection in Android Apps},
  author = {Verma, Manish and Nand, Parma},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2023},
  pages = {341-352},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-5974-7\_28},
  url = {https://doi.org/10.1007/978-981-99-5974-7\_28},
  abstract = {Android app market is growing very fast. Android phone contains a lot of user data and most of the apps access private data. Intentionally or unintentionally some apps leak the private data. Nowadays, protecting the private data is a major concern. Different techniques were used by the researchers for analysis and detection of privacy leakage by Android apps. These techniques were classified into three categories, namely, static, dynamic, and hybrid analysis. All three have their own advantages and limitations. Static analysis is based on investigation of code for the data leakage. Dynamic analysis examines the behavior of Android app at run time. Hybrid analysis is the amalgamation of static and dynamic techniques. This study provides state of overview of advancement in privacy leakage detection methods such as use of TF-IDF, AI, and ML (Peiravian and Zhu, Machine learning for android malware detection using permission and API calls. IEEE, pp. 300–305, 2013; Arslan et al. in Int J Software Eng Knowl Eng 29:43–61, 2019) techniques for the protection of private data.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_80825_9_7,
  title = {SCRUTINIZER: Detecting Code Reuse in Malware via Decompilation and Machine Learning},
  author = {Mirzaei, Omid and Vasilenko, Roman and Kirda, Engin and Lu, Long and Kharraz, Amin},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {130-150},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-80825-9\_7},
  url = {https://doi.org/10.1007/978-3-030-80825-9\_7},
  abstract = {Growing numbers of advanced malware-based attacks against governments and corporations, for political, financial and scientific gains, have taken security breaches to the next level. In response to such attacks, both academia and industry have investigated techniques to model and reconstruct these attacks and to defend against them. While such efforts have been all useful in mitigating the effects of modern attacks, automated malware code reuse inspection and campaign attribution have received less attention. In this paper, we present an automated system, called SCRUTINIZER , to identify code reuse in malware via a novel machine learning-based encoding mechanism at the function-level. By creating a large knowledge base of previously observed and tagged malware campaigns, we can compare unknown samples against this knowledge base and determine how much overlap exists. SCRUTINIZER leverages an unsupervised learning approach to filter out irrelevant functions before code reuse detection. It provides two valuable capabilities. First, it identifies ties between an unknown sample and those malware specimens that are known to be used by a specific campaign. Second, it inspects if specific tools or functionalities are used by a campaign. Using SCRUTINIZER , we were able to identify 12 samples that were previously unknown to us and that we were able to correctly assign to well-known APT campaigns.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_66245_4_13,
  title = {Unpacking Malware in the Real World: A Step-by Step Guide},
  author = {Totosis, Nikolaos and Patsakis, Constantinos},
  booktitle = {Advances in Information Security},
  year = {2025},
  pages = {299-331},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-66245-4\_13},
  url = {https://doi.org/10.1007/978-3-031-66245-4\_13},
  abstract = {The constant arms race between malware authors and defenders has significantly raised the bar for both sides in terms of sophistication. One of the results of the above is that the bulk of modern malware comes in an obfuscated and packed form, armoured with several anti-analysis features. This is to prevent, or at least delay, their analysis, extraction of generic signatures, or even understanding of their capabilities. Thus, simply relying on automated processes and static analysis is not enough. The malware analyst must be able to remove such protection layers from a binary under investigation and examine the core functionality of the malware. This requires a lot of low-level manual effort. To this end, the goal of this chapter is to serve as a guide for potential analysts into how they can manually analyse a malicious sample, protected by a packer, and dump the malicious family payload locally for further research using as baseline a real-world malware.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_63126_9_16,
  title = {Team DESCARTES and DARPA’s Cyber Grand Challenge},
  author = {Lee, Newton},
  booktitle = {Counterterrorism and Cybersecurity},
  year = {2024},
  pages = {507-545},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-63126-9\_16},
  url = {https://doi.org/10.1007/978-3-031-63126-9\_16},
  abstract = {On June 3, 2014, DARPA (Defense Advanced Research Projects Agency) kicked off the first-ever Cyber Grand Challenge. DARPA project manager Mike Walker and Naval Postgraduate School (NPS) lecturer Chris Eagle announced on reddit (1):},
  content_type = {Chapter},
}


@article{springer_10_1007_s10586_025_05624_2,
  title = {Comprehensive AI-driven privacy risk assessment in mobile apps and social networks},
  author = {Blanco-Aza, Daniel and Robles-Gómez, Antonio and Pastor-Vargas, Rafael and Tobarra, Llanos and Vidal-Balboa, Pedro and Méndez-Suárez, Mariano},
  journal = {Cluster Computing},
  year = {2025},
  volume = {28},
  number = {14},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-025-05624-2},
  url = {https://doi.org/10.1007/s10586-025-05624-2},
  abstract = {Abstract The pervasive use of mobile applications and social networks has intensified privacy concerns due to the widespread collection, processing, and sharing of personal data. To address these challenges, we introduce SafeMountain , a novel AI-driven framework designed to systematically quantify, evaluate, and visualize privacy risks in mobile apps and social platforms, ensuring strict compliance with international regulations, particularly the General Data Protection Regulation (GDPR). SafeMountain combines static and dynamic code analyses to scrutinize real-world data handling practices and detect potential privacy breaches. It also employs advanced Natural Language Processing (NLP) techniques for automated interpretation and evaluation of privacy policies and Terms of Service. By mapping textual policy disclosures to actual app permissions and behaviors, it identifies discrepancies and highlights potential non-compliance and data misuse. The framework introduces an objective risk scoring mechanism aligned with international standards and regulatory requirements, offering a structured methodology to classify and visualize privacy risks. This risk assessment spans multiple dimensions (predictability, manageability, and disassociability) leveraging privacy engineering principles and regulatory risk factors, and uses an intuitive traffic-light system (Green, Yellow, Red) to enhance transparency and user comprehension. SafeMountain addresses major research gaps, notably the absence of standardized privacy risk scoring and comprehensive visualization tools. By delivering actionable insights into permission consistency, policy transparency, compliance gaps, and data leakage vulnerabilities, it empowers users, developers, and organizations to manage privacy risks proactively. Ultimately, SafeMountain fosters trust through more transparent and accountable data privacy practices across digital ecosystems.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_99_0838_7_65,
  title = {CFG Analysis for Detecting Vulnerabilities in Smart Contracts},
  author = {Yadav, Karishma and Naval, Smita},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {753-763},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-0838-7\_65},
  url = {https://doi.org/10.1007/978-981-99-0838-7\_65},
  abstract = {Smart contracts are a leading light moment in blockchain technology 2.0 and are universally used in various applications. A smart contract is a digital agreement for financial transactions. A logical or syntactical error in the smart contract will breach the system’s security. However, smart contracts are not always secure, and numerous flaws exist and cannot be modified due to the immutability feature of smart contracts. The most critical problems for smart contracts are vulnerabilities, resulting in massive financial losses. As a result, extensive research should be conducted before installing a smart contract. Despite the fact that numerous methods for detecting vulnerabilities have been proposed in previous research, all of them have a high false positive and false negatives. To address these issues, Ethersolve, a method based on symbolic execution at the EVM bytecode level, was used to analyze the strategies. A static analysis method based on the symbolic implementation of the Ethereum operand stack to settle Ethereum bytecode jumps and establish an accurate control-flow graph (CFG) of the accumulated smart contracts. Here we analyze the CFG of smart contracts using Ethersolve tool. And then weigh the benefits and drawbacks of Ethersolve and present our findings.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_28124_2_37,
  title = {A Critical-Path-Based Vulnerability Detection Method for tx.origin Dependency of Smart Contract},
  author = {Zhao, Hui and Tan, Jiacheng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {393-402},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-28124-2\_37},
  url = {https://doi.org/10.1007/978-3-031-28124-2\_37},
  abstract = {Smart contracts are one of the most successfully applied technologies on the blockchain, which are decentralized and immutable. Smart contracts cannot be modified once deployed. Therefore, security detection of smart contracts before deployment is essential. Some smart contracts may have tx.origin dependency vulnerabilities. In this paper, we propose a critical path vulnerability detection method for detecting tx.origin dependency vulnerabilities in smart contracts. Then, in order to solve the problem that the traditional search algorithm cannot determine the critical path, we propose a path determination method based on path priority. Our method determines the critical path in the control flow graph, which enables us to detect the vulnerabilities existing in smart contracts more quickly. The experimental results show that our method is more efficient than the existing technology and the false positive rate is lower.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42979_025_04608_8,
  title = {Robust Android Malware Detection: Leveraging Generative Transformer-Based Feature Extraction and Hybrid Optimization Techniques},
  author = {Veeresh, K. M. and Naik, Bhukya Ramesh},
  journal = {SN Computer Science},
  year = {2025},
  volume = {7},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42979-025-04608-8},
  url = {https://doi.org/10.1007/s42979-025-04608-8},
  abstract = {The growth of Android devices has increased the chance of malware attacks, and conventional detection techniques are inadequate in dealing with obfuscation, zero-day attacks, and new families of malware. Strong detection frameworks are needed to identify informative features and classify sophisticated malware behaviour precisely. Introduce a hybrid Android malware classifier model integrating generative transformer-based N-tuple contrastive learning for feature representation with a new Quantum Support Red Piranha Vector Regression (QSRPVR) method for accurate classification. The transformer part is able to learn deep semantic patterns, and the N-tuple contrastive learning strengthens feature discriminability and generalizability. The QSRPVR classifier utilizes quantum kernel estimation and Red Piranha optimization for the best feature selection and accurate regression. The method combines static and dynamic analysis for end-to-end behavioural profiling. Experimental results on four benchmark datasets, Drebin, AndroZoo, AMD, and VirusShare, prove the better performance of the model. The method proved to be 99.8\% accurate on Drebin and AndroZoo, and 99.78\% on AMD and VirusShare datasets. The system proves to be highly robust to obfuscation attacks and exhibits generalizability across malware variants. This research introduces a strong and resilient Android malware detection system that blends deep generative learning with hybrid quantum optimization. The model improves detection strength, evasion robustness, and practicality in securing Android ecosystems.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_0336_6_4,
  title = {APK},
  author = {Nu1L Team},
  booktitle = {Handbook for CTFers},
  year = {2022},
  pages = {269-293},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-0336-6\_4},
  url = {https://doi.org/10.1007/978-981-19-0336-6\_4},
  abstract = {In CTFs, the number of Android challenges is generally small, and they usually fall into Misc and Reverse categories. The former usually tries to conceal data based on the characteristics of the system to test the participant’s understanding of Android. The latter mainly examines the player’s ability to reverse Java or C/C++ codes. Challenge designers will often apply obfuscation (ollvm, etc.), reinforcement, anti-debugging, and other techniques to increase the difficulty of reversing the application. These challenges often require participants to be familiar with common debugging and reversing tools, and to know common anti-debugging and shelling methods.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11219_022_09602_4,
  title = {Predicting Android malware combining permissions and API call sequences},
  author = {Chen, Xin and Yu, Haihua and Yu, Dongjin and Chen, Jie and Sun, Xiaoxiao},
  journal = {Software Quality Journal},
  year = {2023},
  volume = {31},
  number = {3},
  pages = {655-685},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11219-022-09602-4},
  url = {https://doi.org/10.1007/s11219-022-09602-4},
  abstract = {Malware detection is an important task in software maintenance. It can effectively protect user information from the attack of malicious developers. Existing studies mainly focus on leveraging permission information and API call information to identify malware. However, many studies pay attention to the API call without considering the role of API call sequences. In this study, we propose a new method by combining both the permission information and the API call sequence information to distinguish malicious applications from benign applications. First, we extract features of permission and API call sequence with a decompiling tool. Then, one-hot encoding and Word2Vec are adopted to represent the permission feature and the API call sequence feature for each application, respectively. Based on this, we leverage Random Forest (RF) and Convolutional Neural Networks (CNN) to train a permission-based classifier and an API call sequence-based classifier, respectively. Finally, we design a linear strategy to combine the outputs of these two classifiers to predict the labels of newly arrived applications. By an evaluation with 15,198 malicious applications and 15,129 benign applications, our approach achieves 98.84\% in terms of precision, 98.17\% in terms of recall, 98.50\% in terms of F1-score, and 98.52\% in terms of accuracy on average, and outperforms the state-of-art method Malscan by 2.12\%, 0.27\%, 1.20\%, and 1.24\%, respectively. In addition, we demonstrate that the method combining two features achieves better performance than the methods based on a single feature.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_032_06161_4_13,
  title = {Proposal of Android Malware Detection Method Based on Component Graphs},
  author = {Hirayama, Kai and Kodama, Eiichiro and Bista, Bhed Bahadur and Wang, Jiahong and Takata, Toyoo},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2026},
  pages = {130-140},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-06161-4\_13},
  url = {https://doi.org/10.1007/978-3-032-06161-4\_13},
  abstract = {Many malware detection methods have been developed for Android. One way is to detect Android malware by representing Android applications (hereinafter, “apps”) as a method call graph. However, there are cases where common libraries are included in the analysis target, and if these libraries are also included in the graph, the detection accuracy is affected and also graph size is unnecessarily large because they represent behaviors that do not occur in the original application. One way to deal with common libraries is to add them to a white list and exclude them from analysis, but since there are many common libraries, it is difficult to exclude all of them in practice. In this study, we define two types of component graphs, devise an algorithm for generating component graphs, and propose an Android malware detection method using component graphs in order to improve the detection rate of Android malware. To confirm whether component graphs are effective for malware detection, we used graph neural networks as a classification algorithm and conducted experiments to evaluate the accuracy of Android malware detection using component graphs and method call graphs. The results showed that our proposed method using component graphs, which are much smaller graphs than method call graphs, succeeded in detecting malware with 96.18\% accuracy, which is comparable with that of method call graphs.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_97_1459_9_4,
  title = {AI-Based Android Malware Detection Methods},
  author = {Niu, Weina and Zhang, Xiaosong and Yan, Ran and Gong, Jiacheng},
  booktitle = {Android Malware Detection and Adversarial Methods},
  year = {2024},
  pages = {55-93},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1459-9\_4},
  url = {https://doi.org/10.1007/978-981-97-1459-9\_4},
  abstract = {With the support of artificial intelligence technology, the integration of program analysis techniques and machine learning algorithms has gradually emerged as a research hotspot in intelligent malware detection methods. Specifically, this chapter will elaborate on various detection methodologies, categorized by their distinct feature extraction methods, analysis approaches, and vectorization techniques post feature extraction. These include detection methods based on permissions, APIs, and components; dynamic runtime feature-based detection methods; code semantics-based detection methods; image-based detection methods; and graph analysis-based detection methods.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_16_0965_7_4,
  title = {AndroHealthCheck: A Malware Detection System for Android Using Machine Learning},
  author = {Agrawal, Prerna and Trivedi, Bhushan},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2021},
  pages = {35-41},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-0965-7\_4},
  url = {https://doi.org/10.1007/978-981-16-0965-7\_4},
  abstract = {With the boom of malware, the area of malware detection and the use of gadget assist to gain knowledge in research drastically with the aid of researchers. The conventional methods of malware detection are incompetent to detect new and generic malware. In this article, a generic malware detection process is proposed using machine learning named AndroHealthCheck. The malware detection process is divided into four phases, namely android file collection, decompilation, feature mining and machine learning. The overall contributions made in AndroHealthCheck are as follows: (1) designing and implementing a crawler for automating the process of benign files download, (2) collection of unstructured data from the downloaded APK files through the decompilation process, (3) defining a proper mechanism for the feature selection process by performing a static analysis process, (4) designing and implementing a feature mining script for extracting the features from unstructured data collection from APK files, (5) generating a rich homemade data set for machine learning with a huge variety and different flavours of malware files from different families and (6) evaluating the performance of the generated data set by using different types of supervised machine learning classifiers. In this article, the overall architecture and deployment flow of AndroHealthCheck are also discussed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_8976_8_46,
  title = {A Convertor Tool to Transform the Android Mobile Application into Java Codes for Software Testing},
  author = {Ibrahim, Rosziati and Madon, Mizani Mohamad and Lee, Zhiang Yue and Jamel, Sapiee and Shahbodin, Faaizah},
  booktitle = {Algorithms for Intelligent Systems},
  year = {2024},
  pages = {555-564},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-8976-8\_46},
  url = {https://doi.org/10.1007/978-981-99-8976-8\_46},
  abstract = {Software testing is an important phase under the development of any software. It is crucial to be able to test the software before it can be used by users. This paper discusses the convertor tool that is first used to convert the mobile application into Java source codes. Then software testing is done by using Eclipse Plug-in Tool (EPiT) to generate test cases automatically. The Java Unit (Junit) testing framework is also used for to generate the test cases. Then both EPiT and JUnit are used for comparison purpose of the time taken to generate the test cases.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_7273_8_34,
  title = {Binary Slice-Level Vulnerability Detection with xLSTM-Based Models: Enhancing Long-Term Semantic Capture},
  author = {Yin, Peng and Ke, Yekun and Wang, Qi and Tao, Wenxin and Hou, Fangyuan and Liu, Yiwei and Su, Xiaohong},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2026},
  pages = {401-411},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-7273-8\_34},
  url = {https://doi.org/10.1007/978-981-96-7273-8\_34},
  abstract = {Binary program vulnerability detection is an important issue in the field of software security. Most of the existing deep learning vulnerability detection methods for binary programs are based on RNN networks or transformer architectures. Due to the characteristic of short length of assembly instruction but long length of instruction sequence, traditional RNNs may encounter gradient vanishing or exploding problems, making it difficult to capture long-term dependencies when dealing with long sequences. Transformer architecture, although it has excellent performance, has high computational complexity, which leads to inefficient detection. In this work, we propose a new binary program code vulnerability detection method that employs a staged code representation architecture and a novel xLSTM model. The staged code representation architecture combines instruction coding network and program coding network to capture long-term dependencies vulnerable instructions, thus improving binary program vulnerability detection performance. The xLSTM improves the performance of binary program vulnerability detection with low resource overhead. Our method achieves the highest F1-meansure and recall compared with the SOTA methods. Our method can achieve comparable performance of transformers architecture with reduced resource overhead. These results demonstrate the advantages of our approach for binary program vulnerability detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_61231_2_17,
  title = {Experimental Toolkit for Manipulating Executable Packing},
  author = {D’Hondt, Alexandre and Van Ouytsel, Charles Henry Bertrand and Legay, Axel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {263-279},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-61231-2\_17},
  url = {https://doi.org/10.1007/978-3-031-61231-2\_17},
  abstract = {Executable packing is a well-known problematic especially in the field of malware analysis. It often consists in applying compression or encryption to a binary file and embedding a stub for reversing these transformations at runtime. This way, the packed executable is more difficult to reverse-engineer and/or is obfuscated, which is effective for evading static detection techniques. Many detection approaches, including machine learning, have been proposed in the literature so far, but most studies rely on questionable ground truths and do not provide any open implementation, making the comparison of state-of-the-art solutions tedious. We thus think that first solving the issue of repeatability shall help to compare existing executable packing static detection techniques. Given this challenge, we propose an experimental toolkit, named Packing Box, that leverages automation and containerization in an open source platform that brings a unified solution to the research community. We present our engineering approach for designing and implementing our solution. We then showcase it with a few basic experiments, including a performance evaluation of open source static packing detectors and training a model with machine learning pipeline automation. This introduces the toolset that will be used in further studies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_39828_5_20,
  title = {Security Analysis of Mobile Point-of-Sale Terminals},
  author = {Mehr Nezhad, Mahshid and Laidlaw, Elliot and Hao, Feng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {363-384},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-39828-5\_20},
  url = {https://doi.org/10.1007/978-3-031-39828-5\_20},
  abstract = {The increasing prevalence of Card Present (CP) transactions has driven the growth of mobile Point-of-Sale (mPoS) terminals. These compact, wireless, and low-cost terminals allow merchants to process transactions conveniently by utilizing a mobile phone. In this paper, we analyze the security implications of mPoS terminals with a focus to study the merchants’ mobile phones as a key component in the mPoS ecosystem. Our examination covers the security aspects of the mobile phone’s communication with the mPoS terminal and the payment provider server, and also the security risks in the mobile phone application itself. We perform an eavesdropping attack to reveal the cryptographic keys in the BLE (Bluetooth Low Energy) communication between the mPoS terminal and the merchant phone, execute a man-in-the-middle (MITM) attack to tamper with the mPoS terminal messages transmitted between the mPoS terminal and the payment provider server, and reverse engineer the mobile phone application to disable the security features that are controlled by the mobile phone.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_96648_5_7,
  title = {XtraLibD: Detecting Irrelevant Third-Party Libraries in Java and Python Applications},
  author = {Kapur, Ritu and Rao, Poojith U. and Dewam, Agrim and Sodhi, Balwinder},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {132-155},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-96648-5\_7},
  url = {https://doi.org/10.1007/978-3-030-96648-5\_7},
  abstract = {Software development comprises the use of multiple Third-Party Libraries (TPLs). However, the irrelevant libraries present in software application’s distributable often lead to excessive consumption of resources such as CPU cycles, memory, and modile-devices’ battery usage. Therefore, the identification and removal of unused TPLs present in an application are desirable. We present a rapid, storage-efficient, obfuscation-resilient method to detect the irrelevant-TPLs in Java and Python applications. Our approach’s novel aspects are i) Computing a vector representation of a .class file using a model that we call Lib2Vec. The Lib2Vec model is trained using the Paragraph Vector Algorithm. ii) Before using it for training the Lib2Vec models, a .class file is converted to a normalized form via semantics-preserving transformations. iii) A e Xtra Lib rary D etector (XtraLibD) developed and tested with 27 different language-specific Lib2Vec models. These models were trained using different parameters and >30,000 .class and >478,000 .py files taken from >100 different Java libraries and 43,711 Python available at MavenCentral.com and Pypi.com, respectively. XtraLibD achieves an accuracy of 99.48\% with an F1 score of 0.968 and outperforms the existing tools, viz., LibScout, LiteRadar, and LibD with an accuracy improvement of 74.5\%, 30.33\%, and 14.1\%, respectively. Compared with LibD, XtraLibD achieves a response time improvement of 61.37\% and a storage reduction of 87.93\% (99.85\% over JIngredient). Our program artifacts are available at https://www.doi.org/10.5281/zenodo.5179747 .},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_64626_3_3,
  title = {Slicing Assisted Program Verification: An Empirical Study},
  author = {Chai, Wenjian and Yan, Rongjie and Zhang, Wenhui and Zhang, Jian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {38-57},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64626-3\_3},
  url = {https://doi.org/10.1007/978-3-031-64626-3\_3},
  abstract = {Simplifying programs before verification aims to reduce program complexity thus saving the verification effort. In the paper, we investigate the impacts of applying program slicing before verification. We consider various techniques and verifiers for the workflow and adopt benchmarks from the software verification community to evaluate the strengths and issues in adopting slicing techniques for program simplification. The evaluation considers reachability as the property to be verified and checks the consistency of verification results, the improvement of verification efficiency, and the advantages of different toolchains when verifying reachability. The investigation shows that most programs keep consistent verification results after slicing and verifying programs with much code unrelated to the properties becomes faster when slicing is applied before verification. However, it is surprising that verification time for some programs can be significantly longer after slicing. We have investigated the reasons for such phenomenon concerning the features of these programs, and provide insightful conclusions obtained from using the slicing+verification approach.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_34969_0_5,
  title = {Efficient Graph-Based Malware Detection Using Minimized Kernel and SVM},
  author = {Tsouvalas, Billy and Serpanos, Dimitrios},
  booktitle = {Security Informatics and Law Enforcement},
  year = {2024},
  pages = {91-117},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-34969-0\_5},
  url = {https://doi.org/10.1007/978-3-031-34969-0\_5},
  abstract = {Malware detection is a classification process that characterizes software samples as malicious or benign. Malware analysis extracts software sample features through static and/or dynamic methods and provides these features to classifiers. We present a static, graph-based method which creates API call graphs from executable samples and applies machine learning to classify them as malicious or benign. In our method, we extract the API calls that a sample makes to the operating system, we create an API call graph, and then, we construct a related abstract API call graph. Subsequently, we calculate a similarity measure of the abstract API call graph with the samples of a given dataset that includes labeled benign and malware samples. The similarity calculations are made using an efficient random walk graph kernel, which exploits constraints of the problem and leads to more efficient calculations relatively to the state of the art. Finally, we use a support vector machine (SVM) algorithm to divide the similarity vector space and perform classification. We evaluate our method for two different cases, unweighted and weighted abstract API call graphs, demonstrating achievement of more than 99.15\% accuracy and outperforming current methodologies accuracies by employing the weighted abstract API call graph.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10586_024_04530_3,
  title = {Efficient malware detection through inter-component communication analysis},
  author = {Chen, Peng and Tian, Shengwei and Wang, Xin and Pei, Xinjun and Nong, Weitao and Zhang, Hao},
  journal = {Cluster Computing},
  year = {2024},
  volume = {27},
  number = {8},
  pages = {11667-11682},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-024-04530-3},
  url = {https://doi.org/10.1007/s10586-024-04530-3},
  abstract = {With the development of science and technology, the number of smartphones has increased dramatically. This also exposes Android-based smartphones to an increasing number of malware attacks. Currently, feature extraction schemes based on sensitive API calls have become mainstream in malware detection. However, such an approach can only capture the behavior of malware when the API is called, but it cannot detect malicious behavior implemented through other means. In the real world, attackers often use the Inter-Component Communication (ICC) mechanism to hide and conceal their malicious intent. In this paper, we propose a novel malware detection framework (named ADACapsNet). This framework first employs an entropy-based approach to extract sensitive API features to reflect the behavior patterns of malware and then captures the information flow across components by monitoring the ICC interactions in the Android systems. We transform sensitive API calls and ICC features into vector representations that are used as inputs to the learning model. Moreover, we propose an adaptive capsule network to mine deep program semantics, which uses an adaptive factor to dynamically assign weights for features, enhancing the model’s ability to focus on relevant features and capture complex spatial relationships. We conducted a number of experiments to demonstrate the effectiveness of the proposed ADACapsNet in detecting malware. Experimental results show that the proposed method is robust against malware attacks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_97620_9_16,
  title = {Poster: All Right Then, (Don’t) Keep Your Secrets: Exposing API Hashing in Malware},
  author = {Bottura, Nicola and Di Pietro, Giorgia and Yamada, Yuya and D’Elia, Daniele Cono and Querzoni, Leonardo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {287-293},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97620-9\_16},
  url = {https://doi.org/10.1007/978-3-031-97620-9\_16},
  abstract = {Modern malware employs disparate anti-analysis techniques to complicate analysis attempts. Among them, API hashing conceals the identity of imported library functions—key indicators for understanding malware behavior—by replacing their standard names with hashed values. Currently, resolving these obfuscated calls relies heavily on manual expertise and community-maintained hash repositories, both of which are time-consuming and difficult to scale. In this work, we explore an automated approach to deobfuscate API hashing. By leveraging dynamic program analysis, we identify and map hash values back to their original function names while also extracting information about the hashing scheme. Our method can then use malware itself as a “hash oracle”, enabling on-demand resolution of standard function names through the malware’s hashing logic, enabling automatic updates of repositories.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_36096_1_1,
  title = {Computer-Aided Reverse Engineering of Protected Software},
  author = {Canavese, Daniele and Regano, Leonardo and Lioy, Antonio},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {3-15},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-36096-1\_1},
  url = {https://doi.org/10.1007/978-3-031-36096-1\_1},
  abstract = {Reverse engineering is undoing or circumventing the protections deployed on a code region. Software crackers perform this to remove license checks in commercial applications and video games, but it can also be done for legitimate purposes. Many software houses perform a security assessment phase by reverse engineering their protected software before releasing it to the market. Furthermore, anti-virus experts need to reverse engineering malware (e.g., viruses and ransomware) to understand how it works and spreads. Typically, reverse engineering is performed by hand with minimal computer support with debuggers, decompilers, and disassemblers. Nevertheless, in recent years, new research directions have proposed various promising automatic methods, primarily based on machine learning and symbolic execution techniques.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_3480_7_5,
  title = {USCSafe: Identifying Permission Vulnerabilities in Upgradeable Smart Contracts},
  author = {Chen, Junjia and Zhong, Zhijie and Zhou, Yuren},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {61-78},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-3480-7\_5},
  url = {https://doi.org/10.1007/978-981-95-3480-7\_5},
  abstract = {To improve the maintainability and upgradeability of smart contracts, many developers use upgradeable contracts. However, this introduces new security risks, as the complex implementation mechanisms can become targets for attackers. Typically, the logical contract linked to a proxy contract is verified via Etherscan, requiring public source code. In this paper, we propose a method for identifying the logical contract of a proxy through historical transaction records, eliminating the need for source code. Additionally, we developed USCSafe, a tool that detects upgradeable permission vulnerabilities by combining taint analysis with permission constraint analysis. We evaluated USCSafe on a public real-world proxy contract dataset and found that it outperformed existing detection tools by detecting more upgradeable smart contract permission vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_45137_9_4,
  title = {Explaining the Use of Cryptographic API in Android Malware},
  author = {Janovsky, Adam and Maiorca, Davide and Macko, Dominik and Matyas, Vashek and Giacinto, Giorgio},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {69-97},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-45137-9\_4},
  url = {https://doi.org/10.1007/978-3-031-45137-9\_4},
  abstract = {Cryptography allows for guaranteeing secure communications, concealing critical data from reverse engineering, or ensuring mobile users’ privacy. Android malware developers extensively leveraged cryptographic libraries to obfuscate and hide malicious behavior. Various system-based and third-party libraries provide cryptographic functionalities for Android, and their use and misuse by application developers have already been documented. This paper analyzes the use of cryptographic APIs in Android malware by comparing them to benign Android applications. In particular, Android applications released between 2012 and 2020 have been analyzed, and more than 1 million cryptographic API expressions have been gathered. We created a processing pipeline to produce a report to reveal trends and insights on how and why cryptography is employed in Android malware. Results showed that the usage of cryptographic APIs in malware differs from that made in benign applications. The different patterns in the use of cryptographic APIs in malware and benign applications have been further analyzed through the explanations of Android malware detectors based on machine learning approaches, showing how crypto-related features can improve detection performances. We observed that the transition to more robust cryptographic techniques is slower in Android malware than in benign applications.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s42400_023_00148_x,
  title = {Are our clone detectors good enough? An empirical study of code effects by obfuscation},
  author = {Huang, Weihao and Meng, Guozhu and Lin, Chaoyang and Yan, Qiucun and Chen, Kai and Ma, Zhuo},
  journal = {Cybersecurity},
  year = {2023},
  volume = {6},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-023-00148-x},
  url = {https://doi.org/10.1186/s42400-023-00148-x},
  abstract = {Abstract Clone detection has received much attention in many fields such as malicious code detection, vulnerability hunting, and code copyright infringement detection. However, cyber criminals may obfuscate code to impede violation detection. To date, few studies have investigated the robustness of clone detectors, especially in-fashion deep learning-based ones, against obfuscation. Meanwhile, most of these studies only measure the difference between one code snippet and its obfuscation version. However, in reality, the attackers may modify the original code before obfuscating it. Then what we should evaluate is the detection of obfuscated code from cloned code, not the original code. For this, we conduct a comprehensive study evaluating 3 popular deep-learning based clone detectors and 6 commonly used traditional ones. Regarding the data, we collect 6512 clone pairs of five types from the dataset BigCloneBench and obfuscate one program of each pair via 64 strategies of 6 state-of-art commercial obfuscators. We also collect 1424 non-clone pairs to evaluate the false positives. In sum, a benchmark of 524,148 code pairs (either clone or not) are generated, which are passed to clone detectors for evaluation. To automate the evaluation, we develop one uniform evaluation framework, integrating the clone detectors and obfuscators. The results bring us interesting findings on how obfuscation affects the performance of clone detection and what is the difference between traditional and deep learning-based clone detectors. In addition, we conduct manual code reviews to uncover the root cause of the phenomenon and give suggestions to users from different perspectives.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_4727_6_18,
  title = {Evaluating Security Risks and Protecting Conversational AI: An in-Depth Vulnerability Assessment and Security Testing of the ChatGPT Android Application},
  author = {Majeti, Srinadh Swamy and Shyam Prasad, T. and Thota, Sunil Kumar},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {177-181},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-4727-6\_18},
  url = {https://doi.org/10.1007/978-981-97-4727-6\_18},
  abstract = {Recent years have seen a surge in the popularity of conversational AI applications like ChatGPT, revolutionizing human–machine interactions. However, as these AI chat systems become more integrated into daily life, ensuring their security is paramount. This research paper conducts a thorough security assessment of ChatGPT, using static and dynamic testing. The study uncovers significant vulnerabilities, including potential data leaks and susceptibility to adversarial attacks, raising concerns about user privacy and potential exploitation. Recommendations for mitigation are provided to enhance ChatGPT's security. This research contributes to the growing body of knowledge on conversational AI security, stressing the importance of proactive measures to protect user data and maintain a secure conversational experience. It also highlights the necessity for ongoing security assessments as AI technology advances.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_88287_6_42,
  title = {Program Structure Defect Localization and Repair Methods in Software Security Reverse Analysis},
  author = {Li, Yan},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2025},
  pages = {444-452},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-88287-6\_42},
  url = {https://doi.org/10.1007/978-3-031-88287-6\_42},
  abstract = {In the field of software security, program structure defects are the main cause of system vulnerability and attack. Especially when the software is very complicated, bug localization and repair become particularly difficult. The aim of the article is to analyze reverse debugging, program structure defect mining, location and repair methods, and enhance the security and stability of software. The binary code is first processed through a combination of several reverse tools, static analysis tools SonarQube and Checkmax to find out potential program structure defects, and then pass the combination of dynamic symbol execution and fuzzy testing method to monitor the behavior of the program during runtime, in order to further verify defects found by static analysis, and to detect new defects generated during runtime. The effectiveness of the method is further evinced by an experiment using 100 open source software. In most cases, the detection rate of static analysis method for structure defects is 78\%, while dynamic analysis on the cloud actually confirms that 92\% of these defects are true, so reverse debugging fully satisfies the requirement of using the value stored in the register ESP of the local stack to locate the position on the reference source. After passing the run, the pass rate of software in security testing increases from 85\% to 95\%, indicating that the application of the method can increase the security and reliability of software. The integrated method can locate and repair buggy structure defects of a program, so that the software has fewer security flaws, and better quality.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11071_024_09322_3,
  title = {Occurrence of mixed-mode oscillations in a system consisting of a Van der Pol system and a Duffing oscillator with two potential wells},
  author = {Lyu, Weipeng and Li, Shaolong and Huang, Juanjuan and Bi, Qinsheng},
  journal = {Nonlinear Dynamics},
  year = {2024},
  volume = {112},
  number = {8},
  pages = {5997-6013},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11071-024-09322-3},
  url = {https://doi.org/10.1007/s11071-024-09322-3},
  abstract = {Mixed-mode oscillations (abbreviated as MMOs) belong to a typical kind of fast/slow dynamical behavior, and how to investigate the mechanism is an important problem in nonlinear dynamics. In this paper, we explore the MMOs induced by the bifurcation delay phenomenon and twist of the trajectories in space based on a coupled system consisting of a Van der Pol system and a Duffing oscillator with two potential wells. Regarding the low-frequency external excitation as a generalized state variable, we obtain the traditional fast and slow subsystems. Appling the equilibrium analysis and bifurcation theory, the stability critical conditions of the equilibrium and the generation conditions of fold and Hopf bifurcation are also presented. To analyze the critical conditions clearly, the two-parameter bifurcation and one-parameter bifurcation diagrams are performed by using numerical simulation method. The bifurcation characteristics are studied, especially the effects of parameter δ on the bifurcation structures. We find that the fast subsystem performs different dynamical behaviors such as fold bifurcation of limit cycles, period-doubling bifurcations, inverse-period-doubling bifurcations and chaos, when parameter δ is taken at different values. By using phase diagrams, time series, maximum Lyapunov exponent diagrams, three-dimensional phase diagrams and superimposed diagrams, the mechanisms of the MMOs are investigated numerically in detail. The Hopf bifurcation delay can lead the trajectories to arrive at the vector fields of the equilibrium point and limit cycles. In addition, the chaotic behaviors can be found on the route of period doubling, which lead to the chaotic spiking-state-oscillations types. Our findings are helpful to understand the generation of the MMOs and intensify the understanding of some special dynamical behaviors on the MMOs.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_95_6203_9_20,
  title = {Tracing Your Roots: Exploring the Security Issues of Root Certificates in Android TLS Connections},
  author = {Wei, Xinyu and Wang, Yuewu and Lei, Lingguang and Wang, Peng and Kou, Chunjing and Ma, Siyuan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {369-389},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-6203-9\_20},
  url = {https://doi.org/10.1007/978-981-95-6203-9\_20},
  abstract = {The widespread adoption of Transport Layer Security (TLS) relies on rigorous certificate verification, but our large-scale analysis reveals shocking security issues in the root certificates themselves and their configuration that undermine TLS authentication guarantees. This paper uncovers security issues at two distinct levels: (1) The default root certificate list on platforms ranging from Android 7 to 14 and HarmonyOS 3.0 to 5.0 contains non-compliant root certificates, such as those associated with critical CVE vulnerability, certificates expired for over four years, and those using weak cryptography algorithm. Overall, HarmonyOS 5.0 performs best, followed by Android 14. (2) We carefully select 1246 popular apps to view their actual usage of custom root certificates. 42\% of them have configuration issues with custom implementations, and some even enable HTTP communication, which indicates that while customizing root certificates provides convenience to users, it also introduces security risks. Finally, we evaluate the priority of root certificates from different sources to help users better understand the root certificates used by the current TLS connection. In general, both manufacturers and developers need to further improve their management and usage of root certificates.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_7238_7_18,
  title = {Aligning Declarations and Practices: Evaluating Privacy Policy Consistency with App Permissions Using Generative AI},
  author = {Duc, Trung Mai and Quoc, Bao Tran and Hong, Khanh Vo and Dang, Trinh Phung and Dang, Khoa Tran and Phu, Loc Van Cao and Thong, Trinh Duc and Minh, Triet Nguyen and Minh, Hieu Doan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {221-233},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-7238-7\_18},
  url = {https://doi.org/10.1007/978-981-96-7238-7\_18},
  abstract = {In an era where mobile app usage is intertwined with privacy concerns, this paper presents a groundbreaking approach in the realm of privacy protection through the alignment of app code and policy. Building upon the foundations laid by significant studies in privacy and preference management, risk assessment, and static analysis for security and malware detection, our research introduces an innovative method utilizing Generative AI (GenAI) for scrutinizing mobile applications. Specifically, our work focuses on detecting discrepancies between the permissions requested by an app and the stipulations within its privacy policy. This novel application of GenAI in static analysis enables a meticulous examination of both the language of privacy policies and the corresponding app codebase. Our methodology not only aids in identifying mismatches indicative of potential privacy risks and non-compliance with regulations like GDPR but also streamlines the process of auditing apps for GDPR compliance.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_7246_6_12,
  title = {What’s Next?},
  author = {Hooyberghs, Johnny},
  booktitle = {Introducing Microsoft Quantum Computing for Developers},
  year = {2022},
  pages = {341-353},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7246-6\_12},
  url = {https://doi.org/10.1007/978-1-4842-7246-6\_12},
  abstract = {Congratulations! You made it to the final chapter of this introductory book on quantum computing and the Microsoft Quantum Development kit.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_97_0811_6_15,
  title = {Malware Detection Method Based on Visualization},
  author = {Xie, Nannan and Liang, Haoxiang and Mu, Linyang and Zhang, Chuanxue},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {252-264},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-0811-6\_15},
  url = {https://doi.org/10.1007/978-981-97-0811-6\_15},
  abstract = {The rapid development of information technology and computer networks has led to the emergence of various new applications on both PC platforms and mobile devices. Malware continues to evolve and update, which often developing new variants or changing existing features to evade detection. Traditional feature based malware detection methods are limited in their ability to detect variants, and are computationally resource-intensive. Considering these issues, a new visualization-based and integrated malware detection method, Mal\_Vis, is introduced. It decompiles the application software and applies PCA to reduce the feature dimension, then visualises the decompiled data to greyscale and RGB image. A Stacking-based ensemble machine learning algorithm is used to classify the visualized images to detect malware. Experiments show the method achievs detection accuracy of 98.19\% and 93.03\% in the Windows and Android application software datasets.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_90567_5_23,
  title = {Mind the Scraps: Attacking Blockchain Based on Selfdestruct},
  author = {Chiu, Wei-Yang and Meng, Weizhi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {451-469},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90567-5\_23},
  url = {https://doi.org/10.1007/978-3-030-90567-5\_23},
  abstract = {A smart contract is a program that resides its binary code and states in blockchain to provide contract-like functionality. The binary code is unchangeable once it is deployed into the chain. This can ensure the underlying blockchain to be an append-only decentralized and secure database, but it may also bring potential threats. For example, Selfdestruct is a typical command used to disable a smart contract and clean all relevant information. It is believed that if an address of a deactivated contract is inaccessible, it is impossible for an attacker to explore. However, in this work, we identify that instead of erasing or overwriting the previously recorded data, the smart contract’s running environment may store its latest data and states in the latest block even after using Selfdestruct. Motivated by this observation, we show how these remained traces can reveal private information, i.e., how a privatized function can be externally accessed, and discuss how to attack the contract without knowing its application binary interface (ABI). In the end, we also discuss some potential solutions to protect information leakage in such scenario.},
  content_type = {Conference paper},
}


@article{springer_10_3103_s014641162207001x,
  title = {On the Characteristics of Symbolic Execution in the Problem of Assessing the Quality of Obfuscating Transformations},
  author = {Borisov, P. D. and Kosolapov, Y. V.},
  journal = {Automatic Control and Computer Sciences},
  year = {2022},
  volume = {56},
  number = {7},
  pages = {595-605},
  publisher = {Allerton Press},
  doi = {10.3103/s014641162207001x},
  url = {https://doi.org/10.3103/s014641162207001x},
  abstract = {Obfuscation is used to protect programs from analysis and reverse engineering. There are theoretically effective and resistant obfuscation methods, however, most of them are not implemented in practice yet. The main issues are the large overhead for the execution of obfuscated code and the limitation of application only to a specific class of programs. On the other hand, a large number of obfuscation methods have been developed that are applied in practice. The existing approaches to the assessment of such obfuscation methods are based mainly on the static characteristics of programs. Therefore, the comprehensive (taking into account the dynamic characteristics of programs) justification of their effectiveness and resistance is a relevant task. It seems that such a justification can be made using machine learning methods based on feature vectors that describe both static and dynamic characteristics of programs. In this paper, it is proposed to build such a vector on the basis of characteristics of two compared programs: the original and obfuscated, original and deobfuscated, obfuscated and deobfuscated. In order to obtain the dynamic characteristics of the program, a scheme based on a symbolic execution is constructed and presented in this paper. The choice of the symbolic execution is justified by the fact that such characteristics can describe the difficulty of comprehension of the program in dynamic analysis. This paper proposes two implementations of the scheme: extended and simplified. The extended scheme is closer to the process of analyzing a program by an analyst, since it includes the steps of disassembly and translation into intermediate code, while in the simplified scheme these steps are excluded. In order to identify the characteristics of symbolic execution that are suitable for assessing the effectiveness and resistance of obfuscation based on machine learning methods, experiments with the developed schemes were carried out. Based on the obtained results, a set of suitable characteristics is determined.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_1459_9_1,
  title = {Introduction of Android Malware Detection},
  author = {Niu, Weina and Zhang, Xiaosong and Yan, Ran and Gong, Jiacheng},
  booktitle = {Android Malware Detection and Adversarial Methods},
  year = {2024},
  pages = {3-19},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1459-9\_1},
  url = {https://doi.org/10.1007/978-981-97-1459-9\_1},
  abstract = {Android is currently the most popular mobile operating system with over 80\% market share. Android’s openness and flexibility provide users and developers with a wealth of features and choices, but it also poses many security risks, generating a large amount of malware that threatens users’ information security. Android malware (malware) refers to the use of Android system vulnerabilities or user negligence to carry out illegal or malicious behaviors, such as stealing user information, consuming resources, spreading viruses, and controlling devices. According to statistics, more than 150 million Android devices were infected with malware in 2023, causing huge economic losses and privacy leaks.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11227_023_05741_y,
  title = {ARdetector: android ransomware detection framework},
  author = {Li, Dan and Shi, Wenbo and Lu, Ning and Lee, Sang-Su and Lee, Sokjoon},
  journal = {The Journal of Supercomputing},
  year = {2024},
  volume = {80},
  number = {6},
  pages = {7557-7584},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-023-05741-y},
  url = {https://doi.org/10.1007/s11227-023-05741-y},
  abstract = {Ransomware has affected a broad range of public and private-sector organizations, and the impacts include direct and indirect financial loss (e.g., opportunity costs), reputational damage, legal implications, and physical consequences (e.g., fatalities). However, it has been challenging to accurately detect ransomware. For example, ransomware’s behavioral characteristics differ from many other malicious applications, and it can be laborious to obtain representative features that can be used for machine learning training. In addition, the issue of the imbalanced dataset of minority and majority classes complicates efforts for machine learning models to learn the internal patterns of minority classes. In an effort for tackling such difficulties, we suggest an architecture regarding Android ransomware detection (hereafter referred to as ARdetector), which allows one to analyze the relationship between behav oral characteristics and other candidate features associated with ransomware to select more representative features. In addition, we design a deep neural network based on focal loss, which lowers the loss generated by the majority class. In our evaluations, we use two real-world datasets of different class proportions, and the findings show that the accuracy of the ARdetector on both datasets is over 99.00\% when the imbalanced ratio is 6. Specifically, via the BMR dataset, the AUC as a synthetical categorizing assessment indicator reaches as high as 0.9625 at that ratio of 15.},
  content_type = {Article},
}


@article{springer_10_1007_s11036_023_02159_x,
  title = {APKOWL: An Automatic Approach to Enhance the Malware Detection},
  author = {Aboshady, Doaa and Ghannam, Naglaa E. and Elsayed, Eman K. and Diab, L. S.},
  journal = {Mobile Networks and Applications},
  year = {2023},
  volume = {28},
  number = {5},
  pages = {1901-1912},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11036-023-02159-x},
  url = {https://doi.org/10.1007/s11036-023-02159-x},
  abstract = {Abstract Malicious software (malware) can steal passwords, leak details, and generally cause havoc with users’ accounts. Most of the current malware detection techniques are designed to detect malware at the code level of the software, where it is actually infected and causes damage. Additionally, current malware detection techniques at the design level are done manually or semi-automatically. This research aims to enhance these methods to detect malware at the design level automatically with a big dataset. The proposed method presents an automatic system for detecting SMS (Short Message Service) malware at the design which is called APKOWL. It is based on reverse engineering of the mobile application and then automatically builds OWL (web ontology Language) ontology. The proposed system is implemented in python and Protégé, and its performance has been tested and evaluated on samples of android mobile applications including 3,904 malware and 3,200 benign samples. The experimental results successfully verify the effectiveness of the proposed method because it has good performance in detecting SMS malware at the software design level. The proposed method obtained an accuracy of 97\%, precision of 97.5\%, and recall of 99\%, outperforming the compared model in all performance metrics.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_024_10485_1,
  title = {A large-scale exploratory study on the proxy pattern in Ethereum},
  author = {Ebrahimi, Amir M. and Adams, Bram and Oliva, Gustavo A. and Hassan, Ahmed E.},
  journal = {Empirical Software Engineering},
  year = {2024},
  volume = {29},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-024-10485-1},
  url = {https://doi.org/10.1007/s10664-024-10485-1},
  abstract = {The proxy pattern is a well-known design pattern with numerous use cases in several sectors of the software industry (e.g., network applications, microservices, and IoT). As such, the use of the proxy pattern is also a common approach in the development of complex decentralized applications (DApps) on the Ethereum blockchain. A contract that implements the proxy pattern (proxy contract) acts as a layer between the clients and the target contract, enabling greater flexibility (e.g., data validation checks) and upgradeability (e.g., online smart contract replacement with zero downtime) in DApp development. Despite the importance of proxy contracts, little is known about (i) how their prevalence changed over time, (ii) the ways in which developers integrate proxies in the design of DApps, and (iii) what proxy types are being most commonly leveraged by developers. In this paper, we present a large-scale exploratory study on the use of the proxy pattern in Ethereum. We analyze a dataset of all Ethereum smart contracts as of Sep. 2022 containing 50M smart contracts and 1.6B transactions, and apply both quantitative and qualitative methods in order to (i) determine the prevalence of proxy contracts, (ii) understand the ways they are deployed and integrated into applications, and (iii) uncover the prevalence of different types of proxy contracts. Our findings reveal that 14.2\% of all deployed smart contracts are proxy contracts. We show that proxy contracts are being more actively used than non-proxy contracts. Also, the usage of proxy contracts in various contexts, transactions involving proxy contracts, and adoption of proxy contracts by users have shown an upward trend over time, peaking at the end of our study period. They are either deployed through off-chain scripts or on-chain factory contracts, with the former and latter being employed in 39.1\% and 60.9\% of identified usage contexts in turn. We found that while the majority (67.8\%) of proxies act as an interceptor, 32.2\% enables upgradeability. Proxy contracts are typically (79\%) implemented based on known reference implementations with 29.4\% being of type ERC-1167, a class of proxies that aims to cheaply reuse and clone contracts’ functionality. Our evaluation shows that our proposed behavioral proxy detection method has a precision and recall of 100\% in detecting active proxies. Finally, we derive a set of practical recommendations for developers and introduce open research questions to guide future research on the topic.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_95_2196_8_31,
  title = {AKdroid: Deep Learning Based-Android Malware Classification Using Markov Images and Text Messages},
  author = {Sondarva, Kumar and Kumar, Adarsh and Gohil, Bhavesh N. and Jinwala, Devesh C. and Patel, Sankita J.},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2026},
  pages = {463-471},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-2196-8\_31},
  url = {https://doi.org/10.1007/978-981-95-2196-8\_31},
  abstract = {Android malware uses images to display messages and threats, while the malware detection classification uses the AndroidManifest.xml, resources.arsc, and classes.dex files for malware classification and fails to detect such an app. To address this issue, we have presented a DL-based Android malware detection system that uses the features extracted from the three files and the text extracted from the image. In this paper, we have utilized the pre-trained model (Inceptionv3 and MobileNetV2) for feature extraction from RGB Markov images of the app. Then, we collected all the pictures in the app, extracted the text, and performed feature extraction. Our experiment shows that using the text extracted along with the Markov images increases the accuracy. On the Dataset, our accuracy reaches 98.97\% without data augmentation compared with the other method.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_6963_2_13,
  title = {A Multimedia Pipeline for Interactive Game Archaeology on the Example of Wolfenstein 3D in Godot Engine},
  author = {Kostka de Sztemberg, Berenika Nawoja and Żywica, Patryk},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {136-142},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-6963-2\_13},
  url = {https://doi.org/10.1007/978-981-95-6963-2\_13},
  abstract = {This work presents a multimedia pipeline for converting binary legacy game data into interactive 3D archaeological visualisations. Using Wolfenstein 3D (1992) as a case study, the system transforms proprietary binary formats into modern JSON representations and generates optimised 3D scenes in real-time using the Godot engine. This addresses a key challenge in software archaeology: making decades-old digital content accessible to contemporary researchers and the public while maintaining original spatial relationships and interactive potential. Unlike emulation-based preservation, this approach creates platform-independent, future-proof visualisations that evolve with modern multimedia technologies. The system enables exploration of historically significant game spaces through first-person navigation and allows users to observe the conversion process in real-time. This methodology has broader implications for digital humanities, providing a framework for transforming legacy interactive media into accessible educational and research tools.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10515_024_00418_z,
  title = {DL4SC: a novel deep learning-based vulnerability detection framework for smart contracts},
  author = {Liu, Yang and Wang, Chao and Ma, Yan},
  journal = {Automated Software Engineering},
  year = {2024},
  volume = {31},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-024-00418-z},
  url = {https://doi.org/10.1007/s10515-024-00418-z},
  abstract = {Smart contract is a new paradigm for the decentralized software system, which plays an important and key role in Blockchain-based application. The vulnerabilities in smart contracts are unacceptable, and some of which have caused significant economic losses. The machine learning, especially deep learning, is a very promising and potential approach to vulnerability detecting for smart contracts. At present, deep learning-based vulnerability detection methods have low accuracy, time-consuming, and too small application range. For dealing with these, we propose a novel deep learning-based vulnerability detection framework for smart contracts at opcode level, named as DL4SC. It orthogonally combines the Transformer encoder and CNN (convolutional neural networks) to detect vulnerabilities of smart contracts for the first time, and firstly exploit SSA (sparrow search algorithm) to automatically search model hyperparameters for vulnerability detection. We implement the framework DL4SC on deep learning platform Pytorch with Python, and compare it with existing works on the three public datasets and one dataset we collect. The experiment results show that DL4SC can accurately detect vulnerabilities of smart contracts, and performs better than state-of-the-art works for detecting vulnerabilities in smart contracts. The accuracy and F1-score of DL4SC are 95.29\% and 95.68\%, respectively.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_6893_8_3,
  title = {Energy Consumption-Based Profiling of Android Apps},
  author = {Singh, Jagannath and Maity, Arpan},
  booktitle = {Studies in Systems, Decision and Control},
  year = {2023},
  pages = {21-32},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-6893-8\_3},
  url = {https://doi.org/10.1007/978-981-19-6893-8\_3},
  abstract = {The main aim of this chapter is to test the power efficiency of any android application. This is done by checking the complexity of the program by counting the number of cycles or loops present in the code of the android application and calculating the energy consumption through a formula. This will help users to decide which application is more efficient and consumes less power. So that they can maximize their usage by choosing the app which consumes less power and save their mobile phones from draining their battery very fast. We have used two demo apps to calculate their energy consumption and check which is more efficient by using a formula that we have derived.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_95_6419_4_11,
  title = {Multimodal Learning with LLM-Fusion Head for Android Malware Detection: Enhancing Cross-Modality Robustness Against Obfuscation and Adversarial Samples},
  author = {Minh, Luong Hoang and Dat, Duong The and Dang, Bui Tan Hai and Thinh, Le Duc and Trung, Doan Minh and Duy, Phan The},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {176-195},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-6419-4\_11},
  url = {https://doi.org/10.1007/978-981-95-6419-4\_11},
  abstract = {Multimodal learning provides an effective approach for Android malware detection by integrating heterogeneous data sources such as permissions, intents, and binary content. However, existing fusion algorithms remain simplistic, lacking the capacity to model complex cross-modal relationships. This paper proposes a Large Language Model (LLM)-based feature fusion framework for Android malware classification. The framework combines tabular features (permissions and intents) and visual representations derived from DEX bytecode using a dual-stream architecture with Deep Neural Network (DNN) and Convolutional Neural Network (CNN) backbones. A fusion head inspired by LLMs is employed to capture rich interactions across modalities. Experimental results on the CICMalDroid 2020 dataset show that LLM-based fusion using TinyLLaMA achieves 96.81\% accuracy in binary classification and 92.01\% in multi-class classification. Under adversarial conditions, the same model reaches 98.24\% and 55.74\% respectively, outperforming conventional strategies such as self-attention (38.29\%, 24.86\%) and concatenation (45.10\%, 25.87\%). Similarly, in obfuscation scenarios, LLM-based fusion (TinyLLaMA and CodeBERT) maintains robust performance, achieving up to 96.66\% binary accuracy and 92.83\% multi-class accuracy. These results demonstrate improved resilience of the proposed approach against obfuscation and adversarial manipulation .},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_025_01105_0,
  title = {PayScan: Detection and Security Analysis of Payment Libraries in Android Apps},
  author = {Mohsen, Fadi and Alohaly, Manar and Rauf, Usman and Therattil, Dominic and Oosterhaven, Loran},
  journal = {International Journal of Information Security},
  year = {2025},
  volume = {24},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-025-01105-0},
  url = {https://doi.org/10.1007/s10207-025-01105-0},
  abstract = {Abstract Third-party payment libraries (TPLs) are widely used in Android applications to facilitate in-app transactions, yet their security implications remain largely underexplored. In this paper, we present a novel approach for automated detection and security analysis of payment libraries in Android applications. Our tool, PayScan, employs byte-pattern analysis and heuristic scanning techniques to identify TPLs and then it assesses their security posture. Additionally, the tool integrates three independent security scanners. We analyzed a dataset of 10,553 Android applications, detecting 18 payment libraries and evaluating their security and privacy risks. Our findings indicate that 71.7\% of applications use outdated payment libraries, with some SDK versions being over four years old. Additionally, we identified 397 private key leaks across 212 applications. The security scanners detected over 20,000 vulnerabilities, including critical issues such as SSL misconfigurations, WebView XSS, and weak cryptographic implementations. We compare our detection approach against LibScout and LibRadar, demonstrating its practical performance in detecting payment libraries, including in obfuscated applications. This study reveals important security risks in mobile payment ecosystems and emphasizes the value of continued monitoring of third-party payment libraries. The proposed tool offers a scalable solution for detection and analysis, providing practical utility for researchers, developers, and auditors focused on financial application security.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_89051_3_16,
  title = {Proving LTL Properties of Bitvector Programs and Decompiled Binaries},
  author = {Liu, Yuandong Cyrus and Pang, Chengbin and Dietsch, Daniel and Koskinen, Eric and Le, Ton-Chanh and Portokalidis, Georgios and Xu, Jun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {285-304},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-89051-3\_16},
  url = {https://doi.org/10.1007/978-3-030-89051-3\_16},
  abstract = {There is increasing interest in applying verification tools to programs that have bitvector operations. SMT solvers, which serve as a foundation for these tools, have thus increased support for bitvector reasoning through bit-blasting and linear arithmetic approximations. In this paper we show that similar linear arithmetic approximation of bitvector operations can be done at the source level through transformations. Specifically, we introduce new paths that over-approximate bitvector operations with linear conditions/constraints, increasing branching but allowing us to better exploit the well-developed integer reasoning and interpolation of verification tools. We show that, for reachability of bitvector programs, increased branching incurs negligible overhead yet, when combined with integer interpolation optimizations, enables more programs to be verified. We further show this exploitation of integer interpolation in the common case also enables competitive termination verification of bitvector programs and leads to the first effective technique for linear temporal logic (LTL) verification of bitvector programs. Finally, we provide an in-depth case study of decompiled (“lifted”) binary programs, which emulate X86 execution through frequent use of bitvector operations. We present a new tool DarkSea , the first tool capable of verifying reachability, termination and LTL of lifted binaries.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s42400_026_00552_z,
  title = {Anakin: explainable android malware detection with graph neural networks},
  author = {Andresini, Giuseppina and Appice, Annalisa and Belvedere, Vincenzo and Fiameni, Giuseppe and Malerba, Donato},
  journal = {Cybersecurity},
  year = {2026},
  volume = {9},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-026-00552-z},
  url = {https://doi.org/10.1186/s42400-026-00552-z},
  abstract = {Abstract Android OS is today the most used Operating System for mobile devices. However, it is susceptible to several malware attacks that may seriously compromise the privacy and security of individuals and organizations. This paper proposes an approach based on a static analysis of decompiled Android PacKages (APKs) to extract critical APIs and detect Android malware. The main contributions lie in the adoption of a graph-based data engineering schema to represent APIs taken from the Function Call Graphs of decompiled APKs and the formulation of a graph-based deep learning approach for explainable malware detection. In particular, the proposed approach, named , implements a Graph Neural Network (GNN) for binary classification (malware versus goodware), and integrates algorithm to disclose how specific API classes and control-flow edges between API calls influence malware alerts. The proposed approach was evaluated by considering 26,527 Android APKs. The results of an extensive and in-depth evaluation show that the presented GNN model achieves higher accuracy than deep neural models trained with traditional API call sequence representations and publicly available related methods. On the other hand, it produces decision explanations that yield interesting insights into the malicious patterns of APKs and support root cause analysis of missed malware alarms.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_53274_0_7,
  title = {A Scalable Middleware for IoT Vulnerability Detection},
  author = {Yoda, Minami and Nakamura, Shigeo and Sei, Yuichi and Tahara, Yasuyuki and Ohsuga, Akihiko},
  booktitle = {Studies in Computational Intelligence},
  year = {2024},
  pages = {85-97},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-53274-0\_7},
  url = {https://doi.org/10.1007/978-3-031-53274-0\_7},
  abstract = {Cyberattacks targeting vulnerabilities in the internet of things (IoT) devices are increasing in number annually. Accordingly, various methods and analysis tools for IoT vulnerability detection have been proposed. Each analysis tool focuses on a specific vulnerability; therefore, it is necessary to use different analysis tools to detect multiple vulnerabilities. However, the currently available analysis tools often suffer from installation errors and are difficult to use effectively. Therefore, we propose a middleware for static analysis of IoT firmware that can be equipped with multiple vulnerability-detection algorithms. Using our middleware, multiple vulnerability-detection algorithms can be combined into a single analysis tool. Our results were compared with those of Karonte, the most popular analysis tool in terms of capability.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_8026_3_6,
  title = {Detecting Privacy Leaks Utilizing Digital Forensics and Reverse Engineering Methodologies},
  author = {Moreb, Mohammed},
  booktitle = {Practical Forensic Analysis of Artifacts on iOS and Android Devices},
  year = {2022},
  pages = {195-225},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-8026-3\_6},
  url = {https://doi.org/10.1007/978-1-4842-8026-3\_6},
  abstract = {Most commercial iOS forensics and data acquisition tools will effectively do the job in general, but in cases of data leaks presented, we need to look between the lines to extract all related logs and API communication that occurred inside the mobile system. Thus, in this chapter we will investigate the most recent updated tools and use more and more tools to have better evidence about our case.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_19_0336_6_5,
  title = {Reverse Engineering},
  author = {Nu1L Team},
  booktitle = {Handbook for CTFers},
  year = {2022},
  pages = {295-427},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-0336-6\_5},
  url = {https://doi.org/10.1007/978-981-19-0336-6\_5},
  abstract = {Reverse engineering is a technical process that involves the reverse analysis and study of a target product to derive design elements such as processing flow, organizational structure, and functional specifications of the product to produce a product with similar but not identical functions. In CTF, reverse engineering generally refers to software reverse engineering, that is, analyzing compiled executable files, studying program behavior and algorithms, and recover the flag based on the analyze.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_64626_3_8,
  title = {On the Decidability of Disassembling Binaries},
  author = {Engel, Daniel and Verbeek, Freek and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {127-145},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64626-3\_8},
  url = {https://doi.org/10.1007/978-3-031-64626-3\_8},
  abstract = {The general consensus is that disassembly of binaries is undecidable. The cause lies in distinguishing instructions from data, and resolving indirections. Furthermore, binaries can behave in “weird” ways which have no counterpart in assembly languages, e.g., instructions may overlap, or use other instructions as data. Yet, the general consensus is that, for a large part of production binaries, disassembly works sufficiently well for the use cases at hand. This paper aims to address the question: for which binaries is disassembly decidable? For which binaries can disassembly become decidable if an external oracle, e.g., provides the set of instruction addresses, or resolves indirections? We present a set of five theorems on decidability of disassembly; each theorem corresponding to a use case. All five theorems are accompanied by a proof of correctness based on bisimilarity between the input binary and the output assembly program, and have been formalized in the Isabelle/HOL theorem prover.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_49179_5_1,
  title = {PySysML2: Building Knowledge from Models with SysML v2 and Python},
  author = {Lucas, Keith L. and Ford, Thomas C. and Stern, Jordan L. and Situ, John X.},
  booktitle = {Conference on Systems Engineering Research Series},
  year = {2024},
  pages = {3-17},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-49179-5\_1},
  url = {https://doi.org/10.1007/978-3-031-49179-5\_1},
  abstract = {The systems engineering community is pushing toward the adoption of digital engineering to improve the design process and resultant systems across the life cycle. This shift depends on the ability to produce useful digital twins. Systems Modeling Language (SysML) version 1.x and its implementing tools do not contain truly open interfaces or otherwise enable data exchange in formats to integrate systems models with a variety of data analysis and simulation tools. Lacking data interoperability, SysML version 1.x models struggle to enable a systems engineering digital engineering vision. SysML v2 corrects many of these shortfalls with specification of a text-based language and a RESTful application programming interface (API). This chapter introduces PySysML2, a prototype software application to integrate SysML v2 models with the Python-based ecosystem of analysis tools. This work demonstrates the functionality and utility of PySysML2 by describing how to read into, manipulate within, and use SysML v2 models in a Python environment. Additionally, we demonstrate SysML v2 model serialization into a portable JSON (JavaScript Object Notation) format that supports interoperability with a wide range of commonly used data analysis tools. We close with a recommendation for continued open-source exploration of the pathfinder work presented in this chapter.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_979_8_8688_0137_2_13,
  title = {Reading and Understanding Code},
  author = {Smith, Stephen},
  booktitle = {Maker Innovations Series},
  year = {2024},
  pages = {271-292},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-0137-2\_13},
  url = {https://doi.org/10.1007/979-8-8688-0137-2\_13},
  abstract = {Now that the core of RISC-V Assembly Language has been covered, this chapter provides the fundamentals to read another programmer’s code. Reading other programmer’s code is a great way to not only add to a toolkit of tips and tricks but also improves coding. Also, where Assembly Language source code for the RISC-V processor can be found will be reviewed. One of the Assembly Language routines from the Linux kernel will be examined to learn new optimization techniques. Then how the GNU C compiler writes Assembly Language code will be examined and analyzed. The NSA’s Ghidra hacking tool that converts Assembly Language code back into C code, at least approximately, will be studied.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_032_02949_2_15,
  title = {Ghidra-Assisted Static Analysis and Ensemble Learning with Differential Privacy GANs for Ransomware Detection},
  author = {Chaturvedi, Ananya and Tyagi, Kavyansh and Sharma, Shweta and Sah, Sweeti},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2026},
  pages = {165-175},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-02949-2\_15},
  url = {https://doi.org/10.1007/978-3-032-02949-2\_15},
  abstract = {Recent times have seen the rise of ransomware as a major cybersecurity threat, wherein attackers have been encrypting victims’ data and demanding ransom for reversing access. As attackers are leveraging advanced encryption techniques, obfuscation methods, and exploiting security flaws, ransomware as a growing challenge to cybersecurity defenses has led to many ransomware variants that can detect the run-time environment and evade dynamic analysis. To counter this, we perform Windows ransomware static analysis and detection using reverse engineering and Ensemble Learning. We start by using Ghidra to perform reverse engineering, in which we automate both static analysis and compilation procedures to curate a dataset that represents ransomware of various kinds. To overcome the issue of limited ransomware samples and existing unrealistic data augmentation techniques, we apply the concept of differential privacy to create our own generative adversarial network. Critical features have been identified and processed through ensemble learning models. The experimental results show that the ensembles of Stacking Decision Trees, Support Vector Machines, and Random Forest yielded a maximum accuracy of 97.51\% in detecting ransomware attacks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_025_01148_3,
  title = {A cross-language and cross-binary type approach to binary-source software composition analysis using BM25},
  author = {Kim, Jong-Wouk and Choi, Mi-Jung},
  journal = {International Journal of Information Security},
  year = {2025},
  volume = {24},
  number = {6},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-025-01148-3},
  url = {https://doi.org/10.1007/s10207-025-01148-3},
  abstract = {Software composition analysis (SCA) involves analyzing open-source software (OSS) components used in software development to identify license compliance issues and security vulnerabilities. It helps developers mitigate the legal and security risks associated with OSS, ensuring safer and more reliable software. Traditional SCA methods often require users to upload their source code to an SCA server for inspection, which then generates reports on component usage. However, vendors have significant concerns about this approach because source code often includes sensitive information like proprietary algorithms, core business logic, and confidential user data. To address these challenges, various SCA techniques, such as binary-binary SCA and binary-source SCA, have been proposed, though most are limited to specific programming languages. Existing SCA frameworks primarily focus on C/C + + and Java. This paper introduces the first binary-source SCA method capable of analyzing three binary types across five programming languages (C/C + + , Objective-C, Swift, Go). Our approach utilizes BM25-based text tokens, significantly reducing computational cost while maintaining detection performance. Empirical results demonstrate that our method achieves up to 81.4\% recall in identifying reused OSS components, providing an efficient and scalable solution for secure software development. Additionally, this study highlights the limitations of the proposed method and suggests future research directions to address these challenges.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_15_9647_6_95,
  title = {AndRev: Reverse Engineering Tool to Extract Permissions of Android Mobile Apps for Analysis},
  author = {Patil, Manisha and Pramod, Dhanya},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2021},
  pages = {1199-1207},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-15-9647-6\_95},
  url = {https://doi.org/10.1007/978-981-15-9647-6\_95},
  abstract = {One of the leading and the most popular operating system for smartphones and tablets is an Android. Being an open-source platform has also become a prime target for the attackers as growing users. This paper focuses on the work done on the Android platform by performing static analysis on the permission-based framework and permission extraction tool—AndRev, which is designed. Extracted many permission-based features by reverse engineering of the Android application (apk) files using the batch-scripted tool. AndRev tool is used to decompile apks in batch mode. Features have been stored in feature vectors. Firstly, analysis is done using feature vectors to study the pattern of permissions in applications as per the category. Two categories of apks, namely general and entertainment apps, are studied with an initial dataset of 50 applications each. Secondly, do an experimental study of applications permission removal by using a reverse engineering method. Updated apks are recompiled apps, which execute on a mobile phone as the way it executes like the original app. The study consists of ten apps from Google Play with various categories. The study concludes that it is not easy to remove permission as per the type of permission and the relation of apps permission with app’s relevant functionality. Finally, performed security analysis on the vulnerabilities within the source code, and those are used for accessing resources or unauthorized permission authorization of Android apk. For the study, many vulnerabilities based features were extracted by vulnerability assessment tool Quixxi for the Android application (apk) files. The study depicts that medium-risk vulnerabilities are higher than high- and low-risk vulnerabilities. In security analysis point of view, observations concluded would be useful to future Android app developers},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_021_10013_5,
  title = {TaintBench: Automatic real-world malware benchmarking of Android taint analyses},
  author = {Luo, Linghui and Pauck, Felix and Piskachev, Goran and Benz, Manuel and Pashchenko, Ivan and Mory, Martin and Bodden, Eric and Hermann, Ben and Massacci, Fabio},
  journal = {Empirical Software Engineering},
  year = {2022},
  volume = {27},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-021-10013-5},
  url = {https://doi.org/10.1007/s10664-021-10013-5},
  abstract = {Abstract Due to the lack of established real-world benchmark suites for static taint analyses of Android applications, evaluations of these analyses are often restricted and hard to compare. Even in evaluations that do use real-world apps, details about the ground truth in those apps are rarely documented, which makes it difficult to compare and reproduce the results. To push Android taint analysis research forward, this paper thus recommends criteria for constructing real-world benchmark suites for this specific domain, and presents TaintBench , the first real-world malware benchmark suite with documented taint flows. TaintBench benchmark apps include taint flows with complex structures, and addresses static challenges that are commonly agreed on by the community. Together with the TaintBench suite, we introduce the TaintBench framework, whose goal is to simplify real-world benchmarking of Android taint analyses. First, a usability test shows that the framework improves experts’ performance and perceived usability when documenting and inspecting taint flows. Second, experiments using TaintBench reveal new insights for the taint analysis tools Amandroid and FlowDroid : (i) They are less effective on real-world malware apps than on synthetic benchmark apps. (ii) Predefined lists of sources and sinks heavily impact the tools’ accuracy. (iii) Surprisingly, up-to-date versions of both tools are less accurate than their predecessors.},
  content_type = {Article},
}


@incollection{springer_10_1007_979_8_8688_1748_9_2,
  title = {Android Forensics Fundamentals},
  author = {Sheth, Ravi and Kaushik, Keshav and Parekha, Chandresh and Chayal, Narendrakumar},
  booktitle = {Android and IOS Mobile Forensics},
  year = {2025},
  pages = {27-59},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-1748-9\_2},
  url = {https://doi.org/10.1007/979-8-8688-1748-9\_2},
  abstract = {Android forensics refers to the process of acquiring, examining, and reporting on digital evidence from Android devices, which is of paramount importance because the Android operating system is currently the most popular in the world. Investigations on Android-based devices involve understanding how the Android operating system is structured and how information is stored. The Android operating system's openness and its applicability on various hardware make forensic analysis very challenging but also beneficial in numerous cases, ranging from cybercrime to legal situations. What is the structure of the Android system?},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_66459_5_10,
  title = {Evaluating the Reusability of Android Static Analysis Tools},
  author = {Mineau, Jean-Marie and Lalande, Jean-Francois},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {153-170},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-66459-5\_10},
  url = {https://doi.org/10.1007/978-3-031-66459-5\_10},
  abstract = {Reproducibility and reusability in computer science experiments become a requirement for research works. Reproducibility ensures that results can be confirmed by using the same dataset and software of previous papers. Reusability helps other researchers to build new approaches with distributed software artifacts. For researchers in the field of security of mobile platforms, ensuring reproducibility and reusability is difficult to implement. In particular for reusability, datasets of Android applications may contain recent applications that past analysis software cannot process. As a consequence, past software produced by researchers may be difficult to reuse, which endangers the reproducibility of research. This paper intends to explore the reusability of past software dedicated to static analysis of Android applications. We pursue the community effort that identified publications between 2011 and 2017 that perform static analysis of mobile applications and we propose a method for evaluating the reusability of the associated tools. We extensively evaluate the success or failure of these tools on a dataset containing Android applications that can have up to six years of distance from the original publication. We also measure the influence of some important characteristics of the application such as being a goodware or a malware or the application size. Our results show that 54.5\% of the evaluated tools are no longer usable and that the size of the bytecode and the min SDK version have the greatest influence on the reusability of tested tools.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_025_10772_5,
  title = {Automatically Detecting Checked-In Secrets in Android Apps: How Far Are We?},
  author = {Li, Kevin and Ling, Lin and Yang, Jinqiu and Wei, Lili},
  journal = {Empirical Software Engineering},
  year = {2026},
  volume = {31},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10772-5},
  url = {https://doi.org/10.1007/s10664-025-10772-5},
  abstract = {Mobile apps are predominantly integrated with cloud services to benefit from enhanced functionalities. Adopting authentication using secrets such as API keys is crucial to ensure secure mobile-cloud interactions. However, developers often overlook the proper storage of such secrets, opting to put them directly into their projects. These secrets are checked into the projects and can be easily extracted and exploited by malicious adversaries. While many researchers investigated the issue of checked-in secret in open-source projects, there is a notable research gap concerning checked-in secrets in Android apps deployed on platforms such as Google Play Store. Unlike open-source projects, the lack of direct access to the source code and the presence of obfuscation complicates the checked-in secret detection for Android apps. This motivates us to conduct an empirical analysis to measure and compare the performance of different checked-in secret detection tools on Android apps. We conducted a systematic literature review to identify existing checked-in secret detection tools and then analyzed how these tools could be adapted and applied to the context of Android apps. Then, we evaluated three representative tools: Three-Layer Filter, LeakScope, and PassFinder on 5,135 Android apps, comparing their performance and analyzing their limitations. Our experiment reveals 2,142 checked-in secrets affecting 2,115 Android apps and also discloses that the current checked-in secret detection techniques suffer from key limitations. While all the tools achieved high precision, each of them can miss a significant number of checked-in secrets in Android apps. Nevertheless, we observed that the tools are complimentary, suggesting the possibility of developing a more effective checked-in secret detection tool by combining their insights. Additionally, we outline potential directions for future research, supported by preliminary experimental results.},
  content_type = {Article},
}


@article{springer_10_1007_s11227_024_06747_w,
  title = {Systematic literature review on quantum applications in nanotechnology},
  author = {Pacheco, A. Lopez and Aguilar, J.},
  journal = {The Journal of Supercomputing},
  year = {2025},
  volume = {81},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-024-06747-w},
  url = {https://doi.org/10.1007/s11227-024-06747-w},
  abstract = {The review of progress in quantum computing (QC) is very pertinent nowadays. There is a remarkable challenge in terms of the contributions that this field can provide at the level of improvements in computing time, but perhaps more importantly, in terms of how to rethink the way in which many of the current problems can be approached. Thus, the objective of this work is a systematic literature review that basically revolves around two questions: How does nanoassembled technology affect quantum computing? And what advantages does quantum computing offer to the advancement of nanotechnology? Therefore, this work analyzes how the advance of quantum computing has been influenced by nanotechnology and vice versa, and how quantum computing affects nanotechnology itself. In this way, this article clarifies the paths at which nanotechnology and quantum computing are connected on the route to future technologies in society. In conclusion, we found out that nanotechnology is crucial for the advancement of QC due to the quantumness stands in the nanometric size and the QC-based industry relies on the solid physics state nanoassembly, while on the other hand, QC significantly increases the performance of nanotransistors, imprint better sensibility features on nanosensors, among other things.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_94590_8_25,
  title = {A3S3 - Automated Android Audit of Safety and Security Signals},
  author = {Nguyen, Guillaume and Devroey, Xavier},
  booktitle = {Lecture Notes in Business Information Processing},
  year = {2025},
  pages = {205-212},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-94590-8\_25},
  url = {https://doi.org/10.1007/978-3-031-94590-8\_25},
  abstract = {Android devices and related applications are increasingly prevalent in our daily routines. Furthermore, these technologies are being used for more than just connecting people around the world. Indeed, Android devices are more and more connected to external sensors or used as sensors, directly gathering data from their environment, which brings them closer to Cyber Physical Systems (CPS) . When used for specific purposes such as health, Android devices and related applications can be life-critical (insulin pumps, heart monitoring, etc.), requiring guarantees specific to the application domain. Interestingly, when considering the technical security in domains related to operational technologies, we can see that many standards are available while not directly intended for Android applications. Other regulatory texts can also be valuable to drive an audit process, although they need more effort to reach technically testable requirements from the legal requirements they define. In particular, Android applications are developed using various device permissions (i.e., resource access), external libraries, etc. In this paper, we present A3S3 a tool to link requirements from industry standards and regulatory texts to Android features to drive a security audit. Following research in the cyber-security community, we suggest an approach based on static code analysis of Android applications to retrieve good and bad signals , denoting potential violations, related to non-functional requirements.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_4759_0_40,
  title = {Integrated Management and Application of Seismic Data Based on Cloud Platform},
  author = {Zhao, Chun-yu and Gu, Juan and Zhang, Ming-ge and Chen, Hao-ge and Liu, Wan-wei and Zhang, Shuang-yan},
  booktitle = {Springer Series in Geomechanics and Geoengineering},
  year = {2025},
  pages = {515-525},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-4759-0\_40},
  url = {https://doi.org/10.1007/978-981-96-4759-0\_40},
  abstract = {As an important data asset in the oilfield, seismic data plays an important supporting role in the research process of oil and gas reserve increase. With the changes in the data management mode of oil companies, data management technology has also progressed and developed. We take several measures to address the challenges of decentralized seismic data management, incomplete supporting governance system, and difficulty in online secure sharing and application of large data volume. First, we have established an integrated seismic data model, optimized the hierarchical storage mechanism of seismic data, and developed a full-process quality control tool for seismic data, forming a full-life cycle management model for seismic results data. Secondly, we have developed supporting technologies such as efficient transmission of large data, rapid integration of geographic information, and full-text search of seismic documents, which have innovated the application mode of seismic data sharing. Thirdly, through cloud deployment of seismic processing and interpretation software, we have developed a two-way integration technology from basic seismic data to project research environment, which greatly improves the efficiency of data application. Since the system was launched, it has fully managed seismic-related data within the oilfield, ensuring the security of oilfield data assets. Moreover, utilizing multi-process management of intermediate seismic, it significantly shortens the seismic processing cycle. Using multi-version management of interpretation results, it effectively supports application scenarios such as basin-level seismic interpretation. Currently, the innovative data management and service technology has been extended to data management fields such as logging and VSP, forming an integrated management approach for large-block data of oilfield.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_9443_3_9,
  title = {Utilizing Convolutional Neural Networks for Android Malware Detection via Permission and Opcode Sequences},
  author = {Gadilohar, Pragat and Tomar, Deepak Singh and Dehalwar, Vasudev and Sharma, Yogesh Kumar},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2026},
  pages = {129-141},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-9443-3\_9},
  url = {https://doi.org/10.1007/978-981-96-9443-3\_9},
  abstract = {Our contemporary digital existence is intricately intertwined with the realm of Android-based smart devices, delivering unparalleled convenience across personal, professional, and social dimensions. However, this profound connectivity exposes us to an escalating barrage of malicious attacks, with Android smartphones emerging as prominent targets. To cultivate a secure, intelligent, and lasting digital environment, we must advance the field of Android malware detection while mitigating the need for frequent retraining. Presently, existing solutions for malware detection on Android devices grapple with persistent challenges, chief among them being the high incidence of false positives and the limited capacity to identify emerging threats. In response, this paper introduces an innovative approach that achieves an outstanding 98\% accuracy in malware detection through the power of deep learning techniques. This study is grounded in a dataset comprising 1000 APK files, evenly distributed between benign and malicious samples (500 each), and leverages advanced deep learning methodologies and feature extraction strategies. The overarching objective is to fortify Android-based smart devices against the ever-evolving landscape of cyber threats. In summary, the research charts a course towards elevated security, heightened resilience, and the enduring relevance of Android-based smart devices in the fabric of daily lives, all made possible through the capabilities of deep learning. Furthermore, detailed classification results for varying dataset sizes, including 200, 500, and 1000 APK files, showcase the scalability and robustness of the approach in effectively detecting malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_03751_0_13,
  title = {Behavioural Analysis for Android Malware Detection: A Deep Learning Approach},
  author = {Ashok, Mayank and Katarya, Rahul},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2026},
  pages = {149-160},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-03751-0\_13},
  url = {https://doi.org/10.1007/978-3-032-03751-0\_13},
  abstract = {Android’s dominance in the global mobile landscape has made it a prime target for increasingly evasive malware. While machine learning and deep learning have shown promise for Android malware detection, prior studies often evaluate isolated models or rely on narrow datasets, limiting real-world applicability. This paper proposes a unified experimental framework that benchmarks classical machine learning models and deep neural architectures using a hybrid dataset composed of both real-device and emulated Android malware. Features were carefully extracted and fused from static and dynamic sources to create a hybrid representation suitable for both lightweight classifiers and high-capacity deep networks. Seven models were evaluated, including Decision Tree, K-Nearest Neighbours, AdaBoost, Extra Trees, Convolutional Neural Network (CNN), Long Short-Term Memory (LSTM), and a hybrid CNN-LSTM architecture. The CNN-LSTM model achieved the highest detection accuracy of 99.82\%, validating the need for combining spatial and temporal learning from static and behavioural malware characteristics. Our findings shed light on the balance that must be struck between making models interpretable, keeping computational requirements reasonable, and achieving strong detection performance. By examining these aspects together, we hope this work will serve as a useful reference point for researchers who are developing or evaluating hybrid approaches to Android malware detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97623_0_17,
  title = {A History of Greed: Practical Symbolic Execution for Ethereum Smart Contracts},
  author = {Ruaro, Nicola and Gritti, Fabio and McLaughlin, Robert and Meng, Dongyu and Grishchenko, Ilya and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {275-296},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97623-0\_17},
  url = {https://doi.org/10.1007/978-3-031-97623-0\_17},
  abstract = {Smart contracts have transformed blockchain applications, enabling decentralized computation and automated asset management without intermediaries. However, with the growth of decentralized finance, the high financial stakes make smart contract vulnerabilities particularly critical. Because vulnerabilities often go undetected, they lead to substantial losses and diminished trust in blockchain systems. Symbolic execution has emerged as a powerful technique to uncover subtle vulnerabilities by systematically exploring feasible execution paths. However, most existing symbolic execution tools for smart contracts are tailored to specific vulnerability patterns, making them unsuitable for detecting new types of vulnerabilities. In this paper, we introduce Greed , a highly versatile symbolic execution framework for Ethereum (or EVM-based) smart contracts. Greed features a state-of-the-art symbolic execution engine coupled with a suite of supporting analyses and a modular design that allows security researchers to prototype new analyses rapidly. To evaluate the effectiveness and extensibility of Greed , we compare it with the state-of-the-art. We first show that Greed can explore significantly more code paths – reaching 84\% of all CALL statements, as opposed to 9\% on average across existing tools. To demonstrate the ease of use (and extensibility) of Greed , we then implement a novel analysis to detect controllable JUMPI instructions and evaluate it against all deployed contracts on Ethereum and Binance Smart Chain (BSC), identifying 390 previously unknown vulnerable contracts. By releasing Greed to the community, we aim to lower the barrier to developing advanced security analyses for smart contracts, empowering security researchers to rapidly prototype new analyses and contribute to a more secure and resilient blockchain ecosystem.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_86637_1_8,
  title = {Intelligent Methods for Android Malware Detection: A Survey},
  author = {Choroma, Marayi and Ahmat, Daouda and Abbo, Bakari},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {95-107},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-86637-1\_8},
  url = {https://doi.org/10.1007/978-3-031-86637-1\_8},
  abstract = {This paper offers an in-depth analysis of malware detection methods on smartphones, highlighting current challenges, existing solutions and prospects. The article reviews recent scientific work and performance evaluations of different detection approaches by exploring the fundamentals of smartphone security and examining the main categories of malware. The use of static malware detection is the most widespread, but there is currently a growing trend towards Deep Learning-based approaches, which on average have a malware detection rate approaching 97\%. The paper also discusses persistent challenges such as the rapidly evolving malware operating mechanism and inherent privacy issues, while identifying future opportunities for improving malware detection on smartphones. This paper thus provides a comprehensive and up-to-date overview of the field of intelligent malware detection, offering valuable pointers for both researchers and practitioners concerned with protecting smartphone users from digital threats.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s41870_025_02615_9,
  title = {Energy-efficient hybrid detection framework for suspicious software components in mobile applications using echo state networks},
  author = {Rawat, Hitesh and Raj, A. Samson Arun and González-Torres, Antonio and Bhardwaj, Purvee and Sankaran, K. Sakthidasan and Thiyagu, T. M. and Rawat, Anjali},
  journal = {International Journal of Information Technology},
  year = {2025},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s41870-025-02615-9},
  url = {https://doi.org/10.1007/s41870-025-02615-9},
  abstract = {This research introduces a novel detection framework for identifying Suspicious Software Components (SSC) in mobile applications, enhancing accuracy and efficiency in cybersecurity. The primary objectives are to develop an advanced threat detection system with improved accuracy, reduce false positive rates, and ensure energy-efficient deployment in resource-constrained environments. The proposed method integrates static feature extraction with deep learning and machine learning (ML) models, leveraging Echo State Networks (ESN) for superior threat classification. Additionally, energy consumption analysis ensures feasibility for deployment in mobile environments. The methodology is validated using the CIC-MalMem-2022 dataset, demonstrating improved detection capabilities while maintaining low false positive rates. Experimental results show that the proposed ESN-based framework achieves an accuracy of 99.85\% while maintaining superior energy efficiency. This work advances mobile security by offering a robust, scalable, and energy-efficient solution for malware detection.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_4960_9_54,
  title = {A Survey: Android Architecture and Security Threats},
  author = {Mourya, Deepika and Srivastava, Surabhi and Pal, Dheeraj and Dehraj, Pooja},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {707-719},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-4960-9\_54},
  url = {https://doi.org/10.1007/978-981-19-4960-9\_54},
  abstract = {Nowadays billions of individuals utilizing brilliant mobile phones and the dramatic development of cell phone apps, it is genius enthusiast for application commercial centres, like Google App Store, to completely check if an application is real. Surprisingly more terrible, late investigations have shown that more than 75\% of applications in business sectors solicitation to gather information insignificant to the primary elements of the applications, which could cause spilling of private data or wasteful utilizations. Thusly, scholastic specialists and business against malware organizations have proposed numerous security systems to address the security issues of the Android gadgets. Considering the instruments and strategies which are diverse in nature and utilized in proposed works, they can be characterized into various classifications. In this overview, we talk about the current Android security problems and existing security authorization arrangement among 2010−2022 and attempt to order works and audit their basic functionalities. We survey a couple of works of each class.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10115_025_02661_6,
  title = {RGV2: A Framework for crypto-ransomware detection using FastText and neural networks},
  author = {Alvi, M. Adnan and Jalil, Zunera and Imran, Mohammad and Ayub, Mubbashir},
  journal = {Knowledge and Information Systems},
  year = {2026},
  volume = {68},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10115-025-02661-6},
  url = {https://doi.org/10.1007/s10115-025-02661-6},
  abstract = {Crypto-ransomware attacks are an escalating global threat, causing significant financial and reputational damage to businesses and individuals. Traditional detection mechanisms, such as signature-based methods, often fail to detect sophisticated ransomware variants that employ advanced evasion tactics. To address these critical shortcomings, this paper introduces RGV2, a next-generation ransomware detection framework that bridges this gap by integrating static and dynamic analysis through Event Tracing for Windows (ETW) logs. RGV2 uses FastText embeddings to extract semantic representations of encoded I/O patterns and leverages deep learning models, such as Conv1D, to classify ransomware based on file I/O behavior. Experimental evaluations show that RGV2 achieves a detection accuracy of 99.64\% while maintaining an exceptionally low false-positive rate. These results highlight RGV2’s potential as a scalable and real-time protection mechanism with significant societal impact by ensuring early detection and mitigation of ransomware attacks in real-world environments.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_032_01910_3_5,
  title = {Improving Smart Contract Security Using Sequential Models},
  author = {Senou, Rosaire and Degila, Jules},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2025},
  pages = {71-80},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-01910-3\_5},
  url = {https://doi.org/10.1007/978-3-032-01910-3\_5},
  abstract = {Blockchain-enabled smart contracts execute without third-party involvement when specific conditions are met. This system significantly reduces the use of paper-based processes while managing substantial funds. As such, it has become the target of hackers. It has suffered several attacks, particularly the DAO (Decentralized Autonomous Organization) attack and the Parity multi-sig wallet hack, which had severe consequences. This has triggered the need for better security measures as the use of this technology has increased significantly in recent years. Several tools have been developed to tackle various problems while they still lack better achievements. As deep learning achieved better results in vulnerability detection domain, we proposed a deep-learning approach using bidirectional long-short term memory (BLSTM) to classify contract either vulnerable (detection of suicidal, prodigal and greedy contracts) or non-vulnerable. The aim was to propose a detection technique that might achieve better results so as to encourage the use of deep learning techniques. The experiment was conducted on a HPC (High-Performance Computing) cluster where each server has a processing power of 2.2 GHz and a RAM of 128G at least. We were able to achieve an accuracy and F1 score of 94\%. This works also set a new benchmark to better smart contract detection while promoting future researches axes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_90573_5_8,
  title = {LLMs as a Compiler for an Arabic Programming Language},
  author = {Sibaee, Serry and Nacar, Omer and Ghouti, Lahouari and Koubaa, Anis},
  booktitle = {Studies in Computational Intelligence},
  year = {2025},
  pages = {251-262},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-90573-5\_8},
  url = {https://doi.org/10.1007/978-3-031-90573-5\_8},
  abstract = {Programming languages force people to think logically while interacting with the computers to reach a conceptual level that makes problem solving accessible to the computer itself. Given their expressive power, natural languages outweigh their programming counterparts. In this paper, we propose a natural to programming language converter using large language models (LLMs) where the user can express the logical constructs in his own language that get converted to Python code. In this way, the converter alleviates the user fear from learning a new programming language. We identify the proposed converter as the Arabic programming language (APL). The APL model runs under the hood GPT4 application program interface (API) using an elaborate prompt engineering scheme. In addition, an intuitive, yet simple, user interface is provided to assist the APL user. As a feedback, the user will rate the APL response to the input prompt as a score ranging from 1 to 5 where 1 would indicate dissatisfactory output and 5 to indicate perfect code execution. The APL API is hosted at https://github.com/riotu-lab/apl-compiler .},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_93299_1_2,
  title = {Implementation Strategies},
  author = {Mogensen, Torben Ægidius},
  booktitle = {Texts in Computer Science},
  year = {2026},
  pages = {29-45},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-93299-1\_2},
  url = {https://doi.org/10.1007/978-3-031-93299-1\_2},
  abstract = {The very first automatic computing machines, such as Babbage’s difference engine and early electronic computers, were specialised to one particular task such as calculating polynomials or multiplying matrices. Early programmable computers were programmed by connecting wires, so there was no real concept of a program.},
  content_type = {Chapter},
}


@article{springer_10_1007_s00521_025_11604_9,
  title = {Cybersecurity challenges and opportunities of machine learning-based artificial intelligence},
  author = {Czaja, Pawel and Gdowski, Bartlomiej and Niemiec, Marcin and Mees, Wim and Stoianov, Nikolai and Votis, Konstantinos and Kharchenko, Vyacheslav and Katos, Vasilis and Merialdo, Matteo},
  journal = {Neural Computing and Applications},
  year = {2025},
  volume = {37},
  number = {33},
  pages = {27931-27956},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-025-11604-9},
  url = {https://doi.org/10.1007/s00521-025-11604-9},
  abstract = {Abstract Artificial intelligence, machine learning, and cybersecurity are the topics of discussion of contemporary information technology sector and computing research. This study investigates the integration of machine learning-based artificial intelligence in the context of cybersecurity. This paper presents an overview of the recent literature, focusing on selected popular areas related to the challenges and opportunities that such implementations introduce. The authors also assess how selected problems related to the application of machine learning algorithms affect the real effectiveness represented by the resulting models. To support this analysis, an experimental study was conducted using a real-world cybersecurity system. This demonstration illustrates the practical implementation of a machine learning-based software solution in cybersecurity and highlights the potential challenges encountered during such implementations.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_35078_8_20,
  title = {A Study on Android Malware Detection Using Machine Learning Algorithms},
  author = {Ujjwal Reddy, K. S. and Sibi Chakkaravarthy, S. and Gopinath, M. and Mitra, Aditya},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2023},
  pages = {232-247},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-35078-8\_20},
  url = {https://doi.org/10.1007/978-3-031-35078-8\_20},
  abstract = {Today, Android has become the most popular operating system because of its salient features. As it is an open-source mobile OS, several developers are developing and publishing their android applications. On the other side, attackers are manipulating those applications in the form of malicious software (Malware) by leveraging the application or functional flow of android OS and those malwares create loss or leakage of confidential sensitive information. Though most anti-virus software affords defence against malware attacks, still the attacks are highly possible in the real time adversarial environment. In this paper, the machine learning-based detection method is designed by combining the features of application namely permission and activity which are obtained during the installation of apps. In our design, permissions and activities of each app are extracted making use of Androguard tool. Using this feature combination, malicious apps are classified as either benign or malicious. The advantage of this method is that there is no need for any dynamic analysis. In our experimentation, we used real-world app samples with 500 malware and 500 benign to train the algorithm for better performance. Based on the experimentation results, highest detection rate is attained by Random Forest (RF) with 95\% of accuracy and lowest detection rate is obtained by K-Nearest Neighbors (KNN) with 79\% of accuracy.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_73068_9_17,
  title = {Ensemble Learning-Based Android Malware Detection},
  author = {Priya, V. and Sathya Sofia, A.},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {205-219},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-73068-9\_17},
  url = {https://doi.org/10.1007/978-3-031-73068-9\_17},
  abstract = {Android has retained its global popularity among cell phone users. Simultaneously, there has been a growth of malware targeting the platform, with larger current lines using unexpectedly cutting-edge detection evasion strategies. Options for timely 0-day detection are necessary as standard signature-based approaches become less effective in detecting unknown threats. This study contributes a strategy based on ensemble learning for detecting malicious apps on Android. To improve the accuracy of Android malware detection, it combines the advantages of hybrid analysis with the efficiency and performance of ensemble device research. Machine learning models are constructed using a large collection of malicious and safe software. The built model can predict all real-world test scenarios. The user has complete access to all program information on their devices. The proposed system employs a variety of machine learning algorithms for ensemble learning, including Decision Tree, Random Forest, and Androguard. The testing module is intended to ensure the efficiency and efficacy of the proposed system. The results show that the suggested method is extremely effective at identifying Android malware, with a detection accuracy of up to 100\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_06764_8_42,
  title = {A Method of Firmware Vulnerability Mining and Verification Based on Code Property Graph},
  author = {Xiao, Na and Zeng, Jing and Yao, Qigui and Huang, Xiuli},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {543-556},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06764-8\_42},
  url = {https://doi.org/10.1007/978-3-031-06764-8\_42},
  abstract = {With the rapid development of smart power grid, the security of intelligent terminal has been widely concerned. Firmware is the core component of intelligent terminal equipment, and its vulnerability has become one of the main threats to intelligent terminal security. However, the difficulty of obtaining firmware, extracting binary files and analyzing code bring a series of difficulties to firmware vulnerability mining, resulting in low accuracy and high false positive rate of vulnerability mining. Therefore, this paper proposes a firmware vulnerability mining method based on code property graph. First, generate the code property graph of the target program; secondly, abstract syntax tree, control flow graph and data dependency graph are extracted from code property graph. Then the traversal analysis of these three graphs gradually reduces the scope of the vulnerability; Finally, combined with manual analysis and review, the results of vulnerability mining are obtained. In this paper, joern tool is used to verify the DVRF project, mining stack overflow vulnerability, heap overflow vulnerability, command injection vulnerability and heap release vulnerability, and good experimental results are obtained.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97693_3_12,
  title = {A Blockchain-Enabled Carbon Emission Trading System for New Energy Vehicle Incentives Utilizing Ethereum 2.0},
  author = {Peng, He and An, Chunjiang and Sun, Yao},
  booktitle = {Lecture Notes in Civil Engineering},
  year = {2025},
  pages = {139-149},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97693-3\_12},
  url = {https://doi.org/10.1007/978-3-031-97693-3\_12},
  abstract = {The greenhouse gas emissions from conventional fossil fuel vehicles have a significant impact on the environment. Compared to fossil fuel vehicles, the new energy vehicles result in greatly lower carbon emissions. Some countries have been providing considerable subsidies for the popularization of new energy vehicles in the recent years, which has been gradually reducing the total urban transportation emissions. However, the rigidity of the existing subsidy policies has limited both policy implementation and incentive outcomes. In this paper, we propose a blockchain-enabled theoretical system for carbon emission trading between new energy vehicles and fossil fuel vehicles. The system is designed for free-market emission trading to realize incentives for clean transportation behaviors by punishing fossil fuel vehicles and rewarding new energy vehicles. To better contribute a high-performance and low-cost structure, Ethereum 2.0 and Rollups are adopted for the development of the new system. A discussion is conducted to illustrate the design advantages and social impact of this theoretical system. In the end, we analyze the feasibility of the proposed system.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42979_022_01543_w,
  title = {A Review on Malware Analysis for IoT and Android System},
  author = {Yadav, Chandra Shekhar and Gupta, Sangeeta},
  journal = {SN Computer Science},
  year = {2022},
  volume = {4},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42979-022-01543-w},
  url = {https://doi.org/10.1007/s42979-022-01543-w},
  abstract = {Today all humankind is willing to avail more facilities and hopes everything should be available with a click of the button. In order to offer different services, the developers have come with inbuilt modules of several systems. This make easy system develoment and services may be offered intantly. These services are connected to the internet and accessible via Android phones and IoT devices. But this inbuilt module suffers from a lot of vulnerabilities, bugs, and default settings which may be difficult to change, as happened at the time of changing the password of home-based Wi-Fi router, which require external applications and OTP verifications, etc. Due to these issues and new hacking tools and techniques, security is a major challenge today. The basic framework to provide adequate security of the system comprises five following principles: integrity, confidentiality, availability, privacy, and nonrepudiation. The attacker may leverage advantage of any shortcomings that may lead to several issues. This work explores the cause of threads/vulnerability particularly for IoT, IIoT, SCADA, and Android application systems. The structure of this work is divided in different sections like, a short introduction to Malware, how it infects the system, and a detailed malware exploitation plan that is generally followed by expert attackers to exploit the vulnerabilities related to critical infrastructure or to defame the organization or countries is presented. In addition, General framework based introduction on IoT and Android is also presented with common vulnerabilities at every stage and respective mitigation strategies. Both static and dynamic analyses are evaluated in this work. It is identified that, for a better model design and evaluation, both are highly recommended for the implementation of effective malware detection strategies. Along with these models in order to protect the infra-structure Honeynet, IDS, IPS, Hardware-based securities like CPU and Memory and forensic analysis are also very effective.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_96_6297_5_36,
  title = {A Comprehensive Survey of Various Software Security Techniques},
  author = {Gautam, Pratiksha},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2025},
  pages = {469-480},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-6297-5\_36},
  url = {https://doi.org/10.1007/978-981-96-6297-5\_36},
  abstract = {In the past few decades, software security became one of the leading important research issues in the software/IT industry. Software security is related to secure software or data from unauthorized alterations. Software security breach leads to huge financial losses as well as a deficit of confidential data in the present scenario. Generally, software security can be of two types as coding errors and intellectual property rights. Existing literature reveals that intellectual property can be broadly categorized into three types as software piracy, reverse engineering and tampering. Thus, in this paper, we present a comprehensive survey on software security types as coding errors and intellectual property right with their attacks and their protection methods as software watermarking tamper resistance, obfuscation. Moreover, one of the software security attacks as code clone is another vital research area for the present scenario is also discussed in this research article. In addition, a future scope is also propounded for academic clara.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_3072_4_4,
  title = {A Survey on Malware Analysis with Large Language Models},
  author = {Guo, Wenjie and Wen, Haoyuan and Kong, Lingming and Xue, Jingfeng and Hu, Jingjing and Han, Weijie and Wang, Yong},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {41-52},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-3072-4\_4},
  url = {https://doi.org/10.1007/978-981-95-3072-4\_4},
  abstract = {With the rapid development of network technologies, the threat posed by malicious software has become increasingly complex and diverse, evolving from traditional viruses and worms to sophisticated ransomware, advanced persistent threats (APTs), and supply chain attacks. Traditional malware detection methods, such as signature-based detection and traditional machine learning techniques, face significant challenges in addressing the polymorphism and obfuscation of modern malware. Recent advances in generative artificial intelligence (GAI), particularly large language models (LLMs) like GPT-4 and CodeBERT, offer new opportunities for malware detection. GAI leverages self-supervised pretraining to understand code syntax and semantics, enabling automated feature extraction and high-level semantic pattern recognition from raw code. By analyzing the structure and behavior of malicious code, GAI can detect hidden threats, predict attack trends, and process complex multimodal data. This paper provides a comprehensive overview of the current challenges in malware detection, including issues with data imbalance, adversarial attacks, and the high cost of expert-labeled samples. It also explores how GAI-powered LLMs enhance static and dynamic analysis, enable multimodal detection, and improve explainability in malware analysis. By summarizing the contributions of GAI in this field, this paper highlights its transformative potential for malware detection methodologies and addresses future research directions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_9443_3_7,
  title = {Android Malware Detection Based on Permissions and API Calls Using Ensemble Based Model},
  author = {Monika and Sharma, Yogesh K. and Tomar, Deepak S. and Pateriya, R. K.},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2026},
  pages = {91-104},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-9443-3\_7},
  url = {https://doi.org/10.1007/978-981-96-9443-3\_7},
  abstract = {The Android operating system has revolutionized the mobile industry and society with its versatility and customization options. However, the increasing popularity of the Android system has caused a rise in the number of malware attacks, making it challenging to combat these threats. This study proposes a malware detection framework for Android systems that combines permissions and API calls as features. An autoencoder is used to reduce the feature set’s dimensionality, and an ensemble model is employed for classification. The results show that the ensemble models outperform individual classifiers, achieving an accuracy of 98.99\%. The study concludes that combining multiple classifiers and feature sets can lead to more accurate and reliable malware detection, providing a foundation for future research in the field of Android malware detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_92854_3_36,
  title = {Performance Parameters Analysis for Hybrid Meta-Heuristic Approach},
  author = {Shirke, Sushama and Naveenkumar, J. and Patil, Suhas and Dhotre, Sunita},
  booktitle = {Sustainable Artificial Intelligence-Powered Applications},
  year = {2025},
  pages = {303-309},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-92854-3\_36},
  url = {https://doi.org/10.1007/978-3-031-92854-3\_36},
  abstract = {To handle large peak loads resource over provisioning is the simple solution but due to the high cost and limited resource capacity at edge nodes over provisioning of resources is unsuitable. The study aims to provide the insights of the Docker containers in various computational environments and potential benefits of the proposed hybrid approach using genetic and falcon optimization algorithms. The proposed system increases the performance with limited resources, less hardware and meta-heuristic optimization algorithm used for balancing the load. Experimental simulation using java cloudsim shows availability of resources for execution of the task and performance analysis for dynamic load balancing using performance parameters like average waiting time, process time, latency, execution time and throughput. The simulation execution validates the proposed hybrid meta-heuristic algorithm on computational storage architecture using resource-based approach. It gives improvement in the throughput around 37–39\% appx and reduced latency by 0.04421, 0.3690 ms appx also execution time reduced by 29\% appx over optimization algorithms used for scheduling in the cloud environment.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_00630_1_5,
  title = {A Multi-dataset Evaluation of Models for Automated Vulnerability Repair},
  author = {Khan, Zanis Ali and Garg, Aayush and Tang, Qiang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {73-87},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-00630-1\_5},
  url = {https://doi.org/10.1007/978-3-032-00630-1\_5},
  abstract = {Software vulnerabilities pose significant security threats, requiring effective mitigation. While Automated Program Repair (APR) has advanced in fixing general bugs, vulnerability patching—a security-critical aspect of APR—remains underexplored. This study investigates pre-trained language models, CodeBERT and CodeT5, for automated vulnerability patching across six datasets and four languages. We evaluate their accuracy and generalization to unknown vulnerabilities. Results show that while both models face challenges with fragmented or sparse context, CodeBERT performs comparatively better in such scenarios, whereas CodeT5 excels in capturing complex vulnerability patterns. CodeT5 also demonstrates superior scalability. Furthermore, we test fine-tuned models on both in-distribution (trained) and out-of-distribution (unseen) datasets. While fine-tuning improves in-distribution performance, models struggle to generalize to unseen data, highlighting challenges in robust vulnerability detection. This study benchmarks model performance, identifies limitations in generalization, and provides actionable insights to advance automated vulnerability patching for real-world security applications.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s12652_020_02196_4,
  title = {Android malware detection method based on bytecode image},
  author = {Ding, Yuxin and Zhang, Xiao and Hu, Jieke and Xu, Wenting},
  journal = {Journal of Ambient Intelligence and Humanized Computing},
  year = {2023},
  volume = {14},
  number = {5},
  pages = {6401-6410},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12652-020-02196-4},
  url = {https://doi.org/10.1007/s12652-020-02196-4},
  abstract = {Traditional machine learning based malware detection methods often use decompiling techniques or dynamic monitoring techniques to extract the feature representation of malware. This procedure is time consuming and strongly depends on the skills of experts. In addition, malware can be packed or encrypted to evade the analysis of decompiling tools. To solve this issue, we propose a static detection method based on deep learning. We directly extract bytecode file from Android APK file, and convert the bytecode file into a two-dimensional bytecode matrix, then use the deep learning algorithm, convolution neural network (CNN), to train a detection model and apply it to classify malware. CNN can automatically learn features of bytecode file which can be used to recognize malware. The proposed detection model avoids the procedure for analyzing malware features and designing the feature representation of malware. The experimental results show the proposed method is effective to detect malware, especially malware encrypted using polymorphic techniques.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_96_9952_0_28,
  title = {Android Malware Classification Based on Cross-Attention Mechanism with Multiscale CNN and GCN},
  author = {Hong, Xin and Jiang, Huai and Wang, Yang},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {327-337},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-9952-0\_28},
  url = {https://doi.org/10.1007/978-981-96-9952-0\_28},
  abstract = {The rapid increase in Android malware presents a significant challenge to the security of mobile devices. To address this issue, this paper proposes a classification model that utilizes multi-view feature fusion to improve malware detection and classification performance. First, A two-layer graph convolutional network is employed to learn structured representations from the Android application’s call graph, effectively capturing its inherent topological characteristics. Secondly, A multi-scale convolutional neural network is leveraged to derive social network representations from the call graph, enhancing both local and global information expression. Subsequently, the two-view features are integrated via a cross-attention strategy, which facilitates more effective modeling of feature correlations and enhances classification accuracy. Experimental results on public datasets show that the proposed model outperforms existing methods in classification metrics, providing a new solution for the detection and classification of Android malware.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11042_024_20455_w,
  title = {PacDroid: lightweight android malware detection using permissions and intent features},
  author = {Kadir, Abdul and Peddoju, Sateesh Kumar},
  journal = {Multimedia Tools and Applications},
  year = {2024},
  volume = {84},
  number = {27},
  pages = {32351-32379},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-024-20455-w},
  url = {https://doi.org/10.1007/s11042-024-20455-w},
  abstract = {The popularity of the Android platform and the widespread use of mobile applications have made them prime targets for cyber threats. Conventional single-feature-based detection models struggle to keep pace with the rapidly evolving landscape of Android malware. This paper introduces PacDroid, a lightweight Android malware detection model that combines Android permissions, Intent Actions, and Category features to train the detection model. The feature selection phase integrates an advanced algorithm based on Gini importance, also known as Mean Decrease Impurity (MDI). This method evaluates and ranks features, selecting the most relevant ones to construct a more streamlined and effective model, thereby mitigating overfitting and enhancing generalization. The algorithm efficiently reduces the feature set size by 85\% and cuts training time up to 90\%, significantly enhancing model performance. We trained and evaluated Machine Learning (ML) classifiers, including Random Forests and XGBoost, on two benchmark datasets, CCCS-CIC and CIC-MalDroid, comprising 88,000 samples. The proposed model achieves 95.81\% accuracy without feature selection and 96.75\% accuracy with feature selection, outperforming existing methodologies.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_27034_5_16,
  title = {Latent Semantic Structure in Malicious Programs},
  author = {Musgrave, John and Messay-Kebede, Temesguen and Kapp, David and Ralescu, Anca},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {234-246},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-27034-5\_16},
  url = {https://doi.org/10.1007/978-3-031-27034-5\_16},
  abstract = {Latent Semantic Analysis is a method of matrix decomposition used for discovering topics and topic weights in natural language documents. This study uses Latent Semantic Analysis to analyze the composition binaries of malicious programs. The semantic representation of the term frequency vector representation yields a set of topics, each topic being a composition of terms. The vectors and topics were evaluated quantitatively using a spatial representation. This semantic analysis provides a more abstract representation of the program derived from its term frequency analysis. We use a metric space to represent a program as a collection of vectors, and a distance metric to evaluate their similarity within a topic. The segmentation of the vectors in this dataset provides increased resolution into the program structure.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_0129_8_25,
  title = {Anomaly Detection Method of Source Code Vulnerability Detection Tools Based on Differential Testing},
  author = {Xiao, Zhaohong and Wang, Zhiming and Shen, Cong and Zhang, Yuque and Du, Jianqi},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {342-357},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-0129-8\_25},
  url = {https://doi.org/10.1007/978-981-95-0129-8\_25},
  abstract = {Deep learning-based source code vulnerability detection tools have gained popularity among developers for identifying security flaws in source code. However, these tools often exhibit poor generalization, achieving high accuracy only on datasets similar to their training data, and performing poorly (less than 20\% accuracy) in real-world environments. This performance gap is attributed not only to training data issues but also to anomalies in tool design, implementation, and robustness—factors typically overlooked in current research. Most existing works focus on improving datasets and algorithms, ignoring the fact that such tools, as software systems, also require systematic testing. This paper views deep learning-based detection tools as software and introduces a novel anomaly detection framework based on differential testing. Unlike prior approaches, our method targets not only common software faults but also deep learning-specific anomalies and those unique to vulnerability detection tools. We further propose a new test case mutation strategy to enhance differential testing effectiveness. Our system identifies, quantifies, and provides fixes for detected anomalies, supporting automated and efficient anomaly detection and repair. This work bridges the gap between software testing and AI-based vulnerability detection, providing a more holistic and robust evaluation and improvement framework.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_979_8_8688_1874_5_14,
  title = {Reading and Understanding Code},
  author = {Smith, Stephen},
  booktitle = {Maker Innovations Series},
  year = {2025},
  pages = {283-302},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-1874-5\_14},
  url = {https://doi.org/10.1007/979-8-8688-1874-5\_14},
  abstract = {Having covered a substantial amount of ARM 64-bit Assembly Language, the next logical step is to read code written by other programmers. Exploring the work of others offers valuable opportunities to expand a repertoire of tips and tricks and to enhance personal coding practices. Several sources provide Assembly Language source code for the ARM processor. Reviewing an Assembly Language routine from the Linux kernel can reveal new optimization techniques.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_96157_1_49,
  title = {Software Privacy Based on Call Graph Diversification and Obfuscation},
  author = {Véliz, Miguel Joseph Rodríguez and González, Anaisa Hernández and Lima, Roberto Sepúlveda and Musa, Yulier Núñez},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2026},
  pages = {671-683},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-96157-1\_49},
  url = {https://doi.org/10.1007/978-3-031-96157-1\_49},
  abstract = {Source code security has gained relevance in recent years due to the increase in software piracy. Several techniques have been developed to complicate the efforts of attackers who use reverse engineering to understand programs. Code obfuscation deliberately conceals its specifics by employing different approaches. This work evaluates the results of several studies that use one or more approaches. Based on this analysis, a software privacy model is presented, which is based on the diversification and obfuscation of the call graph. The model includes the tasks to be performed and the algorithms that implement it. Its evaluation was conducted in a testbed with favorable results.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10207_023_00679_x,
  title = {SFCGDroid: android malware detection based on sensitive function call graph},
  author = {Shi, Sibo and Tian, Shengwei and Wang, Bo and Zhou, Tiejun and Chen, Guanxin},
  journal = {International Journal of Information Security},
  year = {2023},
  volume = {22},
  number = {5},
  pages = {1115-1124},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00679-x},
  url = {https://doi.org/10.1007/s10207-023-00679-x},
  abstract = {Android is now one of the most popular operating systems in the world because of its open source character, so the threshold for hackers to make malware has also become lower, and more and more malware has started to threaten people’s lives. Graphs are used to represent the program’s syntactic and semantic structure, and can naturally represent malicious behavior, so we propose a malware detection method named SFCGDroid, which based on sensitive function call graph, so we propose a malware detection method named SFCGDroid, which based on sensitive function call graph. We first decompile the Android application to generate a function call graph (FCG), and extract the sensitive function call graph (SFCG) on the FCG. Secondly, we extract two class features (1) use the Skip-gram model to obtain function embeddings, and (2) treat the SFCG as a social network and extract the triads attribute of the sensitive API. The two types of features are combined as a feature representation of the SFCG and fed into a graph convolutional network (GCN) for malware detection. For experiments on 26,939 Android software datasets, SFCGDroid in this paper can achieve 98.22\% accuracy and 98.20\% F1 score.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_025_10671_9,
  title = {JNFuzz-Droid: a lightweight fuzzing and taint analysis framework for native code of Android applications},
  author = {Cao, Jianchao and Guo, Fan and Qu, Yanwen},
  journal = {Empirical Software Engineering},
  year = {2025},
  volume = {30},
  number = {5},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10671-9},
  url = {https://doi.org/10.1007/s10664-025-10671-9},
  abstract = {The need to account for native code in Android apps is becoming urgent as the usage of native code is growing in both benign and malicious apps. However, most current state-of-the-art analysis tools cannot effectively analyze the data-flow behavior of native code. On the one hand, existing native dynamic analysis tools are primarily based on test input generation tools to analyze Android apps and are therefore unable to locate native code quickly. On the other hand, existing native static analysis tools are based on symbolic execution to analyze native code and are therefore limited by the path and state explosion issues. In order to effectively analyze the behavior of sensitive data in the native code, we first propose JNFuzz , a fuzzing module for Android native libraries based on Client/Server architecture. Then, we propose JNFuzz-Droid , a lightweight automated fuzzing and taint analysis framework for Android native code, based on this. JNFuzz-Droid first locates the Android native code to which sensitive data is passed and then uses JNFuzz to fuzz the native code to improve code coverage while analyzing the data flow in native code with a dynamic binary tool. Experimental results on benchmarks and real-world apps show that JNFuzz-Droid can effectively detect the leakage or transfer of sensitive data in app native code and outperforms the state-of-the-art native analysis tools.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_92886_4_17,
  title = {Flatdc: Automatic Schema Reverse Engineering of FlatBuffers},
  author = {See, August and Ostendorf, Benedikt and Sell, Lilly and Fischer, Mathias},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2025},
  pages = {249-262},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-92886-4\_17},
  url = {https://doi.org/10.1007/978-3-031-92886-4\_17},
  abstract = {Schema reverse engineering is critical for analyzing closed-source software, including malware. Extracting communication schemas is particularly challenging for binary protocols. This paper presents two approaches for automatically reverse-engineering FlatBuffer schemas, a binary serialization framework by Google that, if exposed, can lead to security vulnerabilities such as size explosion attacks. The first, the binary approach, exploits static analysis and instruction simulation to extract schemas directly from validation logic. The second, the on-the-wire approach, analyzes protocol messages to approximate schemas, effectively narrowing the possible data types per field to an average of 2.3. We evaluate both methods on self-compiled binaries and third-party FlatBuffer schemas. The binary approach consistently extracts full schemas, aiding in vulnerability detection. The on-the-wire approach, though less precise, remains language-agnostic and resilient to binary obfuscation, making it valuable for security-focused protocol analysis.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_5135_1_3,
  title = {Analysis of Threat Models},
  author = {Wei, Qiang and Wang, Wenhai and Huang, Huihui},
  booktitle = {Industrial Internet Security},
  year = {2025},
  pages = {85-135},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-5135-1\_3},
  url = {https://doi.org/10.1007/978-981-96-5135-1\_3},
  abstract = {This chapter examines the escalating cyber-physical threats within the industrial internet due to the deep integration of IT and OT systems. It reviews numerous attack cases against industrial control systems (ICS) over the past two decades to identify patterns, techniques, and models. These insights are crucial for developing threat models, which inform targeted defense strategies and contribute to the establishment of robust security systems.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_024_10602_0,
  title = {Towards an understanding of large language models in software engineering tasks},
  author = {Zheng, Zibin and Ning, Kaiwen and Zhong, Qingyuan and Chen, Jiachi and Chen, Wenqing and Guo, Lianghong and Wang, Weicheng and Wang, Yanlin},
  journal = {Empirical Software Engineering},
  year = {2025},
  volume = {30},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-024-10602-0},
  url = {https://doi.org/10.1007/s10664-024-10602-0},
  abstract = {Large Language Models (LLMs) have drawn widespread attention and research due to their astounding performance in text generation and reasoning tasks. Derivative products, like ChatGPT, have been extensively deployed and highly sought after. Meanwhile, the evaluation and optimization of LLMs in software engineering tasks, such as code generation, have become a research focus. However, there is still a lack of systematic research on applying and evaluating LLMs in software engineering. Therefore, this paper comprehensively investigate and collate the research and products combining LLMs with software engineering, aiming to answer two questions: (1) What are the current integrations of LLMs with software engineering? (2) Can LLMs effectively handle software engineering tasks? To find the answers, we have collected related literature as extensively as possible from seven mainstream databases and selected 123 timely papers published starting from 2022 for analysis. We have categorized these papers in detail and reviewed the current research status of LLMs from the perspective of seven major software engineering tasks, hoping this will help researchers better grasp the research trends and address the issues when applying LLMs. Meanwhile, we have also organized and presented papers with evaluation content to reveal the performance and effectiveness of LLMs in various software engineering tasks, guiding researchers and developers to optimize.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_57537_2_6,
  title = {Effectiveness of Binary-Level CFI Techniques},
  author = {Vaidya, Ruturaj K. and Kulkarni, Prasad A.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {87-103},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-57537-2\_6},
  url = {https://doi.org/10.1007/978-3-031-57537-2\_6},
  abstract = {Memory corruption is an important class of vulnerability that can be leveraged to craft control flow hijacking attacks. Control Flow Integrity (CFI) provides protection against such attacks. Application of type-based CFI policies requires information regarding the number and type of function arguments. Binary-level type recovery is inherently speculative, which motivates the need for an evaluation framework to assess the effectiveness of binary-level CFI techniques. In this work, we develop a novel and extensible framework to assess how the program analysis information we get from advanced binary analysis tools affects the efficacy of type-based CFI techniques. We introduce new and insightful metrics to quantitatively compare source independent CFI policies with their ground truth source aware counterparts. We leverage our framework to evaluate binary-level CFI policies implemented using program analysis information extracted from the IDA Pro binary analyzer and compared with the ground truth information obtained from the LLVM compiler.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_1411_0_15,
  title = {Dual-View Aware Smart Contract Vulnerability Detection for Ethereum},
  author = {Yao, Jiacheng and Wang, Maolin and Chen, Wanqi and Jin, Chengxiang and Zhou, Jiajun and Yu, Shanqing and Xuan, Qi},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {187-200},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-1411-0\_15},
  url = {https://doi.org/10.1007/978-981-96-1411-0\_15},
  abstract = {The wide application of Ethereum technology has brought technological innovation to traditional industries. As one of Ethereum’s core applications, smart contracts utilize diverse contract codes to meet various functional needs and have gained widespread use. However, the non-tamperability of smart contracts, coupled with vulnerabilities caused by natural flaws or human errors, has brought unprecedented challenges to blockchain security. Therefore, in order to ensure the healthy development of blockchain technology and the stability of the blockchain community, it is particularly important to study the vulnerability detection techniques for smart contracts. In this paper, we propose a D ual-view Aware Smart Contract V ulnerability Det ection Framework named DVDet. The framework initially converts the source code and bytecode of smart contracts into weighted graphs and control flow sequences, capturing potential risk features from these two perspectives and integrating them for analysis, ultimately achieving effective contract vulnerability detection. Comprehensive experiments on the Ethereum dataset show that our method outperforms others in detecting vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_8343_7_36,
  title = {An Overview of Innovative Techniques and Approaches in Malware Detection},
  author = {Patel, Sitanshu Kumar and Ojha, Nitish Kumar and Tyagi, Neha},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2025},
  pages = {455-468},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-8343-7\_36},
  url = {https://doi.org/10.1007/978-981-96-8343-7\_36},
  abstract = {In today’s fast-changing world of cybersecurity, detecting malware is a big challenge. Malicious threats keep getting smarter and more. This paper looks at new techniques and methods used in malware detection, showing recent advancements in this area. We’ll discuss various strategies like heuristic analysis, behavioral detection, and deep learning algorithms. There are also hybrid methods that mix different techniques to improve accuracy. Additionally, the paper examines recent developments in signature detection, anomaly detection, behavioral detection, static analysis, dynamic analysis, hybrid analysis, blocklisting, allowlisting, honeypots, and sandboxing methods. This overview attempts to provide insights into the efficiency, constraints, and potential future directions of contemporary malware detection methods by synthesizing studies and trends. The insights provided here are intended to help researchers, practitioners, and cybersecurity experts who want to stay ahead of new emerging threats and strengthen their malware detection capabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_13075_4_15,
  title = {Managing Risks and Improving Cyber Resilience – Assessing Mobile Application Security Using a Reference Model},
  author = {Pieterse, Heloise},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2026},
  pages = {214-229},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-13075-4\_15},
  url = {https://doi.org/10.1007/978-3-032-13075-4\_15},
  abstract = {Mobile devices, especially smartphones, have become an integral part of users’ personal and professional lives. Central to the expansive use and prevalence of mobile devices are mobile applications – software developed to enhance the functionality offered by these devices. Mobile applications offer unparalleled support for users, ranging from personal use to work-related activities. However, increased usage of mobile applications can pose serious security risks due to vulnerabilities or faults that may exist within the software. It becomes, therefore, imperative to evaluate mobile applications for security risks before releasing the software for either general or professional use. Such an evaluation of a mobile application is conducted via a security assessment, which aims to determine if a mobile application conforms to specified security requirements. The proper security assessment of a mobile application requires a framework to guide security analysts in applying techniques and approaches to eliminate risks and ensure resilience against attacks. This paper presents a reference model conceptualising the requirements needed to conduct a comprehensive security assessment of mobile applications. The reference model provides an abstraction of the phases, as well as the relationship between the phases, to guide the assessment of mobile application security. The outcome of this paper is a contribution to a commonly accepted domain definition for assessing mobile application security, ensuring that such assessments can be performed consistently and effectively.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_979_8_8688_0453_3_7,
  title = {Garbage Collection – Introduction},
  author = {Kokosa, Konrad and Nasarre, Christophe and Gosse, Kevin},
  booktitle = {Pro .NET Memory Management},
  year = {2024},
  pages = {343-397},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-0453-3\_7},
  url = {https://doi.org/10.1007/979-8-8688-0453-3\_7},
  abstract = {Welcome to the most important part of this book. The previous chapters have described quite broadly the subject of memory management with some theoretical and hardware introductions. You also got to learn a lot of details about the organization of memory in the .NET environment – how it is divided into segments and generations and how all this infrastructure works with the operating system. Much of this knowledge is valuable in itself, allowing you, for example, to diagnose excessive memory allocations or how to use different methods to avoid them.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_64650_8_44,
  title = {Dynamic Analysis of Window’s Based Malware Using Reverse Engineering: A Case Study of Exmatter},
  author = {Surange, Geetanjali and Khatri, Pallavi and Hazra, Shubhankar},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {438-449},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64650-8\_44},
  url = {https://doi.org/10.1007/978-3-031-64650-8\_44},
  abstract = {Malware analysis, is a crucial and cumbersome task, because of the continuously evolving characteristics of malware. Most of the malware damages the system resources or held them hostages for some unreasonable demands. Trojan is one of the most sought out malware by the attackers as it does destruction itself as well as it carries other types of malwares to the targets. This paper, proposes a framework for carrying out dynamic analysis of Trojan type malware, along with the mitigation methods and ways, by acquiring and executing the code at various stages of the malware in a controlled virtual environment. The experiment was carried out on, a virtual Window’s 11 machine, by following each step of the proposed framework. The analysis of the code is done using open source tools at various stages of the framework. The analysis carried out in the study results in identification of Indicators of Compromise (IOC) and strings that represent suspicious behavior and Tricks, Tactics and Procedures (TTP) of Exmatter malware, which further help to mitigate the effects of the attack.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_89350_6_8,
  title = {On the Properness of Large Language Models for Malware Detection},
  author = {Marilena, Lupaşcu and Constantin, Viţel Silviu and Teodor, Gavriluţ Dragoş and Henri, Luchian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {125-140},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-89350-6\_8},
  url = {https://doi.org/10.1007/978-3-031-89350-6\_8},
  abstract = {The last couple of years were marked by the rise of LLMs (Large Language Models) that are shown to bring important developments in various sectors such as technology, education or customer service. Generative AI also impacts other areas such as content generation, data analysis, and can be used to automate various systems. From a security point of view, initial applications of LLMs improve customer support services - be it direct customer support or security operation centers - and also the way an IT administrator connects with SIEM (Security Information and Event Management) or XDR (Extended Detection and Response) products. However, there were fewer practical attempts to use LLMs to improve the detection rate or a security product at large. The current paper explores this direction by analyzing the detection rate of several LLMs (ChatGPT, LLama, Mistral, Orca2, Falcon) against a recent set of macro VBA (Visual Basic for Application) malware. The respective performance levels are discussed. Other relevant issues, such as inference cost, memory and space requirements and practicality from a security product point of view, are also considered. Even if the models used in our research do not reach adequate results in terms of detection rate they can still be used in security operation centers to assist a security researcher to analyse malicious content. Furthermore, additional fine-tuning might improve the accuracy of such models to a point where they may become a good choice for various security tasks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00034_025_03198_3,
  title = {IAFF-VC: Any-to-Any Voice Conversion Using Attentional Feature Fusion},
  author = {Guo, Kai and Xu, Yang and Zhang, Sicong},
  journal = {Circuits, Systems, and Signal Processing},
  year = {2025},
  volume = {44},
  number = {11},
  pages = {8489-8509},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00034-025-03198-3},
  url = {https://doi.org/10.1007/s00034-025-03198-3},
  abstract = {Voice conversion (VC) requires precise preservation of source speech content while effectively capturing target speaker characteristics. Current approaches predominantly focus on extracting granular acoustic representations, yet often neglect the crucial integration of heterogeneous feature types, resulting in an inherent performance trade-off between content fidelity and speaker similarity. To address this limitation, we present IAFF-VC, a novel framework for non-parallel any-to-any voice conversion that synergistically combines encoder–decoder architecture with multi-scale feature fusion. Our proposed EMAFF module introduces a multi-branch channel grouping mechanism that strategically reorganizes spatial-semantic features across distinct subspaces, enabling optimal fusion of complementary speech attributes. Comprehensive evaluations on the VCTK benchmark demonstrate IAFF-VC’s superior performance in one-shot conversion scenarios, achieving state-of-the-art results with 9.75\% CER and 91.76\% speaker similarity score, while maintaining 4.21 mean opinion score for speech naturalness.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_96_1687_9_7,
  title = {Advancements in Cyber Security Using Deep Learning Techniques Attack Detection for Trojan Horses},
  author = {Amutha, S. and Sagin Sandoz Fernando, E. and Jayanth, G. and Ajay Kumar Reddy, K. and Angel Jean Vincy, K. and Nivethika, K.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2025},
  pages = {91-105},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-1687-9\_7},
  url = {https://doi.org/10.1007/978-981-96-1687-9\_7},
  abstract = {Cybersecurity risks, particularly attacks using Trojan horses, represent a significant risk to modern computer systems. We suggest and evaluate improved deep learning methods for Trojan horse attack detection using the Kaggle-hosted Trojan Detection dataset. Deep learning may help cybersecurity identify Trojan horses. These neural network methods find bad trends in massive data. Deep learning models re more accurate and efficient than traditional detection approaches because they adapt to changing threats. Recent research demonstrates that new Trojan horse detection methods are quicker and more accurate. It prevents data breaches and unauthorized access, making it a vital cybersecurity improvement. This work makes use of these techniques. To achieve a high degree of accuracy in identifying malicious software, our technique is based on the classification of convolutional neural networks (CNNs). We preprocess and enrich the dataset to enhance the model’s generalizability. As a result of extensive testing and optimization, Trojan horse attacks and other cyberattacks risk sensitive data and systems. Trojan horses and malicious software masquerading as legitimate, may be catastrophic. CNN-based classification solves this. From Kaggle’s Trojan Detection dataset. Data preparation and enrichment increase feature representation. Models classify threats. This proposed Model achieved an impressive accuracy rate of 98.6\% in identifying Trojan horse attacks in cybersecurity applications.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_92882_6_5,
  title = {Facing the Challenge of Leveraging Untrained Humans in Malware Analysis},
  author = {Zhao, Benjamin Zi Hao and Asghar, Hassan Jameel and Ikram, Muhammad and Kaafar, Mohamed Ali and Lamont, Sean and Coscia, Daniel},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2025},
  pages = {61-75},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-92882-6\_5},
  url = {https://doi.org/10.1007/978-3-031-92882-6\_5},
  abstract = {Software binary analysis, tools and machine learning aid security analysts in interpreting data, by automated means that filter, prioritize, and arrange pertinent information for skilled analysts. In this work, we revisit cooperative human-machine teams and evaluate the possibility of enabling untrained humans to assist machines and skilled analysts in their analysis of software binaries. Specifically, we propose a pipeline to transform a complex input domain into facial images on which untrained individuals make similarity decisions. Our faces include realistic human, animal, artistic, and anime faces that preserve inherent distances between data points of the input domain. Our approach is evaluated through a human study, where untrained respondents with minimal training successfully flag machine misclassifications. The untrained human does not replace the machine or skilled analyst, instead, utilized in a triage setting, to identify samples without historical precedence, deferring the decision to the skilled analyst for deeper inspection.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42835_025_02413_0,
  title = {Hybrid Temporal Convolutional Networks with LSTSVM Model for Android Malware Detection Using Explainable AI},
  author = {Mohanraj, A. and Sivasankari, K.},
  journal = {Journal of Electrical Engineering \& Technology},
  year = {2026},
  volume = {21},
  number = {1},
  pages = {929-939},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42835-025-02413-0},
  url = {https://doi.org/10.1007/s42835-025-02413-0},
  abstract = {In recent years, malware aimed at Android has become more common. Because of code obfuscation, antivirus solutions and outdated detection algorithms have a hard time keeping up. Researchers have begun using deep learning (DL) algorithms for malware detection, according to current research. Presented a DL model that combines Temporal Convolutional Networks (TCN) with Shapley Additive Explanations (SHAP) model as the basis for an algorithm for Android malware detection. Start by taking a look at the Android virus; not only will static characteristics be extracted, but dynamic behavioral elements with good anti obfuscation ability will as well. The TCN is implemented for processing the static characteristics due to their relative independence. When processing a series of dynamic features, the gate recurrent unit (GRU) is used because of the features’ temporal correlation. Hence, Understandable Artificial Intelligence- Android Malware Detection -Deep Learning (XAI-AMD-DL), a hybrid Android malware detection system employing DL models, is proposed in this research. It combines XAI with TCNs and finally classified using Logistic Twin based Support Vector Machine (SVM) model. Test the suggested model via the CICMalDroid 2020 dataset. The suggested XAI-AMD-DL model surpasses the current DL models with values of 99.98\% accuracy, 99.75\% precision, 99.75\% recall, and f1-score, respectively.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_7446_0_3,
  title = {Project Files},
  author = {Hagos, Ted},
  booktitle = {Beginning IntelliJ IDEA},
  year = {2022},
  pages = {31-37},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7446-0\_3},
  url = {https://doi.org/10.1007/978-1-4842-7446-0\_3},
  abstract = {What we’ll cover in this chapter is as follows:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_19_0336_6_10,
  title = {Code Auditing},
  author = {Nu1L Team},
  booktitle = {Handbook for CTFers},
  year = {2022},
  pages = {651-724},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-0336-6\_10},
  url = {https://doi.org/10.1007/978-981-19-0336-6\_10},
  abstract = {In CTF contests, there are often a variety of code auditing challenges, and it can be said that the code auditing procedures in the CTF challenges are very close to reality. The essence of code audit is to find defects in the code, this chapter only takes the mainstream PHP and Java languages code audit as an example, so that the reader not only understands the CTF code audit challenges but also can accumulate some real-world code audit experience.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_77571_0_50,
  title = {Using the Metadata-Based App-PI Ecosystem to Assess the Privacy Impact of Health Apps},
  author = {Martínez-González, M. Mercedes and Pérez-Fuente, Alejandro and Aparicio, Amador and Criado-Lozano, Pablo A.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {522-533},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-77571-0\_50},
  url = {https://doi.org/10.1007/978-3-031-77571-0\_50},
  abstract = {Mobile applications (apps) facilitate the management of devices and sensors from mobile devices in IoE environments. However, their use carries risks for the privacy of their users: many of them manage personal data. The App-PI (App Privacy Impact) ecosystem analyzes the impact of apps on privacy, addressing the challenge of knowing, understanding and mitigating these risks. In App-PI, a metadata warehouse, a set of analysis tools that calculate indicators, a visualization platform, and verification processes, collaborate. Data flows between these components to provide persons using the visualization platform with accurate, reliable, and understandable information. The warehouse hosts metadata related to the privacy and security of mobile apps. The data flow starts with the collection and integration of data hosted in the warehouse. The analysis tools use these data to calculate indicators that provide objective measures of the risk associated with each app. These values are the input for a verification process based on static analysis, which provides confidence. To make it easier for end users to understand these indicators, they are displayed on the visualization platform with easy-to-understand charts. The flows and usefulness of this ecosystem are shown for health and wellness apps, characteristic of IoE environments.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_95_6209_1_17,
  title = {LLM-DAS: An LLM-Powered Deobfuscation System for ARM Binary Code},
  author = {Liu, Jiahan and Jing, Jing and Lin, Jian and Sun, Haonan and Zhu, Bing},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {312-329},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-95-6209-1\_17},
  url = {https://doi.org/10.1007/978-981-95-6209-1\_17},
  abstract = {Deobfuscation techniques play a crucial role in enhancing the readability and analyzability of obfuscated code, thereby facilitating more effective reverse engineering and security analysis. However, the majority of existing deobfuscation research has primarily focused on the source code level, with limited effectiveness in deobfuscating binary code. Despite the emergence of Large Language Models (LLMs) and their effective application in the deobfuscation domain, there remains a lack of research leveraging LLMs for deobfuscating ARM binary code. In this paper, we construct a high-quality dataset of obfuscated ARM assembly code, comprising seven types of single obfuscations and seven types of multiple obfuscations. Based on this, we propose LLM-DAS, the first deobfuscation system specifically designed for ARM binary code and grounded in large language models. LLM-DAS consists of two finetuned large models tailored for obfuscation detection and deobfuscation, respectively, and we evaluate its performance. The experimental results demonstrate that the obfuscation detection component achieves an average accuracy and precision of 91.96\% and 94.94\%, respectively. In terms of deobfuscation performance, it attains a maximum average SacreBLEU score of 26.21, representing improvements of 20.09 and 17.11 compared to Llama3 and Qwen2.5, which have the same parameter scale. Furthermore, when evaluated against three metrics within the Obfuscation Quality Quantification Framework, LLM-DAS also outperforms the aforementioned two models.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_20096_0_18,
  title = {A Survey of Android Malware Detection Based on Deep Learning},
  author = {Wang, Dianxin and Chen, Tian and Zhang, Zheng and Zhang, Nan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {228-242},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-20096-0\_18},
  url = {https://doi.org/10.1007/978-3-031-20096-0\_18},
  abstract = {Android malware poses a serious threat to cyberspace security, and many researchers are committed to researching fast and effective methods for Android malware detection. However, the latest Android malware usually uses escape techniques such as code obfuscation, so the traditional machine learning methods gradually become invalid. In recent years, deep learning has been gradually applied in the field of Android malware detection due to its powerful data processing and feature representation capabilities, and has achieved convincing performance. This paper conducts a review and research on the related achievements of Android malware detection based on deep learning in recent years, and classifies Android malware detection methods according to different characteristics and different networks. At the same time, a systematic introduction on deep learning model algorithms, such as RNN, CNN, Attention Mechanism, etc., is made. Besides, we analyze most commonly used datasets and evaluation indicators. The outcomes of this paper can provide a more comprehensive overview for researchers in the field, aiming to inspire researchers to make more and better achievements in Android malware detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_79584_9_5,
  title = {Database Program Translation},
  author = {Fong, Joseph S. P. and Wong Ting Yan, Kenneth},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2021},
  pages = {169-213},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-79584-9\_5},
  url = {https://doi.org/10.1007/978-3-030-79584-9\_5},
  abstract = {The concept of a relational database was first proposed by E.F. Codd in 1970. It was almost instantaneously recognized as a more user-friendly model than the previous nonrelational (e.g., hierarchical or network model) database model. However, it was not adopted by the industry until the early 1980s because of its poor performance. Throughout the 1980s, the performance of relational databases improved and gained wider industry acceptance. This created a need to convert existing databases into a relational structure. Yet database conversion is both a costly and time-consuming process. The majority of time spent on such conversion projects is spent on the process of program translation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_89813_6_7,
  title = {Machine Learning-Based Detection of Java Semantic Clones Using Low-Level Abstract Compiled Representation},
  author = {Quradaa, Fahmi H. and Shahzad, Sara and Saeed, Rashad and Al-Hakimi, Mohammed H.},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {102-117},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-89813-6\_7},
  url = {https://doi.org/10.1007/978-3-031-89813-6\_7},
  abstract = {Detecting semantic code clones is crucial in software engineering to identify code fragments with similar functionality but different syntax. This process is vital for maintaining code quality and improving software maintainability. With recent advancements in machine learning and high computational processing, researchers increasingly utilize these sophisticated techniques for code clone detection. This paper presents a semantic code clone detector that utilizes machine learning algorithms on top of the low-level abstract compiled code intermediate representation known as Baf. The proposed technique has been implemented and assessed using real-world code clone pairs from the BigCloneBench dataset written in Java. Multiple experiments have been conducted, and the results have shown that the proposed technique outperforms several baseline methods in detecting semantic clones regarding recall and an F1 score.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_66245_4_9,
  title = {Method to Automate the Classification of PE32 Malware Using Word2vec and LSTM},
  author = {Percílio Azevedo, Bruce William and Oliveira Albuquerque, Robson de and García Villalba, Luis Javier},
  booktitle = {Advances in Information Security},
  year = {2025},
  pages = {213-230},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-66245-4\_9},
  url = {https://doi.org/10.1007/978-3-031-66245-4\_9},
  abstract = {Malware can be defined as a computer program that somehow causes damage to assets once it is executed. There are several types of malware, the most common being downloaders, keyloggers, miners, ransomware, rootkits, and spyware. Each of them has its own behavior and characteristics, and, in some cases, malware can be classified into more than one type due to its characteristics. Malware is typically written in structures with a greater number of utilities, aiming to affect as many assets as possible. One of the most used formats is PE32, which belongs to the object standard of the Microsoft Windows operating system family, where they have been available as executables or binaries. Its structure comprises MS-DOS 2.0 compatible EXE header, OEM identifier, a PE header, Section headers, and Image pages (import, export, and resource information). There are some techniques for analyzing this type of file, and one example is to use a sandbox to emulate the program and map key points, such as memory and file system, to identify malicious behavior. Another way is by using disassembly techniques to verify the program’s intention based on actions. Although these techniques are largely used by the malware research community, by default, they tend to be time-consuming or require considerable manual labor. On the other hand, there is research that aims to apply the use of deep learning to identify types of malware written in PE32 format, using disassembly techniques to recover the functions of the binary file and applying convolutional neural network (CNN) techniques to identify patterns in the use of these functions from malware. This current research proposes to go further, using disassembly techniques to extract functions and files from Microsoft Windows operating systems. After that, a dataset is structured with the extracted data, and a lexical interpretation structure based on word2vec is fostered, aiming to identify types of functions by malware types. Then, the idea is to use the results as input for a deep learning model with long short-term memory (LSTM) techniques, which are widely used as CNN substitutes. LTSM will map the patterns and create a model to identify new inputs (with the same structure) as the malware types of the original training. Using the word2vec model and the LSTM model within a docker structure, it is possible to analyze malware samples and identify their type from a portable environment, easy-lift, and communicating in an open source and well-known pattern.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_33491_7_26,
  title = {An Empirical Analysis of Security and Privacy Risks in Android Cryptocurrency Wallet Apps},
  author = {Sentana, I. Wayan Budi and Ikram, Muhammad and Kaafar, Mohamed Ali},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {699-725},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-33491-7\_26},
  url = {https://doi.org/10.1007/978-3-031-33491-7\_26},
  abstract = {A cryptocurrency wallet app is a piece of software that manages, stores, and generates private keys of cryptocurrency accounts. With the provision of services such as easy access to transaction history, and checking account balance besides transmissions of new transactions in distributed networks such as Blockchains, cryptocurrency wallet apps gain unprecedented popularity which in turn attracts malicious actors to attack users resulting in loss of cryptocurrency assets and leakage of sensitive user data. This paper presents the first large-scale study of Android cryptocurrency wallet apps. We surveyed apps on Google Play to detect and extract meta-data and application packages of 457 cryptocurrency wallet apps. We perform several passive and active measurements designed to investigate the security and privacy features to study the behavior of cryptocurrency wallet apps. Our analysis includes investigating cryptocurrency wallet apps’ third-party embedding, malware presences, and exfiltration of users’ sensitive data to third-parties. Our study reveals vulnerabilities and privacy issues in cryptocurrency apps including the insecure use of HTTP to serve transactions.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_6963_3_7,
  title = {Extending ABAP Development Tools},
  author = {Pęgiel, Łukasz},
  booktitle = {ABAP in Eclipse},
  year = {2021},
  pages = {415-469},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-6963-3\_7},
  url = {https://doi.org/10.1007/978-1-4842-6963-3\_7},
  abstract = {This chapter focuses on the ways to make your plugin work with ADT and how to fetch data from the backend using built-in ADT functionalities. This is presented as a separate chapter so you gain basic knowledge about creating an Eclipse plugin. Otherwise, it could be too much to understand at once. It is also the last chapter of this book. I hope you enjoyed reading it, as I enjoyed writing it!},
  content_type = {Chapter},
}


@article{springer_10_1007_s10489_025_06417_1,
  title = {A reinforcement learning malware detection model based on heterogeneous information network path representation},
  author = {Yang, Kang and Cai, Lizhi and Wu, Jianhua and Liu, Zhenyu and Zhang, Meng},
  journal = {Applied Intelligence},
  year = {2025},
  volume = {55},
  number = {7},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10489-025-06417-1},
  url = {https://doi.org/10.1007/s10489-025-06417-1},
  abstract = {With the significant increase of Android malware, the APP privacy data leakage incidents occur frequently, which poses a great threat to user property and information security. Specifically, the new malware has the characteristics of high evolution rate and diverse variants, leading to the fact that the current malware detection methods still have three key problems: (1) Difficulty in acquiring Android sample structural features; (2) Weakly in representing malware behavior structure; (3) Poor robustness of the detection model. To address the above limitations, we propose a new malware detection framework MPRLDroid with reinforcement learning. First of all, the MPRLDroid model extracts the Android APP structural features and constructs the heterogeneous information network data based on the semantic call structure between APP, API and permission. Subsequently, the model utilizes reinforcement learning to adaptively generate a meta-path for each sample and combines it with a graph attention network to effectively represent the graph of nodes. Finally, the low-dimensional graph node vector data is brought into the downstream detection task for classification, where the performance change of the classification result is used as a reward function for reinforcement learning. The experimental results demonstrate that the MPRLDroid model, when integrated with reinforcement learning, outperforms the baseline models in terms of performance, and its detection model exhibits greater robustness compared to other models.},
  content_type = {Article},
}


@article{springer_10_1007_s10462_024_10968_z,
  title = {Over-the-air upgrading for enhancing security of intelligent connected vehicles: a survey},
  author = {Li, Beibei and Hu, Wei and Da, Lemei and Wu, Yibing and Wang, Xinxin and Li, Yiwei and Yuan, Chaoxuan},
  journal = {Artificial Intelligence Review},
  year = {2024},
  volume = {57},
  number = {11},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10462-024-10968-z},
  url = {https://doi.org/10.1007/s10462-024-10968-z},
  abstract = {Abstract The continuous improvement in the connectivity, automation and autonomy levels of Intelligent Connected Vehicles (ICVs) significantly increases the probability of potential security threats. Over-the-Air (OTA) is a promising technique for upgrading features of ICVs and enhancing their reliability and security against environmental disturbances as well as malicious attacks. To better understand the potential security risks and possible countermeasures, we survey research works in ICV security during OTA from cloud upgrade, terminal upgrade, and object upgrade. We also summarize existing methods in OTA upgrading techniques and systematically investigate the overall framework of OTA upgrading methods from the perspectives of Software-Over-the-Air (SOTA) and Firmware-Over-the-Air (FOTA).We further discuss possible mitigation strategies and open issues yet to be resolved in this research direction. This survey shows that OTA provides a powerful technique for upgrading the ICV features and improving ICV security.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_8749_4_1,
  title = {Android Malware Detection Method Based on Machine Learning},
  author = {Wan, Xiong and Sun, Yuxi and Wang, Yanqing and Xia, Meng},
  booktitle = {Communications in Computer and Information Science},
  year = {2024},
  pages = {3-18},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-8749-4\_1},
  url = {https://doi.org/10.1007/978-981-97-8749-4\_1},
  abstract = {For the Android app market, malware uses code encryption techniques for block detection. For Android applications, scholars have proposed a method to determine whether Android applications are malicious software by analyzing the behavioral characteristics of software operation. The most traditional method is static detection, which is characterized by fast detection speed and less resource occupation. However, Android software cannot be detected by static methods after using encryption technology. The APK package of the application is first decompiled to detect and extract key features, behavioral patterns, and invocation information using Frida and Camille. Subsequently, the long short-term memory network (LSTM) is employed to analyze software intent for determining the presence of malware. The experimental results demonstrate that the static method achieves an accuracy of approximately 80\%, whereas the dynamic method achieves an accuracy of 91\%. Through the utilization of software intention analysis and permission usage checks in combination, the accuracy rate can be further enhanced to 94\%. Upon comparison of the different algorithms utilized in each detection method, it is concluded that both the KNN and random forest algorithms exhibit higher accuracy in the application of such detection methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_53555_0_9,
  title = {Fuzzing IoT Devices via Android App Interfaces with Large Language Model},
  author = {Ma, Wenxing and Cui, Baojiang},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2024},
  pages = {87-99},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-53555-0\_9},
  url = {https://doi.org/10.1007/978-3-031-53555-0\_9},
  abstract = {Most of the current automated testing methods for IoT devices rely on firmware analysis and firmware emulation. However, due to the diverse architectures and structures of firmware across different vendors, these methods have limited applicability and cannot perform large-scale testing. To address this issue, we have designed a tool called FIAL, a novel IoT device fuzzing method based on accompanying app interfaces. FIAL allows for the discovery of firmware vulnerabilities without the need for firmware analysis. It leverages a large language model to analyze the accompanying app and extract the most effective function interfaces for fuzzing. We applied FIAL to analyze five popular devices and discovered a total of 14 bugs, including 5 new vulnerabilities. We conducted a comparison with two other network fuzzing tools, and the experiment showed that FIAL can uncover more exploitable vulnerabilities using fewer test cases.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_64171_8_9,
  title = {Extended Abstract: Evading Packing Detection: Breaking Heuristic-Based Static Detectors},
  author = {D’Hondt, Alexandre and Bertrand Van Ouytsel, Charles Henry and Legay, Axel},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {174-183},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64171-8\_9},
  url = {https://doi.org/10.1007/978-3-031-64171-8\_9},
  abstract = {Nowadays, executable packing remains an open issue in its detection especially when it comes to static analysis. Packing is significantly used in malware to hide malicious code from detection systems. These last years, many studies about static packing detection addressed this problem with heuristics and machine learning, considering different ad hoc techniques, algorithms and feature sets but very few addressed it from the adversarial point of view, that is, how to fool heuristics by altering samples with targeted modifications. The objective of this work is to study to what extent it is easy to evade detection by open source static detectors that are commonly used by the community by applying alterations on packed samples, which require only slight adaptations of the related packers, resulting in evasion. An adversarial setting from the problem-space perspective is addressed by using realistic modifications of binary samples that target common significant features. For this purpose, alterations and datasets are composed and static detection is applied using the experimental toolkit Packing Box. Results of alterations are shown, in terms of information gain of features and accuracy of detection, on open source static packing detectors. Finally, their significant effects are highlighted and their effectiveness is evaluated.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10515_025_00575_9,
  title = {The arts and crafts of android adware across a decade},
  author = {Wang, Chao and Liu, Tianming and Zhao, Yanjie and Zhang, Lin and Du, Xiaoning and Li, Li and Wang, Haoyu},
  journal = {Automated Software Engineering},
  year = {2026},
  volume = {33},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-025-00575-9},
  url = {https://doi.org/10.1007/s10515-025-00575-9},
  abstract = {Adware represents a pervasive threat in the mobile ecosystem, yet its inherent characteristics have been largely overlooked by previous research. This work takes a crucial step towards demystifying Android adware. We present AdwareZoo , a comprehensive dataset comprising 15,996 adware samples across 118 distinct families collected from security reports and app repositories. We identify adware family payloads by isolating packages from samples for VirusTotal rescanning, unveiling distinctive patterns in family naming conventions, and exposing the misclassification of legitimate ad networks as adware. Our analysis of payload location strategies reveals that over 30\% of adware families employ payloads beyond conventional Java/Kotlin code. Based on our dataset analysis, we conducted a comprehensive Adware Characterization of 92 distinct adware families, revealing diverse implementation patterns and evolving techniques across the mobile ecosystem. To facilitate this analysis, we developed an Adware Characterization Schema that provided a structured taxonomy for systematically classifying the observed behaviors. Our investigation uncovered multiple categories of fraudulent activities, including aggressive ad display techniques, sophisticated click fraud implementations, privacy information leakage, malicious promotion mechanisms, and various persistence and evasion mechanisms employed to avoid detection while maximizing illicit revenue. This research establishes foundations for comprehending the fraudulent and adversarial techniques within the mobile adware landscape and facilitates the development of more robust detection mechanisms against these evolving threats.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_99_8024_6_15,
  title = {Multi-class Malware Detection via Deep Graph Convolutional Networks Using TF-IDF-Based Attributed Call Graphs},
  author = {Khan, Irshad and Kwon, Young-Woo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {188-200},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-8024-6\_15},
  url = {https://doi.org/10.1007/978-981-99-8024-6\_15},
  abstract = {The proliferation of malware in the Android ecosystem poses significant security risks and financial losses for enterprises and developers. Malware constantly evolves, exhibiting dynamic behavior and complexity, thus making it challenging to develop robust defense mechanisms. Traditional methods, such as signature-based and battery-monitoring approaches, struggle to detect emerging malware variants effectively. Recent advancements in deep learning have shown promising results in Android malware detection. However, most existing approaches focus on binary classification and need more insights into the model’s generality across different types of malware. This study presents a novel approach to address Android malware detection by integrating TF-IDF (Term Frequency-Inverse Document Frequency) features into the call graph structure. By attributing each node in the call graph with TF-IDF-based feature vectors extracted from the opcode sequences of each method using an opcode list, we present a more thorough representation that encapsulates the complex traits of the malware samples. We employ state-of-the-art graph-based deep learning models to classify malware families, including Graph Convolutional Networks (GCN), SAGEConv, Graph Attention Networks (GAT), and Graph Isomorphism Networks (GIN). By incorporating high-level structural information from the call graphs and TF-IDF-based raw features, our approach aims to enhance the accuracy and generality of the malware detection models. We identify an optimal model for the Android malware family classification task through extensive evaluation and comparison of the above-mentioned models. The findings of this study contribute to advancing the field of Android malware detection and provide insights into the effectiveness of graph-based deep learning models for combating evolving malware threats.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_68285_9_44,
  title = {Risk Analysis and Android Application Penetration Testing Based on OWASP 2016},
  author = {Borja, Thomás and Benalcázar, Marco E. and Valdivieso Caraguay, Ángel Leonardo and Barona López, Lorena Isabel},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {461-478},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-68285-9\_44},
  url = {https://doi.org/10.1007/978-3-030-68285-9\_44},
  abstract = {Mobile Applications have become part of our daily lives so that almost every web or desktop application can be executed from a smartphone, i.e., social networking, Internet shopping, on-line banking, gaming applications, among others. Furthermore, most of the existing mobile applications in digital stores are Android-based applications. Security in these kinds of applications is an issue that must be addressed because they handle sensitive personal information exposed to be exploited or misused by malicious agents. In this context, we have performed a complete security penetration testing on several Android applications following the most common risks according to OWASP mobile 2016 and using different tools such as Drozer, Dex2jar, Android Debug Bridge, among others. We describe the vulnerability, type of attack, application analyzed, and external tools used for each scenario. Once the vulnerabilities are exposed, we show a summary of the performed attacks, a risk analysis, and provide security recommendations for each layout. This work’s novelty is the provisioning of a risk matrix that resumes each attack’s main points and the whole vulnerability analysis in mobile devices, as it does not exist on the official site of OWASP.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_2417_1_2,
  title = {Identifying Ransomware Functions Through Microarchitectural Side-Channel Analysis},
  author = {Startzel, Connor and Brown, Dane and Owens Walker, T. and Hill, Jennie E.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {19-36},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-2417-1\_2},
  url = {https://doi.org/10.1007/978-981-96-2417-1\_2},
  abstract = {Ransomware continues to be an effective and lucrative means to extort large sums of money from organizations which depend on reliable access to data to meet their objectives. Often, the public embarrassment associated with falling victim to a ransomware attack is an effective motivator to pay and avoid the damaging headlines. The goal of this research is to improve the ability of security teams to identify ransomware samples in real-time. This type of determination has traditionally been difficult as attackers have been able to make small changes to malware to create variants which still infect systems but are not recognized by existing analysis tools. The work presented here uniquely leverages leaked source code which has been used by malicious actors to create custom ransomware variants for real ransomware campaigns. By isolating individual options for a build, we are able to determine ground truth and fingerprint its behavior using hardware-based side channel data collected by a CPU performance monitoring tool. This approach allowed us to successfully identify the Hardware Performance Counters and associated function calls which are directly correlated with specific capabilities inherent to the prolific Lockbit 3.0 ransomware. The specific function calls identified were those used to terminate Windows Defender protection and to search for shared network resources to encrypt. The methodology presented will help analysts detect ransomware samples for which there is no existing signature and narrow the scope of follow-on analysis, thus saving valuable time.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s42400_025_00361_w,
  title = {When LLMs meet cybersecurity: a systematic literature review},
  author = {Zhang, Jie and Bu, Haoyu and Wen, Hui and Liu, Yongji and Fei, Haiqiang and Xi, Rongrong and Li, Lun and Yang, Yun and Zhu, Hongsong and Meng, Dan},
  journal = {Cybersecurity},
  year = {2025},
  volume = {8},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-025-00361-w},
  url = {https://doi.org/10.1186/s42400-025-00361-w},
  abstract = {Abstract The rapid development of large language models (LLMs) has opened new avenues across various fields, including cybersecurity, which faces an evolving threat landscape and demand for innovative technologies. Despite initial explorations into the application of LLMs in cybersecurity, there is a lack of a comprehensive overview of this research area. This paper addresses this gap by providing a systematic literature review, covering the analysis of over 300 works, encompassing 25 LLMs and more than 10 downstream scenarios. Our comprehensive overview addresses three key research questions: the construction of cybersecurity-oriented LLMs, the application of LLMs to various cybersecurity tasks, the challenges and further research in this area. This study aims to shed light on the extensive potential of LLMs in enhancing cybersecurity practices and serve as a valuable resource for applying LLMs in this field. We also maintain and regularly update a list of practical guides on LLMs for cybersecurity at https://github.com/tmylla/Awesome-LLM4Cybersecurity .},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_71139_8_5,
  title = {Large Language Models for Software Engineering: A Systematic Mapping Study},
  author = {Görmez, Muhammet Kürşat and Yılmaz, Murat and Clarke, Paul M.},
  booktitle = {Communications in Computer and Information Science},
  year = {2024},
  pages = {64-79},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-71139-8\_5},
  url = {https://doi.org/10.1007/978-3-031-71139-8\_5},
  abstract = {In this research, we aim to conduct a systematic mapping study on Large Language Models (LLMs) for Software Engineering (SE). The significantly enhanced capabilities of LLMs have led to their use in many fields, including the important domain of SE. SE processes involve numerous artifacts, such as code, requirements, and documentation, which can serve as input to LLMs. To determine the potential applications of LLMs in SE, it’s crucial to understand their capabilities. Therefore, this systematic mapping study will explore the capabilities and potential of LLMs in SE tasks. Additionally, this research will address issues associated with LLMs, such as their non-deterministic nature and the problem of hallucinations. It will serve as a valuable resource for software developers, researchers, and practitioners interested in the intersection of artificial intelligence and SE, guiding their decisions on integrating these technologies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_80020_7_13,
  title = {Insights from Running 24 Static Analysis Tools on Open Source Software Repositories},
  author = {Hashmat, Fabiha and Aljaali, Zeyad Alwaleed and Shen, Mingjie and Machiry, Aravind},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {225-245},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-80020-7\_13},
  url = {https://doi.org/10.1007/978-3-031-80020-7\_13},
  abstract = {OSS is important and useful. We want to ensure that it is of high quality and has no security issues. Static analysis tools provide easy-to-use and application-independent mechanisms to assess various aspects of a given code. Many effective open-source static analysis tools exist. In this paper, we perform the first comprehensive analysis using 24 open-source static analysis tools (through Omega Analyzer ) on 4,947 repositories. Our study identified several interesting findings, such as the distribution of errors in relation to the criticality score of repositories shows that repositories with a criticality score have the highest percentage of errors. We envision that our findings provide insights into the effectiveness of static analysis tools on OSS and future research directions in securing OSS repositories.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_91405_8_22,
  title = {Quantifying MEV NFT Arbitrage},
  author = {Krekeler, Matthias Franz},
  booktitle = {Tokenizing the Future},
  year = {2025},
  pages = {337-355},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-91405-8\_22},
  url = {https://doi.org/10.1007/978-3-031-91405-8\_22},
  abstract = {In high-frequency trading, arbitrage is widespread both in traditional finance and in cryptocurrency markets. However, little research has examined it in digital collectibles. Opportunities arise from offers on multiple markets for similar collectibles. For example, a collectible trading card is bought on market A and sold at a premium on market B. This might affect the less sophisticated consumer buyer. To investigate its impact, an empirical analysis of historical arbitrage in non-fungible token (NFT) markets on the Ethereum blockchain was conducted. Using data mining, over 26,000 Ethereum transactions were identified and enriched with market data, including Ethereum price, trading volumes, and network transaction costs. Additionally, the correlation with blockchain-specific trading phenomenons such as maximal extractable value (MEV) or the broader decentralized finance (DeFi) ecosystem is tested. The study reveals that NFT arbitrage is a lucrative yet competitive sector, contributing to less than five percent of the total MEV profits of trading bots on Ethereum. In total, a small group of approximately 150 trading bots dominate NFT arbitrage, generating around \$3 million in profit over the course of three years. The profit distribution is highly uneven, with a few bots earning the majority of the profits. External factors like Ethereum gas prices and total MEV profits present no statistically significant impact on NFT arbitrage profits, while a significant correlation with NFT trading volumes is noted. Finally, case studies examining how inefficiencies occur, establish a basis for understanding market dynamics in the developing NFT landscape.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_81458_7_2,
  title = {Assessing Operation of Mobile Banking Applications that Support Customers to Access Banking Services Remotely},
  author = {Orucho, Daniel Okari and Awuor, Fredrick Mzee and Oduor, Collins},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {20-35},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-81458-7\_2},
  url = {https://doi.org/10.1007/978-3-031-81458-7\_2},
  abstract = {Mobile banking applications are programs that are created by banks to help their customers’ access banking services remotely. This study assesses operation of mobile banking applications that enable customers to access banking services from their devices successfully. Additionally, this study discusses major weaknesses that affect customers while accessing banking services remotely. This study employs a systematic literature review approach. Findings from this study established that mobile banking applications provide a secure connection between the client application and the bank server, followed by customer authentication before accessing banking services remotely. The outcome to this study is a defined set of best practices that can be adopted by customers to access banking services remotely and securely. Notably, this study enlightens bank customers about the existing threat landscape when using mobile banking applications and provides solutions on how best mobile banking applications can be securely utilized to conduct banking services remotely.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_93511_5_4,
  title = {Attacking the IEC 61131 Logic Engine in Programmable Logic Controllers},
  author = {Qasim, Syed Ali and Ayub, Adeen and Johnson, Jordan and Ahmed, Irfan},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2022},
  pages = {73-95},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-93511-5\_4},
  url = {https://doi.org/10.1007/978-3-030-93511-5\_4},
  abstract = {Programmable logic controllers monitor and control physical processes in critical infrastructure assets, including nuclear power plants, gas pipelines and water treatment plants. They are equipped with control logic written in IEC 61131 languages such as ladder diagrams and structured text that define how the physical processes are monitored and controlled. Cyber attacks that seek to sabotage physical processes typically target the control logic of programmable logic controllers. Most of the attacks described in the literature inject malicious control logic into programmable logic controllers. This chapter presents a new type of attack that targets the control logic engine that is responsible for executing the control logic. It demonstrates that a control logic engine can be disabled by exploiting inherent features such as the program mode and starting/stopping the engine. Case studies involving control logic engine attacks on real programmable logic controllers are presented. The case studies present internal details of the logic engine attacks to enable industry and the research community to understand the control logic engine attack vector. Additionally, control engine attacks on power substation, conveyor belt and elevator testbeds are presented to demonstrate their impacts on physical systems.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00521_025_11338_8,
  title = {SLF-ADM: Securing Linux frontiers: Advanced persistent threat (APT) detection using machine learning},
  author = {Karim, Syed Sohaib and Afzal, Mehreen and Iqbal, Waseem and Abri, Dawood Al and Abbas, Yawar},
  journal = {Neural Computing and Applications},
  year = {2025},
  volume = {37},
  number = {21},
  pages = {16715-16734},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-025-11338-8},
  url = {https://doi.org/10.1007/s00521-025-11338-8},
  abstract = {Cyber warfare has reached its peak and the most dangerous threat to any country/state/organization in cyber attack space is Advanced Persistent Threat (APT) due to its nature, intention and impact. These attack campaigns are sophisticated and complex enough to get easily detected, specially in the Linux environment on which most of the back-end technologies and super computers are based. There is no proper solution to detect and predict these sophisticated attack campaign. This article presents a novel machine learning approach that utilizes the FastText embedding with support vector machine (SVM) algorithm for rapid and systematic APT attack detection and prediction. The dataset used in the study is developed by simulating several latest APTs and executing payloads in the Linux environment to effectively analyse, detect and predict the campaign. As per the APT life cycle, there are different stages and each stage has different characteristics and paths to observe, which are taken into consideration in the selected dataset. Utilizing the proposed methodology, there are four ML-model which are trained and tested against the accuracy. The maximum predicted accuracy of 96\% has been achieved for SVM. The results are compared with other machine learning models on same dataset as well. The experiment shows that SVM has performed significantly better in comparison to the other proposed models.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_56583_0_16,
  title = {DynVMDroid: Android App Protection via Code Disorder and Dynamic Recovery},
  author = {Feng, Weimiao and Hu, Rui and Zhou, Cong and Yu, Lei},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2024},
  pages = {244-257},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-56583-0\_16},
  url = {https://doi.org/10.1007/978-3-031-56583-0\_16},
  abstract = {To protect Android applications from reverse engineering, more and more adversarial analysis techniques are proposed, such as packing, encryption, obfuscation, etc. As one of the most advanced techniques for obfuscation, code virtualization at the dex bytecode level has evolved from hiding meta information to protect executable instructions. However, previous approaches are proved to have a certain degree of vulnerability at the directive opcode replacement. In this paper, we present DynVMDroid, a reinforcement system based on code virtualization to protect Android applications from reverse engineering. DynVMDroid consists of two components, a reinforcement engine and a custom runtime environment. The reinforcement engine disrupts the inherent structural order and extends the length of the original instructions from key methods, converting them into virtual code in Android applications. The custom runtime environment dynamically recovering the virtual instructions to ensure the protected application work properly. To verify its performance and compatibility, we have applied DynVMDroid to 10 applications. In addition, various attack methods have been adopted on the protected applications to validate their security. Our experimental results show that the applications protected by DynVMDroid perform correctly and effectively against common reverse analysis techniques with acceptable performance losses.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_08124_7_32,
  title = {BlockLens: Detecting Malicious Transactions in Ethereum Using LLM Techniques},
  author = {Feng, Chi and Fan, Lei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {581-601},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-08124-7\_32},
  url = {https://doi.org/10.1007/978-3-032-08124-7\_32},
  abstract = {This paper presents BlockLens , a supervised, trace-level framework for detecting malicious Ethereum transactions using large language models (LLMs). Unlike prior approaches limited to static features or storage-level abstractions, BlockLens processes complete execution traces, capturing opcode sequences, memory information, gas usage, and call structures to accurately represent the runtime behavior of each transaction. This framework harnesses the exceptional reasoning capabilities of LLMs for long input sequences and is fine-tuned on transaction data. We design a tokenization strategy aligned with Ethereum Virtual Machine (EVM) semantics, mapping execution traces into interpretable tokens. Each transaction captures its complete execution trace through simulated execution and is then sliced into overlapping chunks using a sliding window, allowing for long-range context modeling within memory constraints. During inference, the model outputs both a binary decision and a probability score indicating the likelihood of malicious behavior. We implement the framework based on LLaMA 3.2-1B backbone and fine-tune the model using Low-Rank Adaptation (LoRA). We evaluate it on a curated dataset containing both real-world attacks and normal DeFi transactions. BlockLens outperforms representative baselines, achieving higher F1 scores and recall at top-k thresholds than representative baselines. Additionally, BlockLens offers interpretable chunk-level outputs by localizing suspicious trace segments that enhance explainability, facilitating rapid forensic analysis and actionable decision-making in security-critical environments.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_81888_2_7,
  title = {Automated Programmable Logic Controller Memory Forensics Using RGB Image Analysis and Deep Learning},
  author = {Awad, Rima Asmar and Sprayberry, Michael and Ahmed, Irfan and Rogers, Michael and Lopez, Juan},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2025},
  pages = {131-152},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-81888-2\_7},
  url = {https://doi.org/10.1007/978-3-031-81888-2\_7},
  abstract = {The introduction of Industry 4.0 and Internet-based technologies has enhanced industrial control system operations but have inadvertently increased their vulnerabilities to cyber attacks. When an industrial control system is compromised, security analysts need to identify the root cause quickly to start the recovery process and develop mitigation strategies. Memory forensics is critical in the incident analysis process to ascertain what occurred. Approaches for analyzing the persistent memory in industrial control devices are limited and almost nonexistent for volatile memory. This chapter proposes an automated methodology for programmable logic controller memory dump analysis using computer vision and deep learning techniques. The methodology converts the sequences of bytes in a programmable logic controller memory dump to red-green-blue pixels and employs a deep learning model that learns the underlying patterns and features of pre-labeled forensic artifacts in images and segments them into distinct regions. The trained model is employed to automatically segment new memory images and identify forensic artifacts. Evaluation of the methodology on a Schneider Electric Modicon M221 programmable logic controller under code injection and code modification attacks demonstrates its ability to detect attack artifacts in memory dumps.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s13635_025_00197_4,
  title = {Malicious software identification based on deep learning algorithms and API feature extraction},
  author = {Sun, Wei},
  journal = {EURASIP Journal on Information Security},
  year = {2025},
  volume = {2025},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13635-025-00197-4},
  url = {https://doi.org/10.1186/s13635-025-00197-4},
  abstract = {With the popularization of mobile Internet, the Android operating system has become the main target of malware attacks because of its openness. Traditional malware detection methods face challenges in handling complex feature representations, especially in utilizing the semantic information and call order of application programming interface call sequences. Therefore, this study develops a deep learning method to identify malicious software by analyzing the application programming interface calls and constructing heterogeneous graphs of Android applications. The results showed that the proposed method achieved accuracies of 92.80\% and 94.24\% on the Drebin and AndroZoo datasets, demonstrating excellent robustness and generalization ability. The ablation experiment showed that the accuracy of the complete model was 94.71\%, verifying the key role of each part of the method. In comparison with existing methods, the proposed method led with an average accuracy of 94.27\%, while maintaining detection time within 5–10 s, demonstrating high efficiency and practicality. This study contributes to the in-depth exploration of semantic information and behavioral patterns of application programming interface call sequences. The efficient malware identification method developed can cope with the constantly evolving malware threats.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_99_9119_8_24,
  title = {An Autonomous Recovery Guidance System for USV Based on Optimized Genetic Algorithm},
  author = {Zhou, Lulu and Ye, Xiaoming and Xie, Pengzhan and Liu, Xiang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {258-270},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-9119-8\_24},
  url = {https://doi.org/10.1007/978-981-99-9119-8\_24},
  abstract = {As a kind of flexible and efficient device that can autonomously complete tasks without human intervention, Unmanned Surface Vehicle (USV) has gained increasing attention in the research field recently. Path planning is an essential hotspot in the study of the USV. Unlike traditional robotic path planning, the path planning of the USV needs to consider the dynamic impact of the water environment as well as the constraints of its own vessel’s kinematics. For the sake of enhancing the practical operability of the navigation, an optimized Genetic Algorithm (GA) based on three-dimensional environment modeling is proposed. By simplifying the 3D coordinate, the algorithm can efficiently deal with the avoidance of dynamic and static obstacles. Population initialization is improved to reduce the calculating load, and the Elitism Strategy is combined to ensure convergence. An innovative Sacrifice Strategy and intraspecific hybrid methods are proposed to further increase the genetic diversity and convergence rate. We also propose a new penalty fitness function. Through simulation results and experiments in a water surface environment, the effectiveness and rationality of this method were verified, providing new ideas for path planning research of the USV.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_4880_1_10,
  title = {Optimizing Static Malware Analysis: Tool Efficacy and Performance Metrics},
  author = {Mani, Jibin Jacob and Abishek Ansel, T. M.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2025},
  pages = {127-134},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-4880-1\_10},
  url = {https://doi.org/10.1007/978-981-96-4880-1\_10},
  abstract = {In the field of Cybersecurity, Malware threats can turn out to be a difficult path to navigate. Malware represents real and harmful entities that can jeopardize your computer system. Malicious software, encompasses a range of programs designed to inflict damage on your PC. This term includes Viruses, Worms, Trojans, and other harmful softwares that hackers might use to deploy malicious payloads or extract sensitive information from victimized systems. These programs can severely compromise the integrity and security of Computer System. This work focuses on Static Malware Analysis, a primary methods for examining malware. Static Malware Analysis involves examining the malware without executing it, using a set of specialized tools. A comparative study of various tools were conducted, Dependency Walker had the highest detection rate (78.80\%) and accuracy rate (86.60\%), making it the most reliable instrument. The static analysis tools PiEd, Resource Hacker, PEview, and FileAlyzer had lower detection rates.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_6232_6_14,
  title = {HETCN: A Highly Efficient Temporal Convolutional Neural Network for Vulnerability Detection in Smart Contracts},
  author = {Yan, Hongyu and Cao, Chunjie and Jing, Zhaoxing and Li, Haochen and Liu, Zhiyuan and Yu, Haojie and Zhang, Qi and Sun, Jingzhang},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {254-272},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-6232-6\_14},
  url = {https://doi.org/10.1007/978-981-96-6232-6\_14},
  abstract = {Smart contracts have been developing rapidly in various industries, and their security problems have become increasingly severe, posing significant economic threats. Consequently, the identification of vulnerability in smart contracts is essential for the governance of blockchain. Deep learning has achieved remarkable strides in bolstering software security, and deep learning and smart contract vulnerability detection have become a new research focus. Existing smart contract vulnerability detection methods have difficulty eliminating the influence of redundant information, leading to insufficient special extraction, which leads to missed and false alarms. To bolster the security of smart contracts, we introduce a novel technique that leverages the temporal convolutional network (TCN), specifically the HETCN model. This model refines the Abstract Syntax Tree (AST) to mitigate the impact of superfluous data, thereby enhancing feature extraction. Moreover, the TCN integrates the squeeze-and-excitation network mechanism to distinguish the weights of the data and overcome long-range dependency. We perform reentrancy vulnerability detection on the widely used public dataset SmartBugs Wild. The results indicate that our HETCN method detects reentrancy vulnerability with a higher accuracy of 95.81\%. Compared with other detection methods, HETCN can better identify reentrancy vulnerability.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_97_1459_9_3,
  title = {Behavior-Based Detection Method for Android Malware},
  author = {Niu, Weina and Zhang, Xiaosong and Yan, Ran and Gong, Jiacheng},
  booktitle = {Android Malware Detection and Adversarial Methods},
  year = {2024},
  pages = {43-54},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1459-9\_3},
  url = {https://doi.org/10.1007/978-981-97-1459-9\_3},
  abstract = {The behavior-based Android malware detection method is a method that detects the presence of malicious behavior by observing and analyzing the behavior of an app during operation. Behavior detection mainly refers to the detection method for specific malicious behavior. Typical malicious behaviors include privacy breaches, privilege escalation, and descriptions that are inconsistent with actual behavior, as described below. Privacy leakage: The reasons for privacy leakage can be mainly divided into two categories: one is caused by vulnerabilities in the Android system, and the other is caused by vulnerabilities in Android apps. Android system vulnerabilities are caused by defects in the framework of the Android system itself, with a wide range of impacts and can cause harm to all smartphones installed with the corresponding system. For example, the WebView vulnerability in the Android system is mainly caused by the system allowing JS scripts to make dangerous calls to APIs in Java and native code. Malicious software embeds scripts into WebView components, and when a user clicks to trigger the WebView component, the script triggers a vulnerability and calls related APIs to steal user privacy information. Privacy breaches caused by Android app vulnerabilities are more common than system vulnerabilities, which are caused by developers not paying attention to security when coding, specifically manifested as the lack of legitimacy verification of exposed components in the app. The attacker obtains the interface for stealing user privacy information by analyzing the Android app and hijacks user privacy information through disguise. Permission elevation: Permission elevation refers to software that does not have certain permission obtaining certain permission, mainly due to the existence of call relationships between Android apps. The Android system provides Android apps with the ability to call other apps, such as ordering takeout on takeout software and then calling payment software for payment, but this kind of behavior may bring certain security risks. If the software applies for permissions it does not need and provides an interface to the outside world, malicious apps can obtain sensitive resources by legally calling the public interface, so as to achieve permission enhancement. In the process of Android software development process, following the principle of least privilege (the software should only state the permissions used by the software, not the permissions irrelevant to the software functions) can ensure the data security of the Android system. Inconsistent behavior: Inconsistent behavior refers to the actual execution behavior of software that is inconsistent with its declared behavior. For example, if an app has applied for reading CONTACTS permission but there are no statements related to reading contact information in its description, it is said that the app has inconsistent behavior. There are two main reasons for this problem: firstly, a program is often developed by multiple people together, and the personnel who wrote the app description may not have participated in the complete program development process, so their understanding of the program’s functions is not clear enough. Secondly, most Android software embeds third-party packages during development, and these third-party packages do not contain source code, so developers cannot describe their specific behavior. Behavior-based Android malware detection methods usually use static analysis and dynamic analysis and other program technologies to find malicious behaviors in Android software. At the same time, machine learning technology can be used to enhance the analysis capability of Program analysis technology [ 1 ].},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_39828_5_19,
  title = {Spying on the Spy: Security Analysis of Hidden Cameras},
  author = {Herodotou, Samuel and Hao, Feng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {345-362},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-39828-5\_19},
  url = {https://doi.org/10.1007/978-3-031-39828-5\_19},
  abstract = {Hidden cameras, also called spy cameras, are surveillance tools commonly used to spy on people without their knowledge. Whilst previous studies largely focused on investigating the detection of such a camera and the privacy implications, the security of the camera itself has received limited attention. Compared with ordinary IP cameras, spy cameras are normally sold in bulk at cheap prices and are ubiquitously deployed in hidden places within homes and workplaces. A security compromise of these cameras can have severe consequences. In this paper, we analyse a generic IP camera module, which has been packaged and re-branded for sale by several spy camera vendors. The module is controlled by mobile phone apps available on iOS and Android. By analysing the Android app and the traffic data, we reverse-engineered the security design of the whole system, including the module’s Linux OS environment, the file structure, the authentication mechanism, the session management, and the communication with a remote server. Serious vulnerabilities have been identified in every component. Combined together, these vulnerabilities allow an adversary to take complete control of a spy camera from anywhere over the Internet, enabling arbitrary code execution. This is possible even if the camera is behind a firewall. All that an adversary needs to launch an attack is the camera’s serial number, which users sometimes unknowingly share in online reviews. We responsibly disclosed our findings to the manufacturer. Whilst the manufacturer acknowledged our work, they showed no intention to fix the problems. Patching or recalling the affected cameras is infeasible due to complexities in the supply chain. However, it is prudent to assume that bad actors have already been exploiting these flaws. We provide details of the identified vulnerabilities in order to raise public awareness, especially on the grave danger of disclosing a spy camera’s serial number.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_94855_8_5,
  title = {Analysis of Permissions and Trackers in Android Apps Targeting Children Under Thirteen},
  author = {Fitzpatrick, Jamie and Franqueira, Virginia N. L.},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {63-81},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-94855-8\_5},
  url = {https://doi.org/10.1007/978-3-031-94855-8\_5},
  abstract = {As mobile phone and app use among children increases, ensuring their privacy and safety has become more crucial. This study examines 27 popular Android apps for children under 13, available in the UK via Google Play Store, by analysing the permissions they request and the trackers they share data with. The aim is to determine whether these practices are justified by the apps’ functionalities, and comply with regulatory standards to adequately protect children. Using a traffic light system inspired by the ICO audits, each app is rated green, amber, or red taking into account dangerous permissions and runtime trackers in use. Only one app reached an overall green rating, while 10 apps achieved an overall red rating. The majority of tracker companies (20 out of 21) are based outside the UK or EU, including the US, Russia, China, Israel and India, and two trackers are linked to profiling and fingerprinting of users. Overall, findings suggest that apps often prioritise functionality and user experience over privacy and safety of children.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11277_024_11366_y,
  title = {Hybrid Deep Learning Approach Based on LSTM and CNN for Malware Detection},
  author = {Thakur, Preeti and Kansal, Vineet and Rishiwal, Vinay},
  journal = {Wireless Personal Communications},
  year = {2024},
  volume = {136},
  number = {3},
  pages = {1879-1901},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11277-024-11366-y},
  url = {https://doi.org/10.1007/s11277-024-11366-y},
  abstract = {Malware analysis is essential for detecting and mitigating the effects of malicious software. This study introduces a novel hybrid approach using a combination of long short-term memory (LSTM) and convolutional neural networks (CNN) to enhance malware analysis. The proposed work uses a malware classification method combining image processing and machine learning. Malware binaries are converted into grayscale images and analyzed with CNN-LSTM networks. Dynamic features are extracted, ranked, and reduced via Principal Component Analysis (PCA). Various classifiers are used, with final classification by a voting scheme, providing a robust solution for accurate malware family classification. Our approach processes binary code inputs, with the LSTM capturing temporal dependencies and the CNN performing parallel feature extraction. PCA is employed for prominent feature selection, reducing computational time. The proposed approach was evaluated on a public malware dataset and captured through network traffic, demonstrating state-of-the-art performance in identifying various malware families. It significantly reduces the resources required for manual analysis and improves system security. Our approach achieved high precision, recall, accuracy, and F1 score, outperforming existing methods. Future research directions include improving feature extraction techniques and developing real-time detection models that offer a powerful malware detection and analysis tool with promising results and potential for further advancements.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_99536_1_1,
  title = {On Propositional Program Equivalence (Extended Abstract)},
  author = {Kappé, Tobias},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {3-18},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-99536-1\_1},
  url = {https://doi.org/10.1007/978-3-031-99536-1\_1},
  abstract = {General program equivalence is undecidable. However, if we abstract away the semantics of statements, then this problem becomes not just decidable, but practically feasible. For instance, a program of the form if b then e else f should be equivalent to if not b then f else e —no matter what b , e and f are. This kind of equivalence is known as propositional equivalence . In this extended abstract, we discuss recent developments in propositional program equivalence from the perspective of (Guarded) Kleene Algebra with Tests, or (G)KAT.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_07901_5_1,
  title = {Transparency and Consent Challenges in mHealth Apps: An Interdisciplinary Study of Privacy Policies, Data Sharing, and Dark Patterns},
  author = {Bahrini, Mehrdad and Herbst, Alexander and Freye, Merle and Kohn, Matthias and Sohr, Karsten and Malaka, Rainer},
  booktitle = {Lecture Notes in Computer Science},
  year = {2026},
  pages = {1-21},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-07901-5\_1},
  url = {https://doi.org/10.1007/978-3-032-07901-5\_1},
  abstract = {Health, fitness, and medical apps have become increasingly popular to help users manage their well-being. However, their widespread use raises significant concerns about data privacy, given the sensitive nature of the information they process. In this study, we evaluate the transparency and regulatory compliance of such apps by focusing on three key aspects: actual data transmission behavior, claims made in privacy policies—particularly concerning third-country recipients—and the presence of dark patterns in their user interfaces. We combine network traffic analysis with a systematic review of privacy policies to examine whether data is transmitted before consent and whether recipients align with disclosures. In addition, we analyze interface designs for manipulative elements that can hinder informed consent. Our results reveal discrepancies between stated and observed data flows, instances of pre-consent data transmission, and recurring dark patterns. These findings highlight critical transparency gaps and underscore the need for stronger enforcement and user-centered privacy design.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_43412_9_16,
  title = {Marvolo: Programmatic Data Augmentation for Deep Malware Detection},
  author = {Wong, Mike and Raff, Edward and Holt, James and Netravali, Ravi},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {270-285},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-43412-9\_16},
  url = {https://doi.org/10.1007/978-3-031-43412-9\_16},
  abstract = {Data acquisition for ML-driven malware detection is challenging. While large commercial datasets exist, they are prohibitively expensive. On the other hand, an entity (e.g., a bank or government), may be targeted with unique malware, but the data samples available will never be sufficient to train a bespoke ML-based detector. While data augmentation has been a key component in improving deep learning models by providing requisite diversity for generalization, it has proven far more challenging for malware detection. The main challenges are that (1) determining the augmentations to make is not straightforward, (2) operations are on binaries rather than source code (which is not available), complicating correctness and understanding, and (3) labeling new files mandates expensive binary reverse engineering. We present Marvolo for creating realistic, semantics preserving transformations that mimic the code alterations made by malware authors in practice, allowing us to generate augmented data on raw binary files. This also enables Marvolo to safely propagate labels to newly-generated data. Across several malware datasets and recent ML-based detectors, Marvolo improves accuracy and AUC by up to 5\% and 10\% respectively, while boosting efficiency by 79x by avoiding redundant computation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_97_5603_2_32,
  title = {Firm-Vehicle: Trusted Communication Enabled Instruction Embedding Model for Resource-Constrained VANET Environments},
  author = {Chen, Rui and Younas, Waleed and Zhao, Jing},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {391-402},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-5603-2\_32},
  url = {https://doi.org/10.1007/978-981-97-5603-2\_32},
  abstract = {Instruction embedding is an essential technique in firmware security research and serves as a fundamental component in many vulnerability detection and security analysis methods for VANET. Instruction embedding maps the semantic information of instructions into fixed-dimensional vectors. However, the current instruction embedding approaches often neglect the operational requirements of resource-constrained environments typical of VANET. Moreover, the dependency on third-party disassembly tools for the extraction of instruction call graphs presents challenges related to runtime environment, thereby complicating the feasible application of instruction embedding techniques. To address these limitations, we propose a novel cross-architecture firmware instruction embedding model called Firm-Vehicle, specifically tailored for resource-constrained environments in VANET. Primarily, we devise a lightweight algorithm for extracting instruction call graphs, eliminating the reliance on third-party disassembly tools and improving the efficiency of call graphs extraction, thereby enhancing the instruction embedding model. Through evaluations and comparison with other approaches, Firm-Vehicle not only reduces the required time for instruction call graphs extraction but also enhances the stability of the instruction embedding model, enabling secure and efficient operation within the VANET environment.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_97_3180_0_35,
  title = {Malware Classification Using Deep Learning Approaches},
  author = {Goyal, Riya and Tayal, D. K. and Indra Thannaya, B.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {533-549},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-3180-0\_35},
  url = {https://doi.org/10.1007/978-981-97-3180-0\_35},
  abstract = {Detecting malware poses significant challenges due to the evolving sophistication of malicious software. Conventional detection techniques like signature-based methods and behavioral analysis have experienced diminishing effectiveness. To address this, a groundbreaking deep learning framework called Decomposition Training and Classification Network (DTC-Net) is introduced in this work. DTC-Net consists of three phases: feature extraction utilizing the VGG16 backbone network, data simplification through class decomposition, and classification using fully connected layers. Furthermore, a class composition layer enhances the accuracy of final categorization. Through extensive experimentation, the proposed DTC-Net demonstrates impressive performance, surpassing other state-of-the-art methods. It achieves remarkable results, including an F1-score of 95.364\%, accuracy of 98.545\%, precision of 94.737\%, and recall of 96\%. This research showcases the effectiveness of DTC-Net as an integrated and comprehensive deep learning solution for accurate malware family classification.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10462_024_10798_z,
  title = {Intelligent analysis of android application privacy policy and permission consistency},
  author = {Tu, Tengfei and Zhang, Hua and Gong, Bei and Du, Daizhong and Wen, Qiaoyan},
  journal = {Artificial Intelligence Review},
  year = {2024},
  volume = {57},
  number = {7},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10462-024-10798-z},
  url = {https://doi.org/10.1007/s10462-024-10798-z},
  abstract = {Abstract With the continuous development of mobile devices, mobile applications bring a lot of convenience to people’s lives. The abuse of mobile device permissions is prone to the risk of privacy leakage. The existing detection technology can detect the inconsistency between the declared authority and the actual use authority. But using the third-party privacy policy as the analysis basis for SDK permissions will result in a large set of extracted declaration permissions, which will lead to identifying risky applications as normal applications during consistency comparison. The prevailing approach involves utilizing models based on TextCNN to extract information from privacy policies. However, the training of TextCNN relies on large-scale annotated datasets, leading to high costs. This paper uses BERT as the word vector extraction model to obtain private phrases from the privacy policy. And then we use cosine similarity to automatically filter permission phrase samples, reducing the workload of manual labeling. On the other hand, existing methods do not support the analysis of Chinese privacy policies. In order to solve the problem of consistency judgment between Chinese privacy policy and permission usage, we implement a BERT-based Android privacy policy and permission usage consistency analysis engine. The engine first uses static analysis to obtain the permission list of Android applications, and then combines the BERT model to achieve consistency analysis. After functional and speed testing, we found that the engine can successfully run the consistency analysis function of Chinese declaration permissions and usage permissions, and it is better than the existing detection methods.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_1326_4_2,
  title = {An Overview of Artificial Intelligence Applications in Cybersecurity Domains},
  author = {Lumpatki, Sairaj S. and Patwardhan, Swapnaja},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {11-24},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1326-4\_2},
  url = {https://doi.org/10.1007/978-981-97-1326-4\_2},
  abstract = {Artificial intelligence (AI) is currently exerting a significant influence across diverse sectors. This paper delves into the applications of AI in various domains of cybersecurity. The field of cybersecurity is classified into multiple domains, and the author provides an overview of the utilization of AI in each specific domain. The paper comprehensively covers essential domains from both offensive and defensive perspectives, presenting a general idea of the different tools employed in each domain. Each section is organized into five parts, namely: information, tools used, examples, challenges and drawbacks, and the use of AI in the specific domain. This classification allows readers to gain a concise understanding of each topic addressed in the paper.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_1927_4_10,
  title = {Code Similarity in Clone Detection},
  author = {Krinke, Jens and Ragkhitwetsagul, Chaiyong},
  booktitle = {Code Clone Analysis},
  year = {2021},
  pages = {135-150},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-1927-4\_10},
  url = {https://doi.org/10.1007/978-981-16-1927-4\_10},
  abstract = {Clone detection is one application of measuring the similarity of code. However, clone and plagiarism detectors use very different representations of source code and different techniques to identify similar code fragments. This chapter investigates the impact of source code representation (i.e. tokenisation and renaming of identifiers and literals) and the impact of similarity measurements (e.g. Jaccard index or Kondrak’s distance over n -grams) for measuring source code similarity on two known datasets. A comparison using average precision at k with dedicated clone and plagiarism detectors shows that simple similarity measurements like Kondrak’s distance using n -grams over tokenised source code usually outperform specialised tools for the detection of similar, cloned, plagiarised or duplicated code.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_65175_5_6,
  title = {DryJIN: Detecting Information Leaks in Android Applications},
  author = {Choi, Minseong and Im, Yubin and Ko, Steve and Kwon, Yonghwi and Jeon, Yuseok and Cho, Haehyun},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2024},
  pages = {76-90},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-65175-5\_6},
  url = {https://doi.org/10.1007/978-3-031-65175-5\_6},
  abstract = {Android devices, handling sensitive data like call records and text messages, are prone to privacy breaches. Existing information flow tracking systems face difficulties in detecting these breaches due to two main challenges: the multi-layered Android platform using different programming languages (Java and C/C++), and the complex, event-driven execution flow of Android apps that complicates tracking, especially across these language barriers. Our system, DryJIN, addresses this by effectively tracking information flow within and across both Java and native modules. Utilizing symbolic execution for native code data flows and integrating it with Java data flows, DryJIN enhances existing static analysis techniques (Argus-SAF, JuCify, and FlowDroid) to cover previously unaddressed information flow patterns. We validated DryJIN ’s effectiveness through a comprehensive evaluation on over 168k apps, including malware and real-world apps, demonstrating its superiority over current state-of-the-art methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_56583_0_19,
  title = {An Android Malware Detection Method Based on Optimized Feature Extraction Using Graph Convolutional Network},
  author = {Wang, Zhiqiang and Wang, Zhuoyue and Zhang, Ying},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2024},
  pages = {283-299},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-56583-0\_19},
  url = {https://doi.org/10.1007/978-3-031-56583-0\_19},
  abstract = {With the development of the mobile Internet, mobile devices have been extensively promoted and popularized. Android, as the current popular mobile intelligent operating system, has encountered problems such as the explosive growth of Android malware while bringing convenience to users. The traditional Android malware detection methods have some problems, such as low detection accuracy and difficulty in detecting unknown malware. This paper proposes an Android malware detection method named Android malware detection method based on graph convolutional neural network (AGCN) based on the graph convolutional network (GCN) to solve the above problems. Firstly, we divide the Android software datasets according to family and software features and construct a directed network topology graph. At the same time, the permission features of APK files are extracted and vectorized. Then, we use GCN to learn the features of Android APK files… Finally, we compare AGCN with a multilayer perceptron (MLP), long and short-term memory (LSTM) neural network, bi-directional long and short-term memory (bi-LSTM) neural network, and deep confidence neural network (DCNN) for experiments. Experimental results show that the model has an accuracy of 98.55\% for malware detection, demonstrating the detection method’s effectiveness.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_63092_8_61,
  title = {Suspected Software-Code Restoration Using a Dictionary Led System},
  author = {Domb, Menachem and Leshem, Guy},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {899-908},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63092-8\_61},
  url = {https://doi.org/10.1007/978-3-030-63092-8\_61},
  abstract = {The recent increase of devices connected to the Internet and the introduction of new paradigms; Internet of Things (IoT) and Cloud computing, exposes the Internet to sever security risks, especially malicious alteration of the application software code or utilizing malfunction codes to attack the system. Such an attack can change the behavior and the outcome of the system. This paper suggests a system that identifies unsecured software codes and fixes them to ensure risk safe codes. To execute the proposed system in a secured development and deployment environment, protected from disclosure or modification of the code, we propose using the Intel Software Guard Extensions ( SGX ) environment. Using a list of predefined rules, the system looks for suspicious codes and replaces them with safe codes associated with the rule.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_63989_0_22,
  title = {Research on Data Drift and Class Imbalance in Android Malware Detection},
  author = {Liu, Zhen and Wang, Ruoyu and Peng, Bitao and Wang, Changji and Gan, Qingqing},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2024},
  pages = {429-444},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-63989-0\_22},
  url = {https://doi.org/10.1007/978-3-031-63989-0\_22},
  abstract = {In the Android ecosystem, malware detection is still a nontrivial task. Existing works have recently applied convolution neural networks (CNNs) for detecting Android malwares. However, data drift and class imbalance are still open problems in this field. The distribution of malware data may vary significantly if data are represented by unstable features, leading to data drift problems. The model may not be able to effectively detect malwares on the future data. In addition, the class imbalance may degrade a model on identifying a specific type of malwares with fewer training samples. To handle both of the two problems, this paper presents a new Android malware detection framework. Specifically, we devise a data distribution-aware feature learning framework for learning features with a stable distribution to handle data drift. We further devise a new loss function for CNN to handle the class imbalance problem. Using our loss function, this model can reinforcement learn the minority class samples and hard samples. The experimental results on the real datasets revealed that our method outperforms existing works for Android malware detection on the datasets with data drift and class imbalance problems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_32415_4_33,
  title = {Not so Immutable: Upgradeability of Smart Contracts on Ethereum},
  author = {Salehi, Mehdi and Clark, Jeremy and Mannan, Mohammad},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {539-554},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-32415-4\_33},
  url = {https://doi.org/10.1007/978-3-031-32415-4\_33},
  abstract = {A smart contract that is deployed to a blockchain system like Ethereum is, under reasonable circumstances, expected to be immutable and tamper-proof. This is both a feature (promoting integrity and transparency) and a bug (preventing security patches and feature updates). Modern smart contracts use software tricks to enable upgradeability, raising the research questions of how upgradeability is achieved and who is authorized to make changes. In this paper, we summarize and evaluate six upgradeability patterns. We develop a measurement framework for finding how many upgradeable contracts are on Ethereum that use certain prominent upgrade patters. We find 1.4 million proxy contracts which 8,225 of them are unique upgradeable proxy contracts. We also measure how they implement access control over their upgradeability: about 50\% are controlled by a single Externally Owned Address (EOA), and about 14\% are controlled by multi-signature wallets in which a limited number of persons can change the whole logic of the contract.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_2362_5_29,
  title = {Analysis and Research on Dynamic Measurements Technology},
  author = {Fu, Yingfang and Huang, Haoxiang and Zhang, Jianbiao},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2023},
  pages = {231-238},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-2362-5\_29},
  url = {https://doi.org/10.1007/978-981-99-2362-5\_29},
  abstract = {In cloud computing environments characterized by “dynamics”, the traditional static measurement to ensure the trust of the platform system is difficult to guarantee the trust of four dimensions in the cloud computing environment, such as the platform system, computation, transmission, and storage. Dynamic measurement, as an important key technology to secure reliable system operation, has received much attention from academia and industry. This paper introduces the principles and characteristics of dynamic measurement and the common attack risks in the running system. Meanwhile, this paper surveys the state of the art of dynamic measurement schemes.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_20738_9_8,
  title = {Function Level Cross-Modal Code Similarity Detection with Jointly Trained Deep Encoders},
  author = {Tian, Zhenzhou and Wang, Lumeng},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2023},
  pages = {61-68},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-20738-9\_8},
  url = {https://doi.org/10.1007/978-3-031-20738-9\_8},
  abstract = {Binary source code matching, which matches a source code snippet to its similar binaries or vice versa, facilitates security-critical tasks such as software plagiarism detection and vulnerability confirmation; while the huge structural and syntactical gaps between the two different kind modalities, makes it challenging to calculating their similarity in an accurate manner. To this end, this work presents XMSim ( Cross - M odal function Sim ilarity detector), which compares directly between the source codes and the binary assemblies. XMSim resorts to an Transformer-based encoder and the TextCNN model respectively, to extract semantic vectors from the normalized source code tokens and the assembly instructions. To guarantee the effectiveness the semantic encoders, a large dataset consisting of 92,000 source-binary function pairs is constructed, on which the siamese neural network structure is adopted to get both encoders jointly trained. As the experimental evaluations show, XMSim can effectively identify similar or non-similar relationships between the source codes and the binaries, with the detection accuracy reaches 86.7\%. Also, XMSim show good resilience against the disturbances from different compilers and optimization levels.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s13042_020_01246_9,
  title = {Clone detection in 5G-enabled social IoT system using graph semantics and deep learning model},
  author = {Ullah, Farhan and Naeem, Muhammad Rashid and Mostarda, Leonardo and Shah, Syed Aziz},
  journal = {International Journal of Machine Learning and Cybernetics},
  year = {2021},
  volume = {12},
  number = {11},
  pages = {3115-3127},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s13042-020-01246-9},
  url = {https://doi.org/10.1007/s13042-020-01246-9},
  abstract = {The protection and privacy of the 5G-IoT framework is a major challenge due to the vast number of mobile devices. Specialized applications running these 5G-IoT systems may be vulnerable to clone attacks. Cloning applications can be achieved by stealing or distributing commercial Android apps to harm the advanced services of the 5G-IoT framework. Meanwhile, most Android app stores run and manage Android apps that developers have submitted separately without any central verification systems. Android scammers sell pirated versions of commercial software to other app stores under different names. Android applications are typically stored on cloud servers, while API access services may be used to detect and prevent cloned applications from being released. In this paper, we proposed a hybrid approach to the Control Flow Graph (CFG) and a deep learning model to secure the smart services of the 5G-IoT framework. First, the newly submitted APK file is extracted and the JDEX decompiler is used to retrieve Java source files from possibly original and cloned applications. Second, the source files are broken down into various android-based components. After generating Control-Flow Graphs (CFGs), the weighted features are stripped from each component. Finally, the Recurrent Neural Network (RNN) is designed to predict potential cloned applications by training features from different components of android applications. Experimental results have shown that the proposed approach can achieve an average accuracy of 96.24\% for cloned applications selected from different android application stores.},
  content_type = {Article},
}


@article{springer_10_1007_s11416_023_00510_0,
  title = {Picker Blinder: a framework for automatic injection of malicious inter-app communication},
  author = {Casolare, Rosangela and Fagnano, Stefano and Iadarola, Giacomo and Martinelli, Fabio and Mercaldo, Francesco and Santone, Antonella},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2024},
  volume = {20},
  number = {2},
  pages = {331-346},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-023-00510-0},
  url = {https://doi.org/10.1007/s11416-023-00510-0},
  abstract = {Malware writers, with the aim to elude the current detection mechanism implemented by commercial and free anti-malware, are finding new ways to develop new aggressive attack paradigms. Current anti-malware basically suffer about the following limitations: the first one is that they are not able to detect zero-day malware: as a matter of fact, to mark an application as malware they need to know the malicious payload signature. With regard to the second limitation, they are able to scan only one application at a time: this is the reason why a type of malware characterized by the colluding attack, where the malicious behaviour is divided between several applications, can never be detected. To demonstrate the ineffectiveness of current anti-malware in detecting colluding attacks, in this paper we design a method aimed to automatically inject a malicious payload in two or more different Android applications. We implemented the proposed method into a framework that we called Picker Blinder . In a nutshell, Picker Blinder is able to inject a collusive malicious payload exploiting two different channels (i.e., SharedPreferences and Sockets), allowing the attacker to catch sensitive and private information stored into the infected device. We perform an experimental analysis by submitting 398 colluding applications to different 79 anti-malware, by showing that current detection mechanisms are not able to detect this kind of threat.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_88381_2_6,
  title = {LEVERAGING USB POWER DELIVERY IMPLEMENTATIONS FOR DIGITAL FORENSIC ACQUISITION},
  author = {Alendal, Gunnar and Axelsson, Stefan and Dyrkolbotn, Geir Olav},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2021},
  pages = {111-133},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-88381-2\_6},
  url = {https://doi.org/10.1007/978-3-030-88381-2\_6},
  abstract = {Modern consumer devices present major challenges in digital forensic investigations due to security mechanisms that protect user data. The entire physical attack surface of a seized device such as a mobile phone must be considered in an effort to acquire data of forensic value. Several USB protocols have been introduced in recent years, including Power Delivery, which enables negotiations of power delivery to or from attached devices. A key feature is that the protocol is handled by dedicated hardware that is beyond the control of the device operating systems. This self-contained design is a security liability with its own attack surface and undocumented trust relationships with other peripherals and the main system-on-chips. This chapter presents a methodology for vulnerability discovery in USB Power Delivery implementations for Apple devices. The protocol and Apple-specific communications are reverse engineered, along with the firmware of the dedicated USB Power Delivery hardware. The investigation of the attack surface and potential security vulnerabilities can facilitate data acquisition in digital forensic investigations.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_94455_0_10,
  title = {BinSimDB: Benchmark Dataset Construction for Fine-Grained Binary Code Similarity Analysis},
  author = {Zuo, Fei and Tompkins, Cody and Zeng, Qiang and Luo, Lannan and Choe, Yung Ryn and Rhee, Junghwan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2026},
  pages = {203-225},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-94455-0\_10},
  url = {https://doi.org/10.1007/978-3-031-94455-0\_10},
  abstract = {Binary Code Similarity Analysis (BCSA) has a wide spectrum of applications, including plagiarism detection, vulnerability discovery, and malware analysis, thus drawing significant attention from the security community. However, conventional techniques often face challenges in balancing both accuracy and scalability simultaneously. To overcome these existing problems, a surge of deep learning-based work has been recently proposed. Unfortunately, many researchers still find it extremely difficult to conduct relevant studies or extend existing approaches. First, prior work typically relies on proprietary benchmark without making the entire dataset publicly accessible. Consequently, a large-scale, well-labeled dataset for binary code similarity analysis remains precious and scarce. Moreover, previous work has primarily focused on comparing at the function level, rather than exploring other finer granularities. Therefore, we argue that the lack of a fine-grained dataset for BCSA leaves a critical gap in current research. To address these challenges, we construct a benchmark dataset for fine-grained binary code similarity analysis called BinSimDB , which contains equivalent pairs of smaller binary code snippets, such as basic blocks. Specifically, we propose BMerge and BPair algorithms to bridge the discrepancies between two binary code snippets caused by different optimization levels or platforms. Furthermore, we empirically study the properties of our dataset and evaluate its effectiveness for the BCSA research. The experimental results demonstrate that BinSimDB significantly improves the performance of binary code similarity comparison.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_73429_9_8,
  title = {Android Malware Detection Using Ensemble Learning on Sensitive APIs},
  author = {Yu, Junhui and Zhao, Chunlei and Zheng, Wenbai and Li, Yunlong and Zhang, Chunxiang and Chen, Chao},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {126-140},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-73429-9\_8},
  url = {https://doi.org/10.1007/978-3-030-73429-9\_8},
  abstract = {In recent years, with the quiet popularity of mobile payment methods, mobile terminal equipment also have potential security problems while facilitating people’s lives. Behavior-based Android malware detection is mostly based on permission analysis and API calls. In this paper, we propose a static Android malicious detection scheme based on sensitive API calls. We extracted all APIs called in the experimental samples through decompilation, and then calculated and ranked the threats related to these APIs according to the mutual information model, selected the top 20 sensitive API calls, and generated a 20-dimensional feature vector for each application. In the classification process, an integrated learning model based on DT classifier, kNN classifier and SVM classifier is used to effectively detect unknown APK samples. We collected 516 benign samples and 528 malicious samples. Through a large number of experiments, the results show that the accuracy of our scheme can be up to 94\%, and the precision is up to 95\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_30122_3_28,
  title = {Deep-Learning-Based Vulnerability Detection in Binary Executables},
  author = {Schaad, Andreas and Binder, Dominik},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {453-460},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-30122-3\_28},
  url = {https://doi.org/10.1007/978-3-031-30122-3\_28},
  abstract = {The identification of vulnerabilities is an important element in the software development life cycle to ensure the security of software. While vulnerability identification based on the source code is a well studied field, the identification of vulnerabilities on basis of a binary executable without the corresponding source code is more challenging. Recent research [ 1 ] has shown how such detection can generally be enabled by deep learning methods, but appears to be very limited regarding the overall amount of detected vulnerabilities. We analyse to what extent we could cover the identification of a larger variety of vulnerabilities. Therefore, a supervised deep learning approach using recurrent neural networks for the application of vulnerability detection based on binary executables is used. The underlying basis is a dataset with 50,651 samples of vulnerable code in the form of a standardised LLVM Intermediate Representation. Te vectorised features of a Word2Vec model are used to train different variations of three basic architectures of recurrent neural networks (GRU, LSTM, SRNN). A binary classification was established for detecting the presence of an arbitrary vulnerability, and a multi-class model was trained for the identification of the exact vulnerability, which achieved an out-of-sample accuracy of 88\% and 77\%, respectively. Differences in the detection of different vulnerabilities were also observed, with non-vulnerable samples being detected with a particularly high precision of over 98\%. Thus, our proposed technical approach and methodology enables an accurate detection of 23 (compared to 4 [ 1 ]) vulnerabilities.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_7569_3_28,
  title = {A Deep Dive into Deep Learning-Based Adversarial Attacks and Defenses in Computer Vision: From a Perspective of Cybersecurity},
  author = {Vineetha, B. and Suryaprasad, J. and Shylaja, S. S. and Honnavalli, Prasad B.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {341-356},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-7569-3\_28},
  url = {https://doi.org/10.1007/978-981-99-7569-3\_28},
  abstract = {Adversarial attacks are deliberate data manipulations that may appear harmless to the viewer yet lead to incorrect categorization in a machine learning or deep learning system. These kinds of attacks frequently take shape of carefully constructed “noise”, that may cause misdiagnosis. Deep Neural Networks (DNNs) are being utilized more frequently in the physical world for applications that require high safety standards, including intelligent driverless vehicles, cloud systems, electronic health records, etc. The guiding rules of autonomous automobiles rely mainly on their capacity to gather environmental data through embedded sensors, then use DNN categorization to understand it and come to operational conclusions. For academics, the security and dependability of DNNs present numerous difficulties and worries. Threats of adversarial attacks on DNNs are one of the difficulties that researchers are now facing in their work. An adversarial attack assumes a minor alteration of an original image, with the modifications being nearly undetectable to human vision. In this survey, we describe the most recent studies on adversarial attack mechanisms on DNN-based frameworks and countermeasures to mitigate these attacks. Our main focus in this paper is images based adversarial attacks. We confer each research's benefits, drawbacks, methodology, and experimental results.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_97_1274_8_15,
  title = {Multi-NetDroid: Multi-layer Perceptron Neural Network for Android Malware Detection},
  author = {Rai, Andri and Im, Eul Gyu},
  booktitle = {Communications in Computer and Information Science},
  year = {2024},
  pages = {219-235},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-1274-8\_15},
  url = {https://doi.org/10.1007/978-981-97-1274-8\_15},
  abstract = {Android malware detection has become a critical concern with the emergence of smartphones. Over the last few years, research has revealed a gradual improvement in the detection of malware from mobile operating systems through both static and dynamic analysis. Machine learning techniques are used to analyze various features and to train a larger dataset; to do this, a range of deep learning algorithms have been used previously. In this paper, we proposed a multi-layer perceptron (MLP) neural network for the Android malware detection method named as Multi-NetDroid. Training and evaluation of the proposed model have been done on publicly available datasets of the android applications. The data consist of features extracted from the manifest file (Intent, Permission), the dex file (API Call Signature), and command signatures existing within an APK file. The Multi-NetDroid model is built with four dense layers for training and classification of malware or benign applications and is evaluated as an improved classifier for Android malware detection. To evaluate our model performance we experimented with two separate datasets (Drebin-215 and Malgenome-15), and our model achieved 99.19\% and 99.12\% of accuracy. Furthermore, for the validation of our framework, we have also compared the results with different Machine Learning (ML) classifiers and found that our model Accuracy outperforms the classical ML methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97620_9_13,
  title = {Experimental Study of Binary Diffing Resilience on Obfuscated Programs},
  author = {Cohen, Roxane and David, Robin and Mori, Riccardo and Yger, Florian and Rossi, Fabrice},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {223-243},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97620-9\_13},
  url = {https://doi.org/10.1007/978-3-031-97620-9\_13},
  abstract = {Obfuscation is commonly employed to protect sensitive program assets in legitimate use cases or to conceal malicious behavior in the context of malware. By altering the binary code of a compiled program, obfuscation disrupts binary analysis techniques, such as binary diffing or similarity. However, there is little comprehensive academic research addressing the effects of obfuscation on binary analysis tools and quantifying its impact. In this study, we examine how different types of obfuscation influence binary diffing algorithms. Specifically, we demonstrate a clear relationship between the type of obfuscation and the performance of the diffing algorithms used. Our benchmarks emphasize that, contrary to common assumptions, intra-procedural and data obfuscations have a limited impact on binary diffing when applied alone. In contrast, inter-procedural obfuscations significantly affect the diffing process, degrading performances by up to 40 f1-score points when comparing low and high obfuscation levels. These results highlight the need for modular diffing approaches, where parameters and features can be fine-tuned to handle adversarial scenarios, such as obfuscation. To support this research, we have released a comprehensive dataset comprising pairs of clear and obfuscated compiled programs, along with metadata specifying the type and exact location of each obfuscation. This dataset is intended to facilitate further research in this area.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_73128_0_9,
  title = {Graph-Powered Mining and Analysis of SELinux Security Policies},
  author = {Eaman, Amir and Jadczyk, Peter and Chipman, Hugh},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2024},
  pages = {124-143},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-73128-0\_9},
  url = {https://doi.org/10.1007/978-3-031-73128-0\_9},
  abstract = {In this paper, we propose a graph-powered policy analysis tool to query and envision security policies to precisely pinpoint discrepancies, especially focused on SELinux. The complexity of writing policies and checking security goals in this language has often led security administrators to disable SELinux in these systems. Various studies have been carried out on proposing different tools and techniques for SELinux policy writers for analyzing and refining SELinux policies; however, the solutions they propose often have limitations of their own, and can even add further complexity to the task of defining security policies. This paper proposes a graph-powered approach to analyzing and refining SELinux policies that is simple and straightforward to use. Our approach exploits Neo4j to model the Type Enforcement specifications of SELinux security policies. We focus on the relationships that exist in SELinux policies. We have developed a graph-based access-control model for capturing the complexities of the SELinux Type Enforcement mechanism.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97623_0_8,
  title = {An Empirical Study of Multi-language Security Patches in Open Source Software},
  author = {Sun, Shiyu and Xing, Yunlong and Zou, Grant and Wang, Xinda and Sun, Kun},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {124-146},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97623-0\_8},
  url = {https://doi.org/10.1007/978-3-031-97623-0\_8},
  abstract = {Vulnerabilities in software repositories written in multiple programming languages present a major challenge to modern software quality assurance, especially those resulting from interactions between different languages. Existing static and dynamic program analysis tools are generally constrained to single-language analysis, while current deep-learning models lack the capability to process cross-language interactions effectively. To gain deeper insights into vulnerability patterns and patching behaviors in multi-language code, we conduct a measurement study on commits associated with multi-language security patches. We first collect a large-scale dataset of multi-language security patches from the MITRE corporation. We then analyze trends in language combinations, assess their proneness to vulnerabilities, and compare the severity of these vulnerabilities to those in single-language patches. Additionally, we classify patch patterns based on the types of language interactions to support automated program repair. To encourage further research, we release our dataset to the community, fostering deeper investigation into multi-language security patch development and enhancement.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_97620_9_15,
  title = {Exploring the Potential of LLMs for Code Deobfuscation},
  author = {Beste, David and Menguy, Grégoire and Hajipour, Hossein and Fritz, Mario and Cinà, Antonio Emanuele and Bardin, Sébastien and Holz, Thorsten and Eisenhofer, Thorsten and Schönherr, Lea},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {267-286},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-97620-9\_15},
  url = {https://doi.org/10.1007/978-3-031-97620-9\_15},
  abstract = {Code obfuscation alters software code to conceal its logic while retaining functionality, aiding intellectual property protection but hindering security audits and malware analysis. To address this, automated deobfuscation techniques have been developed, though existing approaches remain constrained by limited scope and specificity. Motivated by these challenges, this paper explores a novel approach for code deobfuscation based on Large Language Models (LLMs). First, we investigate the general capabilities of LLMs in reducing code complexity by choosing five different source-to-source obfuscation methods. Despite challenges regarding semantical correctness, our findings indicate that LLMs can be very effective in this task. Building on this, we fine-tune two versatile models capable of simplifying code obfuscated through up to seven different chained obfuscation transformations while consistently outperforming deobfuscation based on compiler optimizations and general-purpose LLMs. Our best model demonstrates an average Halstead metric program length reduction of 89.21\% for our most challenging scenario. Finally, we conduct a memorization test to assess if performance stems from memorized code rather than true deobfuscation capabilities, which our models pass.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_4566_4_11,
  title = {Automatic Software Vulnerability Detection in Binary Code},
  author = {Liu, Shigang and Li, Lin and Ban, Xinbo and Chen, Chao and Zhang, Jun and Camtepe, Seyit and Xiang, Yang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {148-166},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-4566-4\_11},
  url = {https://doi.org/10.1007/978-981-96-4566-4\_11},
  abstract = {Cybersecurity is critical in today’s digital world, where the severity of threats from software vulnerabilities grows significantly each year. Many techniques have been developed to analyze vulnerabilities in source code. However, source code is not always available (for example, most industry software is closed-source). As a result, analyzing vulnerabilities in binary code becomes necessary and more challenging. This paper presents a novel approach called BiVulD for detecting vulnerabilities at the binary level. BiVulD has three phases: generating assembly language instructions, learning good embeddings, and building a prediction model. First, we create a database of vulnerable binaries using CVE and NVD. Next, we propose using codeBERT to obtain good embeddings. Finally, we apply a bidirectional LSTM on top of codeBERT to build the predictive model. To demonstrate BiVulD’s effectiveness, we compared it with several baselines, including source code-based, binary code-based, and machine learning-based techniques on real-world projects. The experimental results show that BiVulD outperforms the baselines and can detect more vulnerabilities. For instance, BiVulD achieves at least 20\% improvement in Precision, Recall, and F-measure. We believe this work will serve as a foundation for future research in vulnerability detection using only binary code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_66245_4_12,
  title = {Advancements in Malware Evasion: Analysis Detection and the Future Role of AI},
  author = {Gavrila, Razvan and Zacharis, Alexandros},
  booktitle = {Advances in Information Security},
  year = {2025},
  pages = {275-297},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-66245-4\_12},
  url = {https://doi.org/10.1007/978-3-031-66245-4\_12},
  abstract = {This chapter examines the evolution of malware evasion tactics and techniques, focusing on analysis detection. While the topic is well-researched and broad, we intend to provide an overview of malware dynamic analysis and evasion. The information we gather can be used as a starting point for understanding the current landscape but also as a resource for potential new research opportunities. The chapter also provides a historical backdrop of malware evolution, emphasising the tactics used to hide malicious activities from security tools and analysts. We highlight the arms race between malware developers and cybersecurity defenders, focusing on various anti-analysis techniques such as environment detection, reverse Turing tests, and the use of artificial intelligence. Our contribution also pinpoints the growing significance of AI in both improving and countering malware evasion strategies and what would be some potentially interesting areas for future research.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_96_3531_3_12,
  title = {Auditing and Attributing Behaviours of Suspicious Android Health Applications},
  author = {Salman, Muhammad and Santana, I. Wayan Budi and Ikram, Muhammad and Kaafar, Mohamed Ali},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {232-253},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-3531-3\_12},
  url = {https://doi.org/10.1007/978-981-96-3531-3\_12},
  abstract = {Consumer mobile medical, health, and fitness apps, collectively known as mobile health or mHealth apps, monitor user activities such as steps, locations, and email. It seamlessly aggregates sensitive information to facilitate a wide range of functions, such as the management of health conditions and symptom checking. Although mHealth apps provide real-time health monitoring and easier access to healthcare resources, they may also pose serious risks to user safety. While the research community is primarily well aware of the user’s exposure to several types of malware, there has not been a large-scale in-depth analysis of suspicious mHealth apps using a consistent methodology. This study conducts a large-scale security and privacy analysis of 381 suspicious free mHealth apps (chosen from a corpus of 15,893 apps) available on “Google Play”. We built a customized toolset to perform a comprehensive analysis of these apps. We explore the range of mechanisms used by mHealth apps to monitor users’ activities, such as photos, text messages, and live microphone access, mainly through the injection of suspicious third-party libraries. In addition, we uncover the use of obfuscation methods employed by suspicious mHealth apps to hide their malicious codes. As mHealth apps are used by a large number of customers worldwide, we argue that patients, clinicians, technology developers, and policy-makers alike should be conscious of the hidden risks involved and weigh them carefully against the benefits.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_74885_1_2,
  title = {A Comprehensive Review of Machine Learning Approaches in IoT and Cyber Security for Information Systems Analysis},
  author = {Prabhakar Reddy, G. and Deepan, P. and Arsha Reddy, M. and Santhoshkumar, R. and Rajalingam, B.},
  booktitle = {Information Systems Engineering and Management},
  year = {2025},
  pages = {25-41},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-74885-1\_2},
  url = {https://doi.org/10.1007/978-3-031-74885-1\_2},
  abstract = {Sophisticated software analysis techniques are necessary for the security of current IoT systems. Static analysis is one such technique that has consistently proven useful. The labor of human specialists needs to be automated and intellectualized since the connections between IoT systems are becoming more complicated, larger, and more heterogeneous. Therefore, we postulate that machine-learning techniques can be useful for static analysis of IoT systems. The study’s ontology is reflected in the research plan, which seeks to validate the hypothesis. The most important things that this work has accomplished are: Streamlining the process of static analysis for IoT systems and formalizing model decisions for ML problems; reviewing and analyzing a large body of literature in the field; validating that machine learning tools are appropriate for each step of static analysis; and proposing a concept for an intelligent framework to aid in static analysis of IoT systems. The findings are groundbreaking because they formalize the processes and solutions as “Form and Content,” examine each stage from the viewpoint of the complete suite of machine-learning solutions, and account for the entire static analysis process (beginning with the research of IoT systems and ending with the delivery of the results).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_032_17840_4_31,
  title = {Android Malware Detection (AMD) Using Stacked Deep Learning Ensemble Classifier Fusion (SDLECF) with Nature-Inspired Based Ensemble Feature Selection (NIEFS)},
  author = {Rajan, Anuja A. and Durga, R.},
  booktitle = {Communications in Computer and Information Science},
  year = {2026},
  pages = {466-490},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-17840-4\_31},
  url = {https://doi.org/10.1007/978-3-032-17840-4\_31},
  abstract = {Android is the most rapidly expanding mobile computer platform, which has been targeted by a variety of malware. It can be effectively identified using Deep Learning (DL) techniques. Typical feature selection algorithms disregard feature correlation which has been solved by using wrapper-based feature selection models. Wrapper-based techniques take a lot of time to select feature subsets. In this paper, Nature-Inspired Based Ensemble Feature Selection (NIEFS), and Stacked Deep Learning Ensemble Classifier Fusion (SDLECF) classifier has been introduced for combination of DL methods with increased detection accuracy. NIEFS model is developed based on a variety of evolutionary computation approaches, such as the Cauchy Operator Squirrel Search Algorithm (COSSA), Lévy Flight Pigeon-Inspired Optimization (LEFPIO), and Fuzzy Membership Grasshopper Optimization Algorithm (FMGOA) for eliminating redundant or unnecessary features. The outputs of various approaches have been integrated using Mutual Information (MI). SDLECF is introduced by merging many models (Bidirectional Gated Recurrent Unit (Bi-GRU), Sparse Autoencoder based Deep Neural Network (SAE-DNN), Bidirectional Long Short-Term Memory (BDLSTM), and Mean Weight Deep Belief Network (MWDBN)) to attain highest malware detection performance. Bi-GRU can handle data sequences in both forward and backward direction. SAE-DNN includes of three components like an encoder, a decoder, and a classification. BDLSTM classifier is a category of Recurrent Neural Network (RNN) which works on both forward and backward directions. MWDBN includes of Multiple Restricted Boltzmann Machine (RBM) layers for classification. Finally, classifier performance was measured using MATrix LABoratory R2020a (MATLABR2020a) and the metrics like Precision (Pre), Recall (Rec), F-measure (FM), and Weighted F-measure (WFM).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_032_12335_0_14,
  title = {An Overview of Termination in the Ethereum Blockchain},
  author = {Olivieri, Luca and Pasetto, Luca and Negrini, Luca and Ferrara, Pietro},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2026},
  pages = {226-248},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-12335-0\_14},
  url = {https://doi.org/10.1007/978-3-032-12335-0\_14},
  abstract = {The emergence of the Ethereum blockchain and the rise of Turing-complete smart contracts have led to the creation of new solutions for ensuring different kinds of termination. Indeed, non-termination of a smart-contract execution within the blockchain network may have critical consequences, ranging from slow performance to a complete denial of service in the worst scenarios. Furthermore, smart contracts lack a global access-control mechanism and may be executed indefinitely over time, even after they have exhausted their purposes. Therefore, this requires, in some cases, developing solutions implementing “soft” and “hard” terminations—such as pausable, interruptions, and kill-switch mechanisms—as well as providing safe termination guarantees. In addition, termination is even more crucial when we consider legal aspects of smart contracts, including compliance with laws and regulations, such as the smart contract requirements proposed by the European Union Data Act . In this paper, we explore several mechanisms to ensure various kinds of termination in Ethereum, the most widely used blockchain. Moreover, we investigate similar mechanisms for traditional programming languages that can be applied to smart contracts in the blockchain context. The primary purpose of this study is to fill the gap caused by the lack of standards for these mechanisms and the emerging solutions typically proposed by practitioners.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_20322_0_9,
  title = {Comprehension of Computer Programs Through Reverse Engineering Approaches and Techniques: A Systematic Mapping Study},
  author = {Luna-Herrera, Yazmin Alejandra and Pérez-Arriaga, Juan Carlos and Ocharán-Hernández, Jorge Octavio and Sanchéz-García, Ángel J.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {126-140},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-20322-0\_9},
  url = {https://doi.org/10.1007/978-3-031-20322-0\_9},
  abstract = {The maintenance phase is an activity carried out by software engineers that requires an understanding how computer programs work. However, most legacy systems lack associated documentation and have poorly designed artifacts. As a result, technical debt is generated, which causes a significant increase in maintenance costs. Reverse engineering is applied to help software engineers to understand how the program was designed. Within reverse engineering, different approaches reduce the effort required for comprehension. In addition, static, dynamic, and hybrid analysis techniques are used to generate artifacts where the program’s behavior can be easily visualized. This paper presents the results of a Systematic Mapping Study (SMS) conducted to identify reverse engineering approaches to help software engineers understand computer programs. Forty-eight studies were selected. Ten different approaches were identified in these studies, the main ones being Model-Driven Reverse Engineering (MDRE) and visualization graphics; static, dynamic, and hybrid analysis techniques were found; and fifteen artifacts featuring visualization graphs, class diagrams, and sequence diagrams.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_0272_9_4,
  title = {Detecting Unknown Vulnerabilities in Smart Contracts with Multi-Label Classification Model Using CNN-BiLSTM},
  author = {Gu, Wanyi and Wang, Guojun and Li, Peiqiang and Li, Xubin and Zhai, Guangxin and Li, Xiangbin and Chen, Mingfei},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {52-63},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-0272-9\_4},
  url = {https://doi.org/10.1007/978-981-99-0272-9\_4},
  abstract = {Smart contracts are frequently targeted by hackers because they hold large amounts of money and cannot be modified once they are published. Existing detection methods mainly focus on known vulnerabilities with clear features and cannot deal with unknown vulnerabilities. As a consequence, proposing a method for detecting unknown vulnerabilities in smart contracts represents a significant advancement in the field of smart contract security. Aiming at this problem, based on the idea that the opcode sequences of transactions containing unknown vulnerabilities have similarities to the opcode sequences of transactions containing known vulnerabilities, we propose a novel approach for unknown vulnerability detection in smart contracts using a CNN-BiLSTM model. Our model determines whether a vulnerability is unknown by detecting the opcode sequence representing the entire execution process of a transaction. Experimental results with the opcode sequences of transactions show that the model can achieve 82.86\% accuracy and 83.63\% F1-score.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_5652_1_31,
  title = {Adware and Spyware Detection Using Classification and Association},
  author = {Anumula, Kalyan and Raymond, Joseph},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2022},
  pages = {355-361},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-16-5652-1\_31},
  url = {https://doi.org/10.1007/978-981-16-5652-1\_31},
  abstract = {In the android platform, the growth of application development reached 10 million per year. The application developers require to advertise their applications for describing its usage. Among all applications, the malware developers also introduced their applications with obfuscated names and allure to install them on our mobile devices. In this process, the applications run in the background and raise advertisements to bypass the users from the identification of malware. Here we proposed the system with adware and spyware detects by classification and association mechanism which defers specific data to be stolen. Analysis of the application data while running makes security scientists strategically tough tasks to accomplish.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_56252_5_2,
  title = {Out in the Open: On the Implementation of Mobile App Filtering in India},
  author = {Gosain, Devashish and Singh, Kartikey and Sharma, Rishi and Suresh Babu, Jithin and Chakravaty, Sambuddho},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {19-36},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-56252-5\_2},
  url = {https://doi.org/10.1007/978-3-031-56252-5\_2},
  abstract = {In this paper, we present the first comprehensive study highlighting the evolving mobile app filtering within India. We study the recent mobile app blocking in India and describe in detail the mechanics involved. We analyzed 220 Chinese apps that were blocked due to official government orders. Our research reveals a novel “three-tiered” app filtering scheme, with each tier increasing the sophistication of filtering. After thoroughly analyzing the app blocking mechanisms, we present circumvention techniques to bypass the tiered app filtering. We were able to access all the blocked apps with the said techniques. We believe our analysis and findings from the case study of India will aid future research on mobile app filtering.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10586_024_04865_x,
  title = {FEdroid: a lightweight and interpretable machine learning-based android malware detection system},
  author = {Huang, Hong and Huang, Weitao and Zhou, Yinghang and Luo, Wengang and Wang, Yunfei},
  journal = {Cluster Computing},
  year = {2025},
  volume = {28},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-024-04865-x},
  url = {https://doi.org/10.1007/s10586-024-04865-x},
  abstract = {Android operating system, renowned for its open-source nature and flexibility, holds the largest global market share, yet faces significant security challenges, particularly from malware threats. Existing studies often rely on complex feature engineering for malware detection, leading to cumbersome methods prone to noise and lacking effective feature selection mechanisms. Some deep learning approaches also suffer from low efficiency. This paper introduces a lightweight and interpretable Android malware detection system called “FEdroid.” By focusing on code segments that utilize sensitive APIs, the system simplifies the analysis process and extracts key information, employing XGBoost for cross-feature selection to concentrate on a minimal yet crucial feature set. This approach enhances detection accuracy while reducing device resource usage. Experimental results demonstrate that the system achieved an accuracy of 98.26\% and a false negative rate of only 1.86\% across 18,653 APK samples, significantly improving detection efficiency and accuracy while minimizing deployment resource dependency. Furthermore, the application of Shapley values for interpretive analysis greatly enhances the transparency and understandability of the classifier model, thereby improving the overall interpretability of the system.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_9876_8_16,
  title = {Detection of Android Malwares on IOT Platform Using PCA and Machine Learning},
  author = {Mantoo, Bilal Ahmad and Malhotra, Sumit and Gupta, Kiran},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2023},
  pages = {193-205},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-9876-8\_16},
  url = {https://doi.org/10.1007/978-981-19-9876-8\_16},
  abstract = {The Android operating system is considered to be the most advanced and popular smart phone operating system and has a dramatic increase in the market with approximately 1.5 billion Android-based devices shipped by 2021. This spike increased in the market leads to high number of malwares in the Android platform. The reason is simple, because the mutating nature of Android malwares reduces the efficiency of malware detection tools in that are already in the market. Furthermore, the vast number of features in the Android platform provides a big challenge to the current tools to detect the Android malware on IOT-based platform. In this paper, we used a real physical device, i.e., Android smart phone, smart tablets, Android watches instead of protected environment like genymotion for analysis and extract the feature from 10,650 applications of malware and benign. Large spaces of feature set are reduced with the use of principal component analysis approach which extracts the best features from the dataset. The data is then fed to the deep learning model with different hidden layers; the algorithms are applied for dynamic features as well as the combination with permissions. The results reveals that the deep learning model with three hidden layers gives overall best accuracy as compared to the previous works done on the same field using protected environment.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_80119_9_72,
  title = {Mapping Risk Assessment Strategy for COVID-19 Mobile Apps’ Vulnerabilities},
  author = {Sharma, Tanusree and Dyer, Hunter A. and Campbell, Roy H. and Bashir, Masooda},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {1082-1096},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-80119-9\_72},
  url = {https://doi.org/10.1007/978-3-030-80119-9\_72},
  abstract = {Recent innovations in mobile technologies are playing an important and vital role in combating the COVID-19 pandemic. While mobile apps’ functionality plays a crucial role in tackling the COVID-19 spread, it is also raising concerns about the associated privacy risks that users may face. Recent research studies have showed various technological measures on mobile applications that lack consideration of privacy risks in their data practices. For example, security vulnerabilities in COVID-19 apps can be exploited and therefore also pose privacy violations. In this paper, we focus on recent and newly developed COVID-19 apps and consider their threat landscape. Our objective was to identify security vulnerabilities that can lead to user-level privacy risks. We also formalize our approach by measuring the level of risk associated with assets and services that attackers may be targeting to capture during the exploitation. We utilized baseline risk assessment criteria within the scope of three specific security vulnerabilities that often exists in COVID-19 applications namely credential leaks, insecure communication, and HTTP request libraries. We present a proof of concept implementation for risk assessment of COVID-19 apps that can be utilized to evaluate privacy risk by the impact of assets and threat likelihood.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_3656_4_31,
  title = {Three-Layered Hybrid Analysis Technique for Android Malware Detection},
  author = {Sharma, Tejpal and Rattan, Dhavleesh},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2023},
  pages = {303-312},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-3656-4\_31},
  url = {https://doi.org/10.1007/978-981-99-3656-4\_31},
  abstract = {In these days, smartphones become an essential gadget that can perform multiple routine activities like banking, education, entertainment, etc. A large number of companies are developing new smartphones with latest tools and technologies to attract the people. But data security is one of the main issues which is still a hurdle for all because as the technology is growing malware authors are also developing new malwares to attack these mobile devices to show their existence and sometimes for monetary benefits. Android is most used mobile operating system, and this is the reason it is targeted by malware authors or attackers. Malware detection systems are also developed but still there is need to work on this issue. In this paper, we have proposed a technique that will detect the malwares in Android operating system. It is a hybrid technique based on three-layered crossed analysis. In this, we will apply static analysis on first two layers and dynamic on third layer. Visualization and string search analysis will work on static phase, and system call log analysis will check the behaviour of running application. So, it will cover all the packed application along with code obfuscation, metamorphic malware and zero-day attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_93354_7_11,
  title = {RustBound: Function Boundary Detection over Rust Stripped Binaries},
  author = {Evans, Ryan and Hawkins, William and Wang, Boyang},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2025},
  pages = {237-256},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-93354-7\_11},
  url = {https://doi.org/10.1007/978-3-031-93354-7\_11},
  abstract = {Function boundary detection identifies start addresses and end addresses of functions in a binary. It is a critical step in binary analysis and is considered as a challenging task over stripped binaries. While existing studies have shown that it is feasible to efficiently and accurately perform function boundary detection over C stripped binaries, it remains unknown whether these methods will perform well over Rust stripped binaries. In this paper, we experimentally evaluate and compare four methods/tools, including two industry reverse engineering tools (Ghirda and IDA Pro) and two neural-network-based methods, in the context of function boundary detection over Rust binaries. We establish a large-scale dataset consisting of 2,471 Rust binaries (with over 8.69 million functions) across five optimization levels and develop two tools to perform analyses automatically. We derive two major findings based on our experimental results. First, one of the two neural-network-based methods, named XDA, can achieve promising results (e.g., 94.8\% precision and 85.5\% recall over binaries compiled with O0) and outperform other methods/tools in detecting function boundaries over Rust binaries, except over binaries from Oz optimization. Second, although Ghidra and IDA Pro can accurately detect function starts, they are not effective on precisely distinguishing function ends over Rust binaries.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_19_8563_8_25,
  title = {A Computationally Inexpensive Method Based on Transfer Learning for Mobile Malware Detection},
  author = {Acharya, Saket and Rawat, Umashankar and Bhatnagar, Roheet},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {263-274},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-8563-8\_25},
  url = {https://doi.org/10.1007/978-981-19-8563-8\_25},
  abstract = {With the broad usage of Android smartphones, malware growth has been rising exponentially. The high prominence of Android applications has roused attackers to target them. In the past few years, most scientists and researchers have researched detecting Android malware through machine learning and deep learning techniques. Though these traditional techniques provide good detection accuracy, they need high configuration machines such as GPUs to train complex datasets. To resolve this problem, the transfer learning approach is presented in this paper to efficiently detect Android malware with low computational power requirements. By transferring the necessary features and information from a pre-trained source model to a target model, transfer learning lowers the computational cost. In this paper, we initially performed Android malware detection using traditional models such as convolutional neural networks and then we applied the transfer learning technique to reduce the computational cost. Additionally, we evaluated how well the suggested strategy performed against other cutting-edge malware detection methods. The proposed method achieved an accuracy of 97.5 with 2.2\% false positive rate. In addition, the overfitting problem and high computational power requirements are also reduced.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_95767_3_15,
  title = {Obfuscation for Deep Neural Networks Against Model Extraction: Attack Taxonomy and Defense Optimization},
  author = {Sun, Yulian and Bonde, Vedant and Duan, Li and Li, Yong},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {391-414},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-95767-3\_15},
  url = {https://doi.org/10.1007/978-3-031-95767-3\_15},
  abstract = {Well-trained deep neural networks (DNN), including large language models (LLM), are valuable intellectual property assets. To defend against model extraction attacks, one of the major ideas proposed in a large body of previous research is obfuscation: splitting the original DNN and storing the components separately. However, systematically analyzing the methods’ security against various attacks and optimizing the efficiency of defenses are still challenging. In this paper, We propose a taxonomy of model-based extraction attacks, which enables us to identify vulnerabilities of several existing obfuscation methods. We also propose an extremely efficient model obfuscation method called \\(\\mathsf \{O\textasciicircum{}\{2\}Splitter\}\\) using trusted execution environment (TEE). The secrets we store in TEE have \\(\{\\mathcal \{O\}\} (1)\\) -size, i.e., independent of model size. Although \\(\\mathsf \{O\textasciicircum{}\{2\}Splitter\}\\) relies on a pseudo-random function to provide a quantifiable guarantee for protection and noise compression, it does not need any complicated training or filtering of the weights. Our comprehensive experiments show that \\(\\mathsf \{O\textasciicircum{}\{2\}Splitter\}\\) can mitigate norm-clipping and fine-tuning attacks. Even for small noise ( \\(\\epsilon = 50 \\) ), the accuracy of the obfuscated model is close to random guess, and the tested attacks cannot extract a model with comparable accuracy. In addition, the empirical results also shed light on discovering the relation between DP parameters in obfuscation and the risks of concrete extraction attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_2768_5_4,
  title = {Comparative Analysis of Detection of Network Attacks Using Deep Learning Algorithms},
  author = {Singh, Sandeep and Rajput, Mohit and Bajaj, Shalini Bhaskar and Tripathi, Khushboo and Aneja, Nagendra},
  booktitle = {Studies in Autonomic, Data-driven and Industrial Computing},
  year = {2023},
  pages = {35-46},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-2768-5\_4},
  url = {https://doi.org/10.1007/978-981-99-2768-5\_4},
  abstract = {With the notable increase for utilization of the Internet technologies and application and fast growing of Internet and network communication technologies also given the rise to attacks and risk for network communication. Network attack analysis and detection are the active areas of research in the cybersecurity and networking community. Nowadays, the various artificial intelligence-based network detection techniques being used are described in the literature review; these includes deep learning (DL), data encryption, governance management, identity management, and intrusion detection for network protection. However, there are no techniques that are capable to eliminate or detect all types of network issues with the single technique. The author summarizes the fundamental issues of network security, and attack detection techniques and presents several successful related applications with an in-depth learning structure and provides the results of the intrusion detection AODV and the AODV Blackhole scenario for comparison.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_72578_4_3,
  title = {Integrating Artifact Translation Into Model Transformation Processes},
  author = {Vietz, Daniel and Barzen, Johanna and Harzenetter, Lukas and Leymann, Frank and Weder, Benjamin},
  booktitle = {Communications in Computer and Information Science},
  year = {2025},
  pages = {42-62},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-72578-4\_3},
  url = {https://doi.org/10.1007/978-3-031-72578-4\_3},
  abstract = {Model transformation is a critical aspect of modern software engineering, enabling the effective development, maintenance, and evolution of software systems while improving their quality, correctness, and interoperability. However, one issue arises when a model under transformation references artifacts such as source code files or binary executables: Model transformations typically do not consider the referenced artifacts, resulting in the possibility of them becoming incompatible with the final model after transformation. As a result, the referenced artifacts often require manual adaptations which can be complex, time-consuming, and error-prone. To address this issue, we present an approach that integrates artifact translation mechanisms into the model transformation process. In addition to the translation between different concrete artifacts during model transformation, our approach also enables the use of abstract artifacts in models in order to translate them into concrete artifacts during model refinement, which is a special type of model transformation. To validate the practical feasibility of our approach, we present a prototype and two case studies in the domain of quantum software engineering.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_64954_7_22,
  title = {Ransomware as a Service: Demystifying Android Ransomware Generators},
  author = {Tu, Can and Wang, Liu and Xu, Yang and Zhao, Yiping and Xu, Haitao and Wang, Haoyu},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2025},
  pages = {426-447},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64954-7\_22},
  url = {https://doi.org/10.1007/978-3-031-64954-7\_22},
  abstract = {Ransomware has become a pervasive and lucrative threat in the Android platform, prompting the emergence of Ransomware as a Service (RaaS) business model. Ransomware generators, as an outgrowth of this model, have been found to be readily available on the web. This has further fueled the proliferation of ransomware attacks by enabling individuals without programming skills to participate in the ransomware economy. Although the nuisance of ransomware generators has been mentioned by a few security reports, our community lacks an understanding of the characteristics of these Android ransomware generators. In this paper, we take the first step towards systematically studying Android ransomware generators. We analyze the RaaS business model from multiple perspectives including their behaviors, practices, generated apps, and ecosystem. We observe that deceptive tactics exist in some so-called ransomware generator apps, such as malware masquerading and developer spoofing. For the generated ransomware, we reveal their common locking mechanisms and a variety of unlocking mechanisms. We also provide an overview of the ecosystem by revealing the participating entities, propagation channels, and workflow. Our findings contribute to advancing our understanding of Android ransomware generators and their associated risks, and inform the development of effective countermeasures and strategies to combat ransomware threats.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s13677_025_00798_x,
  title = {Graph attention network vulnerability detection model with global feature augmentation for smart contracts},
  author = {Li, Miaoer and Zhu, Yi and Liu, Yali and Li, Zexin and Huang, Junge},
  journal = {Journal of Cloud Computing},
  year = {2025},
  volume = {14},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13677-025-00798-x},
  url = {https://doi.org/10.1186/s13677-025-00798-x},
  abstract = {Smart contracts are self-executing programs on blockchains, critical for enabling efficient, secure, and reliable data exchange and value transfer. However, as their application scenarios expand, reliability issues have become a major bottleneck for blockchain development. Existing vulnerability detection methods often model smart contract source code as graph structures and use Graph Neural Networks (GNNs) for feature learning. Yet these methods over-rely on static execution flow features and ignore dynamic behavioral information of contract accounts in real runtime environments, limiting their ability to capture dynamic patterns and semantic details of contracts. To address these challenges, this paper proposes a graph attention network vulnerability detection model with global feature augmentation for smart contracts (GaGAT). Specifically, we first model key functions and variables in the contract source code as nodes, and execution flows as edges to construct a base contract graph. Then, we innovatively introduce global virtual nodes that integrate two types of information: contract categories and contract account behavioral features, including balance changes, Ether inflow/outflow, daily transaction frequency and single transaction duration. After contract graph contraction and feature transformation, we generate a feature matrix as input to the GaGAT model. Subsequently, we conduct vulnerability detection. Through a series of experiments, we provide empirical evidence of the superior performance of our proposed method compared to existing approaches in detecting six different categories of vulnerabilities.This study provides a new paradigm for cross-modal feature fusion for smart contract security analysis.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_9379_4_39,
  title = {Android Malware Detection Against String Encryption Based Obfuscation},
  author = {Bhakta, Dip and Yousuf, Mohammad Abu and Rana, Md. Sohel},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {543-555},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-9379-4\_39},
  url = {https://doi.org/10.1007/978-981-19-9379-4\_39},
  abstract = {Android operating system is one of the most prominent operating systems among the mobile device users worldwide. But it is often the most targeted platform for malicious activities. Many researchers have studied android malware detection systems over the previous years. But android malware detection systems face many challenges, and obfuscation is one of them. String encryption is one such obfuscation technique which helps android malwares to evade malware detection systems. To address this challenge in android malware detection systems, a novel approach is being proposed in this study where crypto-detector: An open-source cryptography detection tool has been used in decompiled application code to extract encrypted strings and encryption methods as features. Accuracy of 0.9880 and F 1-score of 0.9843 have been achieved during performance evaluation. Importance of newly proposed crypto features has been discussed. Performance of our framework has been compared to those of other similar existing works, and our work has outperformed all of them.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_024_00522_4,
  title = {A vehicle firmware security vulnerability: an IVI exploitation},
  author = {Costantino, Gianpiero and De Vincenzi, Marco and Matteucci, Ilaria},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2024},
  volume = {20},
  number = {4},
  pages = {681-696},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-024-00522-4},
  url = {https://doi.org/10.1007/s11416-024-00522-4},
  abstract = {Abstract In the last years, the increasing vehicular technology has led to a surge in cybersecurity attacks, particularly regarding connected vehicles and their vulnerable infotainment systems. This paper explores the vulnerabilities within an In-Vehicle Infotainment (IVI) system firmware, focusing on the Gen5W\_L multimedia device utilized in Hyundai, Kia, and Genesis vehicles. Leveraging reverse engineering techniques, the study uncovers several security issues within the firmware, allowing for the creation and installation of custom firmware. The paper introduces Chimaera, a reverse engineering attack targeting the IVI system firmware, which exploits a vulnerability introduced by statically compiling the mbedtls library. After a reverse engineering analysis and injecting malicious assembly code directly in the IVI firmware, the attack enables the extraction of sensitive information from the firmware files like the cryptographic keys to install a customized firmware. The research shows that exploiting these vulnerabilities facilitates the installation of insecure firmware, granting attackers unauthorized access to vehicle functionalities. This includes the possibility to inject CAN bus messages, potentially compromising critical vehicle systems such as radio controls and safety features. The findings underscore the need for robust cybersecurity measures within automotive systems and highlight the significance of vulnerability assessment to mitigate security risks in connected vehicles.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_1682_8_5,
  title = {Hacking Your App},
  author = {Gunasekera, Sheran},
  booktitle = {Android Apps Security},
  year = {2020},
  pages = {91-119},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1682-8\_5},
  url = {https://doi.org/10.1007/978-1-4842-1682-8\_5},
  abstract = {In this chapter, I would like to talk about some steps you can take to testing the security of your own app. In a larger organization or a more mature startup (if there is such a thing), the testing may usually be done by the information security team. But before we get started on the technical aspects of hacking an Android app, I want to take a moment to talk about the security testing process.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10586_025_05230_2,
  title = {Contract-guardian: a bagging-based gradient boosting decision tree for detection vulnerability in smart contract},
  author = {Ali, Ghazi Mergani Ahmead and Chen, Hongsong},
  journal = {Cluster Computing},
  year = {2025},
  volume = {28},
  number = {8},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-025-05230-2},
  url = {https://doi.org/10.1007/s10586-025-05230-2},
  abstract = {Smart contracts, a core component of blockchain technology, enable automated and trustless transactions but remain vulnerable to security flaws such as reentrancy, integer overflow, and block number dependency, leading to significant financial risks. Existing static analysis tools provide limited detection capabilities and struggle with complex vulnerabilities. We propose a novel Bagging-based Gradient Boosting Decision Tree (BGBDT-CG) framework for robust vulnerability detection in smart contracts. The framework employs a three-step methodology: (i) feature extraction from control flow graphs (CFGs) and abstract syntax trees (ASTs), leveraging multiple fuzzing analyzers for data labeling; (ii) training a hybrid ensemble model combining bagging with Gradient Boosting Decision Tree (GBDT) algorithms, including GBM, LightGBM, CatBoost, and XGBoost; and (iii) detecting vulnerabilities through classification tasks, with final predictions determined by a majority-voting mechanism across class probabilities. Extensive experiments demonstrate the effectiveness of the BGBDT-CG model, achieving 98\% detection accuracy and an average F1 score of 95.2\%, outperforming existing methods. The integration of bagging and CatBoost proved particularly effective, highlighting the framework's robustness and reliability in smart contract vulnerability detection.},
  content_type = {Article},
}


@article{springer_10_1007_s10207_025_01053_9,
  title = {Ensemble learning-based adaptive and adversarial techniques for APT attack detection},
  author = {Tung, Nguyen Thanh and Do Xuan, Cho and Long, Vu Thanh},
  journal = {International Journal of Information Security},
  year = {2025},
  volume = {24},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-025-01053-9},
  url = {https://doi.org/10.1007/s10207-025-01053-9},
  abstract = {Nowadays, Advanced persistent threats (APT) attacks are not only increasing in number but also becoming more sophisticated, posing serious challenges for organizations in detecting and preventing these threats. Some approaches for detecting APT attacks based on network traffic analysis using artificial intelligence have initially brought many positive results. The trend of these studies often seeks to analyze and extract network flow information in network traffic to find unusual behaviors of APT attacks. However, these approaches still have certain disadvantages that limit detection results, including: i) Only process data sequentially, lack flexibility and do not filter and focus on important data; ii) the context in the data has not been defined and evaluated. Although this is important information, it is closely related and interdependent with abnormal signs. To overcome the above limitations, this study introduces an advanced learning ensemble, combining modern techniques such as Adaptive contextual (AC), Selective adversarial generation (SAG), BiLSTM (Bidirectional long short-term memory), and Transformer. The AC technique is used to adapt to different network traffic data, helping to distill important information and adapt itself to data with different numbers of attacks, demonstrating context preservation and detecting anomalous patterns. SAG is applied to create synthetic data to simulate hacker attack data, helping to balance and improve the learning ability of the model. BiLSTM and Transformer are integrated to exploit contextual relationships and long-term dependencies in data, enhancing data processing capabilities based on parallel computing and analysis techniques. Experimental results in the article show that the proposed model is 2–4\% more effective than other studies on all measures. The experimental results of the study show that the proposed ACG-BT model has achieved an accuracy of up to 99.45\% and an F1-score of 98.35\% on a data set of 1,884 IP pairs extracted from more than 1.6 million flows. These figures demonstrate the model’s superior performance compared to existing methods, with improvements ranging from 2 to 4\% across all metrics.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_93872_7_3,
  title = {Detection of Malicious Program for the Android Platform by Deep Training},
  author = {Suprun, Aleksandr and Tatarnikova, Tatiana and Sikarev, Igor and Shmeleva, Anastasia},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {31-38},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-93872-7\_3},
  url = {https://doi.org/10.1007/978-3-030-93872-7\_3},
  abstract = {The article deals with threats to the Google Android mobile operating system, methods of attacks. The advantages and disadvantages of malware detection mechanisms are analyzed. To solve the problem of classification of threats, it is proposed to use the apparatus of neural networks. The complex application of static and dynamic analysis of Android operating system programs allows you to accurately classify the programs under study with a high degree of probability. The classification problem is solved using the neural network apparatus. The results showed that all malicious programs that were boycotted by obfuscation were correctly identified as malicious.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_57024_8_20,
  title = {Mobile Application Security Using Static and Dynamic Analysis},
  author = {Shahriar, Hossain and Zhang, Chi and Talukder, Md Arabin and Islam, Saiful},
  booktitle = {Studies in Computational Intelligence},
  year = {2021},
  pages = {443-459},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-57024-8\_20},
  url = {https://doi.org/10.1007/978-3-030-57024-8\_20},
  abstract = {The mobile applications have overtaken web applications in the rapid growing of the mobile app market. As mobile application development environment is open source, it attracts new inexperienced developers to gain hands-on experience with application development. However, the data security and vulnerable coding practice are two major issues. Among all mobile operating systems including iOS (by Apple), Android (by Google) and Blackberry (RIM), Android remains the dominant OS on a global scale. The majority of malicious mobile attacks take advantage of vulnerabilities in mobile applications, such as sensitive data leakage via the inadvertent or side channel, unsecured sensitive data storage, data transition and many others. Most of these vulnerabilities can be detected during mobile application analysis phase. In this chapter, we explored some existing vulnerability detection tools available for static and dynamic analysis and hands-on exploration of using them to detect vulnerabilities. We suggest that there is a need of new tools within the development environment for security analysis in the process of application development.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11227_025_07055_7,
  title = {Smali code-based deep learning model for Android malware detection},
  author = {Anand, Abhishek and Singh, Jyoti Prakash and Singh, Amit Kumar},
  journal = {The Journal of Supercomputing},
  year = {2025},
  volume = {81},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-025-07055-7},
  url = {https://doi.org/10.1007/s11227-025-07055-7},
  abstract = {With the widespread adoption of smartphones and the exponential growth of the mobile Internet, the Android platform has emerged as a highly popular choice. However, the platform’s open-source nature has also made it vulnerable to a surge in malware attacks. To address this pressing issue, this research paper introduces a robust malware detection system based on Smali-GRU (gated recurrent unit) network, aimed at enhancing the efficiency of malware detection on the Android platform. The proposed detection system employs a static analysis approach to extract Smali files from Android application packages (APKs). These extracted Smali files then undergo a series of pre-processing steps to extract pertinent features. To ensure compatibility with the GRU model, the preprocessed Smali files are fragmented into smaller segments. The paper explores and tests fragments of varying sizes to identify the optimal configuration that yields the most promising results. The study’s findings highlight that the proposed Smali-GRU model outperforms existing works that employ the same dataset and GRU model, resulting in an impressive accuracy of 98.29\%. Furthermore, the robustness of the model is evaluated using a dataset of obfuscated malware. The results obtained highlight the efficacy and superiority of the proposed model in successfully detecting obfuscated malware in Android applications.},
  content_type = {Article},
}


@article{springer_10_1007_s10515_025_00538_0,
  title = {DESCG: data encoding scheme classification with GNN in binary analysis},
  author = {Dai, Xushu and Luo, Nanqing and Wang, Haizhou and Wang, Zhilong and Cao, Chen and Liu, Peng},
  journal = {Automated Software Engineering},
  year = {2025},
  volume = {32},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-025-00538-0},
  url = {https://doi.org/10.1007/s10515-025-00538-0},
  abstract = {Abstract Binary analysis, the process of examining software without its source code, plays a crucial role in understanding program behavior, e.g., evaluating the security properties of commercial software, and analyzing malware. One challenging aspect of this process is to classify data encoding schemes, such as encryption and compression, due to the absence of high-level semantic information. Existing approaches either rely on code similarity, which only works for known schemes, or heuristic rules, which lack scalability. In this paper, we propose DESCG , a novel deep learning-based method for automatically classifying four widely employed kinds of data encoding schemes in binary programs: encryption, compression, decompression, and hashing. Our approach leverages dynamic analysis to extract execution traces from binary programs, builds data dependency graphs from these traces, and incorporates critical feature engineering. By combining the specialized graph representation with the Graph Neural Network (GNN), our approach enables accurate classification without requiring prior knowledge of specific encoding schemes. The Evaluation result shows that DESCG achieves 97.7\% accuracy and an F1 score of 97.67\%, outperforming baseline models. We also conducted an extensive evaluation of DESCG to explore which feature is more important for it and examine its performance and overhead.},
  content_type = {Article},
}


@article{springer_10_1186_s40537_025_01157_y,
  title = {Application of deep learning in malware detection: a review},
  author = {Song, Yafei and Zhang, Dandan and Wang, Jian and Wang, Yanan and Wang, Yang and Ding, Peng},
  journal = {Journal of Big Data},
  year = {2025},
  volume = {12},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s40537-025-01157-y},
  url = {https://doi.org/10.1186/s40537-025-01157-y},
  abstract = {Abstract The defense of malware remains an important research hotspot in the field of cyberspace security. Recognizing its profound research significance, our defense against malware is still an important research hotspot in the field of cyberspace security. According to several recent surveys, global infrastructure is increasingly attacked by cyber crimes, and the damage of various malicious attacks to countries and even individuals cannot be underestimated, even on the rise. There is an urgent need to adopt advanced tools for early detection of malware and its variants to help researchers take early steps to defend against it. Its broad approach will help the early malware to detect and identify the behavioral patterns of large amounts of malicious data, and the discipline of artificial intelligence offers broad research potential. The results of these tests will help researchers make decisions and early detection, effectively defense against malware. This work compares and reports a classification of malware detection work based on deep learning algorithms. The 2011–2025 articles were considered, and the latest work focused on the literature for the 2018–2025 years; after screening, 72 articles were selected for the initial study. Future researchers will benefit from this review by better understanding current deep learning models in the field of malware detection. The review includes common methods such as convolutional neural networks, recurrent neural networks and generative adversarial networks, focusing on feature extraction techniques such as sequence features, image visualization and data enhancement. The survey summarizes the metrics used to report the accuracy. In addition, it highlights prominent publishers, journals and conferences as platforms for the evaluation of academic works. Taken together, this will help researchers at the current stage gain insight into the unresolved challenges or barriers faced by previous researchers. Among these, the most common problem is the lack of broader and consistent datasets, followed by the need for existing models for further improvement.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_53161_3_5,
  title = {Data Collection with Honeypot Server for Reverse Engineering of Malware},
  author = {Cvitić, Ivan and Periša, Marko and Vladava, Josip},
  booktitle = {EAI/Springer Innovations in Communication and Computing},
  year = {2024},
  pages = {61-77},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-53161-3\_5},
  url = {https://doi.org/10.1007/978-3-031-53161-3\_5},
  abstract = {Malware is any harmful code intended to harm the user. Computer malware is a type of threat that is designed to infiltrate other computers and exfiltrate sensitive user information or act destructively. In response to the growing number of malicious programs, the field of malware analysis is emerging. Malware can be collected by implementing honeypot servers and analyzed using reverse engineering tools and techniques. Honeypot servers can be categorized by their purpose and level of interactivity. The data collected by the honeypot server can be categorized as: connection data, malicious scripts, and malware. By analyzing gathered information and focusing on the reverse engineering of malware, insight will be provided into the functioning of the malicious programs and how to prevent their operation and further spread. Reverse engineering can be divided into two types of analysis – static and dynamic malware analysis. Static analysis is a method in which the malware sample is not executed, while the purpose of dynamic analysis is to monitor the changes caused by the malware after execution. The collected information serves to improve and develop cybersecurity strategies.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_29504_1_6,
  title = {Assessing Deep Learning Predictions in Image-Based Malware Detection with Activation Maps},
  author = {Iadarola, Giacomo and Mercaldo, Francesco and Martinelli, Fabio and Santone, Antonella},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {104-114},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-29504-1\_6},
  url = {https://doi.org/10.1007/978-3-031-29504-1\_6},
  abstract = {Machine learning and deep learning models have been widely adopted to detect malware and protect our cyber infrastructures. The training is the most effective and important element of the artificial intelligence models. Nevertheless, it can be challenging and may require expertise and high-quality data. Inadequate training can be counterproductive, and lead to a model which may not detect the threats or, even worst, being exploited by the attackers. In this regard, the contribution of this short paper is twofold: we propose a method to (i) detect the malware belonging family and (i) provide reasoning about model evaluation and assess model soundness. The rationale behind this work aims to improve the evaluation of image-based deep learning models for malware family detection, especially in supervised learning tasks without recognizable or known patterns in the dataset samples. Our model obtains an overall accuracy of 0.934 in the evaluation of a dataset composed of 15726 real-world malware.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_021_09974_4,
  title = {Beyond the virus: a first look at coronavirus-themed Android malware},
  author = {Wang, Liu and He, Ren and Wang, Haoyu and Xia, Pengcheng and Li, Yuanchun and Wu, Lei and Zhou, Yajin and Luo, Xiapu and Sui, Yulei and Guo, Yao and Xu, Guoai},
  journal = {Empirical Software Engineering},
  year = {2021},
  volume = {26},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-021-09974-4},
  url = {https://doi.org/10.1007/s10664-021-09974-4},
  abstract = {As the COVID-19 pandemic emerged in early 2020, a number of malicious actors have started capitalizing the topic. Although a few media reports mentioned the existence of coronavirus-themed mobile malware, the research community lacks the understanding of the landscape of the coronavirus-themed mobile malware. In this paper, we present the first systematic study of coronavirus-themed Android malware. We first make efforts to create a daily growing COVID-19 themed mobile app dataset, which contains 4,322 COVID-19 themed apk samples (2,500 unique apps) and 611 potential malware samples (370 unique malicious apps) by the time of mid-November, 2020. We then present an analysis of them from multiple perspectives including trends and statistics, installation methods, malicious behaviors and malicious actors behind them. We observe that the COVID-19 themed apps as well as malicious ones began to flourish almost as soon as the pandemic broke out worldwide. Most malicious apps are camouflaged as benign apps using the same app identifiers (e.g., app name, package name and app icon). Their main purposes are either stealing users’ private information or making profit by using tricks like phishing and extortion. Furthermore, only a quarter of the COVID-19 malware creators are habitual developers who have been active for a long time, while 75\% of them are newcomers in this pandemic. The malicious developers are mainly located in the US, mostly targeting countries including English-speaking countries, China, Arabic countries and Europe. To facilitate future research, we have publicly released all the well-labelled COVID-19 themed apps (and malware) to the research community. Till now, over 30 research institutes around the world have requested our dataset for COVID-19 themed research.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_46781_3_29,
  title = {A Method Against Adversarial Attacks to Enhance the Robustness of Deep Learning Models},
  author = {Truong, Phi Ho and Pham, Duy Trung},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {346-357},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-46781-3\_29},
  url = {https://doi.org/10.1007/978-3-031-46781-3\_29},
  abstract = {Deep learning is facing a dangerous challenge because attackers are always lurking to find and exploit the model’s vulnerabilities to deceive, making the model misidentify the classifier for the target model. It is dangerous if a smart device using artificial intelligence misrecognizes the object class. Attackers today often use adversarial examples, which at first glance do not differ from an image that is defined as natural when collected from sensors, or digital devices. Many studies on attacks and methods of combating these attacks have been tested by research groups and announced to be highly effective against attack or pattern recognition. Training the model with the aim of making the model able to recognize the adversarial example, a seemingly simple but effective method to make the model more robust, and capable of classification and identification. In this paper, to enhance the robustness of the model, the authors use adversarial training and experiment on the YOLOv7 model. Experiments show that this method is effective, making the model more powerful, capable of detecting and classifying adversarial examples after the model has been adversarial trained.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_96_7218_9_8,
  title = {Remaining Useful Life Prediction of Power Supply Based on Range-Extended New Energy Vehicles},
  author = {Liu, Hui and Cheng, Fang and Li, Yanfei},
  booktitle = {Prognostics and Health Management for Intelligent Electromechanical Systems},
  year = {2025},
  pages = {159-184},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-7218-9\_8},
  url = {https://doi.org/10.1007/978-981-96-7218-9\_8},
  abstract = {Range-extended new energy vehicles are a type of automobile that combines the advantages of electric vehicles and internal combustion engines (Shi et al. in Mech Syst Signal Process 179, 2022). These vehicles typically use an electric motor as the main propulsion system (Hossain et al. in J Energy Storage 55:105752, 2022), equipped with a small internal combustion engine (usually gasoline or diesel). Under normal conditions, the vehicle primarily relies on battery power, driven by the electric motor, which offers high efficiency and low emissions. When the battery charge drops to a certain level, the internal combustion engine starts and acts as a generator to recharge the battery (Wang et al. in J Power Sources 521, 2022).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_21595_7_10,
  title = {A Reverse Design Framework for Modifiable-off-the-Shelf Embedded Systems: Application to Open-Source Autopilots},
  author = {Kamni, Soulimane and Ouhammou, Yassine and Grolleau, Emmanuel and Bertout, Antoine and Hattenberger, Gautier},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {133-146},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-21595-7\_10},
  url = {https://doi.org/10.1007/978-3-031-21595-7\_10},
  abstract = {The development of real-time embedded systems is usually preceded by an important design phase to ensure that functional and behavioural constraints are met. However, the modification of some systems, especially Unmanned Air Vehicles that need to be frequently customised, is typically done in an ad-hoc way. Indeed, the design information may not be available, which may affect the proper functioning of the system. This paper aims to propose a framework helping reverse-engineering a Modifiable Off-The-Shelf (MOTS) embedded system in order to be able to ease its modification. In other words, our objective is to point out where modifications have to happen, and allow smooth use of third-party analysis and/or architecture exploration tools to re-analyse non-functional properties (safety, performances, etc.) regarding the customisation. This framework extracts functional-chains from the source code and represents them visually as a model-based design by using model-driven engineering settings.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10515_025_00514_8,
  title = {A comparative study between android phone and TV apps},
  author = {Liu, Yonghui and Chen, Xiao and Liu, Yue and Kong, Pingfan and Bissyandé, Tegawendé F. and Klein, Jacques and Sun, Xiaoyu and Li, Li and Chen, Chunyang and Grundy, John},
  journal = {Automated Software Engineering},
  year = {2025},
  volume = {32},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-025-00514-8},
  url = {https://doi.org/10.1007/s10515-025-00514-8},
  abstract = {Smart TVs have surged in popularity, leading developers to create TV versions of mobile apps. Understanding the relationship between TV and mobile apps is key to building consistent, secure, and optimized cross-platform experiences while addressing TV-specific SDK challenges. Despite extensive research on mobile apps, TV apps have been given little attention, leaving the relationship between phone and TV apps unexplored. Our study addresses this gap by compiling an extensive collection of 3445 Android phone/TV app pairs from the Google Play Store, launching the first comparative analysis of its kind. We examined these pairs across multiple dimensions, including non-code elements, code structure, security, and privacy aspects. Our findings reveal that while these app pairs could get identified with the same package names, they deploy different artifacts with varying functionality across platforms. TV apps generally exhibit less complexity in terms of hardware-dependent features and code volume but maintain significant shared resource files and components with their phone versions. Interestingly, some categories of TV apps show similar or even severe security and privacy concerns compared to their mobile counterparts. This research aims to assist developers and researchers in understanding phone-TV app relationships, highlight domain-specific concerns necessitating TV-specific tools, and provide insights for migrating apps from mobile to TV platforms.},
  content_type = {Article},
}


@article{springer_10_1007_s11227_025_06977_6,
  title = {GBADroid: an Android malware detection method based on multi-view feature fusion},
  author = {Meng, Yi and Luktarhan, Nurbol and Yang, Xiaotong and Zhao, Guodong},
  journal = {The Journal of Supercomputing},
  year = {2025},
  volume = {81},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11227-025-06977-6},
  url = {https://doi.org/10.1007/s11227-025-06977-6},
  abstract = {With the development of mobile internet, the open Android operating system has become the most widely used mobile platform globally, leading to a surge in malware that poses serious threats to user device security. Current Android malware detection methods mainly rely on a single feature set, making it difficult to comprehensively represent the characteristics of Android applications. To address this limitation, this paper proposes an Android malware detection method called GBADroid. GBADroid comprehensively characterizes Android software by considering multi-view features. Specifically, it first matches against a list of dangerous permissions to identify potential risks and then employs an information gain algorithm and a Bidirectional Gated Recurrent Unit (BiGRU) to extract opcode features. It also constructs a function call graph (FCG) to extract graph features using Graph Sample and Aggregate (GraphSAGE) algorithm. Experimental results show that GBADroid achieves a detection accuracy of 98.73\%, demonstrating superior performance compared to existing methods.},
  content_type = {Article},
}


@article{springer_10_1007_s10515_022_00374_6,
  title = {BCGen: a comment generation method for bytecode},
  author = {Huang, Yuan and Huang, Jinbo and Chen, Xiangping and He, Kunning and Zhou, Xiaocong},
  journal = {Automated Software Engineering},
  year = {2023},
  volume = {30},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10515-022-00374-6},
  url = {https://doi.org/10.1007/s10515-022-00374-6},
  abstract = {Abstract Bytecode is a form of instruction set designed for efficient execution by a software interpreter. Unlike human-readable source code, bytecode is even harder to understand for programmers and researchers. Bytecode has been widely used in various software tasks such as malware detection and clone detection. In order to understand the meaning of the bytecode more quickly and accurately and further help programmers in more software activities, we propose a bytecode comment generation method (called BCGen) using neural language model. Specifically, to get the structured information of the bytecode, we first generate the control flow graph (CFG) of the bytecode, and serialize the CFG with bytecode semantic information. Then a transformer model combining gate recurrent unit is proposed to learn the features of bytecode to generate comments. We obtain the bytecode by building the Jar packages of the well-known open-source projects in the Maven repository and construct a bytecode dataset to train and evaluate our model. Experimental results show that the BLEU of BCGen can reach 0.26, which outperforms several baselines and proves the effectiveness and practicability of our method. It is concluded that it is possible to generate natural language comments directly from the bytecode. Meanwhile, it is important to take structured and semantic information into account in generating bytecode comments.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_42833_3_10,
  title = {Code Quality Metrics for Functional Features in Modern Object-Oriented Languages},
  author = {Zuilhof, Bart and van Hees, Rinse and Grelck, Clemens},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {358-374},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-42833-3\_10},
  url = {https://doi.org/10.1007/978-3-031-42833-3\_10},
  abstract = {The evolution of main-stream object-oriented languages such as Java and C\# has introduced new code constructs that originate from the functional programming paradigm. We hypothesise that a relationship exists between the usage of these constructs and the error-proneness of code. We define a number of measures specifically focusing on functional programming constructs in the context of object-oriented languages. Based on these measures we define a metric that relates the usage of the functional programming constructs to error-proneness of classes. We validate our metric and confirm our hypothesis using an established methodology for empirical validation of code metrics. Our results presented in this paper grant new insights into the evolution of (increasingly) multi-paradigm programming languages at the cross-roads of the functional and the object-oriented programming paradigms.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s44196_023_00400_9,
  title = {A Lightweight Model for Malicious Code Classification Based on Structural Reparameterisation and Large Convolutional Kernels},
  author = {Li, Sicong and Wang, Jian and Song, Yafei and Wang, Shuo and Wang, Yanan},
  journal = {International Journal of Computational Intelligence Systems},
  year = {2024},
  volume = {17},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s44196-023-00400-9},
  url = {https://doi.org/10.1007/s44196-023-00400-9},
  abstract = {Abstract With the advancement of adversarial techniques for malicious code, malevolent attackers have propagated numerous malicious code variants through shell coding and code obfuscation. Addressing the current issues of insufficient accuracy and efficiency in malicious code classification methods based on deep learning, this paper introduces a detection strategy for malicious code, uniting Convolutional Neural Networks (CNNs) and Transformers. This approach utilizes deep neural architecture, incorporating a novel fusion module to reparametrize the structure, which mitigates memory access costs by eliminating residual connections within the network. Simultaneously, overparametrization during linear training time and significant kernel convolution techniques are employed to enhance network precision. In the data preprocessing stage, a pixel-based image size normalization algorithm and data augmentation techniques are utilized to remedy the loss of texture information in the malicious code image scaling process and class imbalance in the dataset, thereby enhancing essential feature expression and alleviating model overfitting. Empirical evidence substantiates this method has improved accuracy and the most recent malicious code detection technologies.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_93511_5_11,
  title = {Security Analysis of Software Updates for Industrial Robots},
  author = {Chan, Chun-Fai and Chow, Kam-Pui and Tang, Tim},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2022},
  pages = {229-245},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-93511-5\_11},
  url = {https://doi.org/10.1007/978-3-030-93511-5\_11},
  abstract = {Robots are widely deployed in industrial manufacturing environments. Cyber compromises of industrial robots pose threats to products and services, to the robots as well as to human workers. Previous security studies of robots have focused on network service vulnerabilities and privileged execution. However, research has not examined robot software updates and their security features. This chapter investigates the security features of software updates for a Universal Robots UR3 cobot, one of the most commonly-used collaborative industrial robots.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11276_023_03376_8,
  title = {Research on smart-locks cybersecurity and vulnerabilities},
  author = {Caballero-Gil, Cándido and Álvarez, Rafael and Hernández-Goya, Candelaria and Molina-Gil, Jezabel},
  journal = {Wireless Networks},
  year = {2024},
  volume = {30},
  number = {6},
  pages = {5905-5917},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11276-023-03376-8},
  url = {https://doi.org/10.1007/s11276-023-03376-8},
  abstract = {Abstract Smart-locks have become increasingly popular for access to homes and businesses in many countries, because of their ease of use and adaptability. These locks offer a simple and secure alternative to traditional key-based entry, making them an attractive choice for both residential and commercial properties. Nevertheless, it is essential to acknowledge the potential security threats that come with any new technology. The security of smart-locks is particularly critical, as a breach could result in unauthorized entry. Since the smart-locks can connect, there are different ways to check if vulnerabilities can be found easily or on the contrary, if the security level is high. Two of the main ways of checking the security level of this kind of IoT device are the information that can be obtained from the Android application and the security level of the Bluetooth connection. Many vulnerabilities can be found in the Android smart lock management application. This application is very useful to perform all the configurations with such a lock, but if it is not properly implemented and secured, it can provide clues for malicious users to perform unauthorized access to the system. Another security factor is the Bluetooth connection. This ensures that only authorized users have access to the property. In this work, we have analyzed the security level of different parts of smart-locks. In particular, we have analyzed the security of the applications for the most important smart-locks on the market. This study reveals relevant information such as whether the application is obfuscated or not, the encryption algorithm for the Bluetooth connection, or relevant URLs that applications use to connect to the cloud. The security of the Bluetooth connection between the smartphone application and two selected smart-locks was also analyzed. It was demonstrated that if no encryption is used for the Bluetooth connection, the smart-lock is not secure, but if AES encryption is used, the security level is high.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_51476_0_24,
  title = {FSmell: Recognizing Inline Function in Binary Code},
  author = {Lin, Wei and Guo, Qingli and Yin, Jiawei and Zuo, Xiangyu and Wang, Rongqing and Gong, Xiaorui},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {487-506},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-51476-0\_24},
  url = {https://doi.org/10.1007/978-3-031-51476-0\_24},
  abstract = {Function recognition is one of the most critical tasks in binary analysis and reverse engineering. However, the recognition of inline functions still remains challenging. This is mainly due to two factors. Firstly, in binaries, there exist no expert patterns, e.g., prologue/epilogue instructions, for inline functions. Secondly, instruction reordering introduced by compiler optimization makes the address space of the instruction from the same inline function discontinuous. The address space of an inline function is often mingled with that of regular functions. This paper proposes FSmell, a graph theory based function recognition framework that specifically targets inline functions. FSmell introduces Instruction Topology Graph (ITG) to represent the data flow dependencies for instructions in a basic block. With the help of ITG, the problem of distinguishing inline instructions from caller instructions is transformed into the graph connectivity problem, which is solved by computing the minimum vertex separator. We have applied FSmell to analyze 78 binaries compiled by GCC and CLANG with 3 different optimization levels. Of the 205,890 inline functions in the 78 binaries, FSmell reports 76,777, with a precision of 67.5\%, and a recall of 39.2\%. With the help of FSmell, 50\% of the vulnerabilities missed by other methods are detected and located.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_70896_1_2,
  title = {Companion Apps or Backdoors? On the Security of Automotive Companion Apps},
  author = {Mallojula, Prashanthi and Li, Fengjun and Du, Xiaojiang and Luo, Bo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {24-44},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-70896-1\_2},
  url = {https://doi.org/10.1007/978-3-031-70896-1\_2},
  abstract = {Automotive companion apps are mobile apps designed to remotely connect with cars to provide features such as diagnostics, logging, navigation, and safety alerts. Specifically, onboard diagnostics (OBD) based mobile applications directly communicate with the in-vehicle network through the OBD device. This can lead to several security issues, for instance, onboard information of vehicles can be tracked or altered through a malicious or vulnerable app. We conduct a comprehensive measurement study including static, runtime, and network traffic analysis of OBD companion apps. Our analysis has been applied to 125 Android mobile applications available on the Google Play Store. We identify a set of vulnerabilities and further validate these vulnerabilities with real-world vehicles. We show that 70\% of the apps have vulnerabilities that can lead to private information leakage, property theft, and direct risk while driving. For instance, 18 apps could connect to open OBD dongles without requiring any authentication, accept arbitrary CAN commands as inputs from the (potentially malicious) user, and deliver the commands to the CAN bus without any validation. We discuss the possible countermeasures and also make responsible disclosures to app developers.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4899_7502_7_981_1,
  title = {Machine Learning for Static Malware Analysis},
  author = {Mansour, Ziad and Molloy, Christopher and Ding, Steven H. H.},
  booktitle = {Encyclopedia of Machine Learning and Data Science},
  year = {2022},
  pages = {1-4},
  publisher = {Springer US},
  doi = {10.1007/978-1-4899-7502-7\_981-1},
  url = {https://doi.org/10.1007/978-1-4899-7502-7\_981-1},
  abstract = {Malicious software (malware) is a term that describes any malicious program or code that is designed to impose harm or to steal information from systems. It includes various types such as viruses, worms, and Trojan horses. Malware imposes tremendous threats to everyone in contact with the cyberworld. Hence, malware analysis has been extensively researched as the versatility and number of malware have increased dramatically. Until recently, signature-based detection has been prevailing in detecting malware. However, it is becoming ineffective as it relies on detecting malware that was already seen in the past. To countermeasure those new types of malware, there has been a rise in engineering machine learning-based malware detection and analysis techniques. It has seen massive growth in its development thanks to its effectiveness, swiftness, safety, and depth of investigation of malware samples. Static malware analysis relies on examining the static content of an executable without execution. This can be conducted by obtaining features statically such as API calls, binary sequences, and control flow graphs (CFGs). However, this area of research is still growing since packed files and other obfuscation techniques used to evade analysis remain a challenge for pure static analysis methods.},
  content_type = {Living reference work entry},
}


@incollection{springer_10_1007_978_3_030_90022_9_7,
  title = {Horus: A Security Assessment Framework for Android Crypto Wallets},
  author = {Uddin, Md Shahab and Mannan, Mohammad and Youssef, Amr},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {120-139},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90022-9\_7},
  url = {https://doi.org/10.1007/978-3-030-90022-9\_7},
  abstract = {Crypto wallet apps help cryptocurrency users to create, store, and manage keys, sign transactions and keep track of funds. However, if these apps are not adequately protected, attackers can exploit security vulnerabilities in them to steal the private keys and gain ownership of the users’ wallets. We develop a semi-automated security assessment framework, Horus , specifically designed to analyze crypto wallet Android apps. We perform semi-automated analysis on 310 crypto wallet apps, and manually inspect the top 17 most popular wallet apps from the Google Play Store. Our analysis includes capturing runtime behavior, reverse-engineering the apps, and checking for security standards crucial for wallet apps (e.g., random number generation and private key confidentiality). We reveal several severe vulnerabilities, including, for example, storing plaintext key revealing information in 111 apps which can lead to losing wallet ownership, and storing past transaction information in 11 apps which may lead to user deanonymization.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_94910_5_20,
  title = {Program Code Protecting Mechanism Based on Obfuscation Tools},
  author = {Mukhin, Vadym and Zavgorodnii, Valerii and Kornaga, Yaroslav and Krysak, Ivan and Bazaliy, Maxim and Mukhin, Oleg},
  booktitle = {Studies in Computational Intelligence},
  year = {2022},
  pages = {407-419},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-94910-5\_20},
  url = {https://doi.org/10.1007/978-3-030-94910-5\_20},
  abstract = {This paper describes the methods for obfuscation of the server and client parts of program code. The server part is represented by two methods based on obfuscation algorithms and LLVM compilation algorithms. The first method is based on the optimal choice of software code obfuscation algorithms, and the second one on the LLVM compilation and toolkit technologies. Obfuscation of the client part of the program code is based on two models of machine learning. These models are based on periodically learned neural networks, which are in the form of tensors and they are integrated into binary applications.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10586_021_03490_2,
  title = {A federated approach to Android malware classification through Perm-Maps},
  author = {D’Angelo, Gianni and Palmieri, Francesco and Robustelli, Antonio},
  journal = {Cluster Computing},
  year = {2022},
  volume = {25},
  number = {4},
  pages = {2487-2500},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-021-03490-2},
  url = {https://doi.org/10.1007/s10586-021-03490-2},
  abstract = {Abstract In the last decades, mobile-based apps have been increasingly used in several application fields for many purposes involving a high number of human activities. Unfortunately, in addition to this, the number of cyber-attacks related to mobile platforms is increasing day-by-day. However, although advances in Artificial Intelligence science have allowed addressing many aspects of the problem, malware classification tasks are still challenging. For this reason, the following paper aims to propose new special features, called permission maps (Perm-Maps), which combine information related to the Android permissions and their corresponding severity levels. Such features have proven to be very effective in classifying different malware families through the usage of a convolutional neural network. Also, the advantages introduced by the Perm-Maps have been enhanced by a training process based on a federated logic. Experimental results show that the proposed approach achieves up to a 3\% improvement in average accuracy with respect to J48 trees and Naive Bayes classifier, and up to 16\% compared to multi-layer perceptron classifier. Furthermore, the combined use of Perm-Maps and federated logic allows dealing with unbalanced training datasets with low computational efforts.},
  content_type = {Article},
}


@article{springer_10_1186_s42400_024_00349_y,
  title = {XFP-recognizer: detecting cross-file browser fingerprinting},
  author = {Wang, Xiaoxi and Liu, Zhenxu and Zheng, Chunyang and Liu, Xinyu and Liu, Wei and Liu, Yuling and Liu, Qixu},
  journal = {Cybersecurity},
  year = {2025},
  volume = {8},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-024-00349-y},
  url = {https://doi.org/10.1186/s42400-024-00349-y},
  abstract = {Abstract In recent years, the evolving browser fingerprinting technology has posed significant challenges and constant demands on detection methods. Research related to malicious code shows that cross-file techniques, which disperse code into multiple files, can resist current detection methods. To address this challenge, we introduce cross-file tracking technology into browser fingerprinting, constructing cross-file browser fingerprinting (XFP). The dispersion of files and features in XFP effectively circumvents detection methods that primarily focus on single-file tracking. In this paper, we propose XFP-Recognizer, a Random Forest-based detection method for identifying XFP behaviors. XFP-Recognizer aggregates code files and dynamic APIs by constructing function call relationship graphs (FCRgraphs). It extracts dynamic and static features to train random forest models for detecting and classifying the aggregated files, and then backtracks based on FCRgraphs to mark original scripts. To validate our method, we implement a code-splitting algorithm and constructed a cross-file tracking dataset to address the lack of XFP in real-world scenarios. We combine this dataset with the dataset of Alexa Top-10K websites in different proportions to verify the effectiveness of XFP-Recognizer. The results show that XFP-Recognizer achieved an Accuracy of 92.25\%, a Precision of 97.01\% and an AUC of 0.9152 in recognizing browser fingerprinting, demonstrating superior performance in both single-file and cross-file tracking. XFP-Recognizer complements existing detection methods, and the constructed split dataset also serves as a foundational resource for future research.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_7747_8_19,
  title = {Project Bicep},
  author = {Rendón, David},
  booktitle = {Building Applications with Azure Resource Manager (ARM)},
  year = {2022},
  pages = {375-402},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7747-8\_19},
  url = {https://doi.org/10.1007/978-1-4842-7747-8\_19},
  abstract = {Chapter 18 reviewed how you can enable automation through GitHub actions to deploy your ARM templates hosted in your GitHub repository to Azure, and it covered the components of GitHub actions and how you can start working on your actions.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_96_6573_0_11,
  title = {Advanced Experimental Environments},
  author = {Wang, Wenxiang and Xing, Jinzhang},
  booktitle = {CPU Design and Practice},
  year = {2025},
  pages = {307-333},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-6573-0\_11},
  url = {https://doi.org/10.1007/978-981-96-6573-0\_11},
  abstract = {This chapter introduces the Chiplab framework for advanced CPU verification. It covers software/hardware co-simulation, Linux porting, and FPGA-based OS validation. Techniques like differential testing and random instruction generation are explained. Tasks focus on running Linux on FPGA and debugging complex system-level issues.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10009_024_00738_1,
  title = {Deductive verification of smart contracts with Dafny},
  author = {Cassez, Franck and Fuller, Joanne and Antón Quiles, Horacio Mijail},
  journal = {International Journal on Software Tools for Technology Transfer},
  year = {2024},
  volume = {26},
  number = {2},
  pages = {131-145},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10009-024-00738-1},
  url = {https://doi.org/10.1007/s10009-024-00738-1},
  abstract = {We present a methodology to develop verified smart contracts. We write smart contracts, their specifications and implementations in the verification-friendly language Dafny . In our methodology the ability to write specifications, implementations and to reason about correctness is a primary concern. We propose a simple, concise, yet powerful solution for reasoning about contracts that have external calls. This includes arbitrary re-entrancy, which is a major source of bugs and attacks in smart contracts. Although we do not yet have a compiler from Dafny to Ethereum Virtual Machine bytecode, the results we obtain from the Dafny code can reasonably be assumed to translate to contracts written in languages like Solidity. As a result our approach can readily be used to develop and deploy safer contracts.},
  content_type = {Article},
}


@article{springer_10_1007_s10506_022_09329_4,
  title = {Thirty years of Artificial Intelligence and Law: the first decade},
  author = {Governatori, Guido and Bench-Capon, Trevor and Verheij, Bart and Araszkiewicz, Michał and Francesconi, Enrico and Grabmair, Matthias},
  journal = {Artificial Intelligence and Law},
  year = {2022},
  volume = {30},
  number = {4},
  pages = {481-519},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10506-022-09329-4},
  url = {https://doi.org/10.1007/s10506-022-09329-4},
  abstract = {The first issue of Artificial Intelligence and Law journal was published in 1992. This paper provides commentaries on landmark papers from the first decade of that journal. The topics discussed include reasoning with cases, argumentation, normative reasoning, dialogue, representing legal knowledge and neural networks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_99_8296_7_18,
  title = {Differential Privacy Under Membership Inference Attacks},
  author = {Ha, Trung and Vo, Trang and Dang, Tran Khanh and Trang, Nguyen Thi Huyen},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {255-269},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-8296-7\_18},
  url = {https://doi.org/10.1007/978-981-99-8296-7\_18},
  abstract = {Membership inference attacks are used as an audit tool to quantify training data leaks in machine learning models. Protection can be provided by anonymizing the training data or using training functions with differential privacy. Depending on the context, such as building data collection services for central machine learning models or responding to queries from end users, data scientists can choose between local and global differential privacy parameters. Different types of differential privacy have different epsilon values that reflect different mechanisms, making it difficult for data scientists to select appropriate differential privacy parameters and avoid inaccurate conclusions. The experiments in this paper show the relative privacy-accuracy trade-off of local and global differential privacy mechanisms under a white-box membership inference attack. While membership inference only reflects the lower bound for inference risk, and differential privacy formulates the upper bound, the experiments in this study with some datasets show that the trade-off between accuracy and privacy is similar for both types of mechanisms, although there is a large difference in their upper bounds. This suggests that the upper bound is far from the practical susceptibility to membership inference. Therefore, a small epsilon value in global differential privacy and a large epsilon value in local differential privacy lead to the same risk of membership inference. In addition, the risks from membership inference attacks are not uniform across all classes, especially when the training dataset in machine learning models is skewed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_70879_4_18,
  title = {CryptoLLM: Harnessing the Power of LLMs to Detect Cryptographic API Misuse},
  author = {Baek, Heewon and Lee, Minwook and Kim, Hyoungshick},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {353-373},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-70879-4\_18},
  url = {https://doi.org/10.1007/978-3-031-70879-4\_18},
  abstract = {We propose CryptoLLM, a novel static analysis tool leveraging large language models (LLMs) to detect cryptographic API misuse vulnerabilities. Integrating optimized code slicing with fine-tuned LLMs, CryptoLLM achieves superior detection capabilities. After evaluating four models, we recommend CodeT5. CryptoLLM outperforms existing rule-based tools such as CryptoGuard, CogniCrypt, and SpotBugs on the CryptoAPI-Bench dataset (F1 score: 0.935). For unseen real-world Android apps, with a 20-minute analysis limit, CryptoLLM achieved the highest F1 score of 0.898, analyzing all apps without errors, while other tools failed to analyze a significant proportion, with CryptoGuard’s highest F1 score at 0.645. Although CryptoLLM ’s performance initially dropped to 0.749 F1 score on mutated code, retraining with augmented data improved it to 0.988, demonstrating adaptability across diverse datasets.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_19_9601_6_3,
  title = {How to Make Taint Analysis Precise},
  author = {Logozzo, Francesco and Mohamed, Ibrahim},
  booktitle = {Intelligent Systems Reference Library},
  year = {2023},
  pages = {43-55},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-9601-6\_3},
  url = {https://doi.org/10.1007/978-981-19-9601-6\_3},
  abstract = {During a lunch at the ceremony for his honorary degree from the University of Venice, Patrick Cousot asked us the following question: “ Why everyone in security is using taint analysis, if it so imprecise? ”. We answered that yes, taint analysis per se can be very imprecise, but it can be made extremely accurate when (i) it is refined to capture (the abstractions of) the execution flow and the data transformations; and (ii) it is based on the source language and not on some intermediate representation. We explained that at Meta more than \\(50\\\%\\) of the security bugs are automatically detected using refined static taint analyses based on those principles. This short note expands and details the answer we gave Patrick.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_19_8493_8_45,
  title = {Flexible Reverse Engineering of Desktop and Web Applications},
  author = {Sharma, Shilpi and Vashisth, Shubham and Dhall, Ishika},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2023},
  pages = {609-624},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-8493-8\_45},
  url = {https://doi.org/10.1007/978-981-19-8493-8\_45},
  abstract = {The day-to-day increase in the number of cyber-criminal activities raises the demand for strengthening and refining our computer security systems. Reverse engineering plays a decisive role in upholding essential security standards. The method of reverse engineering was formerly applied to hardware, but currently, it is also being applied on software applications, databases and, even in the domain of natural sciences. In cybersecurity, reverse engineering enables the finding of the breach details attempted by the attacker. This additionally helps in the detection of bugs, vulnerabilities and loopholes present in the software application and thereby solidifying the security aspects of the application. This paper discusses the various application of reverse engineering in the field of cybersecurity, appropriate tools for its implementation and practical demonstration of reverse engineering a software application.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_025_10623_3,
  title = {CSAFuzzer: Fuzzing smart contracts combining with static analysis},
  author = {Yang, Jiahui and Zhao, Xiangfu and Zhang, Hanfeng and He, Long and Wang, Shiji and Gou, Naixiang},
  journal = {Empirical Software Engineering},
  year = {2025},
  volume = {30},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10623-3},
  url = {https://doi.org/10.1007/s10664-025-10623-3},
  abstract = {Smart contracts are pivotal in blockchain technology. With enviable digital assets, they have long been targeted by hackers. Unlike traditional programs, once deployed, a contract cannot be modified. Therefore, it is particularly essential to conduct vulnerability detection before deploying smart contracts. Fuzzing is a classic technique for detecting security vulnerabilities. However, existing fuzzers are currently unable to capture vulnerabilities hidden in the deep states of smart contracts. In this paper, we propose CSAFuzzer, a fuzzing framework combined with static analysis. Our approach consists of three main steps: First, we statically extract function invocation sequences before dynamically fuzzing contracts, which explore bugs in deep contract states. Secondly, we iteratively generate high-quality test cases based on high code coverage as a metric. This helps in covering more branches within a limited time, thereby increasing the possibility of discovering potential vulnerabilities. Lastly, we design more accurate test oracles to detect smart contract vulnerabilities. We tested CSAFuzzer and other vulnerability detection tools on over 15K real-world smart contracts. Experimental results demonstrate that CSAFuzzer detects more vulnerabilities compared to other state-of-the-art tools, with an average improvement of about 10\% in detection accuracy. Additionally, CSAFuzzer exhibits an average code coverage higher by 6\% than other tools. Notably, 14\% higher than the state-of-the-art fuzzing approach.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_9875_6_9,
  title = {Tips and Tricks},
  author = {Verma, Rishabh},
  booktitle = {Visual Studio Extensibility Development},
  year = {2024},
  pages = {393-435},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-9875-6\_9},
  url = {https://doi.org/10.1007/978-1-4842-9875-6\_9},
  abstract = {In this chapter, we will discuss several practical tips that can enhance your experience with Visual Studio and aid in both developing and using its extensions. Some of these suggestions will also contribute to enhancing the professionalism of your extensions. We shall also discuss briefly the extensibility of Visual Studio Code. Finally, we will conclude this chapter and the book by showcasing a selection of the cool and valuable extensions that I personally find useful.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_64171_8_14,
  title = {PayRide: Secure Transport e-Ticketing with Untrusted Smartphone Location},
  author = {Michele, Marazzi and Jattke, Patrick and Zibung, Jason and Razavi, Kaveh},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {261-282},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-64171-8\_14},
  url = {https://doi.org/10.1007/978-3-031-64171-8\_14},
  abstract = {The smartphone location is the basis for a plethora of popular applications, such as traffic navigation, games, and geotagging. Since the user can manipulate the reported location, it is possible to compromise these applications with fake locations. These attacks generally have a limited impact, but this is changing with the increasing level of trust in the smartphone location. As a prominent example, recent transport e-ticketing applications perform financial transactions based on the assumption that the smartphone location represents that of the user. Unfortunately, this assumption leads to location-based attacks with direct financial implications. We present FreeRide , a real-world attack that allows a malicious user to ride public transports for free. Existing mitigations against FreeRide are either ineffective or impractical since they attempt to enforce the integrity of the smartphone location. Instead of enforcing location integrity, our proposed mitigation, PayRide , establishes the user’s location using the position of the public transport. We have formally verified the PayRide protocol and evaluated its boundary conditions based on a range of possible accuracies reported by the smartphone and public transport.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_16815_4_36,
  title = {POSTER: Ransomware Detection Mechanism – Current State of the Project},
  author = {Glet, Michał and Kaczyński, Kamil},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {616-620},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-16815-4\_36},
  url = {https://doi.org/10.1007/978-3-031-16815-4\_36},
  abstract = {Ransomware nowadays is one of the most critical security threats. Ransomware attacks are targeted at governments, enterprises, and casual users. Without very good backup and retention policies, it can lead to serious data damage. However, even very good data protection can’t secure data from being stolen and revealed after a successful ransomware attack. This could be also very dangerous, especially for governments and enterprises in terms e.g. of trust and confidence. We have seen many times all these kinds of problems during our professional activity. We have helped recover from many ransomware attacks. Sometimes we were able to recover almost all of the encrypted data, sometimes not even a single one. That is why we have started the project that will end with specifications and working Proof-of-Concept of the ransomware detection mechanism.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_7446_0_1,
  title = {Getting Started},
  author = {Hagos, Ted},
  booktitle = {Beginning IntelliJ IDEA},
  year = {2022},
  pages = {1-12},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7446-0\_1},
  url = {https://doi.org/10.1007/978-1-4842-7446-0\_1},
  abstract = {In this chapter, we will cover the following:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_97_5101_3_14,
  title = {Security Research for Android Remote Assistance Apps},
  author = {Wang, Liwei and Liu, Xiaofeng and Lei, Ting and Song, Wenna and Guo, Shanqing and Ren, Pengcheng},
  booktitle = {Lecture Notes in Computer Science},
  year = {2024},
  pages = {256-276},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-5101-3\_14},
  url = {https://doi.org/10.1007/978-981-97-5101-3\_14},
  abstract = {With the help of remote assistance app, we can watch the screen of a smartphone or control the smartphone remotely. In reality, smartphones often contain a vast amount of personal information. If the information is to be leaked by the remote assistance app, it may lead to serious consequences for users’ privacy. To the best of our knowledge, existing works have not conducted a thorough investigation into the security of this type of app. We present two new research objectives: understanding how such apps work and identifying security risks of the apps. We are carefully selecting remote assistance apps, from popular app markets such as Google Play, to conduct our study. As a result, we have made three important discoveries regarding these apps: (1) identification of security issues related to the leakage of user privacy data, (2) risk of exposing user device to unauthorized remote control, and (3) usage of highly sensitive non-third-party permissions, and the presence of numerous potential security issues such as Secure Socket Layer (SSL) security. Our experiments show that 11 apps had vulnerabilities in login or assistance authentication stage, while 11 apps used insecure communication protocols during the remote assistance stage. Besides, we have submitted 11 more serious vulnerabilities to both the vendor and the security platform. We have received 9 active responses, and some of our vulnerabilities were assessed as high risk. Our studies indicate that it is essential to monitor and regulate the use of these apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_45237_7_6,
  title = {Highly Automated Formal Proofs over Memory Usage of Assembly Code},
  author = {Verbeek, Freek and Bockenek, Joshua A. and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {98-117},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-45237-7\_6},
  url = {https://doi.org/10.1007/978-3-030-45237-7\_6},
  abstract = {Abstract We present a methodology for generating a characterization of the memory used by an assembly program, as well as a formal proof that the assembly is bounded to the generated memory regions. A formal proof of memory usage is required for compositional reasoning over assembly programs. Moreover, it can be used to prove low-level security properties, such as integrity of the return address of a function. Our verification method is based on interactive theorem proving, but provides automation by generating pre- and postconditions, invariants, control-flow, and assumptions on memory layout. As a case study, three binaries of the Xen hypervisor are disassembled. These binaries are the result of a complex build-chain compiling production code, and contain various complex and nested loops, large and compound data structures, and functions with over 100 basic blocks. The methodology has been successfully applied to 251 functions, covering 12,252 assembly instructions.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_022_00601_x,
  title = {Lib2Desc: automatic generation of security-centric Android app descriptions using third-party libraries},
  author = {Cevik, Beyza and Altiparmak, Nur and Aksu, Murat and Sen, Sevil},
  journal = {International Journal of Information Security},
  year = {2022},
  volume = {21},
  number = {5},
  pages = {1107-1125},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-022-00601-x},
  url = {https://doi.org/10.1007/s10207-022-00601-x},
  abstract = {Android app developers are expected to specify the use of dangerous permissions in their app descriptions. The absence of such data indicates suspicious behavior. However, this is not always caused by the malicious intent of developers; it may be due to the lack of documentation of the third-party libraries they use. To fill this gap in the literature, this study aims to enrich application descriptions with security-centric information of third-party libraries. To automatically generate application definitions, the study explores classifying libraries and extracting code summaries of library methods that use dangerous permissions and/or leak data. Both the textual information of third-party libraries and their source code are used to create these definitions. To the best of our knowledge, this is the first approach in the literature that creates app descriptions based on third-party libraries.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_74776_2_11,
  title = {Quantitative Static Timing Analysis},
  author = {Mazzucato, Denis and Campion, Marco and Urban, Caterina},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {268-299},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-74776-2\_11},
  url = {https://doi.org/10.1007/978-3-031-74776-2\_11},
  abstract = {Programming errors in software applications can often be difficult to detect, as they may appear without clear indications of failure. One such example is when certain input variables have an unexpected impact on the program’s behavior. As an indicator of the program’s runtime behavior, this work studies the impact of input variables on the number of loop iterations in a program. Such information is valuable for debugging, optimizing performance, and analyzing security vulnerabilities, such as in side-channel attacks where execution times can be exploited. To address this issue, we propose a sound static analysis based on abstract interpretation to quantify the impact of each input variable on the global number of iterations. Our approach combines a dependency analysis with a global loop bound analysis to derive an over-approximation of the impact quantity. We demonstrate our prototype tool in the S2N-Bignum library for cryptographic systems to certify the absence of timing side-channels.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_26574_8_6,
  title = {A Software Analysis Based Vulnerability Detection System For Smart Contracts},
  author = {Ye, Jiaming and Ma, Mingliang and Peng, Tianyong and Xue, Yinxing},
  booktitle = {Studies in Computational Intelligence},
  year = {2020},
  pages = {69-81},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-26574-8\_6},
  url = {https://doi.org/10.1007/978-3-030-26574-8\_6},
  abstract = {Smart contracts bring Ethereum transactions great convenience, meanwhile, they can have potentially devastating financial consequences. Among the existing tools, few can handle bytecode detection tasks. To address the lack of bytecode security guarantee, we design a software-based detection system that can perform both source code and bytecode. Finally, we conduct preliminary experiments towards building a reliable vulnerability database and concise analysis is provided.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_99461_7_6,
  title = {Translation Certification for Smart Contracts},
  author = {Krijnen, Jacco O. G. and Chakravarty, Manuel M. T. and Keller, Gabriele and Swierstra, Wouter},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {94-111},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-99461-7\_6},
  url = {https://doi.org/10.1007/978-3-030-99461-7\_6},
  abstract = {Compiler correctness is an old problem, but with the emergence of smart contracts on blockchains that problem presents itself in a new light. Smart contracts are self-contained pieces of software that control (valuable) assets in an adversarial environment; once committed to the blockchain, these smart contracts cannot be modified. Smart contracts are typically developed in a high-level contract language and compiled to low-level virtual machine code before being committed to the blockchain. For a smart contract user to trust a given piece of low-level code on the blockchain, they must convince themselves that (a) they are in possession of the matching source code and (b) that the compiler has correctly translated the source code to the given low-level code. Classic approaches to compiler correctness tackle the second point. We argue that translation certification also squarely addresses the first. We describe the proof architecture of a novel translation certification framework, implemented in Coq, for a functional smart contract language. We demonstrate that we can model the compilation pipeline as a sequence of translation relations that facilitate a modular verification methodology and are robust in the face of an evolving compiler implementation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_4408_5_7,
  title = {Virtual Assembly Network Method},
  author = {Wang, Xuewen and Xie, Jiacheng and Li, Suhua},
  booktitle = {Virtual Reality Technology in Mining Machinery},
  year = {2022},
  pages = {123-132},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-4408-5\_7},
  url = {https://doi.org/10.1007/978-981-16-4408-5\_7},
  abstract = {Sharing virtual reality resource library resources such as virtual disassembly and scene simulation through the network to provide resource sharing and technical support for coal mining machinery equipment companies, especially small and medium-sized enterprises, is an important driving force for the establishment of coal mining equipment virtual reality assembly network technology and systems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_979_8_8688_0453_3_4,
  title = {.NET Fundamentals},
  author = {Kokosa, Konrad and Nasarre, Christophe and Gosse, Kevin},
  booktitle = {Pro .NET Memory Management},
  year = {2024},
  pages = {131-206},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-0453-3\_4},
  url = {https://doi.org/10.1007/979-8-8688-0453-3\_4},
  abstract = {Although we are only in the fourth chapter, we have gone through quite a long journey about various aspects of memory management. They were discussed in general to make a more theoretical introduction to this topic. References to .NET were rare, even though this is the subject of the book. It’s time to change that balance. From this chapter to the end of the book, .NET will accompany us constantly. In this chapter, we will look at it with a slightly broader perspective, you will learn some mechanisms behind it, and we will begin to delve into the topics related to how it manages memory. We strongly encourage you to take the time to read the previous three chapters before continuing reading this one. From now on, we will also assume some basic knowledge about assembly language for x86/x64 platforms as we are going to dig deeper and deeper into .NET. If you need some knowledge refresh, read, for example, an excellent book, Modern X86 Assembly Language Programming 3rd edition , by Daniel Kusswurm (Apress, 2023).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_29504_1_5,
  title = {Software Vulnerability Detection via Multimodal Deep Learning},
  author = {Zhou, Xin and Verma, Rakesh M.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {85-103},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-29504-1\_5},
  url = {https://doi.org/10.1007/978-3-031-29504-1\_5},
  abstract = {Vulnerabilities in software are like ticking time bombs, but it is difficult to completely eliminate them. For example, buffer overflow is a quite common vulnerability that occurs when a program receives too much data that can corrupt nearby space in memory and manipulate other data for malicious actions. To detect potential vulnerabilities in source code, we consider the code as multisource data by extracting semantically meaningful sub-graphs: Abstract Syntax Tree Graph (ASTG) and Tokenized Data Flow Graph (TDFG). We combine these with the original sequence of tokens and 49 heuristic features to train and leverage a multimodal deep learning network to detect vulnerable statements. We propose a Multisource Deep Learner (MDL) with joint representations based on the pretrained attention-based Bidirectional Gated Recurrent Unit (BGRU) neural networks for vulnerability detection in source code. Our framework not only detects potential vulnerabilities but also locates and ranks the vulnerable statements according to their importance based on the Program Dependence Graph (PDG). Our results show that an MDL-based model using multiple modalities is significantly better than a single modality based model. We also present comparisons with state-of-the-art methods.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_81685_8_31,
  title = {Verified Cryptographic Code for Everybody},
  author = {Boston, Brett and Breese, Samuel and Dodds, Joey and Dodds, Mike and Huffman, Brian and Petcher, Adam and Stefanescu, Andrei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {645-668},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-81685-8\_31},
  url = {https://doi.org/10.1007/978-3-030-81685-8\_31},
  abstract = {Abstract We have completed machine-assisted proofs of two highly-optimized cryptographic primitives, AES-256-GCM and SHA-384. We have verified that the implementations of these primitives, written in a mix of C and x86 assembly, are memory safe and functionally correct, by which we mean input-output equivalent to their algorithmic specifications. Our proofs were completed using SAW, a bounded cryptographic verification tool which we have extended to handle embedded x86. The code we have verified comes from AWS LibCrypto. This code is identical to BoringSSL and very similar to OpenSSL, from which it ultimately derives. We believe we are the first to formally verify these implementations, which protect the security of nearly everybody on the internet.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_78618_2_51,
  title = {Research on Security Mechanism and Forensics of SQLite Database},
  author = {Zhang, Chengdu and Yin, Jie},
  booktitle = {Communications in Computer and Information Science},
  year = {2021},
  pages = {614-629},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-78618-2\_51},
  url = {https://doi.org/10.1007/978-3-030-78618-2\_51},
  abstract = {With the rapid development of information technology and wireless communication technology, SQLite database has been widely used in various occasions in peacetime. SQLite database, as a relatively common database in the Android operating system, usually contains a series of key information such as call records and short messages. Research on SQLite database has a certain positive effect on public security electronic evidence collection. This article hopes to study the security mechanism and cracking method of SQLite database, the encryption and decryption mechanism and operation method of open source software such as SQL Cipher, and the actual forensic operation of WeChat as an example to conduct the research of SQLite database forensic analysis.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_88418_5_7,
  title = {ARIstoteles – Dissecting Apple’s Baseband Interface},
  author = {Kröll, Tobias and Kleber, Stephan and Kargl, Frank and Hollick, Matthias and Classen, Jiska},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {133-151},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-88418-5\_7},
  url = {https://doi.org/10.1007/978-3-030-88418-5\_7},
  abstract = {Wireless chips and interfaces expose a substantial remote attack surface. As of today, most cellular baseband security research is performed on the Android ecosystem, leaving a huge gap on Apple devices. With iOS jailbreaks, last-generation wireless chips become fairly accessible for performance and security research. Yet, iPhones were never intended to be used as a research platform, and chips and interfaces are undocumented. One protocol to interface with such chips is Apple Remote Invocation (ARI), which interacts with the central phone component CommCenter and multiple user-space daemons, thereby posing a Remote Code Execution (RCE) attack surface. We are the first to reverse-engineer and fuzz-test the ARI interface on iOS . Our Ghidra scripts automatically generate a Wireshark dissector, called ARIstoteles , by parsing closed-source iOS libraries for this undocumented protocol. Moreover, we compare the quality of the dissector to fully-automated approaches based on static trace analysis. Finally, we fuzz the ARI interface based on our reverse-engineering results. The fuzzing results indicate that ARI does not only lack public security research but also has not been well-tested by Apple . By releasing ARIstoteles open-source, we also aim to facilitate similar research in the future.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_4103_9_15,
  title = {Android Malware Analysis Using Machine Learning Classifiers},
  author = {Jain, Sakshi and Khandelwal, Tarul and Jain, Yash and Gajrani, Jyoti},
  booktitle = {Algorithms for Intelligent Systems},
  year = {2022},
  pages = {171-179},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-4103-9\_15},
  url = {https://doi.org/10.1007/978-981-16-4103-9\_15},
  abstract = {Malware is a big threat to mobile users nowadays. Attackers use Android applications installed on smartphones as a medium to steal our private and sensitive information including password, credentials, location, device information, etc. There is a need for a method that can detect malicious applications at a large scale quickly. For the past several years, static and dynamic processing has been used in malware identification. With the addition of machine learning methods, it further aims at reducing human effort and speeding up the analysis time. In this paper, we use machine learning approach for the identification of malicious applications. Our work applies different machine learning techniques and compares the results on the basis of their accuracies. Androguard and Strace are used for the extraction of static and dynamic features, respectively. Our analysis mainly uses app permissions, sources, sinks, presence of crypto code, reflection code, dynamic code, native codes as static features while system calls as dynamic features. We use Logistic regression, KNN, Decision Tree, SVM, Random Forest, Naïve Bayes algorithms for the classification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_40744_4_2,
  title = {LM4HPC: Towards Effective Language Model Application in High-Performance Computing},
  author = {Chen, Le and Lin, Pei-Hung and Vanderbruggen, Tristan and Liao, Chunhua and Emani, Murali and de Supinski, Bronis},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {18-33},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-40744-4\_2},
  url = {https://doi.org/10.1007/978-3-031-40744-4\_2},
  abstract = {In recent years, language models (LMs), such as GPT-4, have been widely used in multiple domains, including natural language processing, visualization, and so on. However, applying them for analyzing and optimizing high-performance computing (HPC) software is still challenging due to the lack of HPC-specific support. In this paper, we design the LM4HPC framework to facilitate the research and development of HPC software analyses and optimizations using LMs. Tailored for supporting HPC datasets, AI models, and pipelines, our framework is built on top of a range of components from different levels of the machine learning software stack, with Hugging Face-compatible APIs. Using three representative tasks, we evaluated the prototype of our framework. The results show that LM4HPC can help users quickly evaluate a set of state-of-the-art models and generate insightful leaderboards.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_9942_2_4,
  title = {Analysis of Firmware Vulnerabilities},
  author = {Tang, Qinghao and Du, Fan},
  booktitle = {Internet of Things Security: Principles and Practice},
  year = {2021},
  pages = {121-197},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-9942-2\_4},
  url = {https://doi.org/10.1007/978-981-15-9942-2\_4},
  abstract = {This chapter will introduce typical security penetration schemes in IoT firmware. Generally, the steps of security penetration include: obtaining firmware, modifying firmware, program analysis, vulnerability mining, and vulnerability exploitation. The researcher’s experience in each step will help readers avoid obstacles, and this chapter introduces shortcuts to common IoT products.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11036_023_02136_4,
  title = {Contact Tracing App Privacy: What Data is Shared by Non-GAEN Contact Tracing Apps},
  author = {Leith, Douglas J.},
  journal = {Mobile Networks and Applications},
  year = {2023},
  volume = {28},
  number = {4},
  pages = {1460-1472},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11036-023-02136-4},
  url = {https://doi.org/10.1007/s11036-023-02136-4},
  abstract = {Abstract We describe the data transmitted to backend servers by the contact tracing apps now deployed in France (TousAntiCovid), Australia (CovidSafe), Singapore (TraceTogether), US/Florida (CombatCovid), Israel (HaMagen), India (Aarogya Setu) with the aim of evaluating the privacy of these contact tracing apps as actually deployed. To the best of our knowledge, the measurements we present are the first public data of this sort for the French, Australian, Israeli, Indian and Florida apps. We find that TousAntiCovid and CovidSafe are generally well-behaved with regard to privacy. TraceTogether and CombatCovid make extensive use of Google Firebase services which means that that there are two main parties involved in handling data transmitted from these apsp, namely Google and the health authority operating the app itself. HaMagen is well-behaved for uninfected users of the app but GPS location data associated with infected is publicly published on the HaMagen server. Aarogya Setu, with >160M users, is found to have a number of serious privacy issues, including silent upload of logged location data.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_93206_0_2,
  title = {Explore Capabilities and Effectiveness of Reverse Engineering Tools to Provide Memory Safety for Binary Programs},
  author = {Vaidya, Ruturaj and Kulkarni, Prasad A. and Jantz, Michael R.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {11-31},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-93206-0\_2},
  url = {https://doi.org/10.1007/978-3-030-93206-0\_2},
  abstract = {Any technique to ensure memory safety requires knowledge of (a) precise array bounds and (b) the data types accessed by memory load/store and pointer move instructions (called, owners ) in the program. While this information can be effectively derived by compiler-level approaches much of this information may be lost during the compilation process and become unavailable to binary-level tools. In this work we conduct the first detailed study on how accurately can this information be extracted or reconstructed by current state-of-the-art static reverse engineering (RE) platforms for binaries compiled with and without debug symbol information. Furthermore, it is also unclear how the imprecision in array bounds and instruction owner information that is obtained by the RE tools impacts the ability of techniques to detect illegal memory accesses at run-time. We study this issue by designing, building, and deploying a novel binary-level technique to assess the properties and effectiveness of the information provided by the static RE algorithms in the first stage to guide the run-time instrumentation to detect illegal memory accesses in the decoupled second stage. Our work explores the limitations and challenges for static binary analysis tools to develop accurate binary-level techniques to detect memory errors.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00607_023_01172_y,
  title = {Turna: a control flow graph reconstruction tool for RISC-V architecture},
  author = {Sahin, Veysel Harun},
  journal = {Computing},
  year = {2023},
  volume = {105},
  number = {8},
  pages = {1821-1845},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00607-023-01172-y},
  url = {https://doi.org/10.1007/s00607-023-01172-y},
  abstract = {A control flow graph (CFG) is a type of directed graph that shows the execution paths of the programs. It is a mathematical structure that is actively used in software testing. It can be constructed from the source or the executable of the program. Construction of the CFG from the executable is called CFG reconstruction. CFG reconstruction is used in many areas of computer science, like reverse engineering, security analysis, and worst-case execution time analysis. CFG reconstruction can be performed using a static, dynamic, or hybrid approach. This paper introduces a new CFG reconstruction tool named Turna that uses a hybrid approach. Turna works on programs that are compiled for RISC-V architecture. One of the main phases of CFG reconstruction is basic block detection. Therefore, together with Turna, a new rule set and an algorithm for basic block detection from RISC-V executables are also introduced. The CFG reconstruction process and the outputs of Turna are shared and discussed.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_62974_8_14,
  title = {On the Struggle Bus: A Detailed Security Analysis of the m-tickets App},
  author = {Sanz Maroto, Jorge and Liu, Haoyu and Patras, Paul},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {234-252},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-62974-8\_14},
  url = {https://doi.org/10.1007/978-3-030-62974-8\_14},
  abstract = {The growing shift from private to public transportation and the increasing use of smartphones have lead to the development of digital transport ticketing systems. Such systems allow transport operators to enhance their services and income, therefore are important assets that require secure implementation and protocols. This paper uncovers a range of vulnerabilities in the m-tickets app used by Lothian Buses, one of the leading transport operators in the United Kingdom (UK). The vulnerabilities identified enable attackers to predict, reactivate and modify tickets, all of which can have damaging consequences to the operator’s business. We further reveal poor implementation of encryption mechanisms, which can lead to information leakage, as well as how adversaries could harness the operator’s infrastructure to launch Denial of Service attacks. We propose several improvements to mitigate the weaknesses identified, in particular an alternative digital ticketing system, which can serve as a blueprint for increasing the robustness of similar apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_7792_8_1,
  title = {Developer Tools and Language Services},
  author = {Gunasinghe, Nadeeshaan and Marcus, Nipuna},
  booktitle = {Language Server Protocol and Implementation},
  year = {2022},
  pages = {1-10},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7792-8\_1},
  url = {https://doi.org/10.1007/978-1-4842-7792-8\_1},
  abstract = {Today, software development has become an area where there are higher expectations when considering the rapid development, go-to market, deployment, distribution, and similar aspects. In this book, we are going to focus on a specific technical perspective related to source code editing or, in other words, writing the software.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_979_8_8688_2105_9_11,
  title = {Security and App Hardening},
  author = {Selvaraj, Sivaraj},
  booktitle = {Advanced Flutter},
  year = {2025},
  pages = {739-785},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-2105-9\_11},
  url = {https://doi.org/10.1007/979-8-8688-2105-9\_11},
  abstract = {In the previous chapter, we explored the integration of powerful AI capabilities into Flutter apps. From setting up TensorFlow Lite and leveraging pre-trained models to building real-time image recognition systems and Natural Language Processing workflows, you gained insight into developing intelligent, responsive, and futuristic applications. These advanced ML features significantly elevate user experiences—but they also introduce new vectors for risk and exploitation.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_658_48318_0_5,
  title = {Opportunities and Challenges of Blockchain Technology for Negotiation Support Systems},
  author = {Witt, Josepha},
  booktitle = {Applications of Blockchain Technology in E-Business Value Chains},
  year = {2025},
  pages = {93-122},
  publisher = {Springer Fachmedien Wiesbaden},
  doi = {10.1007/978-3-658-48318-0\_5},
  url = {https://doi.org/10.1007/978-3-658-48318-0\_5},
  abstract = {Blockchain Technology (BCT) is the backbone of the next generation of the Internet and thus affects how electronic business (e-business) is conducted. While the usage of BCT for the initiation and transaction phases in e-business has been studied, the negotiation aspect has not been considered in a comprehensive manner. The current literature on the utilisation of BCT in electronic negotiations (e-negotiations) primarily focuses on autonomous agents and lacks research on the support of e-negotiations conducted by human negotiators using negotiation support systems (NSSs). This results in the issue that the consequences of a transition to Web3.0-based NSSs are unclear, while other areas of e-business already apply Web3.0 technologies. We address this lack of knowledge following a design-oriented approach in three steps exploring the opportunities and challenges of using BCT for e-negotiations via NSSs. Firstly, the well-established negotiation support system Negoisst is extended by BCT features resulting in the development of a Web3.0-based NSS called NegoisstBCT to demonstrate the technical feasibility of this approach. Secondly, the potential opportunities and challenges of a Blockchain-based NSS are analysed referring to its technical architecture. Thirdly, a generalised view of the application of Web3.0-based NSSs in different settings is taken, discussing future research on BCT in e-negotiations. The present research thus fosters the application of Blockchain-based NSSs in e-negotiations and of NSSs in BCT application areas.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_06365_7_12,
  title = {Understanding the Brains and Brawn of Illicit Streaming App},
  author = {Huang, Kong and Zhang, Ke and Chen, Jiongyi and Sun, Menghan and Sun, Wei and Tang, Di and Zhang, Kehuan},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2022},
  pages = {194-214},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06365-7\_12},
  url = {https://doi.org/10.1007/978-3-031-06365-7\_12},
  abstract = {Content piracy has been the largest threat to the whole TV and Media Industry around the world causing billions of dollars of economic loss. Copyright-protected contents, including movies, live soccer matches, basketball games, dramas, etc., have been taken by “content pirates” and redistributed through the Internet. In the last few years, illegal IPTV providers in the form of an illicit streaming app running on smartphones, smart TVs, and illicit streaming devices have become extremely popular and take away significant subscription revenue from legitimate pay-TV operators around the world. In this research, we study the illicit streaming ecosystem from a new perspective by looking at the illicit streaming apps: we build a semi-automated forensic tool to analyze the common codes, libraries, and network traffic of the apps that facilitate illicit streaming services. As a result, we are able to investigate their background and identify the technology providers behind them. Our research provides insights into the proliferation of illicit streaming services in app markets, as well as the overall illicit streaming ecosystem.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_19_0468_4_26,
  title = {An Online Automated Anti-anti-virus Method},
  author = {Ma, Li and Yang, Huihong and Chai, Yiming and Fan, Jiawen and Yang, Wenyin},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {351-362},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-19-0468-4\_26},
  url = {https://doi.org/10.1007/978-981-19-0468-4\_26},
  abstract = {In offensive and defensive exercises, the security detection side (red team) conducts simulated real network attacks from various entry points to the maximum extent in limited time without affecting the operation of the enterprise. And defense detection side (blue team), always represented the enterprise, conducts the defense based on the existing security measures to the best. Anti-anti-virus technology is significant and commonly used by the red team, to save the virus Trojan from being checked by antivirus software. However, most of existing anti-anti-virus methods are offline and complicated to develop on the site. This paper proposed an online automated anti-anti-virus method and introduced the design and implementation of an online anti-anti-virus tool in Python based on Flask Framework. Testing results show that the virus files processed by this tool can bypass much mainstream security software such as Velvet, 360, and Tencent Computer Control and it can achieve a low detection rate of 21.73\%.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10586_024_04397_4,
  title = {Deep learning vs. adversarial noise: a battle in malware image analysis},
  author = {Asmitha, K. A. and Puthuvath, Vinod and Rafidha Rehiman, K. A. and Ananth, S. L.},
  journal = {Cluster Computing},
  year = {2024},
  volume = {27},
  number = {7},
  pages = {9191-9220},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-024-04397-4},
  url = {https://doi.org/10.1007/s10586-024-04397-4},
  abstract = {The proliferation of malware variants has shown a steep increase, attributed to their enhanced sophistication and the utilization of the latest technologies. This constitutes a severe menace to smart gadgets and IT infrastructure. Malware visualization has emerged as an exceptionally attractive technique, primarily because it obviates the need for disassembly or code execution. In this approach, malicious executables are transformed into visual representations resembling images. This visual representation allows for the extraction of textural features using the Local Binary Pattern (LBP) technique. Subsequently, classification models are constructed using ResNet50, VGG16, and customized models tailored to the specific task. These model undergoes extensive evaluation through two benchmark datasets: the MalImg dataset (consisting of 9,342 instances of malware across 25 families) and the Malware Classification Challenge dataset (BIG2015) (with 10,868 labeled malware instances across nine families). Additionally, the model is validated on a self-made dataset, which we named Malhub, consisting of 26,452 executables comprising 20 families. Furthermore, we implemented a white-box adversarial attack using additive noise (Gaussian, Local Variable, Poisson, Salt and Pepper, Speckle). We observed an F1 score in the range of 0.992 \\(-\\) 0.993 for MalImg, 0.874 \\(-\\) 0.878 for BIG2015, and 0.014 \\(-\\) 0.992 for Malhub dataset. This proves that efforts are required to tune machine learning models to detect adversarial examples.},
  content_type = {Article},
}


@article{springer_10_1007_s11042_023_16994_3,
  title = {Video watermarking of live streamed MPEG-4 frames using ELM-Fuzzy-PSO hybrid scheme},
  author = {Mishra, Anurag and Bansal, Megha and Sharma, Arpita},
  journal = {Multimedia Tools and Applications},
  year = {2023},
  volume = {83},
  number = {14},
  pages = {41997-42035},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-023-16994-3},
  url = {https://doi.org/10.1007/s11042-023-16994-3},
  abstract = {The widespread expansion of internet and digital sharing of multimedia content has led to a huge rise in security concerns like ownership, content authentication and copyright protection of the multimedia data. This paper presents a novel scheme for watermarking of MPEG-4 videos based on the Extreme Learning Machine (ELM) for frame selection task and hybridization of Fuzzy logic with Particle Swarm Optimization technique for watermark embedding and extraction process. The ELM is applied on the host video to select the relevant frames fit for watermarking process. The embedding step is carried out in DWT-SVD domain using Fuzzy-PSO technique. The proposed scheme is tested over five standard videos having advanced video coding (AVC) format. The robustness and visual quality testing post embedding is respectively carried out by computing Normalized Cross-Correlation (NC(W,W’)) and Bit Error Rate (BER(W,W’)) along with Average Peak-Signal-to-Noise Ratio ( \\(\{PSNR\}\_\{avg\}\\) ) parameters by applying eight different attacks. Our proposed scheme is tested and compared for its outcomes with those of different other standard schemes. It is found that our results are superior to all other frontline schemes.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_25460_4_15,
  title = {Towards Reverse Engineering of Industrial Physical Processes},
  author = {Ceccato, Mariano and Driouich, Youssef and Lanotte, Ruggero and Lucchese, Marco and Merro, Massimo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {273-290},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-25460-4\_15},
  url = {https://doi.org/10.1007/978-3-031-25460-4\_15},
  abstract = {The growing connectivity of Industrial Control Systems (ICSs) in the era of Industry 4.0 has triggered a dramatic increase in the number of cyber-physical attacks , i.e., security breaches in cyberspace that adversely alter the physical processes (see, e.g., the Stuxnet worm). The main challenge attackers face in the development of cyber-physical attacks is obtaining an adequate level of process comprehension. Process comprehension is defined as “the understanding of system characteristics and components responsible for the safe delivery of service” (Green et al. 2017). While there exist a number of tools (Nmap, PLCScan, Xprobe, etc.) one can use to develop a level of process comprehension through the targeting of controllers alone, they are limited by functionality, scope, and detectability. Thus, to support the execution of realistic cyber-physical attack scenario with adequate level of physical process comprehension, we propose a black-box dynamic analysis reverse engineering tool to derive from scans of memory registers of exposed controllers an approximated model of the controlled physical process. Such an approximated model is developed by inferring statistical properties, business processes and, in particular, system invariants whose knowledge might be crucial to build up stealthy (i.e., undetectable) attacks. We test the proposed methodology on a non-trivial case study, taken from the context of industrial water treatment systems.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_22390_7_21,
  title = {Representing LLVM-IR in a Code Property Graph},
  author = {Küchler, Alexander and Banse, Christian},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {360-380},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-22390-7\_21},
  url = {https://doi.org/10.1007/978-3-031-22390-7\_21},
  abstract = {In the past years, a number of static application security testing tools have been proposed which use so-called code property graphs (CPGs), a graph model which keeps rich information about the source code while enabling its user to write language-agnostic analyses. However, they suffer from several shortcomings. They work mostly on source code and exclude the analysis of third-party dependencies if they are only available as compiled binaries. Furthermore, they are limited in their analysis to whether an individual programming language is supported or not. While often support for well-established languages such as C/C++ or Java is included, languages that are still heavily evolving, such as Rust, are not considered because of the constant changes in the language design. To overcome these limitations, we extend an open source implementation of a code property graph to support LLVM-IR which can be used as output by many compilers and binary lifters. In this paper, we discuss how we address challenges that arise when mapping concepts of an intermediate representation to a CPG. At the same time, we optimize the resulting graph to be minimal and close to the representation of equivalent source code. Our case-study on detecting cryptographic misuse indicates that existing analyses can be reused and that the analysis time is comparable to operating on source code. This makes the approach suitable for a security analysis of large-scale projects.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_52038_9_5,
  title = {Rhyme: A Data-Centric Expressive Query Language for Nested Data Structures},
  author = {Abeysinghe, Supun and Rompf, Tiark},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {64-81},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-52038-9\_5},
  url = {https://doi.org/10.1007/978-3-031-52038-9\_5},
  abstract = {We present Rhyme, an expressive language designed for high-level data manipulation, with a primary focus on querying and transforming nested structures such as JSON and tensors, while yielding nested structures as output. Rhyme draws inspiration from a diverse range of declarative languages, including Datalog, JQ, JSONiq, Einstein summation (Einsum), GraphQL, and more recent functional logic programming languages like Verse. It has a syntax that closely resembles existing object notation, is compositional, and has the ability to perform query optimization and code generation through the construction of an intermediate representation (IR). Our IR comprises loop-free and branch-free code with program structure implicitly captured via dependencies. To demonstrate Rhyme’s versatility, we implement Rhyme in JavaScript (as an embedded DSL) and illustrate its application across various domains, showcasing its ability to express common data manipulation queries, tensor expressions (à la Einsum), and more.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_99_6553_3_3,
  title = {Smartphone Malware Detection Based on Enhanced Correlation-Based Feature Selection on Permissions},
  author = {Shagun and Kumar, Deepak and Arora, Anshul},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2023},
  pages = {29-52},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-99-6553-3\_3},
  url = {https://doi.org/10.1007/978-981-99-6553-3\_3},
  abstract = {In the present day, smartphones are becoming increasingly ubiquitous, with people of all ages relying on them for daily use. The number of app downloads continues to skyrocket, with 1.6 million apps downloaded every hour in 2022, amounting to a staggering total of 142.6 billion downloads. Google Play outpaces iOS with 110.1 billion downloads compared to iOS’s 32.6 billion. Given the growing threat of malware applications for Android users, it is essential to quickly and effectively identify such apps. App permissions represent a promising approach to malware detection, particularly for Android users. Researchers are actively exploring various techniques for analyzing app permissions to enhance the accuracy of malware detection. Overall, understanding the importance of app permissions in identifying potentially harmful apps is a critical step in protecting smartphone users from malware threats. In our paper, we implemented enhanced correlation-based feature selection (ECFS) technique to predict whether an app is malicious or non-malicious which uses both feature-feature and feature-class correlation scores, i.e., ENMRS and crRelevance for computation. We then predicted the accuracy with various machine learning techniques on the basis of ECFS scores and found the highest accuracy as 92.25 \% for \\(n\_\{1\}\\) and \\(n\_\{2\}\\) values as 0.9 and 0.1, respectively. This accuracy is achieved by random forest ML technique.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_21975_7_15,
  title = {The Security of Wireless Communication Protocols Used in Mobile Health Systems},
  author = {Losiouk, Eleonora},
  booktitle = {Women in Engineering and Science},
  year = {2023},
  pages = {393-411},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-21975-7\_15},
  url = {https://doi.org/10.1007/978-3-031-21975-7\_15},
  abstract = {Today, mobile devices, such as smartphones and tablets, have reached a massive diffusion in industrialized as well as in developing countries. The variety of features provided by those devices makes them essential implements for their owners, who became accustomed to keep them always within an arm reach. Besides personal use based on the individual skills and interests of their owners, mobile devices are being increasingly adopted also as a solution for distributing commercial services. Among the providers of those services, healthcare institutions recently started adopting mobile health applications for supporting and complementing their medical interventions. Today, mobile health can be exploited not only for improving the communication between patients and physicians, but also for supporting the delivery of healthcare services and for enhancing the patient involvement in the management of his/her disease. However, even though mobile health has recently seen a diffusion, there are still some open problems that need to be addressed that concern the wireless communication protocols (e.g., Bluetooth, Bluetooth Low-Energy, NFC) enabling the interaction between a medical device and a mobile health app: the wide practice of designing a custom communication protocol inevitably leads to the introduction of vulnerabilities that can be exploited by attackers (e.g., medical device impersonation, mobile health app impersonation). It is, therefore, important to have an overview of the security of wireless communication protocols used in mobile health systems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_96305_7_58,
  title = {Smart Contract Based Next-Generation Public Key Infrastructure (PKI) Using Permissionless Blockchain},
  author = {Aguru, Aswani Devi and Erukala, Suresh Babu and Kavati, Ilaiah},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {625-635},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-96305-7\_58},
  url = {https://doi.org/10.1007/978-3-030-96305-7\_58},
  abstract = {The traditional Public Key Infrastructure (PKI) solutions are centralized and non-transparent schemes which struggle to combat the current era of distributed applications. One of the major challenging issues of the trusted third party is the issuance of rouge certificates. So the centralized certification authorities can’t be trusted as they may be compromised by disrupting the TLS method for various hosts. In this paper, we have proposed a distributed and transparent PKI system that uses smart contracts while employing a web-of-trust model and runs on the Ethereum blockchain. This work is inspired by the SCPKI system proposed by Mustafa Al-Bassam, which is a Smart Contract-based PKI and Identity System. Our scheme can detect authority certificates after they are printed. We have presented the working prototype of proposed scheme on permissionless ethereum blockchain, with detailed implementation of smart contracts.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_05371_9_6,
  title = {Information-Theoretic Approaches},
  author = {Garzon, Max and Mainali, Sambriddhi and Jana, Kalidas},
  booktitle = {Dimensionality Reduction in Data Science},
  year = {2022},
  pages = {127-144},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-05371-9\_6},
  url = {https://doi.org/10.1007/978-3-031-05371-9\_6},
  abstract = {An entirely different but extremely relevant approach to dimensionality reduction can be taken using a different criterion, namely quantifying the information content of the features involved, within themselves or in relation to others. It turns out that Shannon’s definition of information yields surprisingly interesting reductions. This chapter discusses five major variations of this idea, including comparisons using the concept of mutual information previously used in statistics and machine learning.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_99619_2_24,
  title = {Reasoning About Inter-procedural Security Requirements in IoT Applications},
  author = {Paccamiccio, Mattia and Mostarda, Leonardo},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {245-254},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-99619-2\_24},
  url = {https://doi.org/10.1007/978-3-030-99619-2\_24},
  abstract = {The importance of information security dramatically increased and will further grow due to the shape and nature of the modern computing industry. Software is published at a continuously increasing pace. The Internet of Things and security protocols are two examples of domains that pose a great security challenge, due to how diverse the needs for those software may be, and a generalisation of the capabilities regarding the toolchain necessary for testing is becoming a necessity. Oftentimes, these software are designed starting from a formal model, which can be verified with appropriate model checkers. These models, though, do not represent the actual implementation, which can deviate from the model and hence certain security properties might not be inherited from the model, or additional issues could be introduced in the implementation. In this paper we describe a proposal for a novel technique to assess software security properties from LLVM bitcode. We perform various static analyses, such as points-to analysis, call graph and control-flow graph, with the aim of deriving from them an ‘accurate enough’ formal model of the paths taken by the program, which are then going to be examined via consolidated techniques by matching them against a set of defined rules. The proposed workflow then requires further analysis with more precise methods if a rule is violated, in order to assess the actual feasibility of such path(s). This step is required as the analyses performed to derive the model to analyse are over-approximating the behaviour of the software.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_81007_8_122,
  title = {Robust Malware Detection System Against Adversarial Attacks},
  author = {Yang, Xu and Li, Qian and Li, Cong and Qi, Yong},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2022},
  pages = {1059-1067},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-81007-8\_122},
  url = {https://doi.org/10.1007/978-3-030-81007-8\_122},
  abstract = {The rapid growth of malicious software has brought huge harm to smart users, including tariff consumption, privacy theft, and remote control. To combat the evolving malware attack, deep learning-based systems have been successfully developed and offer unparalleled flexibility in the automatic malware detection. However, deep neural networks are vulnerable to adversarial attacks, and recent researches have demonstrated that adversary can leverage feature amplitude in-equilibrium to bypass malware detectors. Therefore, this paper studies a malware detection scheme AMDNN based on deep learning, it achieves the goal of defending against various adversarial attacks without obtaining detection model information and redeployment. In response to the increasing detection of massive binary applications, we propose and implement a general defense framework DQNet, which enforces the maintenance of malicious semantics through comparative regular constraints during training. Promising experimental results based on real-world datasets demonstrate that AMDNN typically provides superior classification performance and robustness to white-box attacks.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_024_00819_x,
  title = {Real-time system call-based ransomware detection},
  author = {Chew, Christopher Jun Wen and Kumar, Vimal and Patros, Panos and Malik, Robi},
  journal = {International Journal of Information Security},
  year = {2024},
  volume = {23},
  number = {3},
  pages = {1839-1858},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-024-00819-x},
  url = {https://doi.org/10.1007/s10207-024-00819-x},
  abstract = {Abstract Ransomware, particularly crypto ransomware, has emerged as the go-to malware for threat actors aiming to compromise data on Android devices as well as in general. In this paper, we present a ransomware detection technique based on behaviours observed in the system calls performed by the malware. We first describe our repeatable and extensible methodology for extracting the system call log and patterns. We then identify and present some common high-level system call behavioural patterns exhibited by crypto ransomware, and evaluate these patterns. We further describe the implementation of a streaming implementation that utilises regular expressions for modelling malware behaviours and finite state machines for detecting crypto ransomware behaviours in real time. The success of our proof of concept evaluation allows us to envision our proposed technique applied as part of a self-protection system on Android phones against malware.},
  content_type = {Article},
}


@article{springer_10_1007_s10994_022_06154_3,
  title = {Data-aware process discovery for malware detection: an empirical study},
  author = {Bernardi, Mario Luca and Cimitile, Marta and Maggi, Fabrizio Maria},
  journal = {Machine Learning},
  year = {2023},
  volume = {112},
  number = {4},
  pages = {1171-1199},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10994-022-06154-3},
  url = {https://doi.org/10.1007/s10994-022-06154-3},
  abstract = {Mobile devices are undeniably becoming essential in our lives and our daily activities. The adoption of mobile applications increases the human computing experience and the capability to access and exchange data. However, mobile devices are also the target of several malware attacks, usually obtained by evolving existing malicious code. This allows researchers and practitioners to recognize malware applications based on their similarities with existing infected applications. This study uses a multi-perspective declarative language to model the behavior of infected and trusted applications by discovering it from their system call traces. The obtained models are used to classify malware applications and evaluate if they belong to a known malware family. The approach has been evaluated on a dataset obtained by capturing system call traces from more than 160 K trusted and infected applications, the latter gathered from 27 known malware families. The empirical study shows the good performance of the approach in the identification of the infected applications and their membership to a specific malware family. In addition, the approach exhibits a high level of robustness to code transformations and major evasion techniques.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_50733_5_7,
  title = {Solutions to Data Protection Challenges in Distributed Ledger and Blockchain Technologies: A Combined Legal and Technical Approach},
  author = {Povše, Danaja Fabčič and Favenza, Alfredo and Frey, Davide and Mann, Zoltán Ádám and Palomares, Angel and Piatti, Lorenzo and Schroers, Jessica},
  booktitle = {Signals and Communication Technology},
  year = {2024},
  pages = {153-181},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-50733-5\_7},
  url = {https://doi.org/10.1007/978-3-031-50733-5\_7},
  abstract = {Blockchains and distributed ledgers have attracted increasing attention since the introduction of the Bitcoin blockchain. The ability to run decentralized computations on open networks, on Bitcoin and on the Ethereum Virtual Machine, has led practitioners and researchers to investigate the use of blockchains and distributed ledgers for a variety of applications that involve the management of personal data. However, the very characteristics of such distributed ledger technologies (DLTs)—immutability, decentralization, and automation—appear at odds with data protection legislation like the European Union’s General Data Protection Regulation (GDPR). This poses significant challenges when designing applications involving personal data. This chapter provides an analysis of possible solutions to these challenges, including results from the literature, proposals for new solutions, and a discussion of challenges that remain despite these solutions. In all cases, solutions require a combination of legal and technical contributions. For example, legal interpretations must take into account the decentralized and general-purpose nature of DLTs, while solutions like mutable ledgers and geographically aware storage may provide answers to some legal concerns.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_42941_5_47,
  title = {From High-Level Language to Abstract Machine Code: An Interactive Compiler and Emulation Tool for Teaching Structural Operational Semantics},
  author = {Steingartner, William and Sivý, Igor},
  booktitle = {Communications in Computer and Information Science},
  year = {2023},
  pages = {544-551},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-42941-5\_47},
  url = {https://doi.org/10.1007/978-3-031-42941-5\_47},
  abstract = {This paper examines the development of an abstract machine compiler specifically for the Structural Operational Semantics (SOS) framework. This compiler serves as a formal framework for programming language specification and analysis. The paper focuses on key aspects of the development process, such as translating high-level language constructs into low-level machine instructions and implementing memory models. The ultimate objective of this work is to provide valuable insights into the design and implementation of an abstract machine compiler and emulator, with potential applications in language design and verification. Additionally, the tools developed can be applied in educational settings to aid in the teaching process.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11554_023_01311_w,
  title = {RT-Droid: a novel approach for real-time android application analysis with transfer learning-based CNN models},
  author = {Tasyurek, Murat and Arslan, Recep Sinan},
  journal = {Journal of Real-Time Image Processing},
  year = {2023},
  volume = {20},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11554-023-01311-w},
  url = {https://doi.org/10.1007/s11554-023-01311-w},
  abstract = {Today, the number, type and complexity of malware is increasing rapidly. Convolution neural network (CNN) based networks continue to be used in software classification based on image. In this study, a CNN model named Real Time-Droid(RT-Droid), which has a very fast malware detection capability and works based on YOLO V5, is introduced. RT-Droid detects android malware with high accuracy and performs this process at near real-time speed. For this process, firstly the features in the android manifest file are extracted and converted to an image in RGB format similar to QR code. Thus, images become processed by CNN-based deep learning models. These images were used to train VGGNet, Faster R-CNN, YOLO V4 and V5 models with the transfer learning technique. The android malware detection performances of the obtained trained models (weights) were examined. In the tests performed with Drebin, Genome and Arslan dataset, the precision value is 98.3\%, while the F-score value is 97.0\%. In obtaining these values, only 0.019 s per application was needed for analysis. It also requires 25 times less memory space compared to a gray-scale image. Since the small images of the YOLO V5 model can detect objects with very high accuracy and in real time, it provides serious efficiency in processing time. We also compared the results with VGGNet, Faster R-CNN and YOLO V4, which are commonly used CNN models for object detection, and show that it yields results at a higher rate and at least 5.5 times faster than similarly trained networks. Our method detects hacker-generated Android malware very quickly and with high accuracy, while being robust against obfuscated apps.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_3486_5_6,
  title = {A Security Reinforcement Model for Edge Computing Facilities in 5G Power Network},
  author = {Li, Nige and Zhou, Peng and Shao, Zhipeng and Chen, Xiaoxiao},
  booktitle = {Smart Innovation, Systems and Technologies},
  year = {2022},
  pages = {51-59},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-3486-5\_6},
  url = {https://doi.org/10.1007/978-981-19-3486-5\_6},
  abstract = {5G network has attracted much attention from the vertical industry since its commercial use. Compared with previous generations of mobile communication technologies, 5G bandwidth, delay and other communication KPI indicators have been greatly improved. 5G network has three typical application scenarios of large bandwidth, low delay and wide connection. In the power grid scenario, it can meet the needs of various power grid business access. As the key technology to realize 5G, multi-access edge computing (MEC) plays an important role in high-speed and low delay wireless data transmission network and has made indelible contributions to improving end-to-end service quality. In view of today’s increasingly complex network security environment and changing attack means, security attacks against MEC systems and applications have become endless. In order to deal with large-scale and various attacks, this paper studies the micro application security reinforcement and independent application security reinforcement technology deployed in edge computing facilities in the environment of 5G power network, proposes the security reinforcement model of MEC, and strengthens the source code of edge computing facilities based on the so file confusion technology of OLLVM, so as to ensure the safe and stable operation of MEC.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_90072_4_13,
  title = {Malware Classification Based on Graph Neural Network Using Control Flow Graph},
  author = {Xia, Rongze and Cui, Baojiang},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {129-138},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90072-4\_13},
  url = {https://doi.org/10.1007/978-3-030-90072-4\_13},
  abstract = {The classification of malware families is based on the similarity within the malware family, including the similarity of program structure and content. Since the control flow graph belongs to non-Euclidean structured data, it is difficult to directly use the feature extracted from its data and structure for classifying before. However, with the proposal of graph neural network, non-Euclidean graph’s classification become possible. We propose a malware family classification system based on control flow graph and Term Frequency-Inverse Document Frequency. In this system, both the control flow graph branch structure and the instruction sequence in basic blocks are treated as input, and the graph feature representation of the malware family is generated through the graph neural network. The experimental results on the Microsoft Malware Classification Challenge dataset show that retaining the feature data of the graph structure can effectively improve the effect of family classification. And the effect can also be improved through the instruction features based on TF-IDF.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_8745_3_12,
  title = {Building},
  author = {Späth, Peter},
  booktitle = {Pro Android with Kotlin},
  year = {2022},
  pages = {397-412},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-8745-3\_12},
  url = {https://doi.org/10.1007/978-1-4842-8745-3\_12},
  abstract = {In this chapter we talk about the building process of your apps. While building an app given source files can be done using both a terminal and buttons and menu entries from inside the Android Studio IDE, this is not an introduction to Android Studio nor a reference – for these please refer to the help included or books and online resources.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_06773_0_34,
  title = {DSV: Disassembly Soundness Validation Without Assuming a Ground Truth},
  author = {An, Xiaoxin and Verbeek, Freek and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {636-655},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06773-0\_34},
  url = {https://doi.org/10.1007/978-3-031-06773-0\_34},
  abstract = {Disassembly is a crucial step in binary security, reverse engineering, and binary verification. Various studies in these fields use disassembly tools and hypothesize that the reconstructed disassembly is correct. However, disassembly is a challenging and undecidable problem. Even state-of-the-art industrial disassemblers suffer from issues ranging from incorrectly recovered instructions to incorrectly assessing which addresses belong to instructions and which to data. We thus present DSV: a systematic and automated approach to validate whether the output of a disassembler is sound with respect to the binary. No source code, debugging information, or annotations are required. We apply DSV to 102 binaries of Coreutils with eight different state-of-the-art disassemblers from academia and industry. DSV is able to find soundness issues in the output of all these disassemblers. Using DSV to validate the output of a disassembler increases trust in any research effort built on top of it.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_7319_7_11,
  title = {Advanced .NET 6},
  author = {Vermeir, Nico},
  booktitle = {Introducing .NET 6},
  year = {2022},
  pages = {297-311},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7319-7\_11},
  url = {https://doi.org/10.1007/978-1-4842-7319-7\_11},
  abstract = {A lot of the things in .NET that we use on a daily bases are often taken for granted. We reserve memory to store data, and we just assume that that memory gets released at some point. We ask the framework for a thread and we get one, but where does that thread come from? And how does async work again? Let’s go into some more detail and explore how these concepts actually work.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_7981_3_31,
  title = {Android Vault Application Behavior Analysis and Detection},
  author = {Xie, Nannan and Bai, Hongpeng and Sun, Rui and Di, Xiaoqiang},
  booktitle = {Communications in Computer and Information Science},
  year = {2020},
  pages = {428-439},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-7981-3\_31},
  url = {https://doi.org/10.1007/978-981-15-7981-3\_31},
  abstract = {With the widespread application of Android smartphones, privacy protection plays a crucial role. Android vault application provides content hiding on personal terminals to protect user privacy. However, some vault applications do not achieve real privacy protection, and its camouflage ability can be maliciously used to hide illegal information to avoid forensics. In order to solve these two issues, behavior analysis is conducted to compare three aspects of typical vaults in the third-party market. The conclusions and recommendations were given. Support Vector Machine (SVM) was used to distinguish vault from normal applications. Extensive experiments show that SVM can achieve 93.33\% classification accuracy rate.},
  content_type = {Conference paper},
}


@article{springer_10_1186_s13677_022_00349_8,
  title = {A malware detection system using a hybrid approach of multi-heads attention-based control flow traces and image visualization},
  author = {Ullah, Farhan and Srivastava, Gautam and Ullah, Shamsher},
  journal = {Journal of Cloud Computing},
  year = {2022},
  volume = {11},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s13677-022-00349-8},
  url = {https://doi.org/10.1186/s13677-022-00349-8},
  abstract = {Abstract Android is the most widely used mobile platform, making it a prime target for malicious attacks. Therefore, it is imperative to effectively circumvent these attacks. Recently, machine learning has been a promising solution for malware detection, which relies on distinguishing features. While machine learning-based malware scanners have a large number of features, adversaries can avoid detection by using feature-related expertise. Therefore, one of the main tasks of the Android security industry is to consistently propose cutting-edge features that can detect suspicious activity. This study presents a novel feature representation approach for malware detection that combines API-Call Graphs (ACGs) with byte-level image representation. First, the reverse engineering procedure is used to obtain the Java programming codes and Dalvik Executable (DEX) file from Android Package Kit (APK). Second, to depict Android apps with high-level features, we develop ACGs by mining API-Calls and API sequences from Control Flow Graph (CFG). The ACGs can act as a digital fingerprint of the actions taken by Android apps. Next, the multi-head attention-based transfer learning method is used to extract trained features vector from ACGs. Third, the DEX file is converted to a malware image, and the texture features are extracted and highlighted using a combination of FAST (Features from Accelerated Segment Test) and BRIEF (Binary Robust Independent Elementary Features). Finally, the ACGs and texture features are combined for effective malware detection and classification. The proposed method uses a customized dataset prepared from the CIC-InvesAndMal2019 dataset and outperforms state-of-the-art methods with 99.27\% accuracy.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_98668_0_19,
  title = {Relational Hoare Logic for Realistically Modelled Machine Code},
  author = {Mazzucato, Denis and Mohamed, Abdalrhman and Lee, Juneyoung and Barrett, Clark and Grundy, Jim and Harrison, John and Păsăreanu, Corina S.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2025},
  pages = {389-413},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-98668-0\_19},
  url = {https://doi.org/10.1007/978-3-031-98668-0\_19},
  abstract = {Abstract Many security- and performance-critical domains, such as cryptography, rely on low-level verification to minimize the trusted computing surface and allow code to be written directly in assembly. However, verifying assembly code against a realistic machine model is a challenging task. Furthermore, certain security properties—such as constant-time behavior—require relational reasoning that goes beyond traditional correctness by linking multiple execution traces within a single specification. Yet, relational verification has been extensively explored at a higher level of abstraction. In this work, we introduce a Hoare-style logic that provides low-level, expressive relational verification. We demonstrate our approach on the s2n-bignum library, proving both constant-time discipline and equivalence between optimized and verification-friendly routines. Formalized in HOL Light, our results confirm the real-world applicability of relational verification in large assembly codebases.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_7319_7_10,
  title = {.NET Compiler Platform},
  author = {Vermeir, Nico},
  booktitle = {Introducing .NET 6},
  year = {2022},
  pages = {275-295},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7319-7\_10},
  url = {https://doi.org/10.1007/978-1-4842-7319-7\_10},
  abstract = {A part of the strength and flexibility of .NET comes from its compiler platform. Most people have known it under its project name Roslyn. With the compiler platform, developers can analyze their code, enforce coding guidelines, and more. Besides Roslyn, Microsoft has also introduced source generators. Source generators leverage Roslyn to generate code at compile time and include that generated code into the compilation.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11390_021_1674_4,
  title = {Characterizing and Detecting Gas-Inefficient Patterns in Smart Contracts},
  author = {Kong, Que-Ping and Wang, Zi-Yan and Huang, Yuan and Chen, Xiang-Ping and Zhou, Xiao-Cong and Zheng, Zi-Bin and Huang, Gang},
  journal = {Journal of Computer Science and Technology},
  year = {2022},
  volume = {37},
  number = {1},
  pages = {67-82},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11390-021-1674-4},
  url = {https://doi.org/10.1007/s11390-021-1674-4},
  abstract = {Ethereum blockchain is a new internetware with tens of millions of smart contracts running on it. Different from general programs, smart contracts are decentralized, tamper-resistant and permanently running. Moreover, to avoid resource abuse, Ethereum charges users for deploying and invoking smart contracts according to the size of contract and the operations executed by contracts. It is necessary to optimize smart contracts to save money. However, since developers are not familiar with the operating environment of smart contracts (i.e., Ethereum virtual machine) or do not pay attention to resource consumption during development, there are many optimization opportunities for smart contracts. To fill this gap, this paper defines six gas-inefficient patterns from more than 25 000 posts and proposes an optimization approach at the source code level to let users know clearly where the contract is optimized. To evaluate the prevalence and economic benefits of gas-inefficient patterns, this paper conducts an empirical study on more than 160 000 real smart contracts. The promising experimental results demonstrate that 52.75\% of contracts contain at least one gas-inefficient pattern proposed in this paper. If these patterns are removed from the contract, at least \$0.30 can be saved per contract.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_15_5329_5_1,
  title = {A Novel Approach for Analysing and Detection of Obfuscated Malware Payloads in Android Platform Using DexMonitor},
  author = {Sengupta, Anuradha and Sivasankari, S.},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2021},
  pages = {1-9},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-5329-5\_1},
  url = {https://doi.org/10.1007/978-981-15-5329-5\_1},
  abstract = {The developers of Android applications and malware use complex obfuscation and encryption tools and techniques to hinder the mobile applications that they develop from being repackaged and analysed. These tools and techniques obfuscate and encrypt the strings and classes, API calls and control flows in the Dalvik bytecode. The obfuscated and encrypted Android applications which are obtained from sources such as Koodous, Virus Total, etc. need to be analysed using DexMonitor and the countermeasures for packed or obfuscated malware have to be found. A decision support system is then constructed and the guidelines and countermeasures for packed malware are provided.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_11806_7_2,
  title = {Implementation Strategies},
  author = {Ægidius Mogensen, Torben},
  booktitle = {Texts in Computer Science},
  year = {2022},
  pages = {23-39},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-11806-7\_2},
  url = {https://doi.org/10.1007/978-3-031-11806-7\_2},
  abstract = {The very first automatic computing machines, such as Babbage’s difference engine and early electronic computers, were specialised to one particular task such as calculating polynomials or multiplying matrices. Early programmable computers were programmed by connecting wires, so there was no real concept of a program.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_16_2164_2_9,
  title = {Recognizing Child Unsafe Apps Through User Reviews on the Google Play Store},
  author = {Dalvi, Ashwini and Siddavatam, Irfan and Thakkar, Viraj and Vedpathak, Aditya and Patel, Abhishek},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {111-120},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-2164-2\_9},
  url = {https://doi.org/10.1007/978-981-16-2164-2\_9},
  abstract = {Google Play Store serves as a platform to host, download, and review android applications. Many researchers have explored the user review section and worked on approaches and solutions that would prove a more effective pipeline to enable developer feedback on application issues and praised features proving the section’s abundance of information. This work uses this same data to attempt a novel use case of determining child unsafe apps on Google Play Store. User reviews are collected using a crawler and categorized for selected keywords relating to child, media, and India. Since Google Play Store does not provide a definitive number of downloads, this work attempts to mitigate this challenge by instead calculating the user density for an application. The user density helps establish the engagement users have with an application and is calculated by the difference in the timestamps of the most and least recent reviews divided by the sum of total reviews and its upvotes for an application. 60,620 reviews from 1,600 applications were extracted to validate the proposed concept. This concept has proved effective in recognizing applications that present child unsafe content while also offering a novel concept of calculating user density.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_29497_6_11,
  title = {Whiteboxgrind – Automated Analysis of Whitebox Cryptography},
  author = {Holl, Tobias and Bogad, Katharina and Gruber, Michael},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {221-240},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-29497-6\_11},
  url = {https://doi.org/10.1007/978-3-031-29497-6\_11},
  abstract = {Digital intellectual property is often protected by encrypting the data up to the point of use. Whitebox cryptography is an attempt to provide users with the ability to decrypt that data without actually revealing the key by embedding the key inside a cryptographic implementation. In this work, we design and implement Whiteboxgrind , a fast, fully automated toolchain that obtains execution traces from whitebox implementations and applies DCA to recover the hidden embedded keys. To evaluate Whiteboxgrind , we analysed whiteboxes of the CHES WhibOx 2019 competition, and found Whiteboxgrind to provide a significant performance improvement over the state-of-the-art tooling, enabling attacks that were previously infeasible due to memory constraints. Furthermore, we provide Whiteboxgrind ’s source code.},
  content_type = {Conference paper},
}


@article{springer_10_1631_fitee_2400088,
  title = {A survey of binary code representation technology},
  author = {Wang, Taiyan and Xie, Qingsong and Yu, Lu and Pan, Zulie and Zhang, Min},
  journal = {Frontiers of Information Technology \& Electronic Engineering},
  year = {2025},
  volume = {26},
  number = {5},
  pages = {671-694},
  publisher = {Zhejiang University Press},
  doi = {10.1631/fitee.2400088},
  url = {https://doi.org/10.1631/fitee.2400088},
  abstract = {Binary analysis, as an important foundational technology, provides support for numerous applications in the fields of software engineering and security research. With the continuous expansion of software scale and the complex evolution of software architecture, binary analysis technology is facing new challenges. To break through existing bottlenecks, researchers have applied artificial intelligence (AI) technology to the understanding and analysis of binary code. The core lies in characterizing binary code, i.e., how to use intelligent methods to generate representation vectors containing semantic information for binary code, and apply them to multiple downstream tasks of binary analysis. In this paper, we provide a comprehensive survey of recent advances in binary code representation technology, and introduce the workflow of existing research in two parts, i.e., binary code feature selection methods and binary code feature embedding methods. The feature selection section includes mainly two parts: definition and classification of features, and feature construction. First, the abstract definition and classification of features are systematically explained, and second, the process of constructing specific representations of features is introduced in detail. In the feature embedding section, based on the different intelligent semantic understanding models used, the embedding methods are classified into four categories based on the usage of text-embedding models and graph-embedding models. Finally, we summarize the overall development of existing research and provide prospects for some potential research directions related to binary code representation technology.},
  content_type = {Article},
}


@article{springer_10_1007_s10462_023_10448_w,
  title = {Neurosymbolic AI: the 3rd wave},
  author = {Garcez, Artur d’Avila and Lamb, Luís C.},
  journal = {Artificial Intelligence Review},
  year = {2023},
  volume = {56},
  number = {11},
  pages = {12387-12406},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10462-023-10448-w},
  url = {https://doi.org/10.1007/s10462-023-10448-w},
  abstract = {Current advances in Artificial Intelligence (AI) and Machine Learning have achieved unprecedented impact across research communities and industry. Nevertheless, concerns around trust, safety, interpretability and accountability of AI were raised by influential thinkers. Many identified the need for well-founded knowledge representation and reasoning to be integrated with deep learning and for sound explainability. Neurosymbolic computing has been an active area of research for many years seeking to bring together robust learning in neural networks with reasoning and explainability by offering symbolic representations for neural models. In this paper, we relate recent and early research in neurosymbolic AI with the objective of identifying the most important ingredients of neurosymbolic AI systems. We focus on research that integrates in a principled way neural network-based learning with symbolic knowledge representation and logical reasoning. Finally, this review identifies promising directions and challenges for the next decade of AI research from the perspective of neurosymbolic computing, commonsense reasoning and causal explanation.},
  content_type = {Article},
}


@article{springer_10_1007_s12008_023_01578_0,
  title = {Machine learning aided malware detection for secure and smart manufacturing: a comprehensive analysis of the state of the art},
  author = {Rani, Sangeeta and Tripathi, Khushboo and Kumar, Ajay},
  journal = {International Journal on Interactive Design and Manufacturing (IJIDeM)},
  year = {2023},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12008-023-01578-0},
  url = {https://doi.org/10.1007/s12008-023-01578-0},
  abstract = {In the last decade, the number of computer malware has grown rapidly. Currently, cybercriminals typically use malicious software (malware) as a means of attacking industrial systems. By email, malicious websites, and by downloading and installing software, the internet is the main medium by which malware attacks are conducted on computers. As a result of open standards and the opening of the internet, typical attack techniques can be seen in smart factories. Because of the high level of specialization of industrial cyberattacks, traditional intrusion detection systems that rely on a signature database are also failing. Anomaly detection is therefore becoming increasingly important to the research community. When smart manufacturing or cyber–physical systems involve the use of machine learning techniques to implement this paradigm, great results are obtained. A virus, trojan horse, worm, rootkit, adware, or ransomware are examples of malicious software. Analysis of static, dynamic, hybrid, or deep learning samples reveals whether a sample is malicious or benign. The unique traits of malicious and benign files can then be identified. ML-based malware detection techniques are reviewed in this paper to provide a systematic overview. In this article, 117 carefully selected articles related to malware detection are critically evaluated. It was determined which features are most capable of discriminating malware by examining feature selection methods. The most effective malware detection techniques rely on the extraction of malware features. In this paper an examination of recent trends in machine learning is presented along with an analysis of the challenges and limitations of traditional machine learning. The survey can be used by researchers to delve deeper into malware detection and scientific developments in industries.},
  content_type = {Article},
}


@article{springer_10_1007_s10586_022_03688_y,
  title = {On the use of generic types for smart contracts},
  author = {Spoto, Fausto and Migliorini, Sara and Gambini, Mauro and Benini, Andrea},
  journal = {Cluster Computing},
  year = {2023},
  volume = {26},
  number = {4},
  pages = {2099-2113},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-022-03688-y},
  url = {https://doi.org/10.1007/s10586-022-03688-y},
  abstract = {Abstract This paper shows that generic types ( generics ) are useful for writing more abstract and more general smart contracts, but this comes with some security risks, reporting a concrete security issue found while using generics for writing smart contracts that implement shared entities for the Hotmoka blockchain. That issue can be used to steal the remuneration of validator nodes. This paper proposes a patch based on appropriate code rewriting. Namely, smart contracts are pieces of code that are deployed and executed in the context of a blockchain infrastructure in order to automatically enforce some effects when particular events occur. The writing of smart contracts is a complex and critical activity that can benefit from the use of high-level features of programming languages, and generics is one of them. In many programming languages, such as Java, generics are implemented by erasure , i.e. replaced by their upper bound type during compilation into bytecode. This is safe at source level, since the compiler takes care of checking that types are correct, before erasure. However, the erased types of the generated bytecode are consequently weaker. In a permissionless blockchain, where every user can call the bytecode of smart contracts installed by other users, these weaker types pose a risk of attack.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_21750_0_6,
  title = {Cyclomatic Complexity Analysis for Smart Contract Using Control Flow Graph},
  author = {Agarwal, Shantanu and Godboley, Sangharatna and Krishna, P. Radha},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {65-78},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-21750-0\_6},
  url = {https://doi.org/10.1007/978-3-031-21750-0\_6},
  abstract = {Smart Contracts, which are embedded in block-chains, allow for the automatic fulfillment of contractual obligations without the need for a reliable third party. Due to this, companies can save administration and service costs, and improve their processes which in turn improve efficiency and reduce risks. EthIR framework is one of the most precise instruments available, with a high success rate. Smart-Contracts need to ensure that they have a minimal number of flaws and vulnerabilities is critical. In this work, we present a Control Flow Graph to apply Cyclomatic Complexity for analyzing smart contracts. Our approach uses EtiIR framework, for creating a CFG from an Etherium Virtual Machine smart contract.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_979_8_8688_0345_1_11,
  title = {Real SOC Analyst Stories},
  author = {Wall, Tyler and Rodrick, Jarrett},
  booktitle = {Jump-start Your SOC Analyst Career},
  year = {2024},
  pages = {221-256},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-0345-1\_11},
  url = {https://doi.org/10.1007/979-8-8688-0345-1\_11},
  abstract = {In this chapter, we will hear a few stories from people on the front lines: their backgrounds, how they landed their first role, and what advice they have for you. These are people from various backgrounds who know they have something important to share. They have blazed this trail and created a path for you to follow. So, enjoy their tale as they take you along on their journey.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_33_6930_6_6,
  title = {Cybersecurity Protection and Assurance},
  author = {Chinese Academy of Cyberspace Studies},
  booktitle = {China Internet Development Report 2019},
  year = {2021},
  pages = {127-150},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-33-6930-6\_6},
  url = {https://doi.org/10.1007/978-981-33-6930-6\_6},
  abstract = {There will be no national security without cybersecurity. Cybersecurity is essential for national security and social stability as well as the vital interests of the people. It is increasingly becoming a major issue of overall importance.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_024_10470_8,
  title = {VioDroid-Finder: automated evaluation of compliance and consistency for Android apps},
  author = {Chen, Junren and Huang, Cheng and Han, Jiaxuan},
  journal = {Empirical Software Engineering},
  year = {2024},
  volume = {29},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-024-10470-8},
  url = {https://doi.org/10.1007/s10664-024-10470-8},
  abstract = {Rapid growth in the variety and quantity of apps makes it difficult for users to protect their privacy, although existing regulations have been introduced and the Android ecosystem is constantly being improved, there are still violations as privacy policies may not fully comply with regulations, and app behavior may not be fully consistent with privacy policies. To solve such issues, this paper proposes an automated method called VioDroid-Finder aiming at the evaluation of compliance and consistency for Android apps. We first study existing common regulations and conclude the privacy policy content into 7 aspects (i.e., privacy categories), for privacy policies, different compliance rules are required to be complied with in each privacy category. Secondly, we present a policy structure parser model based on the structure extraction/rebuilding method (which can convert the unstructured text to an XML tree) and subtitle similarity calculation algorithm. Thirdly, we propose a violation analyzer using the BERT model to classify each sentence in the privacy policy, we collect existing issues and combine them with manual observations to define 6 types of violations and detect them based on classification results. Then, we propose an inconsistency analyzer that converts permissions, APIs, and GUI into a set of personal information based on static analysis, inconsistencies are detected by comparing that set with personal information declared in the privacy policy. Finally, we evaluate 600 Chinese apps using the proposed method, from which we detect many violations and inconsistencies reflecting the current widespread privacy violation issues.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_19_5209_8_19,
  title = {A Survey of Detection Methods for Software Use-After-Free Vulnerability},
  author = {Lu, Faming and Tang, Mengfan and Bao, Yunxia and Wang, Xiaoyu},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {272-297},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-5209-8\_19},
  url = {https://doi.org/10.1007/978-981-19-5209-8\_19},
  abstract = {Due to the absence of validity detection on pointers and automatic memory rubbish reclaim mechanisms in programming languages such as the C/C++ language, software developed in these languages may have many memory safety vulnerabilities, such as Use-After-Free (UAF) vulnerability. An UAF vulnerability occurs when a memory object has been freed, but it can still be accessed through a dangling pointer that points to the object before it is reclaimed. Since UAF vulnerabilities are frequently exploited by malware which may lead to memory data leakage or corruption, much research work has been carried out to detect UAF vulnerabilities. This paper investigates existing UAF detection methods. After comparing and categorizing these methods, an outlook on the future development of UAF detection methods is provided. This has an important reference value for subsequent research on UAF detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_3071_2_28,
  title = {“Emerging Trends in Computational Intelligence to Solve Real-World Problems” Android Malware Detection Using Machine Learning},
  author = {Singh, Dhananjay and Karpa, Shubham and Chawla, Indu},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2022},
  pages = {329-341},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-3071-2\_28},
  url = {https://doi.org/10.1007/978-981-16-3071-2\_28},
  abstract = {Being the most used operating system makes Android vulnerable to various kinds of malware attacks. This is due to the fact that most applications require several permissions which are necessary for installation or smooth operability. Some Android applications are not certified by legitimate organisations and may contain malware which can steal private user information. This has increased the interest of applying machine learning algorithms for Android malware detection. In this research paper, we work with a dataset comprising of 215 permissions and API calls of 3799 Android applications. We evaluate machine learning classification algorithms like random forest, decision tree, Naive Bayes and support vector machine for detecting malicious Android applications based on permissions and API calls model. The results show that RF performs the best giving an accuracy of 98.15\% using k-fold cross-validation for k = 5 and a mean accuracy of 97.79\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_89912_7_7,
  title = {Double-Extortion Ransomware: A Technical Analysis of Maze Ransomware},
  author = {Kerns, Quintin and Payne, Bryson and Abegaz, Tamirat},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2022},
  pages = {82-94},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-89912-7\_7},
  url = {https://doi.org/10.1007/978-3-030-89912-7\_7},
  abstract = {In cybersecurity, reverse engineering attempts to take malware apart to learn how it works in hopes of detecting and reversing the malware’s effects. This includes decrypting files when dealing with ransomware and learning how hackers write these programs in hopes of preventing future attacks. Ransomware takes all or part of the files in a device and encrypts them, demanding a ransom payment to restore access to the files. In this project, the techniques, tactics, and procedures of Maze ransomware were examined. Maze is a new type of double-extortion ransomware that is intended to 1) infect a target system, 2) steal sensitive files from the system, 3) encrypt files on the system and then demand a ransom to recover the files, and, finally 4) make a second ransom attempt by threatening to leak the sensitive files. This double-extortion characteristic of Maze and related ransomware means that if the ransom is not paid, the files from a compromised system may be released on the Internet by the malware authors. The purpose of this project is to understand the processes and tools used in malware reverse engineering of ransomware malware for future detection and prevention.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11042_022_14236_6,
  title = {EfficientNet deep learning meta-classifier approach for image-based android malware detection},
  author = {Ravi, Vinayakumar and Chaganti, Rajasekhar},
  journal = {Multimedia Tools and Applications},
  year = {2023},
  volume = {82},
  number = {16},
  pages = {24891-24917},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-022-14236-6},
  url = {https://doi.org/10.1007/s11042-022-14236-6},
  abstract = {A survey of literature shows that transforming the application files into images and employing deep learning-based models for image classification has been considered as one of the significant directions for malware detection and classification. Mainly, convolutional neural networks (CNN)-based models are successfully employed for Android malware detection and classification. This is mainly due to the reason that this type of malware detection and classification approach is platform independent and has the capability to detect metamorphic and polymorphic malware. The Image-based Android malware detection is resilient to both unpacked and packed malware. Following, this work employs various 26 CNN-based pretrained models and the detailed investigation and analysis of experiments are shown on the Image-based Android malware dataset. Each of these models have the capability to extract its own optimal features and these features are distinct to each other. The penultimate layer features of best performed CNN-based pretrained models are extracted and dimensionality of the features were reduced using kernel principal component analysis (KPCA). The reduced features were fused together and passed into a meta-classifier or stacked classifier for classification. This classifier has two levels; in the first level support vector machine (SVM) and random forest (RForest) machine learning classifier were included for prediction and logistic regression in the second level for classification. The four combinations of fused models are DenseNet, ResNet, InceptionResNet, and EfficientNet. EfficientNet-based fused models showed better performances compared to other fused models and non-fused CNN-based pretrained models. Moreover, the EfficientNet-based fused models outperformed the existing approaches for Android malware detection. All the model performances were shown on two different testing datasets and the proposed model has shown the similar performances on both the testing datasets with attaining better performances during training and testing. This indicates that the proposed model is more generalizable, robust, and it can be used as tool that can be deployed in any application play store.},
  content_type = {Article},
}


@article{springer_10_1007_s10207_024_00822_2,
  title = {A comprehensive review on permissions-based Android malware detection},
  author = {Sharma, Yash and Arora, Anshul},
  journal = {International Journal of Information Security},
  year = {2024},
  volume = {23},
  number = {3},
  pages = {1877-1912},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-024-00822-2},
  url = {https://doi.org/10.1007/s10207-024-00822-2},
  abstract = {The first Android-ready “G1” phone debuted in late October 2008. Since then, the growth of Android malware has been explosive, analogous to the rise in the popularity of Android. The major positive aspect of Android is its open-source nature, which empowers app developers to expand their work. However, authors with malicious intentions pose grave threats to users. In the presence of such threats, Android malware detection is the need of an hour. Consequently, researchers have proposed various techniques involving static, dynamic, and hybrid analysis to address such threats to numerous features in the last decade. However, the feature that most researchers have extensively used to perform malware analysis and detection in Android security is Android permission. Hence, to provide a clarified overview of the latest and past work done in Android malware analysis and detection, we perform a comprehensive literature review using permissions as a central feature or in combination with other components by collecting and analyzing 205 studies from 2009 to 2023. We extracted information such as the choice opted by researchers between analysis or detection, techniques used to select or rank the permissions feature set, features used along with permissions, detection models employed, malware datasets used by researchers, and limitations and challenges in the field of Android malware detection to propose some future research directions. In addition, on the basis of the information extracted, we answer the six research questions designed considering the above factors.},
  content_type = {Article},
}


@article{springer_10_1007_s10207_023_00699_7,
  title = {AIHGAT: A novel method of malware detection and homology analysis using assembly instruction heterogeneous graph},
  author = {Wang, Runzheng and Gao, Jian and Huang, Shuhua},
  journal = {International Journal of Information Security},
  year = {2023},
  volume = {22},
  number = {5},
  pages = {1423-1443},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00699-7},
  url = {https://doi.org/10.1007/s10207-023-00699-7},
  abstract = {At present, the trend of familiarization of malicious code is becoming more and more obvious, and the research on the homology of malware (the classification of malicious code family) is of great significance for maintaining network security. In order to better express the overall characteristics of malicious code and improve the effect of detection and homology analysis, this paper proposes a method for detection and homology analysis of malware based on heterogeneous graphs of assembly instructions (AIHGAT). We take the assembly instructions of malicious families as the research object and analyze the importance and correlation of assembly instructions of different malicious families. The malware detection and homology analysis are carried out in three aspects: feature extraction, feature preprocessing, and model construction. In the feature extraction of malicious code, in order to alleviate the problem that it is difficult to extract static features of malicious samples that contain countermeasures such as packing and obfuscation, we obtain binary files from dynamic memory through sandbox and then, analyze its assembly instruction set. In feature preprocessing, we divide the assembly instructions into N-tuples and construct a heterogeneous graph based on assembly instructions according to the internal correlation of the gene sequence composed of the assembly N-grams features. Finally, in terms of model construction, we analyze the homology determination effect of the traditional graph neural network and construct the Graph Attention Network based on residual connection named ResGAT to analyze the homology of malicious code. The experimental results show that the ResGAT can gather the core characteristics of malicious families and enhance the ability to recognize malicious family variants. Our model has an accuracy rate of 98.83\%, which is better than traditional machine learning detection methods, and can effectively determine the homology of malicious code families.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_06791_4_50,
  title = {A Binary Code Vulnerability Mining Method Based on Generative Adversarial Networks},
  author = {Lai, Ji and Li, Shuo and Yao, Qigui},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {639-650},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06791-4\_50},
  url = {https://doi.org/10.1007/978-3-031-06791-4\_50},
  abstract = {Generative adversarial networks (GAN) is one of the most promising methods of unsupervised learning in complex distribution in recent years. Gan is widely used to generate data sets for data enhancement. However, the existing binary vulnerability mining methods can be divided into three ways: static analysis, dynamic analysis and dynamic static analysis. The research on the method of fundamentally expanding the data set to achieve vulnerability mining also has strong application value. Therefore, aiming at the problem of too few binary code vulnerability data sets, this paper proposes a binary code vulnerability mining model based on generation countermeasure network. In particular, the proposed system also combines automatic code generation technology, fuzzy testing and symbol execution technology to further optimize and train the generator and discriminator in the generation countermeasure network model to generate high-quality data sets. The experimental results show that, The binary code vulnerability mining model based on generative countermeasure network proposed in this paper can effectively solve the problem of too few data sets.},
  content_type = {Conference paper},
}


@article{springer_10_1365_s43439_022_00064_9,
  title = {Vulnerability management as compliance requirement in product security regulation—a game changer for producers’ liability and consequential improvement of the level of security in the Internet of Things?},
  author = {Dickmann, Roman},
  journal = {International Cybersecurity Law Review},
  year = {2023},
  volume = {4},
  number = {1},
  pages = {21-37},
  publisher = {Springer Fachmedien Wiesbaden GmbH},
  doi = {10.1365/s43439-022-00064-9},
  url = {https://doi.org/10.1365/s43439-022-00064-9},
  abstract = {The article outlines the European Union (EU) regulation of information technology (IT) security in Internet of Things products from a consumer and end user perspective. It starts with civil law and the necessity to address security requirements and specifications in individual contractual terms. Data and consumer protection laws have not helped much, mainly because of missing definitions and levels of applicable security. Two new EU directives reforming the law of obligations may improve the situation for consumers since security is now a named quality requirement, especially for the sale of (digital) goods. Also introduced is the provision of security updates as a contractual duty. But both rule sets address only the traders, not the producers. This is different with the activation of clauses in the radio equipment directive, which sets IT security measures as requirements to be compliant for CE labeling. An important element is the introduction of a vulnerability management system. Details can be found in the draft of technical standard ETSI/EN 303645. The work concludes with a look at the EU’s efforts regarding certification schemes and the interaction of all regulation elements, with more liability for insecure products plus the hope for effectiveness.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_06365_7_6,
  title = {Accessing Secure Data on Android Through Application Analysis},
  author = {Buurke, Richard and Le-Khac, Nhien-An},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2022},
  pages = {93-108},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06365-7\_6},
  url = {https://doi.org/10.1007/978-3-031-06365-7\_6},
  abstract = {Acquisition of non-volatile or volatile memory is traditionally the first step in the forensic process. This approach has been widely used in mobile device investigations. However, with the advance of encryption techniques applied by default in mobile operating systems, data access is more restrictive. Investigators normally do not have administrative control over the device, which requires them to employ various techniques to acquire system data. On the other hand, application analysis is widely used in malware investigations to understand how malicious software operates without having access to the original source code. Hence, in this paper, we propose a new approach to access secure data on Android devices, based on techniques used in the field of malware analysis. Information gained through our proposed process can be used to identify implementation flaws and acquire/decode stored data. To evaluate the applicability of our approach, we analysed three applications that stored encrypted user notes. In two of the applications we identified implementation flaws that enabled acquisition of data without requiring elevated privileges.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s41019_022_00189_1,
  title = {A Risk Estimation Mechanism for Android Apps based on Hybrid Analysis},
  author = {Son, Ha Xuan and Carminati, Barbara and Ferrari, Elena},
  journal = {Data Science and Engineering},
  year = {2022},
  volume = {7},
  number = {3},
  pages = {242-252},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s41019-022-00189-1},
  url = {https://doi.org/10.1007/s41019-022-00189-1},
  abstract = {Abstract Mobile apps represent essential tools in our daily routines, supporting us in almost every task. However, this assistance might imply a high cost in terms of privacy. Indeed, mobile apps gather a massive amount of data about individuals (e.g., users’ profiles and habits) and their devices (e.g., locations), where not all are strictly needed for app execution. According to privacy laws, apps’ providers must inform end-users on adopted data usage practices (e.g., which data are collected and for which purpose). Unfortunately, understanding these practices is a complex task for average end-users. The result is that they install apps without understanding their privacy implications. To support users in making more privacy-aware decisions on app usage, we propose a risk estimation approach based on an analysis of the app’s code. This analysis adopts a hybrid strategy, exploiting static and dynamic code analyses. Static analysis aims at discovering which personal data an app is collecting to determine whether the target app is asking more than required. This gives the first estimation of the app’s risk level. In addition, we also perform a dynamic analysis of the target app’s code. This further analysis helps determining whether the collected personal data is consumed locally on the mobile device or sent out to external services. If this happens, the risk level has to be increased, as personal data are more exposed. To prove the proposal’s effectiveness, we run several experiments involving different groups of participants. The obtained accuracy results are promising and outperform those obtained with static analysis only.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_30823_9_23,
  title = {Inferring Needless Write Memory Accesses on Ethereum Bytecode},
  author = {Albert, Elvira and Correas, Jesús and Gordillo, Pablo and Román-Díez, Guillermo and Rubio, Albert},
  booktitle = {Lecture Notes in Computer Science},
  year = {2023},
  pages = {448-466},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-30823-9\_23},
  url = {https://doi.org/10.1007/978-3-031-30823-9\_23},
  abstract = {Abstract Efficiency is a fundamental property of any type of program, but it is even more so in the context of the programs executing on the blockchain (known as smart contracts ). This is because optimizing smart contracts has direct consequences on reducing the costs of deploying and executing the contracts, as there are fees to pay related to their bytes-size and to their resource consumption (called gas ). Optimizing memory usage is considered a challenging problem that, among other things, requires a precise inference of the memory locations being accessed. This is also the case for the Ethereum Virtual Machine (EVM) bytecode generated by the most-widely used compiler, , whose rather unconventional and low-level memory usage challenges automated reasoning. This paper presents a static analysis, developed at the level of the EVM bytecode generated by , that infers write memory accesses that are needless and thus can be safely removed. The application of our implementation on more than 19,000 real smart contracts has detected about 6,200 needless write accesses in less than 4 hours. Interestingly, many of these writes were involved in memory usage patterns generated by that can be greatly optimized by removing entire blocks of bytecodes. To the best of our knowledge, existing optimization tools cannot infer such needless write accesses, and hence cannot detect these inefficiencies that affect both the deployment and the execution costs of Ethereum smart contracts.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_023_00712_z,
  title = {Malware classification approaches utilizing binary and text encoding of permissions},
  author = {Zyout, Mo’ath and Shatnawi, Raed and Najadat, Hassan},
  journal = {International Journal of Information Security},
  year = {2023},
  volume = {22},
  number = {6},
  pages = {1687-1712},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00712-z},
  url = {https://doi.org/10.1007/s10207-023-00712-z},
  abstract = {With the advancement of smartphone technology, the development of mobile applications is rapidly growing. These apps are designed to help mobile users with a variety of everyday tasks, such as e-commerce and online services. Because these applications are widely used, they are susceptible to malicious user attacks. As a result, new challenges have emerged, such as the inability to differentiate between benign and malicious malware applications. This paper proposes two methods for classifying mobile applications into either benign or malicious: 1D convolution (Conv1d) and long short-term memory (LSTM). The suggested approaches use two encoding techniques, namely binary and text encoding, which were applied to the Android permissions of each application. In addition, the support vector machine and K-nearest-neighbor classifiers are reported as well. The two primary approaches were tested on the well-known CICMalDroid2020 dataset. Conv1d and LSTM with text encoding performed the best in terms of precision and accuracy (98.16\%, 97.72\%, and 96.63\%, 96.69\%, respectively). When compared with the Mal-Prem dataset, the Conv1d on binary classification beat the LSTM model.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_14179_9_19,
  title = {Alice in (Software Supply) Chains: Risk Identification and Evaluation},
  author = {Benedetti, Giacomo and Verderame, Luca and Merlo, Alessio},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {281-295},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-14179-9\_19},
  url = {https://doi.org/10.1007/978-3-031-14179-9\_19},
  abstract = {The fast pace of modern development paradigms like DevOps boosted the complexity of development pipelines. In particular, developers rely on many external assets and third-party software to build the final product and match the demanding requirements in terms of release cycles and functionalities. However, such a choice impacts all the elements of the development pipeline composing the so-called Software Supply Chain (SSC), degrading its maintainability and security. From a security standpoint, successful attacks can go unnoticed and impact many targets that use the affected software before being resolved. Unfortunately, traditional security assessment methodologies might detect the symptoms (e.g., the piece of vulnerable code) but not the cause, i.e., the attack vector and the affected asset of the SSC, failing to mitigate the risk of new attack campaigns. In this paper, we propose Sunset , a methodology with a two-fold objective. First, it allows the automatic reconnaissance of the SSC assets and dependencies to alleviate the burden of monitoring the composition of the SSC. Then, it computes a risk profile, identifying the SSC risk sources and how they can impact the final software to support the identification of the weakest points of the SSC and activate the necessary organizational and technical countermeasures to prevent future SSC attack campaigns.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_03884_6_25,
  title = {Development Processes of Vulnerability Detection Systems: A Systematic Review, Approaches, Challenges, and Future Directions},
  author = {Reyes, Jorge and Fuertes, Walter and Macas, Mayra},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {335-350},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-03884-6\_25},
  url = {https://doi.org/10.1007/978-3-031-03884-6\_25},
  abstract = {In cybersecurity, a vulnerability is any software or hardware failure that compromises the information’s integrity, availability, or confidentiality. Nowadays, the number of vulnerabilities is increasing exponentially. The early detection, analysis, and efficient treatment of vulnerabilities constitute significant challenges for organizations, as they are arduous and expensive processes. This study aims to thoroughly and systematically research the approaches, techniques, and tools used in implementing vulnerability detection and scanning systems. We conduct a systematic literature review based on the methodological guide of Barbara Kitchenham to carry out a synthesis of the evidence available in primary studies in the last five years. The results show that studies evaluate the efficiency and complexity of the development process for vulnerability detection through a combination of methods, techniques, tools, and metrics. Moreover, this study serves as a baseline for establishing a new development process proposal to benefit organizations planning to create custom vulnerability detection systems. Finally, current challenges are highlighted, and future research directions for addressing them are explored.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_19_0019_8_37,
  title = {Sniffing Android Malware Using Deep Learning},
  author = {Tirkey, Anand and Mohapatra, Ramesh Kumar and Kumar, Lov},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2022},
  pages = {489-505},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-19-0019-8\_37},
  url = {https://doi.org/10.1007/978-981-19-0019-8\_37},
  abstract = {Android malware classification problem seems to have been solved with published AUC and F1 scores up to 0.99 or is it a facade, hiding an inherent problem? In this paper, we bring forward a novel method of recognising android malware using object-oriented software metrics-based dataset and deep learning. We realise that the real-world android malware is a minority class and its distribution according to 2017 Google’s android security report, and Miller et al. [ 17 ] is estimated to be about 8–12\%. The malware distribution in our dataset of 93K samples spanning over three years is around 10.9\%. In this study, four data-sampling methods, six feature selection techniques and five deep learning networks with varying hidden layers are used over the imbalanced dataset of 93K samples. A total of 120 different machine-learned models are developed, and its classification potential is compared using area under ROC curve (AUC) metric. Finally, a machine-learned model obtained using upscale sampling (USD) data-sampling method applying significant set of metrics (SGM) feature selection technique over deep learning network with two hidden layers (DL2) yields a better AUC value of 0.893681.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_16_3097_2_24,
  title = {How Efficient Is Blockchain While Dealing with Android Malware? A Review Paper},
  author = {Wadali, Jagjot Singh and Madan, Sanjay and Khosla, Praveen Kumar},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2022},
  pages = {285-301},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-3097-2\_24},
  url = {https://doi.org/10.1007/978-981-16-3097-2\_24},
  abstract = {Android is an open-source mobile operating system that became more popular in recent years than any other mobile operating system. The main reason for its popularity is the wide range of functionality available at an affordable cost. Moreover, millions of android-based free applications are easily available for users on the android market store, that is, Play Store. Because of the expanded user base globally, there is a significant rise in cyber-attacks on android devices in the last decade so as to have large impact. The main goals of the attackers are to gain access to these devices and steal private as well as confidential information stored on these devices. There is a wide variety of android malware specifically designed for these devices with the capability of spreading and propagation. Even some of the android malware code is written in such a way that they have the capability to evade the detection system. Various frameworks and technologies are used for the detection of android malware but still, attackers are finding new ways to evade detection. Meanwhile, blockchain technology is emerging and has proved its worth in various sectors. In this paper, we reviewed the use cases of blockchain technology for the detection of android malware which manifests the capability and effectiveness of this emerging technology to secure ubiquitous mobile cyber-infrastructure.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_90016_8_2,
  title = {Prediction of Android Malicious Software Using Boosting Algorithms},
  author = {Nath, Deepon Deb and Khan, Nafiz Imtiaz and Akhter, Jesmin and Rahaman, Abu Sayed Md. Mostafizur},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {21-36},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90016-8\_2},
  url = {https://doi.org/10.1007/978-3-030-90016-8\_2},
  abstract = {Android malware, a group of malicious software variants, including viruses, ransomware and spyware, designed to cause substantial damage to data and systems or to access a network without authorization. With an inexorable shift in technology, Android has supplanted other Mobile platforms by being flexible and user-friendly to the users. As the number of Android apps continues to grow every day, the number of malwares aimed at attacking those users is also on the rise. Thus, it becomes emergent to identify and remove malicious Android applications before installation to prevent user’s loss. Several studies have already been carried out to anticipate Android malware using machine learning algorithms, while as per the literature survey conducted by this study, a significant research has not been found to be focusing especially on the genre of boosting algorithms. Therefore, the objective of this paper is to classify malicious and benign Android applications by using Boosting algorithm. To attain the research objective, four widely defined boosting models viz. AdaBoost, CatBoost, XGBoost, and GradientBoost were developed whereas, it was found that CatBoost and GradientBoost had the highest F1 score (93.9\%), followed by Adaboost (F1 score 93.5\%), and XGBoost (F1 score 93.5\%).},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_92317_4_4,
  title = {SolarWinds Software Supply Chain Security: Better Protection with Enforced Policies and Technologies},
  author = {Yang, Jeong and Lee, Young and McDonald, Arlen P.},
  booktitle = {Studies in Computational Intelligence},
  year = {2022},
  pages = {43-58},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-92317-4\_4},
  url = {https://doi.org/10.1007/978-3-030-92317-4\_4},
  abstract = {A recent cybersecurity attack took place on US governments and companies utilizing a popular network performance monitoring tool, SolarWinds. The attack appears to be not only extensive but also comprehensive in the scope of the common security tools that have been breached. This attack targeted the complex software supply chain. The wave of those attacks was mainly focused on the critical departments of the U.S. government and of many other leading corporations. Even if the attackers did not actively exploit their systems, the comprehensive nature of these breaches seems to indicate that there are fundamental flaws with existing security infrastructure. This paper investigates what caused this significant attack and what solutions we might have to prevent similar attacks in the future. The paper concludes that a combined set of actions of the government and industries on better policies and technologies is needed to develop a unified strategy in each organization.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_97_9314_3_38,
  title = {Microprocessor Assurance and the Role of Theorem Proving},
  author = {Goel, Shilpi and Ray, Sandip},
  booktitle = {Handbook of Computer Architecture},
  year = {2025},
  pages = {1321-1363},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-9314-3\_38},
  url = {https://doi.org/10.1007/978-981-97-9314-3\_38},
  abstract = {Theorem proving is a technology where we use logical deduction to prove properties of mathematical artifacts, often assisted by a computer program called a theorem prover . One way to verify computing systems is to model them as mathematical artifacts and then use theorem proving to prove their desired properties as theorems. This approach has in fact been used to verify a wide spectrum of properties of computing systems. In this chapter, we recount the role of theorem proving in microprocessor verification and discuss the scope, applicability, and limits of the technology.},
  content_type = {Reference work entry},
}


@incollection{springer_10_1007_978_3_030_79584_9_1,
  title = {Information Systems Reengineering, Integration, and Normalization},
  author = {Fong, Joseph S. P. and Wong Ting Yan, Kenneth},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2021},
  pages = {1-28},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-79584-9\_1},
  url = {https://doi.org/10.1007/978-3-030-79584-9\_1},
  abstract = {The primary goal of electronic data processing (EDP) in the 1960s and 1970s was the automation of existing business operations in organizations. However, except for the quicker availability of more accurate management reporting information, such operations were automated without fundamental changes. During these two decades, data were stored in flat file formats that could be classified into two different forms, namely, batch files and online files.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_025_10685_3,
  title = {On state reverting in solidity smart contracts: Developer practices, fault categorization, and tool evaluation},
  author = {Liu, Lu and Wei, Lili and Zhang, Wuqi and Li, Shuqing and Zhou, Yifan and Liu, Yepang and Cheung, Shing-Chi and Lyu, Michael R.},
  journal = {Empirical Software Engineering},
  year = {2025},
  volume = {30},
  number = {5},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-025-10685-3},
  url = {https://doi.org/10.1007/s10664-025-10685-3},
  abstract = {Smart contracts are computer programs deployed on blockchains to facilitate transactions. A critical aspect of smart contract security is the use of state-reverting statements (e.g., require , if...revert , if...throw ). These statements protect transactions from abnormal behaviors or malicious attacks by reverting a contract to its previous state when certain input constraints or security properties are violated. While essential, the correct use of these state-reverting (SR) statements is nontrivial. Improper use can lead to security vulnerabilities, resulting in substantial financial losses or other severe consequences. It is, therefore, highly important to understand developers’ practices of state reverting in smart contracts and the common mistakes they make. To achieve this goal, we conduct the first comprehensive empirical study on the use of SR statements and their related faults in Solidity smart contracts. First, we analyze the prevalence and purposes of SR statements in 21,414 verified contracts from popular decentralized applications (dapps) and manually examine 381 SR statements, leading to a taxonomy of their uses. Second, we collect 320 real-world state-reverting faults (SR faults) from open-source projects on GitHub and audit reports on Code4rena. We categorize the SR faults into 17 types and summarize 12 distinct fixing strategies. This knowledge can help researchers and practitioners to better understand the common usages of SR statements and learn how to prevent or cope with SR faults. Lastly, the variety of SR fault types and the presence of high-risk issues highlight the need for automated tools to identify and mitigate these faults. This further motivates us to assess the SR fault detection performance of state-of-the-art security analyzers, with the aim of understanding their capability and identifying their deficiencies. Via evaluating 12 representative tools on a benchmark comprising 243 contracts with six types of SR faults and the corresponding patched versions, we observe that existing tools exhibit limited capabilities in detecting SR faults (the average detection rate is 14.4\%). This result underscores the need for more advanced security analysis tools specifically tailored for SR faults. To facilitate the development of such tools, we further provide a comprehensive analysis of three common limitations of existing tools.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_96_5135_1_7,
  title = {Control Security Analysis},
  author = {Wei, Qiang and Wang, Wenhai and Huang, Huihui},
  booktitle = {Industrial Internet Security},
  year = {2025},
  pages = {297-345},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-96-5135-1\_7},
  url = {https://doi.org/10.1007/978-981-96-5135-1\_7},
  abstract = {This chapter delves into the critical role of control systems within the industrial internet, which are essential for managing production equipment, workflow processes, and product quality. It highlights the importance of control security analysis in identifying and addressing potential ICS threats to ensure safe production practices and environmental protection. The chapter provides a comprehensive evaluation of ICS threats, vulnerability assessments, and attack methodologies. It discusses the integration of cyber and physical elements for predeployment testing in ICS simulation environments and outlines strategies for postdeployment attack detection to safeguard the stable operation and critical resources of the industrial production backbone.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_17081_2_10,
  title = {Black-Box Testing of Cryptographic Algorithms Based on Data Characteristics},
  author = {Fan, Haoling and Meng, Lingjia and Zheng, Fangyu and Wang, Mingyu and Xu, Bowen},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2022},
  pages = {153-169},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-17081-2\_10},
  url = {https://doi.org/10.1007/978-3-031-17081-2\_10},
  abstract = {Serving communications security, identity authentication, etc., cryptographic algorithms constitute the cornerstone of cyberspace security. During the past decades, cryptanalysts have proved that many once prevailing cryptographic algorithms (e.g., MD4, MD5, 3DES, RC4) are no longer secure now. However, insecure cryptographic algorithms are still widely deployed in practice, seriously endangering the security of cyberspace. The reasons for this dilemma are many-fold, one of which is difficult to detect the algorithms used in the legacy binaries. Most of the existing detecting methods of cryptographic algorithms, either require source code analysis (i.e., white-box testing) or depend on the dynamic execution information (i.e., dynamic testing), narrowing the testing scope where the source codes of commercial software are not provided and the running environment may be difficult to deploy. In this paper, we propose a method of static black-box testing of cryptographic algorithms, which can identify a specific algorithm based on the corresponding data characteristics. We have implemented the testing method and used it to check 150 binaries of three types, including cryptographic libraries, commonly-used programs that use cryptographic algorithms, and general-purpose Github projects without cryptographic algorithms. The empirical results demonstrate that 80.6\% of the insecure cryptographic algorithm are implemented in the test files that contain the cryptographic algorithms. The false negative rate and false positive rate were 2.10\% and 1.68\% using our method. Moreover, we found that the insecure cryptographic algorithms (i.e., MD4, SHA-1) is still exist in some popular software, e.g., MbedTLS and 7-Zip.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_023_00759_y,
  title = {A survey on run-time packers and mitigation techniques},
  author = {Alkhateeb, Ehab and Ghorbani, Ali and Habibi Lashkari, Arash},
  journal = {International Journal of Information Security},
  year = {2024},
  volume = {23},
  number = {2},
  pages = {887-913},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00759-y},
  url = {https://doi.org/10.1007/s10207-023-00759-y},
  abstract = {The battle between malware analysts and malware authors is a never-ending challenge with the advent of complex malware such as polymorphic, metamorphic, and packed malware. A malware packer uses various techniques combined with file encryption to harden against reverse engineering of the program and hinder the analysis of program behaviors. In any case, substantial elements have emerged after more than a decade of continuous research in malware packer detection, such as multi-packing. Newly modified packers have this persistent problem, which demands new concepts and techniques. This study aims to provide a systematic and comprehensive review of run-time packers’ mitigation techniques. We provide different types of packers and propose a malware packer handling life cycle for AV engines. Furthermore, we deliver a modern malware packers classification features set by examining the feature engineering in the packing handling life-cycle, such as feature extraction techniques in machine learning approaches. Also, we present extensive related works and discuss each work’s benefits and weaknesses to address this problem, with a particular emphasis on packers identification techniques, to aid in unpacking malware. Finally, we identify the current gaps in knowledge and provide ideas about future work.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_93733_1_10,
  title = {IReEn: Reverse-Engineering of Black-Box Functions via Iterative Neural Program Synthesis},
  author = {Hajipour, Hossein and Malinowski, Mateusz and Fritz, Mario},
  booktitle = {Communications in Computer and Information Science},
  year = {2021},
  pages = {143-157},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-93733-1\_10},
  url = {https://doi.org/10.1007/978-3-030-93733-1\_10},
  abstract = {In this work, we investigate the problem of revealing the functionality of a black-box agent. Notably, we are interested in the interpretable and formal description of the behavior of such an agent. Ideally, this description would take the form of a program written in a high-level language. This task is also known as reverse engineering and plays a pivotal role in software engineering, computer security, but also most recently in interpretability. In contrast to prior work, we do not rely on privileged information on the black box, but rather investigate the problem under a weaker assumption of having only access to inputs and outputs of the program. We approach this problem by iteratively refining a candidate set using a generative neural program synthesis approach until we arrive at a functionally equivalent program. We assess the performance of our approach on the Karel dataset. Our results show that the proposed approach outperforms the state-of-the-art on this challenge by finding an approximately functional equivalent program in 78\% of cases – even exceeding prior work that had privileged information on the black-box.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_1682_8_4,
  title = {Securing Your Apps at Scale},
  author = {Gunasekera, Sheran},
  booktitle = {Android Apps Security},
  year = {2020},
  pages = {57-89},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1682-8\_4},
  url = {https://doi.org/10.1007/978-1-4842-1682-8\_4},
  abstract = {I wanted to cover some techniques that I have seen and used when protecting Android apps. I titled the chapter with the words "at scale" because when I was at GO-JEK, everything was at scale – the users, the engineering teams, the threats. As I may or may not have mentioned in my previous book, a healthy dose of paranoia will serve you well. Personally, I don't think that you as a developer stand a chance against the reverse engineers. They are always ahead, and they are always at an advantage. I think it is somewhat of a waste of time spending a disproportionate amount of time trying to secure your apps. Then all you have built is an app with 20\% actual features and 80\% security. No balance. It's like the engineering team that focuses so much on testing that you're devoting all your time and energy to tests and not to the code itself. I recall Zed Shaw (the creator of the Mongrel web server for Ruby web applications) once wrote about this in a scathing piece leveled at the Ruby on Rails community entitled "Rails is A Ghetto." He was mentioning a well-known software development company at the time, and he said:},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_79584_9_10,
  title = {Conclusion},
  author = {Fong, Joseph S. P. and Wong Ting Yan, Kenneth},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2021},
  pages = {369-377},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-79584-9\_10},
  url = {https://doi.org/10.1007/978-3-030-79584-9\_10},
  abstract = {As computer technologies evolve, it becomes a necessity for companies to upgrade their information systems. The objective of reengineering is to protect their huge investments and to maintain their competitive edge. However, information systems reengineering is a complicated task that requires much expertise and knowledge. It needs users’ input to recover lost semantics inside the existing database system and/or the existing expert system. It also requires technical expertise to replace obsolete information systems with newer systems. Very often, because of the lack of methodologies and expertise, companies choose to redevelop rather than reengineer when upgrading their information systems. The purpose of this book is to convince these companies that reengineering is a more cost-effective and feasible solution.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_024_10453_9,
  title = {Analyzing and revivifying function signature inference using deep learning},
  author = {Lin, Yan and Singhal, Trisha and Gao, Debin and Lo, David},
  journal = {Empirical Software Engineering},
  year = {2024},
  volume = {29},
  number = {3},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-024-10453-9},
  url = {https://doi.org/10.1007/s10664-024-10453-9},
  abstract = {Function signature plays an important role in binary analysis and security enhancement, with typical examples in bug finding and control-flow integrity enforcement. However, recovery of function signatures by static binary analysis is challenging since crucial information vital for such recovery is stripped off during compilation. Although function signature recovery using deep learning (DL) is proposed in an effort to handle such challenges, the reported accuracy is low for binaries compiled with optimizations. In this paper, we first perform a systematic study to quantify the extent to which compiler optimizations (negatively) impact the accuracy of existing DL techniques based on Recurrent Neural Network (RNN) for function signature recovery. Our experiments show that the state-of-the-art DL technique has its accuracy dropped from 98.7\% to 87.7\% when training and testing optimized binaries. We further investigate the type of instructions that existing RNN model deems most important in inferring function signatures with the help of saliency map. The results show that existing RNN model mistakenly considers non-argument-accessing instructions to infer the number of arguments, especially when dealing with optimized binaries. Finally, we identify specific weaknesses in such existing approaches and propose an enhanced DL approach named ReSIL to incorporate compiler-optimization-specific domain knowledge into the learning process. Our experimental results show that ReSIL significantly improves the accuracy and F1 score in inferring function signatures, e.g., with accuracy in inferring the number of arguments for callees compiled with optimization flag O1 from 84.83\% to 92.68\%. Meanwhile, ReSIL correctly considers the argument-accessing instructions as the most important ones to perform the inferencing. We also demonstrate security implications of ReSIL in Control-Flow Integrity enforcement in stopping potential Counterfeit Object-Oriented Programming (COOP) attacks.},
  content_type = {Article},
}


@article{springer_10_1007_s12652_023_04603_y,
  title = {Advanced Persistent Threats (APT): evolution, anatomy, attribution and countermeasures},
  author = {Sharma, Amit and Gupta, Brij B. and Singh, Awadhesh Kumar and Saraswat, V. K.},
  journal = {Journal of Ambient Intelligence and Humanized Computing},
  year = {2023},
  volume = {14},
  number = {7},
  pages = {9355-9381},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12652-023-04603-y},
  url = {https://doi.org/10.1007/s12652-023-04603-y},
  abstract = {In today’s cyber warfare realm, every stakeholder in cyberspace is becoming more potent by developing advanced cyber weapons. They have equipped with the most advanced malware and maintain a hidden attribution. The precocious cyber weapons, targeted and motivated with some specific intention are called as Advanced Persistent Threats (APT). Developing defense mechanisms and performing attribution analysis of such advanced attacks are extremely difficult due to the intricate design of attack vector and sophisticated malware employed with high stealth and evasive techniques. These attacks also include advanced zero-day and negative-day exploits and payloads. This paper provides a comprehensive survey on the evolution of advanced malware design paradigms, APT attack vector and its anatomy, APT attack Tactics, Techniques, and Procedures (TTP) and specific case studies on open-ended APT attacks. The survey covers a detailed discussion on APT attack phases and comparative study on threat life-cycle specification by various organizations. This work also addresses the APT attack attribution and countermeasures against these attacks from classical signature and heuristic based detection to modern machine learning and genetics based detection mechanisms along with sophisticated zero-day and negative day malware countermeasure by various techniques like monitoring of network traffic and DNS logs, moving target based defense, and attack graph based defenses. Furthermore, the survey addresses various research scopes in the domain of APT cyber-attacks.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_032_01184_8_12,
  title = {Catalog of Architecture Styles},
  author = {Kim, Soo Dong and Kim, Mira},
  booktitle = {Hands-on Software Architecture},
  year = {2025},
  pages = {349-414},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-032-01184-8\_12},
  url = {https://doi.org/10.1007/978-3-032-01184-8\_12},
  abstract = {The objective of this chapter is to present an essential overview of representative software architecture styles that serve as foundational design paradigms for structuring complex systems. Each style is systematically described in terms of its core structural elements, collaboration mechanisms, and associated strengths and limitations. This catalog serves as a reference framework for selecting appropriate architectural styles based on system requirements, quality attributes, and design constraints.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11276_025_03942_2,
  title = {Forensics and security issues in the Internet of Things},
  author = {Ahmed, Shams Forruque and Shawon, Shanjana Shuravi and Bhuyian, Afsana and Afrin, Shaila and Mehjabin, Aanushka and Kuldeep, Sweety Angela and Alam, Md. Sakib Bin and Gandomi, Amir H.},
  journal = {Wireless Networks},
  year = {2025},
  volume = {31},
  number = {4},
  pages = {3431-3466},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11276-025-03942-2},
  url = {https://doi.org/10.1007/s11276-025-03942-2},
  abstract = {Abstract Given the exponential expansion of the internet, the possibilities of security attacks and cybercrimes have increased accordingly. However, poorly implemented security mechanisms in the Internet of Things (IoT) devices make them susceptible to cyberattacks, which can directly affect users. IoT forensics is thus needed to investigate and mitigate such attacks. While many works have examined IoT applications and challenges, only a few have focused on both the forensic and security issues in IoT. Therefore, this paper reviews forensic and security issues associated with IoT in different fields. Prospects and challenges in IoT research and development are also highlighted. As the literature demonstrates, most IoT devices are vulnerable to attacks due to a lack of standardized security measures. Unauthorized users could get access, compromise data, and even benefit from control of critical infrastructure. To fulfill the security-conscious needs of consumers, IoT can be used to develop a smart home system by designing the security-conscious needs of consumers; IoT can be used to create a smart home system by designing an IoT can be used to develop a smart home system by designing a FLIP-based system that is highly scalable and adaptable. A blockchain-based authentication mechanism with a multi-chain structure can provide additional security protection between different trust domains. Deep learning can be utilized to develop a network forensics framework with a high-performing system for detecting and tracking cyberattack incidents. Moreover, researchers should consider limiting the amount of data created and delivered when using big data to develop IoT-based smart systems. The findings of this review will stimulate academics to seek potential solutions for the identified issues, thereby advancing the IoT field.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_20917_8_15,
  title = {FolketID: A Decentralized Blockchain-Based NemID Alternative Against DDoS Attacks},
  author = {Chiu, Wei-Yang and Meng, Weizhi and Li, Wenjuan and Fang, Liming},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {210-227},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-20917-8\_15},
  url = {https://doi.org/10.1007/978-3-031-20917-8\_15},
  abstract = {Electronic Identity (eID) is a solution toward solving the identity problem when deploying e-Government. Such solution should not only be secure, but also have to be robust enough under adversarial conditions. In Denmark, NemID is a digital eID used to log into public websites, for online banking and many digital services. However, it suffers from some security threats such as Distributed Denial of Service (DDoS) attack. In 2013, a tremendous DDoS attack over NemID caused chaos in Danish society, people found themselves out-of-reach to many services. Focused on this threat, we develop FolketID, a blockchain-based NemID alternative against DDoS attacks. The DDoS mitigation is achieved by not only utilizing its powerful data distribution ability, but also exploiting the economy system in blockchain. It particularly takes use of the transaction fees to effectively prevent DDoS attacks. In the evaluation, our experimental results demonstrate the viability and effectiveness of FolketID in defeating DDoS attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_78841_4_2,
  title = {Behavioral Synthesis of Key-Obfuscated RTL IP},
  author = {Islam, Sheikh Ariful and Katkoori, Srinivas},
  booktitle = {Behavioral Synthesis for Hardware Security},
  year = {2022},
  pages = {17-42},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-78841-4\_2},
  url = {https://doi.org/10.1007/978-3-030-78841-4\_2},
  abstract = {This chapter presents techniques to incorporate key-based obfuscation mechanisms during Behavioral Synthesis (also known as High-Level Synthesis, HLS) against the capability of rogue employees and malicious tools to perform reverse engineering (RE) for all counterfeiting types. Obfuscation embeds immutable multiplexers on non-critical paths of design that remain transparent to system integrator and foundry along the supply chain. The locations and number of these key-obfuscated modules are co-optimized to trade-off security versus design parameters. For four datapath-intensive Digital Signal Processing (DSP) filters and one crypto-core, we evaluate the security metrics and design overheads for three different key lengths and in three design corners in 90 nm technology. For the 32-bit key, the average area, power, and delay overheads are 2.45\%, 2.61\%, and 2.65\%, respectively. For 64-bit key, the same overheads are 4.30\%, 16.51\%, and 3.87\%; while for 128-bit key, the respective overheads are 6.21\%, 20.88\%, and 6.52\%. For security evaluation, we measure the design’s resilience in terms of the probability of guessing the key bits. We show that this probability is extremely low for all the designs.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_19_8746_5_8,
  title = {Effective Imbalance Learning Utilizing Informative Data},
  author = {Tai, Han and Wong, Raymond and Li, Bing},
  booktitle = {Communications in Computer and Information Science},
  year = {2022},
  pages = {99-114},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-8746-5\_8},
  url = {https://doi.org/10.1007/978-981-19-8746-5\_8},
  abstract = {The class imbalance problem that is caused by unequal data distribution usually results in poor performance, and it has attracted increasing attention in the research community. The challenge of the problem is the difficulty to extract sufficient information from the minority class. As a result, the classifier converges to a sub-optimal state. While methods based on resampling and reweighing the cost for different classes are the common strategies to address the problem, there are still numerous issues with these methods such as under- or over-sampling that may remove necessary information or introduce noise, respectively; and reweighing may result in an inappropriate cost matrix. To address the above shortcomings, in this paper, an enhanced approach based on informative samples is proposed. In our approach, the classifier can indicate which class a sample is closer to by comparing it with boundary samples. The informative samples include the samples from both positive and negative samples located around the boundary. Finally, our experiments show that our proposed method outperforms state-of-the-art algorithms by 18\% on \\(F\_1\\) score.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11042_024_18511_6,
  title = {IPAnalyzer: A novel Android malware detection system using ranked Intents and Permissions},
  author = {Sharma, Yash and Arora, Anshul},
  journal = {Multimedia Tools and Applications},
  year = {2024},
  volume = {83},
  number = {33},
  pages = {78957-79008},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-024-18511-6},
  url = {https://doi.org/10.1007/s11042-024-18511-6},
  abstract = {Android malware has been growing in scale and complexity, spurred by the unabated uptake of smartphones worldwide. Millions of malicious Android applications have been detected in the past few years, posing severe threats like system damage, information leakage, etc. This calls for novel approaches to mitigate the growing threat of Android malware. Among various detection schemes, permission and intent-based ones have been widely proposed in the literature. However, many permissions and intents patterns are similar in normal and malware datasets. Such high similarity in both datasets’ permissions and intents patterns motivates us to rank them to find the distinguishing features. Hence, we have proposed a novel Android malware detection system named IPAnalyzer that first ranks the permissions and intents with a frequency-based Chi-square test. Then, the system applies a novel detection algorithm that combines ranked permissions and intents and involves various machine learning and deep learning classifiers. As a result, the proposed system gives the best set of permissions and intents with higher detection accuracy as an output. The experimental results highlight that our proposed approach can effectively detect Android malware with 98.49\% detection accuracy, achieved with the combination of the top six permissions and top six intents. Furthermore, our experiments demonstrate that the proposed system with the Chi-square ranking is better than other statistical tests like Mutual Information and Pearson Correlation Coefficient. Moreover, the proposed model can detect Android malware with better accuracy and less number of features than various state-of-the-art techniques for Android malware detection.},
  content_type = {Article},
}


@article{springer_10_1007_s11416_022_00430_5,
  title = {Reversing Kia Motors Head Unit to discover and exploit software vulnerabilities},
  author = {Costantino, Gianpiero and Matteucci, Ilaria},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2022},
  volume = {19},
  number = {1},
  pages = {33-49},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-022-00430-5},
  url = {https://doi.org/10.1007/s11416-022-00430-5},
  abstract = {Abstract Modern vehicles resemble four-wheels computers connected to the Internet via their In-Vehicle Infotainment (IVI) systems. As with PCs in the past, cars, being connected to the Internet can be potentially vulnerable. The IVI system of a car is part of the intra-vehicle network and can be the entry-point of offensive cybersecurity attacks. The intra-vehicle network, based on the CAN protocol, is vulnerable by design : messages are exchanged in clear. Thus, the uncontrolled access to the CAN bus may have serious impact on the vehicle itself and its passengers. In this paper, we present a vulnerability assessment, through a reverse engineering process, of Kia vehicles IVI system. In particular, we focused on reverse engineer the Kia IVI system to discover vulnerabilities that may allow an attacker to compromise the IVI functionalities and inject CAN frames into the CAN bus to alter the behaviour of (part of) the vehicle. By reverse engineering the IVI, we identified four important vulnerabilities that affect all Kia vehicles that embed the studied IVI. Finally, we show how an attacker can easily control the IVI and inject CAN bus frames by means of a Metasploit module that we wrote.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_031_21280_2_17,
  title = {PriApp-Install: Learning User Privacy Preferences on Mobile Apps’ Installation},
  author = {Son, Ha Xuan and Carminati, Barbara and Ferrari, Elena},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {306-323},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-21280-2\_17},
  url = {https://doi.org/10.1007/978-3-031-21280-2\_17},
  abstract = {It is undeniable that smartphones play a vital role in our lives, as their applications (apps) can be used to access various services anytime and anywhere. Despite the benefits provided by mobile apps, there are risks connected to the release of personal and sensitive data. Understanding the potential privacy risks of installing an app based on its description or privacy policy could be challenging, especially for non-skilled users. In this paper, to assist users in their app selection process, we propose PriApp-Install, a privacy-aware app installation recommendation system. It leverages semi-supervised learning to learn individual privacy preferences w.r.t mobile app installation. Learning is done based on a rich set of features modelling both the app behavior w.r.t. personal data consumption and the benefits a user can get in installing the app. We tested four learning strategies on a real dataset by exploiting three participant groups: security and privacy experts, IT workers, and crowd workers. The obtained results show the effectiveness of our proposal.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_022_00452_z,
  title = {Improving binary diffing speed and accuracy using community detection and locality-sensitive hashing: an empirical study},
  author = {Karamitas, Chariton and Kehagias, Athanasios},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2022},
  volume = {19},
  number = {2},
  pages = {319-337},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-022-00452-z},
  url = {https://doi.org/10.1007/s11416-022-00452-z},
  abstract = {Abstract Binary diffing is a commonly used technique for detecting syntactic and semantic similarities and/or differences between two programs’ binary executables ( not source code). Here we present REveal , a binary diffing application. REveal is based on the detection of Function Call Graph (FCG) approximate isomorphism and improves both speed and accuracy, mainly by the use of two techniques. First, we propose the use of hierarchical Community Detection (CD) in executables’ FCGs, for the purpose of detecting groups of densely connected functions, thus partitioning them in smaller groups. Moreover, we use Locality-Sensitive Hashing (LSH) for further grouping of similar functions in hash buckets. Both techniques are used in a divide-and-conquer fashion to simplify the diffing process of the programs being compared, practically reducing it to diffing of their FCG communities and LSH buckets.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_6193_4_16,
  title = {Debuggers and Assembly Language},
  author = {Mohanta, Abhijit and Saldanha, Anoop},
  booktitle = {Malware Analysis and Detection Engineering},
  year = {2020},
  pages = {525-638},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-6193-4\_16},
  url = {https://doi.org/10.1007/978-1-4842-6193-4\_16},
  abstract = {In the previous chapters we spoke about analyzing malware samples both statically and dynamically. From the analysis techniques we discussed, we might be able to derive most of the times if a sample file is malware or not. But sometimes malware may not execute in the malware analysis environment, due to various armoring mechanisms implemented inside the malware sample to dissuade analysis and even detection. To beat armoring mechanisms you want to figure out the internals of the malware code so that you can devise mechanisms to bypass them.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_8752_8_55,
  title = {Threat Level Detection in Android Platform Using Machine Learning Algorithms},
  author = {Deepa, D. and Jena, Sachitananda and Ganesh, Yadavalli and Roobini, M. S. and Ponraj, Anitha},
  booktitle = {Lecture Notes in Electrical Engineering},
  year = {2021},
  pages = {543-551},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-15-8752-8\_55},
  url = {https://doi.org/10.1007/978-981-15-8752-8\_55},
  abstract = {Android and Mac OS apps have become an important asset of our daily lives of mobile device users by which translates into an increase in mobile applications. Now, a one-day user can access an ample amount of applications through different platforms like play store, apple store, etc. Due to a certain amount of vulnerabilities, hackers are developing mobile malware, which in turn threatens the system and can lead to remote control, loss of privacy, etc. Therefore, it is necessary to detect the threat level of a certain application installed on mobile devices. In this next module, we present an approach in which we allow the user to select any application from the play store, where the user has the possibility to select a specific authorization, and the privacy policy extracts a list of relevant phrases and presents them, together a proper describing of the permission from the user . This interface allows the user to quickly evaluate the private owned risks of android apps that are highlighting the relevant sections of the private policies that are owned by them and providing useful information on sensitive permissions, a particular application has authority on it.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_06975_8_22,
  title = {AndroClonium: Bytecode-Level Code Clone Detection for Obfuscated Android Apps},
  author = {Foroughipour, Ardalan and Stakhanova, Natalia and Abazari, Farzaneh and Sistany, Bahman},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2022},
  pages = {379-397},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-06975-8\_22},
  url = {https://doi.org/10.1007/978-3-031-06975-8\_22},
  abstract = {Detecting code clones is essential for many security tasks, e.g., vulnerability detection, malware analysis, legacy software patching. In many of these security scenarios, source code is not available, leaving binary code analysis as the only option. Yet, evaluation of binary code is often exacerbated by the wide use of obfuscation. In this work, we propose an approach for obfuscation-resistant fine-grained detection of code clones in Android apps at the bytecode level. To mitigate inherent constraints of static analysis and to achieve obfuscation resistance, we partially simulate the execution of Android code, and abstract the resulting execution traces. We validate our approach’s ability to detect different types of code clones on a set of 20 injected clones and explore its resistance against obfuscation on a set of 1085 obfuscated apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_66922_5_13,
  title = {A Multi-class Detection System for Android Malicious Apps Based on Color Image Features},
  author = {Zhang, Hua and Qin, Jiawei and Zhang, Boan and Yan, Hanbing and Guo, Jing and Gao, Fei},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {186-206},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-66922-5\_13},
  url = {https://doi.org/10.1007/978-3-030-66922-5\_13},
  abstract = {The visual recognition of Android malicious applications(Apps) is mainly focused on the binary classification using gray-scale images, while the multi-classification of malicious App families is rarely studied. If we can visualize the Android malicious Apps as color images, we will get more features than using grayscale images. In this paper, a method of color visualization for Android Apps is proposed and implemented. Based on this, combined with deep learning models, a multi-classifier for the Android malicious App families is implemented, which can classify 131 common malicious App families. Compared with the App classifier based on the gray-scale visualization method, it is verified that the classifier using the color visualization method can achieve better classification results. This paper uses three classes of Android App APK features: classes.dex file, class name collection and API call sequence as input for App visualization, and analyzes the classifier detection accuracy and detection time under each input characteristics. According to the experimental results, we found that using the API call sequence as the color visualization input feature can achieve the highest detection accuracy rate, which is 96.01\% in the ten malicious family classification and 100\% in the binary classification.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_6014_9_66,
  title = {Data Mining and Machine Learning Techniques for Malware Detection},
  author = {Sharma, Niharika and Arora, Bhavna},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {557-567},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-6014-9\_66},
  url = {https://doi.org/10.1007/978-981-15-6014-9\_66},
  abstract = {Malware or malicious software is an umbrella term for viruses, worms, Trojans, spyware, and the like; it is a piece of code that is intentionally installed to infect computational devices. Several techniques have been proposed from time to time to detect these malwares. These techniques range from the early day signature-based detection to the machine and deep learning techniques. In the current scenario, the malwares use the techniques of obfuscation and polymorphism in order to hide themselves and go undetected. To detect these malwares, machine learning and data mining techniques are combined with existing detection methods in order to facilitate the detection process. Basic malware analysis techniques like static, dynamic, and hybrid have been detailed in this paper. In this paper, malware detection techniques have also been critically evaluated. This paper also focuses on the study of various data mining/machine learning approaches for malware detection proposed by different researchers.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s12083_025_02112_7,
  title = {Malware Detection with AI: A Comprehensive Review of Trends and Challenges with Future Directions},
  author = {Singh, Kritika and Gaur, Manish and Shukla, Piyush Kumar and Yadav, D. S.},
  journal = {Peer-to-Peer Networking and Applications},
  year = {2025},
  volume = {18},
  number = {6},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12083-025-02112-7},
  url = {https://doi.org/10.1007/s12083-025-02112-7},
  abstract = {Detection of malware is an important problem to be addressed in the realm of computer and network security. Malware writers are becoming increasingly competent at creating new versions of malware at a lightning-fast speed using various kinds of obfuscation mechanisms. These new generation malware are so complex that a straightforward simplistic method like the one based on malware signatures can no longer be used for detecting them. Therefore, we need heuristics-based methods that use machine learning and deep learning techniques for learning what features in a file make it malicious or benign. The ML/DL algorithms can do this because they are trained on a huge amount of data. These techniques can further be categorized as static and dynamic malware detection techniques. In this article, we have briefly explored basic malware concepts, various types of malware, malware evasion mechanisms and existing popular malware datasets used in malware detection research. Then we discuss at length, the various types of malware detection approaches using machine learning as well as deep learning by organizing the methods into eight ’novel’ categories based on the kind of input features the methods operate upon. Such a categorization has not been done previously to the best of our knowledge. The discussion also includes a critical analysis of the various methods under each category including insights obtained by cross comparison, strengths/weaknesses of each method as well as the various limitations and challenges. The article also includes current challenges in malware detection like code obfuscation, adversarial attacks, real-time detection, concept drift and evolving malware, explainability and trust in ML/DL models and various areas for futuristic research endeavors like anomaly detection based malware detection, enhancing adversarial robustness of the models, employing attention mechanisms, explainable malware detection, detection of hibernating malware.},
  content_type = {Article},
}


@article{springer_10_1186_s42400_020_00049_3,
  title = {Layered obfuscation: a taxonomy of software obfuscation techniques for layered security},
  author = {Xu, Hui and Zhou, Yangfan and Ming, Jiang and Lyu, Michael},
  journal = {Cybersecurity},
  year = {2020},
  volume = {3},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-020-00049-3},
  url = {https://doi.org/10.1186/s42400-020-00049-3},
  abstract = {Abstract Software obfuscation has been developed for over 30 years. A problem always confusing the communities is what security strength the technique can achieve. Nowadays, this problem becomes even harder as the software economy becomes more diversified. Inspired by the classic idea of layered security for risk management, we propose layered obfuscation as a promising way to realize reliable software obfuscation. Our concept is based on the fact that real-world software is usually complicated. Merely applying one or several obfuscation approaches in an ad-hoc way cannot achieve good obscurity. Layered obfuscation, on the other hand, aims to mitigate the risks of reverse software engineering by integrating different obfuscation techniques as a whole solution. In the paper, we conduct a systematic review of existing obfuscation techniques based on the idea of layered obfuscation and develop a novel taxonomy of obfuscation techniques. Following our taxonomy hierarchy, the obfuscation strategies under different branches are orthogonal to each other. In this way, it can assist developers in choosing obfuscation techniques and designing layered obfuscation solutions based on their specific requirements.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_34238_8_9,
  title = {Authorship Attribution},
  author = {Alrabaee, Saed and Debbabi, Mourad and Shirani, Paria and Wang, Lingyu and Youssef, Amr and Rahimian, Ashkan and Nouh, Lina and Mouheb, Djedjiga and Huang, He and Hanna, Aiman},
  booktitle = {Advances in Information Security},
  year = {2020},
  pages = {211-230},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-34238-8\_9},
  url = {https://doi.org/10.1007/978-3-030-34238-8\_9},
  abstract = {Binary authorship attribution refers to the process of discovering information related to the author(s) of anonymous binary code on the basis of stylometric characteristics extracted from the code. However, in practice, authorship attribution for binary code still requires considerable manual and error-prone reverse engineering analysis, which can be a daunting task given the sheer volume and complexity of today’s malware. In this chapter, we propose BinAuthor , a novel and the first compiler-agnostic method for identifying the authors of program binaries. Having filtered out unrelated functions (compiler and library) to detect user-related functions, it converts user-related functions into a canonical form to eliminate compiler/compilation effects. Then, it leverages a set of features based on collections of authors’ choices made during coding. These features capture an author’s programming coding habits.},
  content_type = {Chapter},
}


@article{springer_10_1007_s00521_021_05813_1,
  title = {Character-based handwritten text transcription with attention networks},
  author = {Poulos, Jason and Valle, Rafael},
  journal = {Neural Computing and Applications},
  year = {2021},
  volume = {33},
  number = {16},
  pages = {10563-10573},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-021-05813-1},
  url = {https://doi.org/10.1007/s00521-021-05813-1},
  abstract = {The paper approaches the task of handwritten text recognition (HTR) with attentional encoder–decoder networks trained on sequences of characters, rather than words. We experiment on lines of text from popular handwriting datasets and compare different activation functions for the attention mechanism used for aligning image pixels and target characters. We find that softmax attention focuses heavily on individual characters, while sigmoid attention focuses on multiple characters at each step of the decoding. When the sequence alignment is one-to-one, softmax attention is able to learn a more precise alignment at each step of the decoding, whereas the alignment generated by sigmoid attention is much less precise. When a linear function is used to obtain attention weights, the model predicts a character by looking at the entire sequence of characters and performs poorly because it lacks a precise alignment between the source and target. Future research may explore HTR in natural scene images, since the model is capable of transcribing handwritten text without the need for producing segmentations or bounding boxes of text in images.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_16_5662_0_8,
  title = {Assembly Language and Operating Systems},
  author = {Wang, Shuangbao Paul},
  booktitle = {Computer Architecture and Organization},
  year = {2021},
  pages = {213-242},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-5662-0\_8},
  url = {https://doi.org/10.1007/978-981-16-5662-0\_8},
  abstract = {Assembly language is the closest computer language to communicate with computers. It is the machine language (1s and 0s) that a CPU uses to operate in an easy to remember and understand format. Only assembly language can take the full advantages of the processor architecture, and it is hardware dependent. For example, Intel and AMD processors use different assembly languages. Even within the Intel processors, different CPUs have different assembly language instructions, even though many of them may be the same.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10207_020_00491_x,
  title = {Do not let Next-Intent Vulnerability be your next nightmare: type system-based approach to detect it in Android apps},
  author = {El-Zawawy, Mohamed A. and Losiouk, Eleonora and Conti, Mauro},
  journal = {International Journal of Information Security},
  year = {2021},
  volume = {20},
  number = {1},
  pages = {39-58},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-020-00491-x},
  url = {https://doi.org/10.1007/s10207-020-00491-x},
  abstract = {Android is currently the most widespread operating system (OS) worldwide, but also the most prone to attacks. Despite the challenges faced by Industry and Academia to improve the Android OS security, it still has several vulnerabilities. Among those, the severity of the Next-Intent Vulnerability (NIV) can be immediately grasped. Android apps are made of components, which by default are private and cannot be targeted by other apps on the same phone. However, NIV allows any app to access the private components of a different app, eventually generating a crash or stealing sensitive data. NIV occurs when there is a chain of calls among different components based on the Intent messaging model and there is no control over the reliability of the first component triggering the call. NIV was first detected in 2013, but it is still an open issue. In this paper, we present Next-Intent Vulnerability Detector ( \\(\\mathcal \{N\}\\hbox \{I\}\\mathcal \{V\}\\hbox \{D\}\\) ), a novel approach to detect NIV in Android apps by relying on type systems. \\(\\mathcal \{N\}\\hbox \{I\}\\mathcal \{V\}\\hbox \{D\}\\) applies the inference rules of its type system to the app execution paths containing a sequence of calls to three NIV-related Android APIs. Compared to the state-of-the-art, \\(\\mathcal \{N\}\\hbox \{I\}\\mathcal \{V\}\\hbox \{D\}\\) is faster and more efficient, without losing precision in detecting NIV. Finally, through \\(\\mathcal \{N\}\\hbox \{I\}\\mathcal \{V\}\\hbox \{D\}\\) Google Photos was found to be vulnerable, and we disclosed the finding on the Google official bug report website (issue number 124342801).},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_79584_9_3,
  title = {Schema Translation},
  author = {Fong, Joseph S. P. and Wong Ting Yan, Kenneth},
  booktitle = {Information Systems Reengineering, Integration and Normalization},
  year = {2021},
  pages = {77-131},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-79584-9\_3},
  url = {https://doi.org/10.1007/978-3-030-79584-9\_3},
  abstract = {A database system consists of three components: schemas, data, and programs. Database reengineering starts with the schema, which defines the meaning of data and their relationship in different models. Only after a schema has been redefined can data and programs then be reengineered into a new database system, which makes use of the translated schema. Schema translation is the process of changing a schema expressed in one data model into an equivalent schema expressed in a different data model.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_979_8_8688_0057_3_9,
  title = {Security Operations},
  author = {Bouke, Mohamed Aly},
  booktitle = {Certification Study Companion Series},
  year = {2023},
  pages = {569-644},
  publisher = {Apress},
  doi = {10.1007/979-8-8688-0057-3\_9},
  url = {https://doi.org/10.1007/979-8-8688-0057-3\_9},
  abstract = {In the multifaceted world of information security, the domain of Security Operations stands as a critical pillar, holding a central position in the CISSP examination. This chapter delves into the intricate daily operations that are instrumental in safeguarding the confidentiality, integrity, and availability of information within an organization, a task paramount in today’s digitally connected era.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_1275_9_17,
  title = {Host-Server-Based Malware Detection System for Android Platforms Using Machine Learning},
  author = {Fatima, Anam and Kumar, Saurabh and Dutta, Malay Kishore},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {195-205},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-1275-9\_17},
  url = {https://doi.org/10.1007/978-981-15-1275-9\_17},
  abstract = {The popularity and openness of Android have made it the easy target of malware operators acting mainly through malware-spreading apps. This requires an efficient malware detection system which can be used in mass market and is capable of mitigating zero-day threats as opposed to signature-based approach which requires regular update of database. In this paper, an efficient host-server-based malicious app detection system is presented where on-device feature extraction is performed for the app to be analyzed and extracted features are sent over to remote server where machine learning is applied for malware analysis and detection. At server-end, static features such as permissions, app components, etc., have been used to train classifier using random forest algorithm resulting in detection accuracy of more than 97\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_94822_1_16,
  title = {Longitudinal Compliance Analysis of Android Applications with Privacy Policies},
  author = {Hashmi, Saad Sajid and Waheed, Nazar and Tangari, Gioacchino and Ikram, Muhammad and Smith, Stephen},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2022},
  pages = {280-305},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-94822-1\_16},
  url = {https://doi.org/10.1007/978-3-030-94822-1\_16},
  abstract = {Contemporary mobile applications (apps) are designed to track, use, and share users’ data, often without their consent, which results in potential privacy and transparency issues. To investigate whether mobile apps have always been (non-)transparent regarding how they collect information about users, we perform a longitudinal analysis of the historical versions of 268 Android apps. These apps comprise 5,240 app releases or versions between 2008 and 2016. We detect inconsistencies between apps’ behaviors and the stated use of data collection in privacy policies to reveal compliance issues. We utilize machine learning techniques to classify the privacy policy text and identify the purported practices that collect and/or share users’ personal information, such as phone numbers and email addresses. We then uncover the data leaks of an app through static and dynamic analysis. Over time, our results show a steady increase in the number of apps’ data collection practices that are undisclosed in the privacy policies. This behavior is particularly troubling since privacy policy is the primary tool for describing the app’s privacy protection practices. We find that newer versions of the apps are likely to be more non-compliant than their preceding versions. The discrepancies between the purported and the actual data practices show that privacy policies are often incoherent with the apps’ behaviors, thus defying the ‘notice and choice’ principle when users install apps.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_96630_0_11,
  title = {Explainable Artificial Intelligence for Smart City Application: A Secure and Trusted Platform},
  author = {Kabir, M. Humayun and Hasan, Khondokar Fida and Hasan, Mohammad Kamrul and Ansari, Keyvan},
  booktitle = {Studies in Computational Intelligence},
  year = {2022},
  pages = {241-263},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-96630-0\_11},
  url = {https://doi.org/10.1007/978-3-030-96630-0\_11},
  abstract = {Artificial Intelligence (AI) is one of the disruptive technologies that is shaping the future. It has growing applications for data-driven decisions in major smart city solutions, including transportation, education, healthcare, public governance, and power systems. At the same time, it is gaining popularity in protecting critical cyber infrastructure from cyber threats, attacks, damages, or unauthorized access. However, one of the significant issues of those traditional AI technologies (e.g., deep learning) is that the rapid progress in complexity and sophistication propelled and turned out to be uninterpretable black boxes. On many occasions, it is very challenging to understand the decision and bias to control and trust systems’ unexpected or seemingly unpredictable outputs. It is acknowledged that the loss of control over interpretability of decision-making becomes a critical issue for many data-driven automated applications. But how may it affect the system’s security and trustworthiness? This chapter conducts a comprehensive study of machine learning applications in cybersecurity to indicate the need for explainability to address this question. While doing that, this chapter first discusses the black-box problems of AI technologies for Cybersecurity applications in smart city-based solutions. Later, considering the new technological paradigm, Explainable Artificial Intelligence (XAI), this chapter discusses the transition from black-box to white-box. This chapter also discusses the transition requirements concerning the interpretability, transparency, understandability, and Explainability of AI-based technologies in applying different autonomous systems in smart cities. Finally, it has presented some commercial XAI platforms that offer explainability over traditional AI technologies before presenting future challenges and opportunities.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_22390_7_20,
  title = {Dissecting Applications Uninstallers and Removers: Are They Effective?},
  author = {Botacin, Marcus and Grégio, André},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {339-359},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-22390-7\_20},
  url = {https://doi.org/10.1007/978-3-031-22390-7\_20},
  abstract = {Developing a safe application is so important as to properly install it in a system, and not an application’s tampered version. In a similar note, developers should properly care about applications’ uninstall process to avoid leaving traces of sensitive data behind in the system or interfere with the remaining applications. Until now, the academic literature has paid little attention to uninstall procedures so far. Moreover, a whole ecosystem of application uninstallers has been created, making multiple uninstallers available in software repositories. A key point is to understand how these applications work so as to develop stronger systems. To this end, we present a landscape work evaluating the operation of the 11 most downloaded uninstaller applications from the three most popular Internet software repositories. We discovered that most of these applications are not very different from the native Windows uninstaller. Although evaluated uninstallers present a more organized User Interface, thus enhancing usability, they are only able to find the same installed application as the native Windows uninstaller, but not broken installations. Few uninstallers apply heuristics to find broken application installations. However, we show that those heuristics can be abused by attackers to remove third applications. Finally, we also show that none of the removers is resistant to malicious uninstallers that terminate the remover process.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_89554_9_13,
  title = {Security and Privacy Threats in IoT-Enabled Smart Cities},
  author = {Koshy, Aditya Sam and Fatima, Nida and Agarwal, Parul and Rodrigues, Joel J. P. C.},
  booktitle = {Internet of Things},
  year = {2022},
  pages = {277-300},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-89554-9\_13},
  url = {https://doi.org/10.1007/978-3-030-89554-9\_13},
  abstract = {Presently, the globe is going through development in smart cities as the Internet of Things (IoT) is capable of connecting with almost every object in the environment through sensors, cloud, end user devices, and user interface. This is possible because of the uprising in information technology day by day, thereafter contributing to the social and economic welfare of citizens. The Internet is becoming more integrated in daily life as managed by the Internet of Things. As IoT devices embrace novel endless opportunities to make life easier for people, they also increase the risk of data breaches, unsuspected users, and malicious attacks in the IoT framework. So preserving security and privacy from threats and attacks is an endowing challenge that is faced by IoT devices. It is known to an extent that data are more vulnerable in terms of security and privacy, because of integrated features implemented in the Internet of Things. Consequently, it is more prone to cyber threats and attacks despite the fact that it brings unbounded comfort and social security. Resolving these challenges and promising security and privacy of information against threats and attacks should be the prime priority while designing and implementing the architecture of Internet of things (IoT). However, the end user ought to trust that IoT devices and services provided by them are safe and secure. IoT devices protection needs to be considered while designing the framework, to protect it from any kind of threat and attack while keeping in mind ethics and policies which are utilized by the Internet of Things mechanization. In this chapter, privacy and security issues are discussed along with threats and attacks. Overview of the Interest of Things (IoT) is discussed in the beginning. Research work done in the past is also reviewed and examined with state of the art whereupon highlighting techniques utilized including the objectives and limitations. Additionally, this chapter covers layers of the Internet of Things (IoT) with the network of IoT and security and challenges in each layer of IoT architecture. Major security issues are also considered, followed by a discussion about Smart City Applications with their threats and solutions precisely to preserve concealment of Internet of Things (IoT) devices.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_1682_8_6,
  title = {The Tool Bag},
  author = {Gunasekera, Sheran},
  booktitle = {Android Apps Security},
  year = {2020},
  pages = {121-144},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1682-8\_6},
  url = {https://doi.org/10.1007/978-1-4842-1682-8\_6},
  abstract = {The techniques in this book are heavily reliant on external tools. This book does not teach you how to develop those tools but attempts to enlighten you on how you can make use of these tools to both build and test your apps. That’s why I have dramatically decided to call this chapter “The Tool Bag.” I will also spend a little time telling you about my setup that I use when reverse engineering and debugging Android apps. Your mileage will considerably vary, and perhaps you do not want to or are unable to set up your environment this way. This is fine. You can still get the job done, so don’t fret too much. In this chapter, I will talk about tools that I use to build, test, and break Android apps. The list will be a combination of free and commercial tools that I use personally in my daily routines depending on whether I am wearing a builder hat or breaker hat. I skew toward breaker by nature and by the career that I have had. This may be apparent in the dearth of the builder tools covered here, but it will cover the basics of what you need so that you can build your apps and then ensure that they are secure.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_031_20137_0_8,
  title = {LOW-MAGNITUDE INFILL STRUCTURE MANIPULATION ATTACKS ON FUSED FILAMENT FABRICATION 3D PRINTERS},
  author = {Rais, Muhammad Haris and Ahsan, Muhammad and Sharma, Vaibhav and Barua, Radhika and Prins, Rob and Ahmed, Irfan},
  booktitle = {IFIP Advances in Information and Communication Technology},
  year = {2022},
  pages = {205-232},
  publisher = {Springer Nature Switzerland},
  doi = {10.1007/978-3-031-20137-0\_8},
  url = {https://doi.org/10.1007/978-3-031-20137-0\_8},
  abstract = {As 3D printing applications in industry verticals increase, researchers have been developing new attacks on additive manufacturing processes and appropriate defense techniques. A major attack category on additive manufacturing processes is printed object sabotage. If an attack causes obvious deformations, the part will be rejected before it is used. However, the inherent layer-by-layer printing process enables malicious actors to induce hidden defects in the internal layers of finished parts. The stealthiness of an attack increases its chances of evading detection and the printed part being used in an operational environment where it can cause harm. Several detection schemes have been proposed for identifying attacks on external and internal features of printed objects, but all these schemes have detection thresholds that are well above printer accuracy. Reducing the attack magnitude to the order of printer accuracy can evade detection. This chapter describes two infill structure manipulation attacks that are easy to launch at the cyber-physical boundary and evade conventional cyber security tools by employing subtle printed part variations below the detection horizon. Specifically, the magnitudes of the variations fall within the printer resolution and trueness values, rendering it challenging for detection schemes to differentiate printed part modifications from benign printing errors. Destructive testing demonstrates that the infill structure manipulation attacks consistently reduce the strength of printed parts. This chapter also highlights the need to incorporate the physical characteristics of printed parts in attack detection.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_031_05324_5_12,
  title = {Quantum Software Tools Overview},
  author = {Cruz-Lemus, José A. and Serrano, Manuel A.},
  booktitle = {Quantum Software Engineering},
  year = {2022},
  pages = {229-250},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-031-05324-5\_12},
  url = {https://doi.org/10.1007/978-3-031-05324-5\_12},
  abstract = {This chapter provides an overview of state-of-the-art quantum software technologies: quantum programming languages, quantum software simulators and design environments, quantum tools and libraries, quantum annealing environments, and quantum software development and run platforms.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_34238_8_2,
  title = {Binary Analysis Overview},
  author = {Alrabaee, Saed and Debbabi, Mourad and Shirani, Paria and Wang, Lingyu and Youssef, Amr and Rahimian, Ashkan and Nouh, Lina and Mouheb, Djedjiga and Huang, He and Hanna, Aiman},
  booktitle = {Advances in Information Security},
  year = {2020},
  pages = {7-44},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-34238-8\_2},
  url = {https://doi.org/10.1007/978-3-030-34238-8\_2},
  abstract = {When the source code is unavailable, it is important for security applications, such as malware detection, software license infringement , vulnerability analysis , and digital forensics to be able to efficiently extract meaningful fingerprints from the binary code. Such fingerprints will enhance the effectiveness and efficiency of reverse engineering tasks as they can provide a range of insights into the program binaries. However, a great deal of important information will likely be lost during the compilation process, including variable and function names, the original control and data flow structures, comments, and layout. In this chapter, we provide a comprehensive review of existing binary code fingerprinting frameworks. As such, we systematize the study of binary code fingerprints based on the most important dimensions: the applications that motivate it, the approaches used and their implementations, the specific aspects of the fingerprinting framework, and how the results are evaluated.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_1682_8_7,
  title = {Hacking Your App \#2},
  author = {Gunasekera, Sheran},
  booktitle = {Android Apps Security},
  year = {2020},
  pages = {145-172},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-1682-8\_7},
  url = {https://doi.org/10.1007/978-1-4842-1682-8\_7},
  abstract = {We're going to take apart some apps in this chapter. This time, we will examine what an app looks like while it is running. Stepping through machine code is not my intention in this chapter. Instead, we are going to look at how we can reveal the inner workings of an app by tracing back from its functionality and user interface. A key skill that will unlock this all for us is called dynamic analysis.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_16_0666_3_50,
  title = {Validation and Feasibility of Differentially Private Local Aggregation of Real-Time Data Streams from Resource-Constrained Healthcare IoT Edge Devices},
  author = {Vaidya, Niramay and Shelke, Srishti and Shahani, Snehkumar and Abraham, Jibi},
  booktitle = {Lecture Notes in Networks and Systems},
  year = {2021},
  pages = {607-620},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-0666-3\_50},
  url = {https://doi.org/10.1007/978-981-16-0666-3\_50},
  abstract = {Differential privacy (DP) techniques provide important mathematical guarantees of privacy and in particular local DP mechanisms used to protect individual privacy without needing to trust any external entity. However, validation of these techniques is usually carried out using static datasets since IoT devices generating real-time streaming data pose additional difficulties. Hence, current work aims to validate the effectiveness of one such scheme, Privacy-Preserving Endpoint Aggregation (PPEA), on real-time private data obtained from resource-constrained edge devices by measuring utility metrics for the average operation aggregate function. This paper aims to study the feasibility of implementing PPEA for periodic real-time heart rate collection from fitness trackers, which are pervasive IoT devices within the personal healthcare domain capable of recording individual's private data, by considering factors like memory consumption, execution time, and power consumption. We address challenges concerning resource limitations on edge devices regarding lacking out-of-the-box provisions for implementing randomization techniques to achieve DP on streaming data.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s00607_022_01069_2,
  title = {Formal model for inter-component communication and its security in android},
  author = {El-Zawawy, Mohamed A. and Faruki, Parvez and Conti, Mauro},
  journal = {Computing},
  year = {2022},
  volume = {104},
  number = {8},
  pages = {1839-1865},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00607-022-01069-2},
  url = {https://doi.org/10.1007/s00607-022-01069-2},
  abstract = {Abstract The Android application framework has a pervasive presence. In early 2021, Android has over \$\$70\\\%\$\$ 70 \% share of the operating system mobile market (according to GlobalStats ). Components are the main building blocks of Android Applications. These blocks communicate via a rich Inter-Component Communication (ICC) model rather than the traditional inter-process communication model. , -filters, and their resolution (matching) algorithm are main elements of the ICC. However, the resolution algorithm is not robust enough and has flaws that can lead to security breaches. In this paper, we present DLAIR, as an enrichment of the resolution algorithm to overcome its security issues. To this end, we start by presenting a formal model to express and validate the ICC semantics. This includes defining key properties guaranteeing consistent and realistic semantic states. We then demonstrate how the semantics can be used to formally validate ICC aspects and to express and check ICC system updates. We verified our proposed model and all its lemmas and theorems in the Coq Proof Assistant, a machine-assisted verification tool. We extend our semantics to develop DLAIR which is assisted by a heuristic, and lightweight tool, LekInt. This tool identifies suspicious execution paths responsible for based sensitive user-information leakage. On a dataset of 2000 real-world apps, we evaluated LekInt against Flowdroid, a state-of-the-art information leakage analysis tool. Experiments show that LekInt is more effective and efficient than Flowdroid which has a higher false-negative rate and lower false-positive rate than LekInt. Considering the dynamic context in which LekInt is designed to work, the advantage of efficiency overcomes the disadvantage of higher false-negative.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_33_4400_6_15,
  title = {Machine Learning Aided 2D-3D Architectural Form Finding at High Resolution},
  author = {Zhang, Hang and Huang, Ye},
  booktitle = {Proceedings of the 2020 DigitalFUTURES},
  year = {2021},
  pages = {159-168},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-33-4400-6\_15},
  url = {https://doi.org/10.1007/978-981-33-4400-6\_15},
  abstract = {Abstract In the past few years, more architects and engineers start thinking about the application of machine learning algorithms in the architectural design field such as building facades generation or floor plans generation, etc. However, due to the relatively slow development of 3D machine learning algorithms, 3D architecture form exploration through machine learning is still a difficult issue for architects. As a result, most of these applications are confined to the level of 2D. Based on the state-of-the-art 2D image generation algorithm, also the method of spatial sequence rules, this article proposes a brand-new strategy of encoding, decoding, and form generation between 2D drawings and 3D models, which we name 2D-3D Form Encoding WorkFlow. This method could provide some innovative design possibilities that generate the latent 3D forms between several different architectural styles. Benefited from the 2D network advantages and the image amplification network nested outside the benchmark network, we have significantly expanded the resolution of training results when compared with the existing form-finding algorithm and related achievements in recent years.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_78459_1_23,
  title = {Investigating Protected Health Information Leakage from Android Medical Applications},
  author = {Grispos, George and Flynn, Talon and Glisson, William Bradley and Choo, Kim-Kwang Raymond},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {311-322},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-78459-1\_23},
  url = {https://doi.org/10.1007/978-3-030-78459-1\_23},
  abstract = {As smartphones and smartphone applications are widely used in a healthcare context (e.g., remote healthcare), these devices and applications may need to comply with the Health Insurance Portability and Accountability Act (HIPAA) of 1996. In other words, adequate safeguards to protect the user’s sensitive information (e.g., personally identifiable information and/or medical history) are required to be enforced on such devices and applications. In this study, we forensically focus on the potential of recovering residual data from Android medical applications, with the objective of providing an initial risk assessment of such applications. Our findings (e.g., documentation of the artifacts) also contribute to a better understanding of the types and location of evidential artifacts that can, potentially, be recovered from these applications in a digital forensic investigation.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_74575_2_7,
  title = {Revisiting the Approaches, Datasets and Evaluation Parameters to Detect Android Malware: A Comparative Study from State-of-Art},
  author = {Siddikk, Abu Bakkar and Muntasir, Md. Fahim and Lia, Rifat Jahan and Rahman, Sheikh Shah Mohammad Motiur and Islam, Takia and Alazab, Mamoun},
  booktitle = {Studies in Big Data},
  year = {2021},
  pages = {125-141},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-74575-2\_7},
  url = {https://doi.org/10.1007/978-3-030-74575-2\_7},
  abstract = {Alongside the recognition of the android operating system (OS), android malware is on the increase. Cybercriminals are using different techniques to develop malware for android devices. In addition, malware authors are trying to make malicious android applications that severely undermine the potential of traditional malware detectors. The key purpose of the chapter is to analyze and have a different appearance at various techniques of Android malware detection in a variety of research articles. However, this chapter presents an analysis of varied android malware detection approaches and comparing them to supported various parameters like detection technique, analysis method, features extracted and so on. The experiments are based on substantial malware datasets, evaluation parameters and this study employ a wide variety of machine learning techniques, including decision trees and random forests, support vector machines, logistic model trees, and artificial neural networks, also Deep learning techniques. It is a comparative analysis that should be useful in this field for researchers. The analysis shows, based on simple criteria, the similarities and differences in essential published research in addition to the accuracy. Thus, this chapter aims to study various android malware detection techniques and to identify plausible research directions. The findings showed that machine learning, with greater detection accuracy, is a more promising method. In order to achieve improved accuracy, future researchers can pursue a deep learning approach with the use of a large dataset.},
  content_type = {Chapter},
}


@article{springer_10_1007_s00521_022_07707_2,
  title = {Definition, approaches, and analysis of code duplication detection (2006–2020): a critical review},
  author = {Chen, Chang-Feng and Zain, Azlan Mohd and Zhou, Kai-Qing},
  journal = {Neural Computing and Applications},
  year = {2022},
  volume = {34},
  number = {23},
  pages = {20507-20537},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00521-022-07707-2},
  url = {https://doi.org/10.1007/s00521-022-07707-2},
  abstract = {Code duplication detection is the act of finding similar code in software development. It is important for software engineer to address the issues of code duplication detection. In this paper, a critical review of previous works on code duplication for code clone and plagiarism detection is performed. The review involves five main parts. Firstly, a systematic literature review is conducted to confirm the selected articles. Secondly, a critical review of different code duplication approaches is conducted based on three phases; processing, detection, and decision. Thirdly, statistical analysis of the number of review articles is performed to show the trends and hots of code duplication research. Moreover, quantitative analysis of different code duplication approaches is presented to show the effectiveness of different approaches. Fourthly, the advantages and disadvantages of different approaches and techniques are summarized and discussed. Finally, the conclusion of the review is summarized and future research direction of code duplication is described.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_16_7913_1_5,
  title = {Realization of Safety Reinforced Terminal Equipment for Secondary System of Substation},
  author = {Wang, Xiaoming and Zhou, Ke and Wu, Congyun},
  booktitle = {Communications in Computer and Information Science},
  year = {2021},
  pages = {58-74},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-16-7913-1\_5},
  url = {https://doi.org/10.1007/978-981-16-7913-1\_5},
  abstract = {With the high integration of informatization and industrialization, the degree of intelligence and automation of the secondary system of substations has been continuously enhanced. While enjoying the convenience, we also need to face the challenges and threats brought by the Internet. Given the confidentiality, integrity, and other security threats that the secondary system applications or tools may face during the calculation and transmission process, the safety reinforced terminal protection technology based on the USB interface has become a research hotspot. Although traditional safety reinforced equipment is easy to produce, the algorithms in it have been specified by the manufacturer and downloaded to the corresponding equipment. Considering that the security requirements of different scenarios are quite different, and different users have multi-level security requirements, the AVR microcontroller is programmed through the Arduino IDE platform, and a safety-reinforced terminal device with a customizable encryption algorithm is designed and implemented, which not only realizes functions such as identity authentication and content encryption, but also meets the personalized needs of users’ independent choices, and improves the security and controllability of the entire secondary system. After the test, the usability and robustness of the terminal are preliminarily proved.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10207_023_00669_z,
  title = {Secure cloud-based mobile apps: attack taxonomy, requirements, mechanisms, tests and automation},
  author = {Chimuco, Francisco T. and Sequeiros, João B. F. and Lopes, Carolina Galvão and Simões, Tiago M. C. and Freire, Mário M. and Inácio, Pedro R. M.},
  journal = {International Journal of Information Security},
  year = {2023},
  volume = {22},
  number = {4},
  pages = {833-867},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00669-z},
  url = {https://doi.org/10.1007/s10207-023-00669-z},
  abstract = {Abstract The adoption and popularization of mobile devices, such as smartphones and tablets, accentuated after the second decade of this century, has been motivated by the growing number of mobile applications, which can solve problems in different areas of contemporary societies. Conversely, the software development industry is motivated by the increasing number and quality of resources that mobile devices possess nowadays (e.g., memory, sensors, processing power or battery). While powerful mobile devices do exist, one of the main driving factors behind the increase of resources is the usage of Cloud technology, which strongly complement mobile computing. As expected, the adoption of measures to mitigate security issues has not accompanied the growth and speed of development for Cloud and Mobile software, to ensure that these are resilient to attacks by design. Aiming to contribute to decrease the gap between software and security engineering, this paper presents a deep approach to attack taxonomy, security mechanisms, and security test specification for the Cloud and Mobile ecosystem of applications. This is also the first time an encompassing and conjoined approach is provided for attack taxonomy and specification of security tests automation tools for this ecosystem.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_74664_3_2,
  title = {Background and Related Work},
  author = {Billah Karbab, ElMouatez and Debbabi, Mourad and Derhab, Abdelouahid and Mouheb, Djedjiga},
  booktitle = {Advances in Information Security},
  year = {2021},
  pages = {7-39},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-74664-3\_2},
  url = {https://doi.org/10.1007/978-3-030-74664-3\_2},
  abstract = {In this chapter, we review and compare the state-of-the-art proposals on Android malware analysis and detection according to a novel taxonomy. Due to the large number of published contributions, we focus our review on the most prominent articles in terms of novelty and contributions, with an emphasis on those published in top-tier security journals and conferences. The proposed taxonomy is based on the generality of Android malware threats. It classifies the existing systems into: (1) general malware detection , which aims to detect malware without taking into account a particular type of attack, and (2) attack-based malware detection , which aims at detecting specific attacks such as privilege escalation attacks, data leakage attacks, etc. Furthermore, each threat category is classified according to the system deployment of the detection approach, i.e., the physical environment into which the system is intended to run. Furthermore, we consider three main deployment architectures: workstation-based , mobile-based , and hybrid architectures. The proposed two-level taxonomy allows carrying out an objective and appropriate analysis by comparing only systems that are addressing the same threat category, and having the same deployment architecture as they share the same goals and have similar issues to solve.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11042_021_10647_z,
  title = {A new machine learning-based method for android malware detection on imbalanced dataset},
  author = {Dehkordy, Diyana Tehrany and Rasoolzadegan, Abbas},
  journal = {Multimedia Tools and Applications},
  year = {2021},
  volume = {80},
  number = {16},
  pages = {24533-24554},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11042-021-10647-z},
  url = {https://doi.org/10.1007/s11042-021-10647-z},
  abstract = {Nowadays, malware applications are dangerous threats to Android devices, users, developers, and application stores. Researchers are trying to discover new methods for malware detection because the complexity of malwares, their continuous changes, and damages caused by their attacks have increased. One of the most important challenges in detecting malware is to have a balanced dataset. In this paper, a detection method is proposed to identify malware to improve accuracy and reduce error rates by preprocessing the used dataset and balancing it. To attain these purposes, the static analysis is used to extract features of the applications. The ranking methods of features are used to preprocess the feature set and the low-effective features are removed. The proposed method also balances the dataset by using the techniques of undersampling, the Synthetic Minority Oversampling Technique (SMOTE), and a combination of both methods, which have not yet been studied among detection methods. Then, the classifiers of K-Nearest Neighbor (KNN), Support Vector Machine, and Iterative Dichotomiser 3 are used to create the detection model. The performance of KNN with SMOTE is better than the performance of the other classifiers. The obtained results indicate that the criteria of precision, recall, accuracy, F-measure, and Matthews Correlation Coefficient are over 97\%. The proposed method is effective in detecting 99.49\% of the malware’s existing in the used dataset and new malware.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_34080_3_46,
  title = {A Detailed Analysis of Data Security Issues in Android Devices},
  author = {Dutta, Ditipriya and Agarwal, Shubham and Dash, Ria and Sahoo, Bhaswati},
  booktitle = {Lecture Notes on Data Engineering and Communications Technologies},
  year = {2020},
  pages = {410-417},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-34080-3\_46},
  url = {https://doi.org/10.1007/978-3-030-34080-3\_46},
  abstract = {People believe that any sufficiently advanced technology is indistinguishable from magic. The ability to analyze and act on data is increasingly gaining importance in this ever-expanding world. Data forms an integral part of the identity of an individual or an organization. However, as data is getting digitized and more information is being shared online via various social media platforms and apps that are specifically designed to cater to the needs of users, data privacy is becoming a matter of extreme concern. Protecting data is of paramount importance because data in the hands of nefarious individuals or organizations can pose a massive threat to both the digital and real worlds alike. Data protection is not just about protecting one’s personal data, it also includes the protection of fundamental rights and freedom of the people associated with it. Every organization is in charge of personal data associated with either the organization itself or to the clients they serve. Protecting the identity of their customers is a very huge task in itself. Illegal extraction of private and personal data by malpractices is taking place every other second and as digitally-enhanced citizens, recognizing the deliberate attempts at data phishing should be our key concern. Personal data can be used to influence and control our decisions and somewhat mould our behaviour and hence, we, as an individual, have a lot at stake when it comes to protecting confidential information. In this paper, we will discuss the various data security issues in Android devices, until the launch of Android Nougat 7.0, and how data extraction without prior information is a threat to the security, integrity, and confidentiality of the users.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_020_09897_6,
  title = {Scalable online vetting of Android apps for measuring declared SDK versions and their consistency with API calls},
  author = {Wu, Daoyuan and Gao, Debin and Lo, David},
  journal = {Empirical Software Engineering},
  year = {2021},
  volume = {26},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-020-09897-6},
  url = {https://doi.org/10.1007/s10664-020-09897-6},
  abstract = {Android has been the most popular smartphone system with multiple platform versions active in the market. To manage the application’s compatibility with one or more platform versions, Android allows apps to declare the supported platform SDK versions in their manifest files. In this paper, we conduct a systematic study of this modern software mechanism. Our objective is to measure the current practice of declared SDK versions (which we term as DSDK versions afterwards) in real apps, and the (in)consistency between DSDK versions and their host apps’ API calls. To successfully analyze a modern dataset of 22,687 popular apps (with an average app size of 25MB), we design a scalable approach that operates on the Android bytecode level and employs a lightweight bytecode search for app analysis. This approach achieves a good performance suitable for online vetting in app markets, requiring only around 5 seconds to process an app on average. Besides shedding light on the characteristics of DSDK in the wild, our study quantitatively measures two side effects of inappropriate DSDK versions: (i) around 35\% apps under-set the minimum DSDK versions and could incur runtime crashes, but fortunately, only 11.3\% apps could crash on Android 6.0 and above; (ii) around 2\% apps, due to under-claiming the targeted DSDK versions, are potentially exploitable by remote code execution, and half of them invoke the vulnerable API via embedded third-party libraries. These results indicate the importance and difficulty of declaring correct DSDK , and our work can help developers fulfill this goal.},
  content_type = {Article},
}


@article{springer_10_1007_s10922_021_09634_4,
  title = {Effective and Efficient Hybrid Android Malware Classification Using Pseudo-Label Stacked Auto-Encoder},
  author = {Mahdavifar, Samaneh and Alhadidi, Dima and Ghorbani, Ali. A.},
  journal = {Journal of Network and Systems Management},
  year = {2022},
  volume = {30},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10922-021-09634-4},
  url = {https://doi.org/10.1007/s10922-021-09634-4},
  abstract = {Android has become the target of attackers because of its popularity. The detection of Android mobile malware has become increasingly important due to its significant threat. Supervised machine learning, which has been used to detect Android malware is far from perfect because it requires a significant amount of labeled data. Since labeled data is expensive and difficult to get while unlabeled data is abundant and cheap in this context, we resort to a semi-supervised learning technique, namely pseudo-label stacked auto-encoder (PLSAE), which involves training using a set of labeled and unlabeled instances. We use a hybrid approach of dynamic analysis and static analysis to craft feature vectors. We evaluate our proposed model on CICMalDroid2020, which includes 17,341 most recent samples of five different Android apps categories. After that, we compare the results with state-of-the-art techniques in terms of accuracy and efficiency. Experimental results show that our proposed framework outperforms other semi-supervised approaches and common machine learning algorithms.},
  content_type = {Article},
}


@article{springer_10_1007_s10207_023_00765_0,
  title = {Vulnerabilities and attacks assessments in blockchain 1.0, 2.0 and 3.0: tools, analysis and countermeasures},
  author = {Hamdi, Ahlem and Fourati, Lamia and Ayed, Samiha},
  journal = {International Journal of Information Security},
  year = {2024},
  volume = {23},
  number = {2},
  pages = {713-757},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-023-00765-0},
  url = {https://doi.org/10.1007/s10207-023-00765-0},
  abstract = {Nowadays, blockchain has become increasingly popular due to its promise of supporting critical business services in various areas. Blockchain systems, like Ethereum and Hyperledger Fabric, rely on sophisticated middleware, which enables the execution of smart contracts. Smart contracts define the business logic within cooperative applications. Detecting attacks and vulnerabilities within blockchain is a crucial issue for ensuring the security of different generations of blockchains. Testing a blockchain application serves multiple purposes: it ensures its quality, maximizes test coverage, and minimizes the risks associated with insufficient knowledge that could potentially impact the software development process. That is why several static analysis tools targeting Ethereum smart contracts and Hyperledger Fabric chaincode have recently been proposed by the blockchain research community. However, the efficiency of these analysis tools remains an open issue that requires further investigation. In this context, this paper presents a new taxonomy related to attacks targeting different generations of blockchain and evaluates the available analysis tools that can be utilized to assess the resilience of blockchain 2.0 and blockchain 3.0 against a range of vulnerabilities and attacks. Additionally, this study presents two quantitative analyses: one assessing the performance of tools in evaluating smart contract vulnerabilities within blockchain 2.0, and another analyzing the performance of tools in assessing blockchain 3.0 vulnerabilities within chaincode. Furthermore, this comprehensive study holds value for the research community as it considers various generations of blockchain.},
  content_type = {Article},
}


@article{springer_10_1007_s12652_021_03094_z,
  title = {Evaluation of sports training effect based on GABP neural network and artificial intelligence},
  author = {Yu, Li and He, Yifan},
  journal = {Journal of Ambient Intelligence and Humanized Computing},
  year = {2021},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12652-021-03094-z},
  url = {https://doi.org/10.1007/s12652-021-03094-z},
  abstract = {Sports training effect evaluation has a direct role in improving the effect of sports training. Based on the idea of artificial intelligence and the GABP neural network algorithm, this paper constructs a sports training effect evaluation model based on the GABP neural network. Moreover, this article vectorizes the code based on the sample matrix to improve code conciseness and increase computational efficiency. In addition, this article tests and evaluates the two neural networks that have been optimized for training, and analyzes and compares the nature of the network, topology, and parameter update methods. After testing, it is found that the trained GABP neural network can achieve the ideal high fitting accuracy of training samples and high generalization ability of test samples under the conditions of low memory usage and short training time. The experimental research results show that the model constructed in this paper meets the actual needs of sports training.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_6193_4_2,
  title = {Malware Analysis Lab Setup},
  author = {Mohanta, Abhijit and Saldanha, Anoop},
  booktitle = {Malware Analysis and Detection Engineering},
  year = {2020},
  pages = {25-50},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-6193-4\_2},
  url = {https://doi.org/10.1007/978-1-4842-6193-4\_2},
  abstract = {In this chapter, we talk about setting up the right malware analysis and reversing environment and configuring the tools needed for malware analysis. We also introduce new tools that we developed to make the analysis process faster and simpler.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_6218_1_10,
  title = {Debug},
  author = {Zheng, Gavin and Gao, Longxiang and Huang, Liqun and Guan, Jian},
  booktitle = {Ethereum Smart Contract Development in Solidity},
  year = {2021},
  pages = {281-314},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-6218-1\_10},
  url = {https://doi.org/10.1007/978-981-15-6218-1\_10},
  abstract = {Like other programming languages such as Java, C++, Solidity has some built-in mechanisms for debugging purpose.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_65474_0_15,
  title = {Exact and Linear-Time Gas-Cost Analysis},
  author = {Das, Ankush and Qadeer, Shaz},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {333-356},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-65474-0\_15},
  url = {https://doi.org/10.1007/978-3-030-65474-0\_15},
  abstract = {Blockchains support execution of smart contracts: programs encoding complex transactions between distrusting parties. Due to their distributed nature, blockchains rely on third-party miners to execute and validate transactions. Miners are compensated by charging users with gas based on the execution cost of the transaction. To compute the exact gas cost, blockchains track gas cost dynamically creating its own overhead. This paper presents a static exact gas-cost analysis technique that can be employed to eliminate dynamic gas tracking. This approach presents further benefits such as providing miners with a trusted gas bound that can be verified in linear time, and eliminating out-of-gas exceptions. To handle recursion and unbounded computation, we propose a novel amortization technique that stores gas inside data structures. We have implemented our analysis technique in a tool called GasBoX that takes a contract as input and infers the gas cost of its functions automatically. We have evaluated GasBoX on \\(13\\) standard smart contracts borrowed from real-world blockchain projects. Our soundness theorem proves that the gas bound inferred by GasBoX exactly matches the gas cost at runtime and no dynamic gas tracking is necessary.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11390_021_1647_7,
  title = {HRPDF: A Software-Based Heterogeneous Redundant Proactive Defense Framework for Programmable Logic Controller},
  author = {Liu, Ke and Wang, Jing-Yi and Wei, Qiang and Zhang, Zhen-Yong and Sun, Jun and Ma, Rong-Kuan and Deng, Rui-Long},
  journal = {Journal of Computer Science and Technology},
  year = {2021},
  volume = {36},
  number = {6},
  pages = {1307-1324},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11390-021-1647-7},
  url = {https://doi.org/10.1007/s11390-021-1647-7},
  abstract = {Programmable logic controllers (PLCs) play a critical role in many industrial control systems, yet face increasingly serious cyber threats. In this paper, we propose a novel PLC-compatible software-based defense mechanism, called Heterogeneous Redundant Proactive Defense Framework (HRPDF). We propose a heterogeneous PLC architecture in HRPDF, including multiple heterogeneous, equivalent, and synchronous runtimes, which can thwart multiple types of attacks against PLC without the need of external devices. To ensure the availability of PLC, we also design an inter-process communication algorithm that minimizes the overhead of HRPDF. We implement a prototype system of HRPDF and test it in a real-world PLC and an OpenPLC-based device, respectively. The results show that HRPDF can defend against multiple types of attacks with 10.22\% additional CPU and 5.56\% additional memory overhead, and about 0.6 ms additional time overhead.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_72654_6_42,
  title = {Effective and Potential Implications of Blockchain Technology for Auditing},
  author = {Silva, Romildo and Inácio, Helena and Marques, Rui Pedro},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {435-451},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-72654-6\_42},
  url = {https://doi.org/10.1007/978-3-030-72654-6\_42},
  abstract = {The development of blockchain technology and some of its peculiarities such as smart contracts and asset tokenization have important implications in the auditing environment. This paper aims to evaluate the current stage of blockchain technology application on auditing area, analyzing scientific publications since the emergence of this distributed ledger technology, identifying the main implications what is already reality and the potential effects of its improvements in the audit professionals’ activities performance, based on the proposals and suggestions on the main research indexed by Scopus and Web of Science databases. Through a proof of concept, this study advances with the contribution of demonstrating the creation and tracking a token on a public blockchain, evidencing the representation of assets in digital form, known as tokenization. The token example was created on the Ethereum testing platform (Ropsten Test Network). It is possible the traceability for different wallets and proof of ownership, for the purposes of possible disclosure to any interested with internet connection. The new possibilities, like real time auditing, associated with the conference of assets physical existence and their comparison of what is on the blockchain with the accounting records and the real world by the auditors represents a new reality and new challenges in terms of skills and knowledge.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_89137_4_4,
  title = {Mining Trojan Detection Based on Multi-dimensional Static Features},
  author = {Tang, Zixian and Wang, Qiang and Li, Wenhao and Bao, Huaifeng and Liu, Feng and Wang, Wen},
  booktitle = {Lecture Notes in Computer Science},
  year = {2021},
  pages = {51-65},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-89137-4\_4},
  url = {https://doi.org/10.1007/978-3-030-89137-4\_4},
  abstract = {The developing technic and the variety of Mining Trojan is increasingly threatening the computational resources from the weak-defend systems. Mining Trojan is illicitly implanted into the systems and mines cryptocurrency such as Bitcon through the hijacked resource. Previous work focuses on performing binary classification to identify a malicious software from the benign ones, but fail to classify the specific Mining Trojan. In order to tackle the above issues, in this paper, we propose a hierarchical detector, called Miner-Killer, to effectively and precisely classify Mining Trojans apart from the benign ones. First, Miner-Killer converts binary codes from Trojan samples to format files, assembly files and string files. Second, the static features are extracted by MSFV Extractor. Then, an ensemble learning model is trained by the extracted features and is applied to classify the unseen Mining Trojans. Experiments on two real-world datasets demonstrate that our proposed method can significantly detect the Mining Trojans, which outperforms the state-of-the-art methods applied to detect malware.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_98795_4_10,
  title = {Intelligent Malware Defenses},
  author = {Nadeem, Azqa and Rimmer, Vera and Joosen, Wouter and Verwer, Sicco},
  booktitle = {Lecture Notes in Computer Science},
  year = {2022},
  pages = {217-253},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-98795-4\_10},
  url = {https://doi.org/10.1007/978-3-030-98795-4\_10},
  abstract = {With rapidly evolving threat landscape surrounding malware, intelligent defenses based on machine learning are paramount. In this chapter, we review the literature proposed in the past decade and identify the state-of-the-art in various related research directions—malware detection, malware analysis, adversarial malware, and malware author attribution. We discuss challenges that emerge when machine learning is applied to malware. We also identify the key issues that need to be addressed by the research community in order to further deepen and systematize research in the malware domain.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10586_021_03491_1,
  title = {A review of smart contract-based platforms, applications, and challenges},
  author = {Sharma, Pratima and Jindal, Rajni and Borah, Malaya Dutta},
  journal = {Cluster Computing},
  year = {2023},
  volume = {26},
  number = {1},
  pages = {395-421},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10586-021-03491-1},
  url = {https://doi.org/10.1007/s10586-021-03491-1},
  abstract = {Blockchain is a modern technology that has gained enormous attention in scientific and practical applications. A smart contract is a digital transaction that runs, executes, and records the dynamic operation on the ledger automatically. A smart contract is the central aspect of a blockchain that facilitates blockchain as a platform outside the cryptocurrency spectrum. It applies to many applications such as education, voting, real estate, entertainment, IoT, supply chain, healthcare, and much more. While recent years have seen remarkable progress in developing blockchain technologies, emphasizing smart contracts, there is a lack of study of the smart contract concept. This paper extensively examines the core principles and guides recent research and advances in smart contracts. The study analyses are summarized in three key categories: (i) smart contract-based platforms and decentralized applications, (ii) risk problem identification, and (iii) potential solutions and future directions.},
  content_type = {Article},
}


@article{springer_10_1007_s00607_021_00954_6,
  title = {Blockchain-based public ecosystem for auditing security of software applications},
  author = {Hu, Qinwen and Asghar, Muhammad Rizwan and Zeadally, Sherali},
  journal = {Computing},
  year = {2021},
  volume = {103},
  number = {11},
  pages = {2643-2665},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s00607-021-00954-6},
  url = {https://doi.org/10.1007/s00607-021-00954-6},
  abstract = {Over the years, software applications have captured a big market ranging from smart devices (smartphones, smart wearable devices) to enterprise resource management including Enterprise Resource Planning, office applications, and the entertainment industry (video games and graphics design applications). Protecting the copyright of software applications and protection from malicious software (malware) have been topics of utmost interest for academia and industry for many years. The standard solutions use the software license key or rely on the Operating System (OS) protection mechanisms, such as Google Play Protect. However, some end users have broken these protections to bypass payments for applications that are not free. They have done so by downloading the software from an unauthorised website or by jailbreaking the OS protection mechanisms. As a result, they cannot determine whether the software they download is malicious or not. Further, if the software is uploaded to a third party platform by malicious users, the software developer has no way of knowing about it. In such cases, the authenticity or integrity of the software cannot be guaranteed. There is also a problem of information transparency among software platforms. In this study, we propose an architecture that is based on blockchain technology for providing data transparency, release traceability, and auditability. Our goal is to provide an open framework to allow users, software vendors, and security practitioners to monitor misbehaviour and assess software vulnerabilities for preventing malicious software downloads. Specifically, the proposed solution makes it possible to identify software developers who have gone rogue and are potentially developing malicious software. Furthermore, we introduce an incentive policy for encouraging security engineers, victims and software owners to participate in collaborative works. The outcomes will ensure the wide adoption of a software auditing ecosystem in software markets, specifically for some mobile device manufacturers that have been banned from using the open-source OS such as Android. Consequently, there is a demand for them to verify the application security without completely relying on the OS-specific security mechanisms.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_37629_1_74,
  title = {A Proposed Architecture Based on CNN for Feature Selection and Classification of Android Malwares},
  author = {Ilham, Soussi and Abderrahim, Ghadi and Abdelhakim, Boudhir Anouar},
  booktitle = {Lecture Notes in Intelligent Transportation and Infrastructure},
  year = {2020},
  pages = {1026-1037},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-37629-1\_74},
  url = {https://doi.org/10.1007/978-3-030-37629-1\_74},
  abstract = {Malware detection process is based principally on extracting data given to classifier model; those data are information about application’s behavior during its execution, permissions required by it or activities made in response to some commands. Which clearly make the features chosen and build as features vector highly influence the credibility of the model in classifying with high accuracy the unknown applications. For this reason, the research field gave a decent attention to resolve this problematic in malware detection models by improving the quality of features used in classification process, and performing feature selection processes in order to reduce dimensionality of features vectors, selecting most relevant, correlated and informative features and to eliminate redundant information. Many solutions were invented for this purpose using machine-learning algorithm to evaluate performance of classification using a specific set of features or by using filter feature selection algorithms that give a rank to each feature depending on its occurrence frequency, weight or its correlation. In this paper, we proposed an approach using CNN deep learning model for classifying and detecting android malwares as a solution for feature selection and redundancy problematic.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s12046_022_01980_6,
  title = {Defense against adversarial malware using robust classifier: DAM-ROC},
  author = {Selvaganapathy, Shymala Gowri and Sadasivam, Sudha},
  journal = {Sādhanā},
  year = {2022},
  volume = {47},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12046-022-01980-6},
  url = {https://doi.org/10.1007/s12046-022-01980-6},
  abstract = {Malware authors focus on deceiving and evading Anti Malware Engines (AME). Evasion attacks take in malware samples and modify those samples to by-pass ml based AME. Existing learning based anti-malware solutions are either too limited or insufficient to neutralize the threats arising from evasion attacks. This has necessitated a more comprehensive and robust solution. This research attempts to develop a secure learning framework entitled, damroc. The objective is to shield anti-malware entities against evasion attacks by making use of an adaptive adversarial training framework with novel retraining sample selector, (DAM-ROC OR) for dnn based learners. Usage of bnn along with possible quantification of predictive uncertainties is adapted. This generic framework, DAM-ROC is evaluated on benchmarked Android and Windows datasets to explore necessary trade-off between performance and robustness. DAM-ROC models are retrained to defend against gradient attacks like rBIMk, dBIMk, GRAMS and JSMA. Empirical results show that proposed DAM-ROC framework could increase robustness against multiple evasion attacks without compromising on performance when compared against two existing frameworks, SLEIPNIR and KBL. GRAMS retrained Bayesian models have demonstrated consistent performance against all considered attacks which is crucial for real world scenarios since it cannot be predicted in advance which attack will be deployed.},
  content_type = {Article},
}


@article{springer_10_1007_s10664_022_10131_8,
  title = {Characterizing usages, updates and risks of third-party libraries in Java projects},
  author = {Huang, Kaifeng and Chen, Bihuan and Xu, Congying and Wang, Ying and Shi, Bowen and Peng, Xin and Wu, Yijian and Liu, Yang},
  journal = {Empirical Software Engineering},
  year = {2022},
  volume = {27},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-022-10131-8},
  url = {https://doi.org/10.1007/s10664-022-10131-8},
  abstract = {Third-party libraries are a key building block in software development as they allow developers to reuse common functionalities instead of reinventing the wheel. However, third-party libraries and client projects are developed and continuously evolving in an asynchronous way. As a result, outdated third-party libraries might be commonly used in client projects, while developers are unaware of the potential risk (e.g., security bugs) in usages. Outdated third-party libraries might be updated in client projects in a delayed way, while developers are less aware of the potential risk (e.g., API incompatibilities) in updates. Developers of third-party libraries may be unaware of how their third-party libraries are used or updated in client projects. Therefore, a quantitative and holistic study on usages, updates and risks of third-party libraries in open-source projects can provide concrete evidence on these problems, and practical insights to improve the ecosystem sustainably. In this paper, we make the first contribution towards such a study in the Java ecosystem. First, using 806 open-source projects and 13,565 third-party libraries, we conduct a library usage analysis (e.g., usage intensity and usage outdatedness), followed by a library update analysis (e.g., update intensity and update delay). The two analyses aim to quantify usage and update practices from the two holistic perspectives of open-source projects and third-party libraries. Then, we carry out a library risk analysis (e.g., usage risk and update risk) on 806 open-source projects and 544 security bugs. This analysis aims to quantify the potential risk of using and updating outdated third-party libraries with respect to security bugs. Our findings suggest practical implications to developers and researchers on problems and potential solutions in maintaining third-party libraries (e.g., smart alerting and automated updating of outdated third-party libraries). To demonstrate the usefulness of our findings, we propose a security bug-driven alerting system, named LibSecurify , for assisting developers to make confident decisions by quantifying risks and effort when updating outdated third-party libraries. 33 open-source projects have confirmed the presence of security bugs after receiving our alerts, and 24 of those 33 have updated their third-party libraries. We have released our dataset to foster valuable applications and improve the Java third-party library ecosystem.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_5881_1_15,
  title = {Reading and Understanding Code},
  author = {Smith, Stephen},
  booktitle = {Programming with 64-Bit ARM Assembly Language},
  year = {2020},
  pages = {327-346},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-5881-1\_15},
  url = {https://doi.org/10.1007/978-1-4842-5881-1\_15},
  abstract = {We’ve now learned quite a bit of ARM 64-bit Assembly Language; one of the things we can do is read another programmer’s code. Reading another programmer’s code is a great way to not only add to our toolkit of tips and tricks but also improve our own coding. We’ll review some places where you can find Assembly source code for the ARM processor. We’ll examine one of the Assembly Language routines from the Linux kernel to learn some new optimization techniques. Then we’ll look at how the GNU C compiler writes Assembly code and how we can analyze it. We’ll look at the NSA’s Ghidra hacking tool that converts Assembly Language code back into C code—at least approximately.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_1_4842_7307_4_10,
  title = {Modules},
  author = {Sharan, Kishori and Davis, Adam L.},
  booktitle = {Beginning Java 17 Fundamentals},
  year = {2022},
  pages = {355-394},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7307-4\_10},
  url = {https://doi.org/10.1007/978-1-4842-7307-4\_10},
  abstract = {In this chapter, you will learn: how to declare modules, what the implicit readability of a module means and how to declare it, the difference between unqualified and qualified exports, declaring the runtime optional dependency of a module, and much more about modules in Java.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_7683_6_3,
  title = {Coarrays in the Context of XcalableMP},
  author = {Iwashita, Hidetoshi and Nakao, Masahiro},
  booktitle = {XcalableMP PGAS Programming Language},
  year = {2021},
  pages = {97-122},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-7683-6\_3},
  url = {https://doi.org/10.1007/978-981-15-7683-6\_3},
  abstract = {Abstract Coarray features have been implemented on the Omni XcalableMP compiler with a source-to-source translator and layered runtime libraries. Three memory allocation methods for coarrays were implemented for the GASNet and MPI-3 communication libraries and the native interface of Fujitsu. For the coarray PUT/GET communication, algorithms using DMA (zero-copy) and buffering were introduced. Important techniques for achieving high performance were the non-blocking PUT communication implemented in the runtime library and the optimization for the GET communication in the translator. Using the ping-pong benchmark and the modified version, the fundamental performance was evaluated and analyzed. The MPI version of the Himeno benchmark was ported to the coarray version and modified for fully using the non-blocking PUT. As a result of the evaluation, the non-blocking coarray version clearly outperformed the original and non-blocking MPI versions.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11390_020_9323_x,
  title = {Feature Selection for Malware Detection on the Android Platform Based on Differences of IDF Values},
  author = {Peynirci, Gökçer and Eminağaoğlu, Mete and Karabulut, Korhan},
  journal = {Journal of Computer Science and Technology},
  year = {2020},
  volume = {35},
  number = {4},
  pages = {946-962},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11390-020-9323-x},
  url = {https://doi.org/10.1007/s11390-020-9323-x},
  abstract = {Android is the mobile operating system most frequently targeted by malware in the smartphone ecosystem, with a market share significantly higher than its competitors and a much larger total number of applications. Detection of malware before being published on official or unofficial application markets is critically important due to the typical end users’ widespread security inadequacy. In this paper, a novel feature selection method is proposed along with an Android malware detection approach. The feature selection method proposed in this study makes use of permissions, API calls, and strings as features, which are statically extractable from the Android executables (APK files) and it can be used in a machine learning process with different algorithms to detect malware on the Android platform. A novel document frequencybased approach, namely Delta IDF, was designed and implemented for feature selection. Delta IDF was tested upon three universal benchmark datasets that contain Android malware samples and highly promising results were obtained by using several binary classification algorithms.},
  content_type = {Article},
}


@article{springer_10_1007_s10207_025_00992_7,
  title = {Large language models for software vulnerability detection: a guide for researchers on models, methods, techniques, datasets, and metrics},
  author = {Taghavi Far, Seyed Mohammad and Feyzi, Farid},
  journal = {International Journal of Information Security},
  year = {2025},
  volume = {24},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10207-025-00992-7},
  url = {https://doi.org/10.1007/s10207-025-00992-7},
  abstract = {Large language models (LLMs) have emerged as transformative tools in the domain of software vulnerability detection and management, offering sophisticated capabilities in identifying, analyzing, and mitigating security risks. This article delves into the utilization of LLMs, examining their role in revolutionizing traditional approaches to software vulnerability detection. We explore the various categories of LLMs, such as bidirectional encoder representations from transformers (BERT) and generative pre-trained transformer (GPT), and how these models are being leveraged to improve the accuracy and efficiency of vulnerability detection. This article reviews how LLMs are being integrated into existing software security frameworks, synthesizing research findings on their performance in various contexts. It includes insights into how LLM-based methods complement traditional techniques like static analysis and fuzz testing, without engaging in a direct comparative analysis of these approaches. The comparison highlights the strengths of LLMs, such as their ability to generalize across diverse codebases and programming languages, while also addressing their limitations, such as susceptibility to biases from training data and the hallucination. The article synthesizes findings from recent research, showcasing how LLMs have been successfully employed to detect a range of vulnerabilities, from buffer overflows to SQL injections, and outlines how these models enhance productivity by automating the detection and reporting of security flaws. Additionally, we discuss the inherent challenges in applying LLMs to software vulnerability detection, such as the need for high-quality datasets, and the ethical implications related to the deployment of LLM-based systems in security-critical applications. Addressing these challenges is crucial for the future advancement of LLM technologies in the cybersecurity domain. A comprehensive introduction to foundational and specialized datasets is provided, including datasets such as CVEfixes, Big-Vul, and LineVul, which are tailored for software vulnerability detection. These datasets serve as crucial resources for training and benchmarking LLMs. Moreover, we introduce evaluation metrics such as F1-score, precision, recall, and AUC-ROC that are used to assess the performance of models in detecting and mitigating vulnerabilities, offering a structured way to gauge the success and limitations of LLMs. In addition, the article explores fine-tuning techniques such as full fine-tuning, feature extraction, adapter-based fine-tuning, and LoRA (low-rank adaptation), highlighting how each method can enhance LLM performance in vulnerability detection. By focusing on parameter-efficient fine-tuning approaches, such as adapter layers and prefix-tuning, and LoRa, we outline ways to optimize model performance while reducing computational overhead. By providing a comprehensive review of the literature and practical insights into LLM integration, this article aims to fill the gap in existing research and serve as a foundational guide for future investigations. Researchers and practitioners in the field of software security will benefit from the comparative analyses, detailed case studies, and strategic recommendations provided herein, which collectively highlight the potential of LLMs to complement and enhance traditional software vulnerability detection techniques.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_6904_6_8,
  title = {Real SOC Analyst Stories},
  author = {Wall, Tyler and Rodrick, Jarrett},
  booktitle = {Jump-start Your SOC Analyst Career},
  year = {2021},
  pages = {89-109},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-6904-6\_8},
  url = {https://doi.org/10.1007/978-1-4842-6904-6\_8},
  abstract = {In this chapter we will hear a few stories from people on the front lines: their backgrounds, how they landed their first role, and what advice they have for you. These are people from various backgrounds who know they have something important to share. They have blazed this trail and created a path for you to follow. So, enjoy their tale as they take you along their journey.},
  content_type = {Chapter},
}


@article{springer_10_1186_s42400_022_00119_8,
  title = {On building machine learning pipelines for Android malware detection: a procedural survey of practices, challenges and opportunities},
  author = {Mehrabi Koushki, Masoud and AbuAlhaol, Ibrahim and Raju, Anandharaju Durai and Zhou, Yang and Giagone, Ronnie Salvador and Shengqiang, Huang},
  journal = {Cybersecurity},
  year = {2022},
  volume = {5},
  number = {1},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1186/s42400-022-00119-8},
  url = {https://doi.org/10.1186/s42400-022-00119-8},
  abstract = {Abstract As the smartphone market leader, Android has been a prominent target for malware attacks. The number of malicious applications (apps) identified for it has increased continually over the past decade, creating an immense challenge for all parties involved. For market holders and researchers, in particular, the large number of samples has made manual malware detection unfeasible, leading to an influx of research that investigate Machine Learning (ML) approaches to automate this process. However, while some of the proposed approaches achieve high performance, rapidly evolving Android malware has made them unable to maintain their accuracy over time. This has created a need in the community to conduct further research, and build more flexible ML pipelines. Doing so, however, is currently hindered by a lack of systematic overview of the existing literature, to learn from and improve upon the existing solutions. Existing survey papers often focus only on parts of the ML process (e.g., data collection or model deployment), while omitting other important stages, such as model evaluation and explanation. In this paper, we address this problem with a review of 42 highly-cited papers, spanning a decade of research (from 2011 to 2021). We introduce a novel procedural taxonomy of the published literature, covering how they have used ML algorithms, what features they have engineered, which dimensionality reduction techniques they have employed, what datasets they have employed for training, and what their evaluation and explanation strategies are. Drawing from this taxonomy, we also identify gaps in knowledge and provide ideas for improvement and future work.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_64949_4_9,
  title = {MiBeX: Malware-Inserted Benign Datasets for Explainable Machine Learning},
  author = {Stegner, Wayne and Westland, Tyler and Kapp, David and Kebede, Temesguen and Jha, Rashmi},
  booktitle = {Studies in Computational Intelligence},
  year = {2021},
  pages = {269-291},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-64949-4\_9},
  url = {https://doi.org/10.1007/978-3-030-64949-4\_9},
  abstract = {Deep learning has shown its capability for achieving extremely high accuracy for malware detection, but it suffers from an inherent lack of explainability. While methods for explaining these black-box algorithms are being extensively studied, explanations offered by algorithms, such as saliency mapping, are difficult to understand due to the lack of interpretability of many malware datasets. This chapter explores the role of information granularity in malware detection, as well as a scalable method to produce an intelligible malware dataset for machine learning classification. One of the resultant datasets is then used with a Malware as Image classifier to prove the method’s validity for use in training deep learning algorithms. The Malware as Image classifier achieves a training accuracy of 98.94\% and a validation accuracy of 93.83\%, showing that the method can produce valid datasets for use with machine learning. Gradient-based saliency mapping is then applied to the trained classifier to generate heat-map explanations of the network output.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_90022_9_5,
  title = {An Empirical Study on Mobile Payment Credential Leaks and Their Exploits},
  author = {Shi, Shangcheng and Wang, Xianbo and Zeng, Kyle and Yang, Ronghai and Lau, Wing Cheong},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {79-98},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-90022-9\_5},
  url = {https://doi.org/10.1007/978-3-030-90022-9\_5},
  abstract = {Recently, mobile apps increasingly integrate with payment services, enabling the user to pay orders with a third-party payment service provider, namely Cashier. During the payment process, both the app and Cashier rely on some credentials to secure the service. Despite the importance, many developers tend to overlook the protection of payment credentials and inadvertently expose them to the wild. Such leaks severely affect the security of end-users and the merchants associated with the apps, resulting in privacy violations and actual financial loss. In this paper, we study the payment credential leaks for four top-tiered Cashiers that serve over one billion users and tens of millions of merchants globally. Through studying practical mobile payment systems, we identify new leaking sources of payment credentials and find 4 types of exploits with severe consequences, which are caused by the credential leaks and additional implementation flaws. Besides, we design an automatic tool, PayKeyMiner, and use it to discover around 20,000 leaked payment credentials, affecting thousands of apps. We have reported our findings to the Cashiers. All of them have confirmed the issue and pledged to notify the affected merchant apps, while some of these apps have updated the leaked payment credentials afterward.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s41060_021_00281_1,
  title = {Identification of token contracts on Ethereum: standard compliance and beyond},
  author = {Di Angelo, Monika and Salzer, Gernot},
  journal = {International Journal of Data Science and Analytics},
  year = {2023},
  volume = {16},
  number = {3},
  pages = {333-352},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s41060-021-00281-1},
  url = {https://doi.org/10.1007/s41060-021-00281-1},
  abstract = {Abstract Next to cryptocurrencies, tokens are a widespread application area of blockchains. Tokens are digital assets implemented as small programs on a blockchain. Being programmable makes them versatile and an innovative means for various purposes. Tokens can be used as investment, as a local currency in a decentralized application, or as a tool for building an ecosystem or a community. A high-level categorization of tokens differentiates between payment, security, and utility tokens. In most jurisdictions, security tokens are regulated, and hence, the distinction is of relevance. In this work, we discuss the identification of tokens on Ethereum, the most widely used token platform. The programs on Ethereum are called smart contracts, which—for the sake of interoperability—may provide standardized interfaces. In our approach, we evaluate the publicly available transaction data by first reconstructing interfaces in the low-level code of the smart contracts. Then, we not only check the compliance of a smart contract with an established interface standard for tokens, but also aim at identifying tokens that are not fully compliant. Thus, we discuss various heuristics for token identification in combination with possible definitions of a token. More specifically, we propose indicators for tokens and evaluate them on a large set of token and non-token contracts. Finally, we present first steps toward an automated classification of tokens regarding their purpose.},
  content_type = {Article},
}


@article{springer_10_1007_s12083_023_01478_w,
  title = {IoT malware: An attribute-based taxonomy, detection mechanisms and challenges},
  author = {Victor, Princy and Lashkari, Arash Habibi and Lu, Rongxing and Sasi, Tinshu and Xiong, Pulei and Iqbal, Shahrear},
  journal = {Peer-to-Peer Networking and Applications},
  year = {2023},
  volume = {16},
  number = {3},
  pages = {1380-1431},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12083-023-01478-w},
  url = {https://doi.org/10.1007/s12083-023-01478-w},
  abstract = {During the past decade, the Internet of Things (IoT) has paved the way for the ongoing digitization of society in unique ways. Its penetration into enterprise and day-to-day lives improved the supply chain in numerous ways. Unfortunately, the profuse diversity of IoT devices has become an attractive target for malware authors who take advantage of its vulnerabilities. Accordingly, enhancing the security of IoT devices has become the primary objective of industrialists and researchers. However, most present studies lack a deep understanding of IoT malware and its various aspects. As understanding IoT malware is the preliminary base of research, in this work, we present an IoT malware taxonomy with 100 attributes based on the IoT malware categories, attack types, attack surfaces, malware distribution architecture, victim devices, victim device architecture, IoT malware characteristics, access mechanisms, programming languages, and protocols. In addition, we have mapped these categories into 77 IoT Malwares identified between 2008 and 2022. Furthermore, To provide insight into the challenges in IoT malware research for future researchers, our study also reviews the existing IoT malware detection works.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_63092_8_54,
  title = {Classification Method for Malware Detection on Android Devices},
  author = {Fournier, Arthur and El Khoury, Franjieh and Pierre, Samuel},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2021},
  pages = {810-829},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63092-8\_54},
  url = {https://doi.org/10.1007/978-3-030-63092-8\_54},
  abstract = {Due to its popularity and open-source nature, Android is the mobile platform that has been targeted the most by malware. Android allows downloading and installation of apps from other unofficial market places. This aims to steal personal information or to control the users’ devices. More specifically, malware attacks private and financial information on mobile payment applications and networks, and thus is very sensitive. In this paper, we propose an efficient malware detection model for Android devices centered on mobile payment applications. This model is based on client/server architecture to reduce the heavy computations of data on the mobile device and doing the processing remotely on the server. Our approach aims to develop an optimized algorithm based on machine learning models to extract the permissions and for better classification of the new installed applications on Android devices. The Random Forest regression algorithm with the numerical ranging from −100 (benign) to 100 (malware) gives good results and an accuracy close to 100\%. Therefore, the proposed model is suitable to secure the Android devices in the mobile commerce context.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_71842_8_3,
  title = {Explanation},
  author = {Diederich, Joachim},
  booktitle = {Cognitive Systems Monographs},
  year = {2021},
  pages = {33-53},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-71842-8\_3},
  url = {https://doi.org/10.1007/978-3-030-71842-8\_3},
  abstract = {Any form of artificial superintelligence has to be transparent, in other words, how it works must be comprehensible to humans at all times. Not just a few selected experts but to any human who requests information. This includes children and individuals with an intellectual disability. An advanced artificial intelligence must explain in human comprehensible form why certain actions were performed and how certain outcomes were achieved. These explanations must take the form of videos, multimedia content or demonstrations so that anybody can understand them. If humans want to have any trust in an artificial superintelligence then explanation is a core requirement.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10772_020_09703_0,
  title = {Application intelligent search and recommendation system based on speech recognition technology},
  author = {Jiang, Jie and Wang, Harry Haoxiang},
  journal = {International Journal of Speech Technology},
  year = {2021},
  volume = {24},
  number = {1},
  pages = {23-30},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10772-020-09703-0},
  url = {https://doi.org/10.1007/s10772-020-09703-0},
  abstract = {With the progress of science and technology, artificial intelligence as the emerging tool has been deeply into our lives. The application of modern intelligent equipment is more and more extensive, and also inseparable from our lives. The mobile intelligent terminal represented by smart phone is a powerful intelligent computing and networking device, which has more perception and interaction capabilities. Due to the emergence of a large number of application software, it is not easy to find and get the app that you really need. Therefore, this paper uses speech recognition technology to build an app intelligent search and recommendation system. We designed the system from the levels of speech information extraction, analysis and finalized recommendation. Experimental results show that the proposed method is more efficient and intelligent.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_62582_5_5,
  title = {A Survey of Intelligent Techniques for Android Malware Detection},
  author = {Kumars, Rajesh and Alazab, Mamoun and Wang, WenYong},
  booktitle = {Malware Analysis Using Artificial Intelligence and Deep Learning},
  year = {2021},
  pages = {121-162},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-62582-5\_5},
  url = {https://doi.org/10.1007/978-3-030-62582-5\_5},
  abstract = {The revolution of smart devices such as smartphones, smart washing machines, smart cars is increasing every year, as these devices are provided connected with the network and provide the online functionality and services available with the lowest cost. In this context, the Android operating system (OS) is very popular due to its openness. It has major stakeholder in the smart devices but has also become an attractive target for cyber-criminals. This chapter presents a systematic and detailed survey of the malware detection mechanisms using deep learning and machine learning techniques. Also, it classifies the Android malware detection techniques in three main categories including static, dynamic, and hybrid analysis. The main contribution of this chapter are (1) It briefly describing the background and feature extraction of the static, dynamic, and hybrid analysis. (2) This chapter discusses the basic methodology and frameworks which classify, cluster, or extract Android malware features. (3) Exploring the dataset, harmful features, and classification results. (4) Discussing the current challenges and issues. Moreover, it discusses the most important factors, data-mining algorithms, and processed frameworks.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_59638_5_15,
  title = {Have I Been Exploited?},
  author = {Connelly, Daniel and Feng, Wu-chang},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {221-228},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-59638-5\_15},
  url = {https://doi.org/10.1007/978-3-030-59638-5\_15},
  abstract = {Ethereum Smart Contracts, also known as Decentralized Applications (DApps), are small programs which orchestrate financial transactions. Though beneficial in many cases, such contracts can and have been exploited, leading to a history of financial losses in the millions of dollars for those who have invested in them. It is critical that users be able to trust the contract code they place their money into. One way for verifying a program’s integrity is Symbolic Execution. Unfortunately, while the information derived from symbolic execution is beneficial, performing it is often financially and technically infeasible for users to do. To address this problem, this paper describes the design and implementation of a registry of vulnerable Ethereum contracts. The registry compiles the results of exhaustive application of symbolic analysis to deployed contracts and makes it available to users seeking to understand the risks associated with contracts they are intending to utilize.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_5136_2_10,
  title = {Spring and Kotlin},
  author = {Cosmina, Iuliana},
  booktitle = {Pivotal Certified Professional Core Spring 5 Developer Exam},
  year = {2020},
  pages = {819-853},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-5136-2\_10},
  url = {https://doi.org/10.1007/978-1-4842-5136-2\_10},
  abstract = {Until this chapter in the book, Spring applications were written using Java. This chapter teaches you how to write Spring applications using Kotlin. Kotlin is a JVM programming language that my favorite software company, JetBrains (the same company that develops IntelliJ IDEA), started working on in 2011. As an IntelliJ IDEA fan since 2005, I cannot imagine JetBrains producing something that is not absolutely great. So, clearly, Kotlin had to be another awesome product. After seeing Josh Long’s “Bootiful Kotlin” presentation at the Spring IO conference in Barcelona, I decided that this was a programming language that I needed to learn.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_51054_1_7,
  title = {Extensible Extraction of Efficient Imperative Programs with Foreign Functions, Manually Managed Memory, and Proofs},
  author = {Pit-Claudel, Clément and Wang, Peng and Delaware, Benjamin and Gross, Jason and Chlipala, Adam},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {119-137},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-51054-1\_7},
  url = {https://doi.org/10.1007/978-3-030-51054-1\_7},
  abstract = {We present an original approach to sound program extraction in a proof assistant, using syntax-driven automation to derive correct-by-construction imperative programs from nondeterministic functional source code. Our approach does not require committing to a single inflexible compilation strategy and instead makes it straightforward to create domain-specific code translators. In addition to a small set of core definitions, our framework is a large, user-extensible collection of compilation rules each phrased to handle specific language constructs, code patterns, or data manipulations. By mixing and matching these pieces of logic, users can easily tailor extraction to their own domains and programs, getting maximum performance and ensuring correctness of the resulting assembly code. Using this approach, we complete the first proof-generating pipeline that goes automatically from high-level specifications to assembly code. In our main case study, the original specifications are phrased to resemble SQL-style queries, while the final assembly code does manual memory management, calls out to foreign data structures and functions, and is suitable to deploy on resource-constrained platforms. The pipeline runs entirely within the Coq proof assistant, leading to final, linked assembly code with overall full-functional-correctness proofs in separation logic.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_021_00390_2,
  title = {Detection and robustness evaluation of android malware classifiers},
  author = {Anupama, M. L. and Vinod, P. and Visaggio, Corrado Aaron and Arya, M. A. and Philomina, Josna and Raphael, Rincy and Pinhero, Anson and Ajith, K. S. and Mathiyalagan, P.},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2022},
  volume = {18},
  number = {3},
  pages = {147-170},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-021-00390-2},
  url = {https://doi.org/10.1007/s11416-021-00390-2},
  abstract = {Android malware attacks are tremendously increasing, and evasion techniques become more and more effective. For this reason, it is necessary to continuously improve the detection performances. With this paper, we wish to pursue this purpose with two contributions. On one hand, we aim at evaluating how improving machine learning-based malware detectors, and on the other hand, we investigate to which extent adversarial attacks can deteriorate the performances of the classifiers. Analysis of malware samples is performed using static and dynamic analysis. This paper proposes a framework for integrating both static and dynamic features trained on machine learning methods and deep neural network. On employing machine learning algorithms, we obtain an accuracy of 97.59\% with static features using SVM, and 95.64\% is reached with dynamic features using Random forest. Additionally, a 100\% accuracy was obtained with CART and SVM using hybrid attributes (on combining relevant static and dynamic features). Further, using deep neural network models, experimental results showed an accuracy of 99.28\% using static features, 94.61\% using dynamic attributes, and 99.59\% by combining both static and dynamic features (also known as multi-modal attributes). Besides, we evaluated the robustness of classifiers against evasion and poisoning attack. In particular comprehensive analysis was performed using permission, APIs, app components and system calls (especially n -grams of system calls). We noticed that the performances of the classifiers significantly dropped while simulating evasion attack using static features, and in some cases 100\% of adversarial examples were wrongly labelled by the classification models. Additionally, we show that models trained using dynamic features are also vulnerable to attack, however they exhibit more resilience than a classifier built on static features.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_1_4842_7337_1_6,
  title = {Mapping with Annotations},
  author = {Ottinger, Joseph B. and Linwood, Jeff and Minter, Dave},
  booktitle = {Beginning Hibernate 6},
  year = {2022},
  pages = {171-236},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-7337-1\_6},
  url = {https://doi.org/10.1007/978-1-4842-7337-1\_6},
  abstract = {In Chapter 5 , we discussed the need to create mappings between the database model and the object model. Mappings can be created in two different ways: via inline annotations (as we’ve done through the book so far) or as separate XML files in one of two primary formats (Hibernate’s internal XML format and JPA’s mapping format, both of which have value but are not suggested for most applications).},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_19_0336_6_3,
  title = {Advanced Web Challenges},
  author = {Nu1L Team},
  booktitle = {Handbook for CTFers},
  year = {2022},
  pages = {195-268},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-0336-6\_3},
  url = {https://doi.org/10.1007/978-981-19-0336-6\_3},
  abstract = {The first two chapters focus on traditional Web vulnerabilities. This chapter mainly starts from the language features of PHP and Python, and introduces the common vulnerabilities of these two mainstream Web languages in CTF competition, namely deserialization vulnerabilities and Python security issues. Meanwhile, it introduces Web vulnerabilities and Web logic vulnerabilities related to cryptography, so that readers can have a more comprehensive understanding of the vulnerabilities in the direction of Web.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_91424_0_12,
  title = {A Usability Study of Cryptographic API Design},
  author = {Luo, Junwei and Yi, Xun and Han, Fengling and Yang, Xuechao},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2021},
  pages = {194-213},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-91424-0\_12},
  url = {https://doi.org/10.1007/978-3-030-91424-0\_12},
  abstract = {Software developers interact with cryptographic components via APIs provided by a cryptographic library to protect sensitive information such as passwords and files. While cryptographic algorithms have been standardised for over a decade, with variety of crypto libraries that implemented the algorithm, many developers struggle to use the library correctly. This paper evaluates 6 different cryptographic libraries written in 3 different programming languages to find out what factors affect usability. We analyse the usability of surveyed libraries with regards to its API call sequence, number of parameters, exception handling mechanism and documentation. In the end, several recommendations are provided to help developers choose which library to use and more importantly, this paper showcases a few common pitfalls for library designers to prevent common misuses when designing a cryptographic library.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_63319_6_73,
  title = {CLIPS Utilization for Automation of Models’ Translation},
  author = {Polenov, Maxim and Kurmaleev, Artem and Gushanskiy, Sergey and Madrigal, Omar Correa},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2020},
  pages = {788-796},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63319-6\_73},
  url = {https://doi.org/10.1007/978-3-030-63319-6\_73},
  abstract = {An approach to models’ reuse is considered in this paper. It was started with development of the Multitranslator package that allowed translating of the models’ source codes into required format. Then it was split into client-server tool called Distributed Storage of Models that has also models storage functions. However, we faced some problems of uncertainty due to lack of source data in translation process. It led into looking for another solution and as a result it was decided to use an expert system based on CLIPS. It was developed an interaction between Distributed Storage of Models, that contains Multitranslator, with CLIPS to automate the translation process in exceptional cases with uncertainty. To utilize CLIPS, we are not just using the expert system itself with knowledge base making user interaction with it, being integrated into the complex of translation, but also allow to edit the rules within the base for the advanced users via interface of intelligent editor. The results of the tests show possibility to reduce time costs of some types of uncertainty cases even at early stages of development. It proves to further increase functionality of the translation complex in terms of automation of models’ translation.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s12083_021_01127_0,
  title = {Blockchain smart contracts: Applications, challenges, and future trends},
  author = {Khan, Shafaq Naheed and Loukil, Faiza and Ghedira-Guegan, Chirine and Benkhelifa, Elhadj and Bani-Hani, Anoud},
  journal = {Peer-to-Peer Networking and Applications},
  year = {2021},
  volume = {14},
  number = {5},
  pages = {2901-2925},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s12083-021-01127-0},
  url = {https://doi.org/10.1007/s12083-021-01127-0},
  abstract = {In recent years, the rapid development of blockchain technology and cryptocurrencies has influenced the financial industry by creating a new crypto-economy. Then, next-generation decentralized applications without involving a trusted third-party have emerged thanks to the appearance of smart contracts, which are computer protocols designed to facilitate, verify, and enforce automatically the negotiation and agreement among multiple untrustworthy parties. Despite the bright side of smart contracts, several concerns continue to undermine their adoption, such as security threats, vulnerabilities, and legal issues. In this paper, we present a comprehensive survey of blockchain-enabled smart contracts from both technical and usage points of view. To do so, we present a taxonomy of existing blockchain-enabled smart contract solutions, categorize the included research papers, and discuss the existing smart contract-based studies. Based on the findings from the survey, we identify a set of challenges and open issues that need to be addressed in future studies. Finally, we identify future trends.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_15_6401_7_38_1,
  title = {Microprocessor Assurance and the Role of Theorem Proving},
  author = {Goel, Shilpi and Ray, Sandip},
  booktitle = {Handbook of Computer Architecture},
  year = {2022},
  pages = {1-43},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-15-6401-7\_38-1},
  url = {https://doi.org/10.1007/978-981-15-6401-7\_38-1},
  abstract = {Theorem proving is a technology where we use logical deduction to prove properties of mathematical artifacts, often assisted by a computer program called a theorem prover . One way to verify computing systems is to model them as mathematical artifacts and then use theorem proving to prove their desired properties as theorems. This approach has in fact been used to verify a wide spectrum of properties of computing systems. In this chapter, we recount the role of theorem proving in microprocessor verification and discuss the scope, applicability, and limits of the technology.},
  content_type = {Living reference work entry},
}


@incollection{springer_10_1007_978_981_19_0336_6_1,
  title = {Introduction to the Web},
  author = {Nu1L Team},
  booktitle = {Handbook for CTFers},
  year = {2022},
  pages = {1-82},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-19-0336-6\_1},
  url = {https://doi.org/10.1007/978-981-19-0336-6\_1},
  abstract = {Web challenges could be seen everywhere in traditional CTF competitions. They are easier to get started because they do not require in-depth knowledge of operating systems and complicated assembly instructions than PWN and Reverse challenges. On the other hand, they do not require strong programming skills compared to Crypto and MISC challenges.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_51051_0_12,
  title = {Vulnerability Analysis in Mobile Banking and Payment Applications on Android in African Countries},
  author = {Bassolé, Didier and Koala, Gouayon and Traoré, Yaya and Sié, Oumarou},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2020},
  pages = {164-175},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-51051-0\_12},
  url = {https://doi.org/10.1007/978-3-030-51051-0\_12},
  abstract = {In this paper, we analyze vulnerability of some mobile banking and payment applications on Android platforms. This analysis aims at performing vulnerability assessments, facilitating an informed assessment of the information security and privacy risks that mobile banking and payment applications face in African countries, and creating awareness in the research and practice communities. We especially try to assess the risks of attacks related to privacy and data confidentiality by checking access permissions and code vulnerability of these applications. Another purpose of our work is to enable users, businesses and governments to take advantage of the opportunities offered by mobile banking and payment applications while minimising the information security risks to which they are exposed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_8083_3_19,
  title = {Effective Android Malware Detection Based on Deep Learning},
  author = {Jin, Yueqi and Yang, Tengfei and Li, Yangyang and Xie, Haiyong},
  booktitle = {Communications in Computer and Information Science},
  year = {2020},
  pages = {206-218},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-8083-3\_19},
  url = {https://doi.org/10.1007/978-981-15-8083-3\_19},
  abstract = {Android, the world’s most widely used mobile operating system, is the target of a large number of malwares. These malwares have brought great trouble to information security and users’ privacy, such as leaking personal information, secretly downloading programs to consume data, and secretly sending deduction SMS messages. With the increase of malwares, detection methods have been proposed constantly. Especially in recent years, the malware detection methods based on deep learning are popular. However, the detection methods based on static features have a low accuracy, and others based on dynamic features take a long time, all this limits its scope. In this paper, we proposed a static feature detection method based on deep learning. It extracts specific API calls of applications and uses DNN network for detection. With the dataset composed about 4000 applications and extremely short time, it can achieve an accuracy rate of more than 99\%.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_41593_8_1,
  title = {Analysis of the Impact of Permissions on the Vulnerability of Mobile Applications},
  author = {Koala, Gouayon and Bassolé, Didier and Zerbo/Sabané, Aminata and Bissyandé, Tegawendé F. and Sié, Oumarou},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2020},
  pages = {3-14},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-41593-8\_1},
  url = {https://doi.org/10.1007/978-3-030-41593-8\_1},
  abstract = {In this paper, we explored the potential risks of authorizations unexplained by benign apps in order to maintain the confidentiality and availability of personal data. More precisely, we focused on the mechanisms for managing risk permissions under Android to limit the impact of these permissions on vulnerability vectors. We analyzed a sample of forty (40) apps developed in Burkina Faso and identified abuses of dangerous authorizations in several apps in relation to their functional needs. We also discovered combinations of dangerous permissions because it exposes the confidentiality of the data. This analysis allowed us to establish a link between permissions and vulnerabilities, as a source of risk of data security. These risks facilitate exploits of privileges that should be reduced. We have therefore proposed the need to coordinate resolution mechanisms to the administrators, developers, users to better guide the required permissions by benign apps on Android.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_22263_5_38,
  title = {A Static Instrumentation Method for ELF Binary},
  author = {Yang, Wenchuan and Wang, Yifei and Cui, Baojiang and Chen, Chen},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2020},
  pages = {393-403},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-22263-5\_38},
  url = {https://doi.org/10.1007/978-3-030-22263-5\_38},
  abstract = {Binary instrumentation is a process of inserting other code into an executable to observe or modify the binary execution. However, current instrumentation tools depend on platform strongly and the execution efficiency is low, which make it difficult to be used in embedded devices. In this paper, we propose a static instrumentation method using the trampoline technology to perform the binary instrumentation on the Linux OS, which can support CISC and RISC instruction sets. The experiment showed that the file size and execution time of the binary are less affected after instrumentation by comparing with other dynamic and static instrumentation tools.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11416_021_00389_9,
  title = {The blockchain potential in computer virology: leveraging combinatorial techniques of k-ary codes},
  author = {Moubarak, Joanna and Filiol, Eric and Chamoun, Maroun},
  journal = {Journal of Computer Virology and Hacking Techniques},
  year = {2021},
  volume = {17},
  number = {3},
  pages = {199-220},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11416-021-00389-9},
  url = {https://doi.org/10.1007/s11416-021-00389-9},
  abstract = {The threat landscape is continuously evolving and attackers are improving their tactics and techniques. From worms and viruses, initially introduced in 1982, to advanced, targeted and persistent attacks that have emerged in recent years, many verdicts demonstrate that no architecture is invulnerable. Nowadays, malware and cyberthreats are penetrating many platforms and the growth is exponential and a corporate and politically-driven outbreak has surfaced worldwide. A continuous back-and-forth between vulnerabilities and controls directs the evolution of the information age. Besides, intelligent technologies are a dual-use and a new class of smart cyberthreats is arisen. This paper presents a state of the art in computer virology and explores how we leveraged the blockchain technology to create a new form of malware offering a new aspect to the cyber-vector.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_15032_7_46,
  title = {Analysis of Ethereum Smart Contracts and Opcodes},
  author = {Bistarelli, Stefano and Mazzante, Gianmarco and Micheletti, Matteo and Mostarda, Leonardo and Tiezzi, Francesco},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2020},
  pages = {546-558},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-15032-7\_46},
  url = {https://doi.org/10.1007/978-3-030-15032-7\_46},
  abstract = {Much attention has been paid in recent years to the use of smart contracts. A smart contract is a transaction protocol that executes the terms of an agreement. Ethereum is a widely used platform for executing smart contracts, defined by using a Turing-complete language. Various studies have been performed in order to analyse smart contract data from different perspectives. In our study we gather a wide range of verified smart contracts written by using the Solidity language and we analyse their code. A similar study is carried out on Solidity compilers. The aim of our investigation is the identification of the smart contract functionalities, i.e. opcodes, that play a crucial role in practice, and single out those functionalities that are not practically relevant.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_61467_6_5,
  title = {Making Tezos Smart Contracts More Reliable with Coq},
  author = {Bernardo, Bruno and Cauderlier, Raphaël and Claret, Guillaume and Jakobsson, Arvid and Pesin, Basile and Tesson, Julien},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {60-72},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-61467-6\_5},
  url = {https://doi.org/10.1007/978-3-030-61467-6\_5},
  abstract = {Tezos is a smart-contract blockchain. Tezos smart contracts are written in a low-level stack-based language called Michelson. This article gives an overview of efforts using the Coq proof assistant to have stronger guarantees on Michelson smart contracts: the Mi-Cho-Coq framework, a Coq library defining formal semantics of Michelson, as well as an interpreter, a simple optimiser and a weakest-precondition calculus to reason about Michelson smart contracts; Albert, an intermediate language that abstracts Michelson stacks with a compiler written in Coq that targets Mi-Cho-Coq.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_65299_9_5,
  title = {Entropy-Based Feature Grouping in Machine Learning for Android Malware Classification},
  author = {Shim, Hyunseok and Jung, Souhwan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {59-72},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-65299-9\_5},
  url = {https://doi.org/10.1007/978-3-030-65299-9\_5},
  abstract = {In this paper, we have developed a tool to perform an analysis for all APIs over an APK and all APIs of every version of Android, to solve problems of overfitting in machine-learning-based malware classification. The tool is Java-based software consisting of approximately 2,000 lines, performing frequency analysis for the entire API or performing frequency analysis based on the decompiled APK. For frequency analysis, we split all API signatures into word units and grouped them according to their entropy, which is calculated by the number of the emergence of each unit words. As a result, the tool reduces 39,031 methods to 4,972 groups and 12,123 groups when including classes. This shows an approximately 69\% feature reduction rate. For classification using machine learning, 14,290 APKs from 14 different categories are collected and trained with 10,003 APKs and tested with 4,287 APKs among them. As a result, we got 98.83\% of true positive rate and 1.16\% of false positive rate on average, with 98.8\% of F-measure score.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s42452_020_3132_2,
  title = {Android malware detection based on image-based features and machine learning techniques},
  author = {Ünver, Halil Murat and Bakour, Khaled},
  journal = {SN Applied Sciences},
  year = {2020},
  volume = {2},
  number = {7},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s42452-020-3132-2},
  url = {https://doi.org/10.1007/s42452-020-3132-2},
  abstract = {In this paper, a malware classification model has been proposed for detecting malware samples in the Android environment. The proposed model is based on converting some files from the source of the Android applications into grayscale images. Some image-based local features and global features, including four different types of local features and three different types of global features, have been extracted from the constructed grayscale image datasets and used for training the proposed model. To the best of our knowledge, this type of features is used for the first time in the Android malware detection domain. Moreover, the bag of visual words algorithm has been used to construct one feature vector from the descriptors of the local feature extracted from each image. The extracted local and global features have been used for training multiple machine learning classifiers including Random forest, k-nearest neighbors, Decision Tree, Bagging, AdaBoost and Gradient Boost. The proposed method obtained a very high classification accuracy reached 98.75\% with a typical computational time does not exceed 0.018 s for each sample. The results of the proposed model outperformed the results of all compared state-of-art models in term of both classification accuracy and computational time.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_981_97_0116_2_3,
  title = {The Principle and Structure of Cyberspace Endogenous Security and Safety},
  author = {Wu, Jiangxing},
  booktitle = {Cyber Resilience System Engineering Empowered by Endogenous Security and Safety},
  year = {2024},
  pages = {111-202},
  publisher = {Springer Nature Singapore},
  doi = {10.1007/978-981-97-0116-2\_3},
  url = {https://doi.org/10.1007/978-981-97-0116-2\_3},
  abstract = {As can be seen from the previous chapter, the incomplete intersection principle (IIP) points out that if the functions of DVR in a cybersecurity defense system cannot be completely intersected, it will be impossible to have the structural capabilities to prevent unknown security threats (especially internal-external collaborative network attacks). In other words, no matter what kind of security technology is added to the target system or how many built-in, embedded, endosymbiotic, and other non-integrated defense measures are deployed, it is theoretically impossible to effectively resist “unknown unknown” security threats or “internal-external collaborative” cyberattacks. This chapter needs to prove whether the “DVR complete intersection” can, in mechanism, transform generalized uncertain disturbances into differential-mode or perceivable common-mode security incidents that can be described by probabilistic tools in the DVR domain, i.e., to theoretically analyze and prove whether this “DVR transformation” has the basic attributes mentioned in the vision of CESS. In a more general sense, it is to prove whether the inference that “structure determines security” is true at the theoretical level. Then, there is also a discussion about what kind of model or algorithm can technically realize DVR complete intersection. It is found that the introduction of a state or output feedback control mechanism on the basis of a dissimilar redundancy structure (DRS) can form a feedback loop consisting of all links, elements, or variables in the structure of DVR complete intersection that are well connected and causally related to each other, where a change in any one of them will cause a change in other links or elements, thus forming a feedback loop and controlling movement. Therefore, the feedback control is mechanically able to adjust variety (V) and redundancy (R) in real time through the dynamics (D) of iterative convergence, thus meeting the requirements of the DVR complete intersection model. In view of this, the author invented the dynamic, heterogeneous, and redundant (DHR) architecture (the same papers also called “the mimic architecture (MA)” or “mimic defense”) [1] based on the principle that “structure determines security.” It solves multiple intertwined functional safety, network security, and even information/data security problems such as unknown threats or attacks in the architectural environment with an integrated effect. Then, this chapter introduces in detail the structure and function of the DHR architecture, the mechanism of ESS, the environmentally encrypted attack surface (AS), and the engineering expression of ESS and proves from the perspective of cryptography that, compared with the “perfect secrecy” model of Shannon’s information theory, the ideal DHR model, which does not rely on prior knowledge, essentially puts forward an innovative method to obtain “perfect safety” functions through “structural coding/environmental encryption.” This enriches the connotation and extension of the ESS theory. Finally, a general testing and “golden standard” of measurement of ESS functions and performance—the white box plug method—is given.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_63095_9_14,
  title = {AOMDroid: Detecting Obfuscation Variants of Android Malware Using Transfer Learning},
  author = {Jiang, Yu and Li, Ruixuan and Tang, Junwei and Davanian, Ali and Yin, Heng},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2020},
  pages = {242-253},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63095-9\_14},
  url = {https://doi.org/10.1007/978-3-030-63095-9\_14},
  abstract = {Android with its large market attracts malware developers. Malware developers employ obfuscation techniques to bypass malware detection mechanisms. Existing systems cannot effectively detect obfuscated Android malware. In this paper, We propose a novel approach to identify obfuscated Android malware. Our proposed approach is based on the intuition that opcode sequences are more resilient to the obfuscation techniques. We first propose an effective approach based on TFIDF algorithm to identify distinctive opcode sequences. Then we represent the opcode sequences as images and reduce the problem of identifying an obfuscated malware to the problem of transforming two images to one another, i.e. unobfuscated malware representation to the obfuscated one. In order to achieve the above, we resort to the transfer learning. We implemented a prototype dubbed AOMDroid based on the proposed approach and extensively evaluated its performance of accuracy and detection time. AOMDroid outperforms four related works that we compared with, and has an accuracy rate of 92.26\% in detecting Android obfuscated malware. In addition, AOMDroid supports the detection of 21 Android malware family types. Its malware family detecion accuracy rate is 87.39\%. The average time spent by AOMDroid to detect a single Android application is 0.963 s.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_021_10018_0,
  title = {Maintenance-related concerns for post-deployed Ethereum smart contract development: issues, techniques, and future challenges},
  author = {Chen, Jiachi and Xia, Xin and Lo, David and Grundy, John and Yang, Xiaohu},
  journal = {Empirical Software Engineering},
  year = {2021},
  volume = {26},
  number = {6},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-021-10018-0},
  url = {https://doi.org/10.1007/s10664-021-10018-0},
  abstract = {Software development is a very broad activity that captures the entire life cycle of a software, which includes designing, programming, maintenance and so on. In this study, we focus on the maintenance-related concerns of the post-deployment of smart contracts. Smart contracts are self-executed programs that run on a blockchain. They cannot be modified once deployed and hence they bring unique maintenance challenges compared to conventional software. According to the definition of ISO/IEC 14764, there are four kinds of software maintenance, i.e., corrective, adaptive, perfective, and preventive maintenance. This study aims to answer (i) What kinds of issues will smart contract developers encounter for corrective, adaptive, perfective, and preventive maintenance after they are deployed to the Ethereum? (ii) What are the current maintenance-related methods used for smart contracts? To obtain the answers to these research questions, we first conducted a systematic literature review to analyze 131 smart contract related research papers published from 2014 to 2020. Since the Ethereum ecosystem is fast-growing, some results from previous publications might be out-of-date and there may be a gap between academia and industry. To address this, we performed an online survey of smart contract developers on Github to validate our findings and received 165 useful responses. Based on the survey feedback and literature review, we present the first empirical study on smart contract maintenance-related concerns. Our study can help smart contract developers better maintain their smart contract-based projects, and we highlight some key future research directions to improve the Ethereum ecosystem.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_32523_7_31,
  title = {Application of Siamese Neural Networks for Fast Vulnerability Detection in MIPS Executable Code},
  author = {Demidov, Roman and Pechenkin, Alexander},
  booktitle = {Advances in Intelligent Systems and Computing},
  year = {2020},
  pages = {454-466},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-32523-7\_31},
  url = {https://doi.org/10.1007/978-3-030-32523-7\_31},
  abstract = {The paper addresses a problem of lightweight vulnerability detection in program code, represented by MIPS instruction set, which is widely used in network and IoT devices. For these purposes, it is proposed to use the Siamese neural network, which was involved both for pre-training the instruction embeddings, and for training the code vulnerability classifier. Instruction embeddings are obtained by solving auxiliary task of matching the semantically equivalent code pieces. Proposed approach has been tested on publicly available dataset and gave positive results.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_31703_4_5,
  title = {Malware},
  author = {Prasad, Ramjee and Rohokale, Vandana},
  booktitle = {Springer Series in Wireless Technology},
  year = {2020},
  pages = {67-81},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-31703-4\_5},
  url = {https://doi.org/10.1007/978-3-030-31703-4\_5},
  abstract = {FedEx Corporation, a global courier system, Russian criminal investigation agency and a top mobile operator, Megaphone, United Kingdom healthcare centers, worldwide banking services have come under recent malware attack during massive WannaCry Ransomware attack wave (Associated Press, ABC News 2017). Nowadays our society is successfully going towards tech savvy mode. This is very positive step towards growth, but at the same time our infrastructure relies on technology as well as computers. A threat to the computing system has become a threat to the society. There are four key threats to consider like Spam, Bugs, Denials of service, malicious software, etc.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_15_5232_8_56,
  title = {An Improved Ensemble Based Machine Learning Technique for Efficient Malware Classification},
  author = {Hussain, Farwa Maqbool and Khan, Farhan Hassan},
  booktitle = {Communications in Computer and Information Science},
  year = {2020},
  pages = {651-662},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-5232-8\_56},
  url = {https://doi.org/10.1007/978-981-15-5232-8\_56},
  abstract = {Android smartphones have become an emerging technology due to widespread adoption. The widely used Android devices allow installation of apps and grant privileges to access confidential information from the phone which resulted in being targeted by malware developers. The dramatic rise in the number of attacks, develop an interest to make a robust system that automatically identifies the presence of malicious behavior in Android applications. The previous malware detection studies comprised of static and dynamic analysis techniques, extreme learning machine and virtual machine introspection that have few shortcomings in detection of data outflow such as high computational and performance cost, low accuracy, high false positive rates, etc. The proposed approach overcomes the problems of static and dynamic techniques in malware detection. The novel classification approach senses all kinds of source-code and application behaviors. The proposed technique scans the keywords of manifest.xml files for malicious items. By the enhancement of manifest.xml feature the proposed technique can reduce apps scan time as compared to previous proposed malware detection frameworks. This technique also improves the security of Android users.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s11390_020_0496_0,
  title = {Learning Human-Written Commit Messages to Document Code Changes},
  author = {Huang, Yuan and Jia, Nan and Zhou, Hao-Jie and Chen, Xiang-Ping and Zheng, Zi-Bin and Tang, Ming-Dong},
  journal = {Journal of Computer Science and Technology},
  year = {2020},
  volume = {35},
  number = {6},
  pages = {1258-1277},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11390-020-0496-0},
  url = {https://doi.org/10.1007/s11390-020-0496-0},
  abstract = {Commit messages are important complementary information used in understanding code changes. To address message scarcity, some work is proposed for automatically generating commit messages. However, most of these approaches focus on generating summary of the changed software entities at the superficial level, without considering the intent behind the code changes (e.g., the existing approaches cannot generate such message: “fixing null pointer exception”). Considering developers often describe the intent behind the code change when writing the messages, we propose ChangeDoc, an approach to reuse existing messages in version control systems for automatical commit message generation. Our approach includes syntax, semantic, pre-syntax, and pre-semantic similarities. For a given commit without messages, it is able to discover its most similar past commit from a large commit repository, and recommend its message as the message of the given commit. Our repository contains half a million commits that were collected from SourceForge. We evaluate our approach on the commits from 10 projects. The results show that 21.5\% of the recommended messages by ChangeDoc can be directly used without modification, and 62.8\% require minor modifications. In order to evaluate the quality of the commit messages recommended by ChangeDoc, we performed two empirical studies involving a total of 40 participants (10 professional developers and 30 students). The results indicate that the recommended messages are very good approximations of the ones written by developers and often include important intent information that is not included in the messages generated by other tools.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_64881_7_10,
  title = {Enabling Next-Generation Cyber Ranges with Mobile Security Components},
  author = {Russo, Enrico and Verderame, Luca and Merlo, Alessio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {150-165},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-64881-7\_10},
  url = {https://doi.org/10.1007/978-3-030-64881-7\_10},
  abstract = {The number of security incidents involving mobile devices has risen in the past years. This means that organizations must seriously consider such devices within their threat landscape and prepare their cybersecurity operators to prevent, identify, and manage security issues involving them. Nowadays, cyber ranges represent the most effective and versatile systems for training skills in the cybersecurity domain as they provide hands-on experiences in large, sophisticated infrastructures. Nevertheless, cyber ranges are capable of emulating components and interactions of the Information and Operational Technology domains, but they lack the support of mobile devices with the same effectiveness and realism. In this paper, we propose an enhancement of the architecture and the training environments of an existing cyber range, which properly integrates mobile security components. The effectiveness of such an integration is due to a thorough review of the mobile threat landscape and the functional components of a cyber range.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_65726_0_5,
  title = {Explaining Android Application Authorship Attribution Based on Source Code Analysis},
  author = {Murenin, Ivan and Novikova, Evgenia and Ushakov, Roman and Kholod, Ivan},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {43-56},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-65726-0\_5},
  url = {https://doi.org/10.1007/978-3-030-65726-0\_5},
  abstract = {Source code authorship attribution is a process of source code authorship identification based on set of known code samples belonging to the given author. One of practical applications of code attribution is a malware analysis and detection. In the paper we explore attribution of Android applications based on classification of source code data with particular focus on explanation of the role of selected features and their impact on the final classifier decision. The proposed solution uses Local Interpretable Model–Agnostic Explanations (LIME) technique to explain decisions produced by classifiers. We explored this approach on several types of classifiers such as SVM, Random Forrest and neural network and dataset containing applications belonging to more than 20 different authors.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10462_025_11338_z,
  title = {Generative AI for cyber threat intelligence: applications, challenges, and analysis of real-world case studies},
  author = {Balasubramanian, Prasasthy and Liyana, Sonali and Sankaran, Hamsini and Sivaramakrishnan, Shambavi and Pusuluri, Sruthi and Pirttikangas, Susanna and Peltonen, Ella},
  journal = {Artificial Intelligence Review},
  year = {2025},
  volume = {58},
  number = {11},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10462-025-11338-z},
  url = {https://doi.org/10.1007/s10462-025-11338-z},
  abstract = {Abstract This paper presents a comprehensive survey of the applications, challenges, and limitations of Generative AI (GenAI) in enhancing threat intelligence within cybersecurity, supported by real-world case studies. We examine a wide range of data sources in Cyber Threat Intelligence (CTI), including security reports, blogs, social media, network traffic, malware samples, dark web data, and threat intelligence platforms (TIPs). This survey provides a full reference for integrating GenAI into CTI. We discuss various GenAI models such as Large Language Models (LLMs) and Deep Generative Models (DGMs) like Variational Autoencoders (VAEs), Generative Adversarial Networks (GANs), and Diffusion Models, explaining their roles in detecting and addressing complex cyber threats. The survey highlights key applications in areas such as malware detection, network traffic analysis, phishing detection, threat actor attribution, and social engineering defense. We also explore critical challenges in deploying GenAI, including data privacy, security concerns, and the need for interpretable and transparent models. As regulations like the European Commission’s AI Act emerge, ensuring trustworthy AI solutions is becoming more crucial. Real-world case studies, such as the impact of the WannaCry ransomware, the rise of deepfakes, and AI-driven social engineering, demonstrate both the potential and current limitations of GenAI in CTI. Our goal is to provide foundational insights and strategic direction for advancing GenAI’s role in future cybersecurity frameworks, emphasizing the importance of innovation, adaptability, and ongoing learning to enhance resilience against evolving cyber threats. Ultimately, this survey offers critical insights into how GenAI can shape the future of cybersecurity by addressing key challenges and providing actionable guidance for effective implementation.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_47131_6_4,
  title = {Forensic Investigation of Ransomware Activities—Part 1},
  author = {Young, Cian and McArdle, Robert and Le-Khac, Nhien-An and Choo, Kim-Kwang Raymond},
  booktitle = {Studies in Big Data},
  year = {2020},
  pages = {51-77},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-47131-6\_4},
  url = {https://doi.org/10.1007/978-3-030-47131-6\_4},
  abstract = {Techniques employed by malware authors evolve and become more advanced each day in an effort to bypass defences and evade detection. From 2013 to the present, a type of malware known as ransomware has increased exponentially in popularity with cyber criminals. Ransomware encrypts files on a victim’s filesystem and subsequently demands a ransom payment to release the files. The exponential growth of ransomware poses a serious and real threat to end-users and organisations worldwide. The exponential growth also poses serious challenges to the security industry, such as the need to analyse and study the large volume of emerging ransomware families. A problem exists in that new ransomware families may use previously unseen techniques to evade detection and detonate successfully. A second problem exists for security analysts when it comes to analysing the ever increasing volume of emerging ransomware families. Malware analysis generally falls into one of two categories: static and dynamic analysis. Dynamic analysis is effective at classifying malware, however it’s ineffective at discovering newly developed techniques or functionality. On the contrary static analysis is effective at discovering newly developed techniques and functionality, however it requires significantly more time to complete than dynamic analysis. The information gathered from static analysis is essential to enable organisations better defend against these new attacks. The information obtained from this research can be used to help defend against future threats using similar techniques and highlight the effectiveness of manual analysis to discover new and advanced techniques.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_64881_7_5,
  title = {APPregator: A Large-Scale Platform for Mobile Security Analysis},
  author = {Verderame, Luca and Caputo, Davide and Romdhana, Andrea and Merlo, Alessio},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {73-88},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-64881-7\_5},
  url = {https://doi.org/10.1007/978-3-030-64881-7\_5},
  abstract = {The Google Play Store currently includes up to 2.8M apps. Nonetheless, it is rather straightforward for a user to quickly retrieve the app that matches her tastes, as Google provides a reliable search engine. However, it is likewise almost impossible to select apps according to a security footprint (e.g., all apps that enforce SSL pinning). To overcome this limitation, this paper presents APPregator, a platform which allows security analysts to i) download apps from multiple app stores, ii) perform automated security analysis (both static and dynamic), and iii) aggregate the results according to user-defined security constraints (e.g., vulnerability patterns). The empirical assessment of APPregator on a set of 200.000 apps taken from the Google Play Store and Aptoide suggests that the current implementation grants a good level of performance and reliability. APPregator will be made freely available to the research community by the end of 2020.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_61078_4_3,
  title = {Detection of Metamorphic Malware Packers Using Multilayered LSTM Networks},
  author = {Bergenholtz, Erik and Casalicchio, Emiliano and Ilie, Dragos and Moss, Andrew},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {36-53},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-61078-4\_3},
  url = {https://doi.org/10.1007/978-3-030-61078-4\_3},
  abstract = {Malware authors do their best to conceal their malicious software to increase its probability of spreading and to slow down analysis. One method used to conceal malware is packing, in which the original malware is completely hidden through compression or encryption, only to be reconstructed at run-time. In addition, packers can be metamorphic, meaning that the output of the packer will never be exactly the same, even if the same file is packed again. As the use of known off-the-shelf malware packers is declining, it is becoming increasingly more important to implement methods of detecting packed executables without having any known samples of a given packer. In this study, we evaluate the use of recurrent neural networks as a means to classify whether or not a file is packed by a metamorphic packer. We show that even with quite simple networks, it is possible to correctly distinguish packed executables from non-packed executables with an accuracy of up to \\(89.36\\\%\\) when trained on a single packer, even for samples packed by previously unseen packers. Training the network on more packer raises this number to up to \\(99.69\\\%\\) .},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_62223_7_10,
  title = {Malware Detection Based on Static and Dynamic Features Analysis},
  author = {Xu, Budong and Li, Yongqin and Yu, Xiaomei},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {111-124},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-62223-7\_10},
  url = {https://doi.org/10.1007/978-3-030-62223-7\_10},
  abstract = {Machine learning algorithms are widely used in malware detection where successful analysis on static and dynamic features plays a crucial role in process of detecting malicious samples. In this paper, the potential malicious features are summarized with their effectiveness in detection. Moreover, the machine learning approaches based on static and dynamic features analysis are studied with both merits and limitations. Finally, possible solutions are proposed and novel malware detection are put forward, which shows superiority in performance comparison.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_57321_8_1,
  title = {Explainable Artificial Intelligence: Concepts, Applications, Research Challenges and Visions},
  author = {Longo, Luca and Goebel, Randy and Lecue, Freddy and Kieseberg, Peter and Holzinger, Andreas},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {1-16},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-57321-8\_1},
  url = {https://doi.org/10.1007/978-3-030-57321-8\_1},
  abstract = {The development of theory, frameworks and tools for Explainable AI (XAI) is a very active area of research these days, and articulating any kind of coherence on a vision and challenges is itself a challenge. At least two sometimes complementary and colliding threads have emerged. The first focuses on the development of pragmatic tools for increasing the transparency of automatically learned prediction models, as for instance by deep or reinforcement learning. The second is aimed at anticipating the negative impact of opaque models with the desire to regulate or control impactful consequences of incorrect predictions, especially in sensitive areas like medicine and law. The formulation of methods to augment the construction of predictive models with domain knowledge can provide support for producing human understandable explanations for predictions. This runs in parallel with AI regulatory concerns, like the European Union General Data Protection Regulation, which sets standards for the production of explanations from automated or semi-automated decision making. Despite the fact that all this research activity is the growing acknowledgement that the topic of explainability is essential, it is important to recall that it is also among the oldest fields of computer science. In fact, early AI was re-traceable, interpretable, thus understandable by and explainable to humans. The goal of this research is to articulate the big picture ideas and their role in advancing the development of XAI systems, to acknowledge their historical roots, and to emphasise the biggest challenges to moving forward.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_63086_7_6,
  title = {Coronavirus Contact Tracing App Privacy: What Data Is Shared by the Singapore OpenTrace App?},
  author = {Leith, Douglas J. and Farrell, Stephen},
  booktitle = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
  year = {2020},
  pages = {80-96},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63086-7\_6},
  url = {https://doi.org/10.1007/978-3-030-63086-7\_6},
  abstract = {We report on measurements of the actual data transmitted to backend servers by the Singapore OpenTrace app, with a view to evaluating impacts on user privacy. We have three main findings: 1) The OpenTrace app uses Google’s Firebase service to store and manage user data. This means that there are two main parties involved in handling data transmitted from the app, namely Google and the health authority operating the OpenTrace app itself. We find that OpenTrace’s use of Firebase Analytics telemetry means the data sent by OpenTrace potentially allows the (IP-based) location of user handsets to be tracked by Google over time. We therefore recommend that OpenTrace be modified to disable use of Firebase Analytics. 2) OpenTrace also currently requires users to supply a phone number to use the app and uses the Firebase Authentication service to validate and store the entered phone number. The decision to ask for user phone numbers (or other identifiers) presumably reflects a desire for contact tracers to proactively call contacts of a person that has tested positive. Alternative designs make those contacts aware of the positive test, but leave it to the contact to initiate action. This may indicate a direct trade-off between privacy and the effectiveness of contact tracing. If storage of phone numbers is judged necessary we recommend changing OpenTrace to avoid use of Firebase Authentication for this. And finally, 3) the reversible encryption used in OpenTrace relies on a single long-term secret key stored in a Google Cloud service and so is vulnerable to disclosure of this secret key.},
  content_type = {Conference paper},
}


@article{springer_10_1007_s10664_021_09973_5,
  title = {Understanding and improving artifact sharing in software engineering research},
  author = {Timperley, Christopher S. and Herckis, Lauren and Le Goues, Claire and Hilton, Michael},
  journal = {Empirical Software Engineering},
  year = {2021},
  volume = {26},
  number = {4},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-021-09973-5},
  url = {https://doi.org/10.1007/s10664-021-09973-5},
  abstract = {In recent years, many software engineering researchers have begun to include artifacts alongside their research papers. Ideally, artifacts, including tools, benchmarks, and data, support the dissemination of ideas, provide evidence for research claims, and serve as a starting point for future research. However, in practice, artifacts suffer from a variety of issues that prevent the realization of their full potential. To help the software engineering community realize the full potential of artifacts, we seek to understand the challenges involved in the creation, sharing, and use of artifacts. To that end, we perform a mixed-methods study including a survey of artifacts in software engineering publications, and an online survey of 153 software engineering researchers. By analyzing the perspectives of artifact creators, users, and reviewers, we identify several high-level challenges that affect the quality of artifacts including mismatched expectations between these groups, and a lack of sufficient reward for both creators and reviewers. Using Diffusion of Innovations (DoI) as an analytical framework, we examine how these challenges relate to one another, and build an understanding of the factors that affect the sharing and success of artifacts. Finally, we make recommendations to improve the quality of artifacts based on our results and existing best practices.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_66626_2_10,
  title = {An Insecurity Study of Ethereum Smart Contracts},
  author = {Gupta, Bishwas C. and Kumar, Nitesh and Handa, Anand and Shukla, Sandeep K.},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {188-207},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-66626-2\_10},
  url = {https://doi.org/10.1007/978-3-030-66626-2\_10},
  abstract = {Ethereum is the second most valuable cryptocurrency, right after Bitcoin. The most distinguishing feature of Ethereum was the introduction of smart contracts which are essentially small computer programs that sit on top of the blockchain. They are written in programming languages like Solidity and are executed by the Ethereum Virtual Machine (EVM). Since these contracts are present on the blockchain itself, they become immutable as long as the blockchains integrity is not compromised. This makes it a nightmare for security researchers as the vulnerabilities found cannot be patched. Also, since Ethereum is a public blockchain, all the contract bytecodes are available publicly. The DAO and the Parity attack are two prominent attacks that have caused great monetary losses. There are many tools that have been developed to cope with these challenges. However, the lack of a benchmark to compare these tools, non-standard vulnerability naming conventions, etc. make the job of a security analyst very difficult. This paper provides the first ever comprehensive comparison of smart contract vulnerability discovery tools which are available in the public domain based on a comprehensive benchmark developed here. The benchmark development is based on a novel taxonomy of smart contract vulnerabilities which has been created after a thorough study of security vulnerabilities present in smart contracts.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_61638_0_15,
  title = {Post-exploitation and Persistence Techniques Against Programmable Logic Controller},
  author = {Bytes, Andrei and Zhou, Jianying},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {255-273},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-61638-0\_15},
  url = {https://doi.org/10.1007/978-3-030-61638-0\_15},
  abstract = {The rising appearance of system security threats against real-world Critical Infrastructure (CI) sites over the past years brought significant research attention into the security of Industrial Control Systems (ICS). Academic institutions and major industrial appliance vendors have since increased efforts on effective vulnerability discovery in these systems. However, from the investigation of the major recent ICS incidents, it is evident that a targeted post-exploitation chain plays a crucial role for an attack to succeed. After the initial access to the system is gained, typically through a previously unknown (zero-day) or unpatched vulnerability, weak credentials or insider assistance, a specific knowledge on the system architecture is applied to achieve stealthy and persistent presence in the system before the physical process is disrupted. In this work, we propose a set of post-exploitation and persistence techniques against WAGO PFC200 Series Programmable Logic Controller (PLC). It will help to raise the awareness of stealthy and persistent threats to PLCs built on top of the variations of CODESYS runtime.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_5943_6_8,
  title = {Exploring the Basic APIs, Part 2},
  author = {Späth, Peter and Friesen, Jeff},
  booktitle = {Learn Java for Android Development},
  year = {2020},
  pages = {359-385},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-5943-6\_8},
  url = {https://doi.org/10.1007/978-1-4842-5943-6\_8},
  abstract = {There are more basic APIs in the java.lang package and also in java.lang.ref , java.lang.reflect , and java.util to consider for your Android apps. For example, you can add timers to your games.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_54994_7_4,
  title = {Compiling C and C++ Programs for Dynamic White-Box Analysis},
  author = {Baranová, Zuzana and Ročkai, Petr},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {30-45},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-54994-7\_4},
  url = {https://doi.org/10.1007/978-3-030-54994-7\_4},
  abstract = {Building software packages from source is a complex and highly technical process. For this reason, most software comes with build instructions which have both a human-readable and an executable component. The latter in turn requires substantial infrastructure, which helps software authors deal with two major sources of complexity: first, generation and management of various build artefacts and their dependencies, and second, the differences between platforms, compiler toolchains and build environments. This poses a significant problem for white-box analysis tools, which often require that the source code of the program under test is compiled into an intermediate format, like the LLVM IR. In this paper, we present divcc , a drop-in replacement for C and C++ compilation tools which transparently fits into existing build tools and software deployment solutions. Additionally, divcc generates intermediate and native code in a single pass, ensuring that the final executable is built from the intermediate code that is being analysed.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_1_4842_5853_8_9,
  title = {Tips and Tricks},
  author = {Verma, Rishabh},
  booktitle = {Visual Studio Extensibility Development},
  year = {2020},
  pages = {375-412},
  publisher = {Apress},
  doi = {10.1007/978-1-4842-5853-8\_9},
  url = {https://doi.org/10.1007/978-1-4842-5853-8\_9},
  abstract = {In this chapter, we will discuss a few handy tips that can be useful for working with Visual Studio and for developing and using its extensions. A few of these tips will also help to make the extensions more professional. We shall also discuss briefly the extensibility of Visual Studio Code and Visual Studio for Mac. Finally, we will wrap up this chapter and the book with a few of the cool and useful extensions that I use.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_981_33_4922_3_5,
  title = {MinerGate: A Novel Generic and Accurate Defense Solution Against Web Based Cryptocurrency Mining Attacks},
  author = {Yu, Guorui and Yang, Guangliang and Li, Tongxin and Han, Xinhui and Guan, Shijie and Zhang, Jialong and Gu, Guofei},
  booktitle = {Communications in Computer and Information Science},
  year = {2020},
  pages = {50-70},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-33-4922-3\_5},
  url = {https://doi.org/10.1007/978-981-33-4922-3\_5},
  abstract = {Abstract Web-based cryptocurrency mining attacks, also known as cryptojacking, become increasingly popular. A large number of diverse platforms (e.g., Windows, Linux, Android, and iOS) and devices (e.g., PC, smartphones, tablets, and even critical infrastructures) are widely impacted. Although a variety of detection approaches were recently proposed, it is challenging to apply these approaches to attack prevention directly. Instead, in this paper, we present a novel generic and accurate defense solution, called “MinerGate”, against cryptojacking attacks. To achieve the goal, MinerGate is designed as an extension of network gateways or proxies to protect all devices behind it. When attacks are identified, MinerGate can enforce security rules on victim devices, such as stopping the execution of related JavaScript code and alerting victims. Compared to prior approaches, MinerGate does not require any modification of browsers or apps to collect the runtime features. Instead, MinerGate focuses on the semantics of mining payloads (usually written in WebAssembly/asm.js), and semantic-based features. In our evaluation, we first verify the correctness of MinerGate by testing MinerGate in a real environment. Then, we check MinerGate’s performance and confirm MinerGate introduces relatively low overhead. Last, we verify the accuracy of MinerGate. For this purpose, we collect the largest WebAssembly/asm.js related code with ground truth to build our experiment dataset. By comparing prior approaches and MinerGate on the dataset, we find MinerGate achieves better accuracy and coverage (i.e., 99\% accuracy and 98\% recall). Our dataset will be available online, which should be helpful for more solid understanding of cryptojacking attacks.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_58951_6_12,
  title = {Dynamic and Secure Memory Transformation in Userspace},
  author = {Lyerly, Robert and Wang, Xiaoguang and Ravindran, Binoy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {237-256},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-58951-6\_12},
  url = {https://doi.org/10.1007/978-3-030-58951-6\_12},
  abstract = {Continuous code re-randomization has been proposed as a way to prevent advanced code reuse attacks. However, recent research shows the possibility of exploiting the runtime stack even when performing integrity checks or code re-randomization protections. Additionally, existing re-randomization frameworks do not achieve strong isolation, transparency and efficiency when securing the vulnerable application. In this paper we present Chameleon, a userspace framework for dynamic and secure application memory transformation. Chameleon is an out-of-band system, meaning it leverages standard userspace primitives to monitor and transform the target application memory from an entirely separate process. We present the design and implementation of Chameleon to dynamically re-randomize the application stack slot layout, defeating recent attacks on stack object exploitation. The evaluation shows Chameleon significantly raises the bar of stack object related attacks with only a 1.1\% overhead when re-randomizing every 50 ms.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_1706_8_9,
  title = {Applications of Decision Trees},
  author = {Thomas, Tony and P. Vijayaraghavan, Athira and Emmanuel, Sabu},
  booktitle = {Machine Learning Approaches in Cyber Security Analytics},
  year = {2020},
  pages = {157-184},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-1706-8\_9},
  url = {https://doi.org/10.1007/978-981-15-1706-8\_9},
  abstract = {Decision tree is a machine learning technique for solving both classification and regression problems. They help in identifying the relationship among data points in a dataset by constructing tree structures. These tree-like structures are used to make accurate predictions about unseen data. The dataset is split into multiple subsets, thereby resulting in each decision node branching to more decision nodes. The very first decision node from which the split begins is called the root node, and the final decision nodes which do not split further anymore are called the leaf nodes. Decision trees are constructed as a top-to-down structured model in the divide-and-conquer fashion.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_61467_6_14,
  title = {The Good, The Bad and The Ugly: Pitfalls and Best Practices in Automated Sound Static Analysis of Ethereum Smart Contracts},
  author = {Schneidewind, Clara and Scherer, Markus and Maffei, Matteo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {212-231},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-61467-6\_14},
  url = {https://doi.org/10.1007/978-3-030-61467-6\_14},
  abstract = {Ethereum smart contracts are distributed programs running on top of the Ethereum blockchain. Since program flaws can cause significant monetary losses and can hardly be fixed due to the immutable nature of the blockchain, there is a strong need of automated analysis tools which provide formal security guarantees. Designing such analyzers, however, proved to be challenging and error-prone. We review the existing approaches to automated, sound, static analysis of Ethereum smart contracts and highlight prevalent issues in the state of the art. Finally, we overview eThor , a recent static analysis tool that we developed following a principled design and implementation approach based on rigorous semantic foundations to overcome the problems of past works.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_981_15_1706_8_4,
  title = {Support Vector Machines and Malware Detection},
  author = {Thomas, Tony and P. Vijayaraghavan, Athira and Emmanuel, Sabu},
  booktitle = {Machine Learning Approaches in Cyber Security Analytics},
  year = {2020},
  pages = {49-71},
  publisher = {Springer Singapore},
  doi = {10.1007/978-981-15-1706-8\_4},
  url = {https://doi.org/10.1007/978-981-15-1706-8\_4},
  abstract = {In this chapter, we shall take a look at what support vector machine (SVM) is, how it works, and then get into the details of applying SVM in malware detection. SVM learning algorithm is a supervised machine learning technique used for both regression and classification problems. Regression models are used in predicting continuous values, and classification models are used in predicting which class a data point is part of. SVMs are mostly used for solving classification problems. At the end of this chapter, we also demonstrate the classification of malware from benign ones.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_58768_0_11,
  title = {Hoare-Style Logic for Unstructured Programs},
  author = {Lundberg, Didrik and Guanciale, Roberto and Lindner, Andreas and Dam, Mads},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {193-213},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-58768-0\_11},
  url = {https://doi.org/10.1007/978-3-030-58768-0\_11},
  abstract = {Enabling Hoare-style reasoning for low-level code is attractive since it opens the way to regain structure and modularity in a domain where structure is essentially absent. The field, however, has not yet arrived at a fully satisfactory solution, in the sense of avoiding restrictions on control flow (important for compiler optimization), controlling access to intermediate program points (important for modularity), and supporting total correctness. Proposals in the literature support some of these properties, but a solution that meets them all is yet to be found. We introduce the novel Hoare-style program logic \\(\\mathcal \{L\}\_A\\) , which interprets postconditions relative to program points when these are first encountered. The logic can support both partial and total correctness, derive contracts for arbitrary control flow, and allows one to freely choose decomposition strategy during verification while avoiding step-indexed approximations and global invariants. The logic can be instantiated for a variety of concrete instruction set architectures and intermediate languages. The rules of \\(\\mathcal \{L\}\_A\\) have been verified in the interactive theorem prover HOL4 and integrated with the toolbox HolBA for semi-automated program verification, making it applicable to the ARMv6 and ARMv8 instruction sets.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_62077_6_7,
  title = {Formal Verification of Ethereum Smart Contracts Using Isabelle/HOL},
  author = {Ribeiro, Maria and Adão, Pedro and Mateus, Paulo},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {71-97},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-62077-6\_7},
  url = {https://doi.org/10.1007/978-3-030-62077-6\_7},
  abstract = {The concept of blockchain was developed with the purpose of decentralizing the trade of assets, suppressing the need for intermediaries during this process, as well as achieving a digital trust between parties. A blockchain consists in a public immutable ledger, constituted by chronologically ordered blocks such that each block contains records of a finite number of transactions. The Ethereum platform, that this paper builds upon, is implemented using a blockchain architecture and introduces the possibility of storing Turing complete programs. These programs, also known as smart contracts, can then be executed using the Ethereum Virtual Machine. Despite its core language being the EVM bytecode, they can also be implemented using a higher-level language that is later compiled to EVM, being Solidity the most used. Among its applications stand out decentralized information storage, tokenization of assets, and digital identity verification. In this paper we propose a method for formal verification of Solidity smart contracts in Isabelle/HOL. We start from the imperative language and big-step semantics proposed by Schirmer [ 23 ], and adapt it to describe a rich subset of Solidity, implementing it using the Isabelle/HOL proof assistant. Then, we describe the properties about programs using Hoare logic, and present a proof system for the language, for which results on soundness and (relative) completeness are obtained. Finally, we describe the verification of an electronic voting smart contract, which illustrates the degree of proof complexity that can be achieved using this method. Examples of smart contracts containing overflow and reentrancy vulnerabilities are also presented.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_021_09990_4,
  title = {Evaluating the robustness of source code plagiarism detection tools to pervasive plagiarism-hiding modifications},
  author = {Cheers, Hayden and Lin, Yuqing and Smith, Shamus P.},
  journal = {Empirical Software Engineering},
  year = {2021},
  volume = {26},
  number = {5},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-021-09990-4},
  url = {https://doi.org/10.1007/s10664-021-09990-4},
  abstract = {Source code plagiarism is a common occurrence in undergraduate computer science education. In order to identify such cases, many source code plagiarism detection tools have been proposed. A source code plagiarism detection tool evaluates pairs of assignment submissions to detect indications of plagiarism. However, a plagiarising student will commonly apply plagiarism-hiding modifications to source code in an attempt to evade detection. Subsequently, prior work has implied that currently available source code plagiarism detection tools are not robust to the application of pervasive plagiarism-hiding modifications. In this article, 11 source code plagiarism detection tools are evaluated for robustness against plagiarism-hiding modifications. The tools are evaluated with data sets of simulated undergraduate plagiarism, constructed with source code modifications representative of undergraduate students. The results of the performed evaluations indicate that currently available source code plagiarism detection tools are not robust against modifications which apply fine-grained transformations to the source code structure. Of the evaluated tools, JPlag and Plaggie demonstrates the greatest robustness to different types of plagiarism-hiding modifications. However, the results also indicate that graph-based tools, specifically those that compare programs as program dependence graphs, show potentially greater robustness to pervasive plagiarism-hiding modifications.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_41251_7_7,
  title = {Cognitively-Inspired Inference for Malware Task Identification},
  author = {Nunes, Eric and Buto, Casey and Shakarian, Paulo and Lebiere, Christian and Bennati, Stefano and Thomson, Robert},
  booktitle = {Lecture Notes in Social Networks},
  year = {2020},
  pages = {165-194},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-41251-7\_7},
  url = {https://doi.org/10.1007/978-3-030-41251-7\_7},
  abstract = {Malware reverse-engineering, specifically, identifying the tasks a given piece of malware was designed to perform (e.g., logging keystrokes, recording video, establishing remote access) is a largely human-driven process that is a difficult and time-consuming operation. In this chapter, we present an automated method to identify malware tasks using two different approaches based on the ACT-R cognitive architecture, a popular implementation of a unified theory of cognition. Using three different malware collections, we explore various evaluations for each of an instance-based and rule-based model—including cases where the training data differs significantly from test; where the malware being evaluated employs packing to thwart analytical techniques; and conditions with sparse training data. We find that our approach based on cognitive inference consistently out-performs the current state-of-the art software for malware task identification as well as standard machine learning approaches—often achieving an unbiased F1 score of over 0.9.},
  content_type = {Chapter},
}


@article{springer_10_1007_s11704_020_9284_9,
  title = {Ethereum smart contract security research: survey and future research opportunities},
  author = {Wang, Zeli and Jin, Hai and Dai, Weiqi and Choo, Kim-Kwang Raymond and Zou, Deqing},
  journal = {Frontiers of Computer Science},
  year = {2021},
  volume = {15},
  number = {2},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s11704-020-9284-9},
  url = {https://doi.org/10.1007/s11704-020-9284-9},
  abstract = {Blockchain has recently emerged as a research trend, with potential applications in a broad range of industries and context. One particular successful Blockchain technology is smart contract, which is widely used in commercial settings (e.g., high value financial transactions). This, however, has security implications due to the potential to financially benefit from a security incident (e.g., identification and exploitation of a vulnerability in the smart contract or its implementation). Among, Ethereum is the most active and arresting. Hence, in this paper, we systematically review existing research efforts on Ethereum smart contract security, published between 2015 and 2019. Specifically, we focus on how smart contracts can be maliciously exploited and targeted, such as security issues of contract program model, vulnerabilities in the program and safety consideration introduced by program execution environment. We also identify potential research opportunities and future research agenda.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_63287_8_18,
  title = {Constructing Random Oracles—UCEs},
  author = {Mittelbach, Arno and Fischlin, Marc},
  booktitle = {Information Security and Cryptography},
  year = {2021},
  pages = {727-778},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-63287-8\_18},
  url = {https://doi.org/10.1007/978-3-030-63287-8\_18},
  abstract = {Indifferentiability provides us with a framework to analyze and sanity-check hash function constructions that are based on a simpler primitive such as a compression function or a block cipher.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_47218_4_1,
  title = {Information Weapon: Concepts, Means, Methods, and Examples of Application},
  author = {Belous, Anatoly and Saladukha, Vitali},
  booktitle = {Viruses, Hardware and Software Trojans},
  year = {2020},
  pages = {1-99},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-47218-4\_1},
  url = {https://doi.org/10.1007/978-3-030-47218-4\_1},
  abstract = {This chapter is dedicated to the analysis of concepts, means, and methods of implementation of new dangerous and effective information technology weapons (cyberweapons ). For a deeper understanding of all aspects related to the development and application features of cyberweapons , the following issues are consistently discussed in this chapter: principles of ensuring information security of a sovereign state, main methods of modern information warfare . Information technology impacts are defined and classified, the most common of them are discussed in detail along with various technical channels of information leakage. Additionally, there are a number of examples of the use of this type of weapon.},
  content_type = {Chapter},
}


@article{springer_10_1007_s10664_019_09796_5,
  title = {An exploratory study of smart contracts in the Ethereum blockchain platform},
  author = {Oliva, Gustavo A. and Hassan, Ahmed E. and Jiang, Zhen Ming},
  journal = {Empirical Software Engineering},
  year = {2020},
  volume = {25},
  number = {3},
  pages = {1864-1904},
  publisher = {Springer Science and Business Media LLC},
  doi = {10.1007/s10664-019-09796-5},
  url = {https://doi.org/10.1007/s10664-019-09796-5},
  abstract = {Ethereum is a blockchain platform that supports smart contracts. Smart contracts are pieces of code that perform general-purpose computations. For instance, smart contracts have been used to implement crowdfunding initiatives that raised a total of US\$6.2 billion from January to June of 2018. In this paper, we conduct an exploratory study of smart contracts. Differently from prior studies that focused on particular aspects of a subset of smart contracts, our goal is to have a broader understanding of all contracts that are currently deployed in Ethereum. In particular, we elucidate how frequently used the contracts are (activity level), what they do (category), and how complex they are (source code complexity). To conduct this study, we mined and cross-linked data from four sources: Ethereum dataset on the Google BigQuery platform, Etherscan, State of the DApps, and CoinMarketCap. Our study period runs from July 2015 (inception of Ethereum) until September 2018. With regards to activity level, we notice that it is concentrated on a very small subset of the contracts. More specifically, only 0.05\% of the smart contracts are the target of 80\% of the transactions that are sent to contracts. New solutions to cope with Ethereum’s limited scalability should take such an activity imbalance into consideration. With regards to categories, we highlight that the new and widely advertised rich programming model of smart contracts is currently being used to develop very simple applications that tend to be token-centric (e.g., ICOs, Crowdsales, etc). Finally, with regards to code complexity, we observe that the source code of high-activity verified contracts is small, with at most 211 instructions in 80\% of the cases. These contracts also commonly include at least two subcontracts and libraries in their source code. The comment ratio of these contracts is also significantly higher than that of GitHub top-starred projects written in Java, C ++ , and C \# . Hence, the source code of high-activity verified smart contracts exhibit particular complexity characteristics compared to other popular programming languages. Further studies are necessary to uncover the actual reasons behind such differences. Finally, based on our findings, we propose an open research agenda to drive and foster future studies in the area.},
  content_type = {Article},
}


@incollection{springer_10_1007_978_3_030_36962_0_4,
  title = {Aiming at Predictive Accuracy},
  author = {Holeňa, Martin and Pulc, Petr and Kopp, Martin},
  booktitle = {Studies in Big Data},
  year = {2020},
  pages = {165-196},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-36962-0\_4},
  url = {https://doi.org/10.1007/978-3-030-36962-0\_4},
  abstract = {In this chapter, support vector machines (SVM) are introduced - a kind of classifiers developed specifically to achieve high predictive accuracy. First, the basic variant for binary classification into linearly separable classes is presented, which is then followed by extensions to non-linear classification, multiple classes and noise-tolerant classification. SVM are illustrated on examples from spam filtering, recommender systems and malware detection. In connection with SVM, the method of active learning is explained and illustrated on an example of SVM active learning in recommender systems.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_29844_9_10,
  title = {Engineering and Implementation of Mimic Defense},
  author = {Wu, Jiangxing},
  booktitle = {Wireless Networks},
  year = {2020},
  pages = {495-560},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-29844-9\_10},
  url = {https://doi.org/10.1007/978-3-030-29844-9\_10},
  abstract = {In Chap. 9 , we described the basic principles of mimic defense. In this chapter, we will focus on the basic conditions and constraints for mimic defense engineering and implementation, the key implementation mechanisms, major issues, and possible approaches and solutions. We will also briefly explore how to test and evaluate the mimic defense.},
  content_type = {Chapter},
}


@incollection{springer_10_1007_978_3_030_44914_8_1,
  title = {Trace-Relating Compiler Correctness and Secure Compilation},
  author = {Abate, Carmine and Blanco, Roberto and Ciobâcă, Ștefan and Durier, Adrien and Garg, Deepak and Hrițcu, Cătălin and Patrignani, Marco and Tanter, Éric and Thibault, Jérémy},
  booktitle = {Lecture Notes in Computer Science},
  year = {2020},
  pages = {1-28},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-44914-8\_1},
  url = {https://doi.org/10.1007/978-3-030-44914-8\_1},
  abstract = {Abstract Compiler correctness is, in its simplest form, defined as the inclusion of the set of traces of the compiled program into the set of traces of the original program, which is equivalent to the preservation of all trace properties. Here traces collect, for instance, the externally observable events of each execution. This definition requires, however, the set of traces of the source and target languages to be exactly the same, which is not the case when the languages are far apart or when observations are fine-grained. To overcome this issue, we study a generalized compiler correctness definition, which uses source and target traces drawn from potentially different sets and connected by an arbitrary relation. We set out to understand what guarantees this generalized compiler correctness definition gives us when instantiated with a non-trivial relation on traces. When this trace relation is not equality, it is no longer possible to preserve the trace properties of the source program unchanged. Instead, we provide a generic characterization of the target trace property ensured by correctly compiling a program that satisfies a given source property, and dually, of the source trace property one is required to show in order to obtain a certain target property for the compiled code. We show that this view on compiler correctness can naturally account for undefined behavior, resource exhaustion, different source and target values, side-channels, and various abstraction mismatches. Finally, we show that the same generalization also applies to many secure compilation definitions, which characterize the protection of a compiled program against linked adversarial code.},
  content_type = {Conference paper},
}


@incollection{springer_10_1007_978_3_030_29844_9_7,
  title = {DHR Architecture},
  author = {Wu, Jiangxing},
  booktitle = {Wireless Networks},
  year = {2020},
  pages = {273-337},
  publisher = {Springer International Publishing},
  doi = {10.1007/978-3-030-29844-9\_7},
  url = {https://doi.org/10.1007/978-3-030-29844-9\_7},
  abstract = {As we have learned from Chap. 6 , DRS has an inherent anti-attack attribute (i.e., intrusion-tolerant attribute) in addition to the conventional robust control attribute, where the “one-way transparent attack from within and without” based on the backdoor of static target vulnerabilities under a single-space shared resource mechanism can be upgraded in respect of complexity to the cooperative attack stage based on the backdoor of static multi-target vulnerabilities. Thus, deterministic attacks targeted at each executor, in a given multimodal OV space, will be forced by the MV mechanism into a probability event strongly correlated with the redundancy size, executor heterogeneity, and OV complexity. However, the attack resistance of DRS is affected by the following conditions and factors: ① Suppose that the heterogeneity of the DHR redundant executors is infinite in size, that is, there are no existing dark function intersections; ② the number of executors in the abnormal state within the architecture must meet the condition of f ≤ (N−1)/2; ③ external and internal coordinated attacks aiming at backdoors or malicious codes within the architecture are not taken into account; ④ majority selection ruling algorithms have judgement-blind areas against the multiple or concerted attacks and escapes; ⑤ there are no post-processing mechanisms against the executors with abnormal output vectors except hang-up/cleaning. What is worse is that the operation environment of all the executors in the DRS structure and the exploitable conditions of vulnerabilities and backdoor are statically determined and the parallel deployment of the executors usually does not change the accessibility of attack surface. Therefore, theoretically speaking, attackers can reach two aims through an unrestricted trial-and-error approach: the first aim is to break through the executors with exploitable vulnerabilities and backdoors continuously or one by one so that the number of abnormal executors which happen concurrently in the architecture is larger than f = (N−1)/2; the second aim is that the attacker may use the dark functions existing in the executors to launch standby coordinated attacks or tunnel breakthrough (please refer to Sect. 6.5.3) so as to use the judgement-blind areas of the majority selection ruling mechanisms for attack and escape. And the attack experience can be inherited. Attack methods can be copied, and the attack effects have afterward-exploitability value. That is, DRS staticity, certainty, and similarity have serious genetic defects in the security area. As a result, it lacks the capability of maintaining nondecreasing information entropy against general uncertain disturbances and therefore does not possess such features as stable robust control and quality robust control against cyber attacks. This chapter focuses on how to use the general robust control technology to change the DRS “structural genes.” Dynamic convergent and iterative diversified defense scenarios will be used to replace excessively rigid and costly heterogeneous designing to obtain the effects with the measurable designing and verifiable structure so that it is possible to stably suppress general uncertain disturbances including attacks aiming at unknown vulnerabilities and backdoors.},
  content_type = {Chapter},
}
