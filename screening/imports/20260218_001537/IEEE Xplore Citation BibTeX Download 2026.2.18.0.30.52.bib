@INPROCEEDINGS{5272381,
  author={Asher, Yosi Ben and Rotem, Nadav},
  booktitle={2009 International Conference on Field Programmable Logic and Applications}, 
  title={Binary Synthesis with multiple memory banks targeting array references}, 
  year={2009},
  volume={},
  number={},
  pages={600-603},
  abstract={High level synthesis (HLS) is the field of transforming a high level programming language, such as C, into a register transfer level(RTL) description of the design. In HLS, binary synthesis is a method for synthesizing existing compiled applications for which the source code is not available. One of the advantages of FPGAs over software is the availability of multiple memory banks. Until now, binary synthesis systems have not made use of the multiple memory banks on FPGAs. In our work, we decompile the binary executable into an intermediate representation, and we target architectures with multiple memory banks and multiple memory ports. We present methods for detecting memory regions and synthesis of the decompiled code. The proposed methods accelerate the execution time of applications which use multiple memory regions concurrently.},
  keywords={Field programmable gate arrays;Acceleration;Circuit synthesis;High level synthesis;Hardware;Application software;Computer architecture;Memory architecture;Central Processing Unit;Control system synthesis},
  doi={10.1109/FPL.2009.5272381},
  ISSN={1946-1488},
  month={Aug},}@INPROCEEDINGS{5412653,
  author={Tang, Zhangyong and Chen, Xiaojiang and Fang, Dingyi and Chen, Feng},
  booktitle={2009 Fourth International Conference on Innovative Computing, Information and Control (ICICIC)}, 
  title={Research on Java Software Protection with the Obfuscation in Identifier Renaming}, 
  year={2009},
  volume={},
  number={},
  pages={1067-1071},
  abstract={Identifier renaming is an important aspect of code obfuscation. Identifier renaming can increase program's complexities and makes the program less readable. Programs after code obfuscated by identifier renaming become more difficult to be decompiled, or the decompiled programs become harder to be recompiled. This paper proposes four identifier renaming algorithms and presents a new obfuscation tool-JIRO. JIRO produces scrambled bytecode with good obfuscation effects while reducing the effort spent on manually code development. Experimental results demonstrate the performance and efficiency of the JIRO.},
  keywords={Java;Software protection;Runtime;Educational institutions;Information science;Computer languages;Intellectual property;Merging;Computer errors;Error correction},
  doi={10.1109/ICICIC.2009.312},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{8936022,
  author={Semenov, Serhii and Davydov, Viacheslav and Voloshyn, Denys},
  booktitle={2019 XXIX International Scientific Symposium "Metrology and Metrology Assurance" (MMA)}, 
  title={Obfuscated Code Quality Measurement}, 
  year={2019},
  volume={},
  number={},
  pages={1-6},
  abstract={Nowadays, number of cyber-attacks aimed at software increases. Thus, improving the quality of software security services becomes acute. Confidentiality is one of the basic security services. It is provided, including through the use of obfuscation mechanism. Code quality measurement Methods has been investigated. Particular attention is paid to methods aimed at decompiled code, where standard metrics do not take in account. The method of decompiled code static analysis has been improved. This method takes into account the features of the compile procedure for languages with intermediate code.},
  keywords={Codes;Atmospheric measurements;Static analysis;Metrology;Particle measurements;Software;Security;Standards;Cyberattack;obfuscation;security service;code quality;immediate code},
  doi={10.1109/MMA.2019.8936022},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{9647781,
  author={Enders, Steffen and Rybalka, Mariia and Padilla, Elmar},
  booktitle={2021 18th International Conference on Privacy, Security and Trust (PST)}, 
  title={PIdARCI: Using Assembly Instruction Patterns to Identify, Annotate, and Revert Compiler Idioms}, 
  year={2021},
  volume={},
  number={},
  pages={1-7},
  abstract={Analysis of binary code is a building block of computer security. Especially in malware or firmware analysis where source code oftentimes is not available, techniques like decompilation are utilized to Figure out the functionality of binaries. During the optimization phase in modern compilers, human-readable expressions are often transformed into instruction sequences (compiler idioms or idioms) that may be more efficient in terms of speed or size than the direct translation. However, these transformations are often considerably worse in terms of readability for the analyst. Such compiler specific sequences are not only significantly longer than the apparent translation of the original high-level language operation but also have no trivial correlation to the original expression’s semantics. Modern decompilers address this issue by reverting idioms using static, manually crafted rules. In this paper, we introduce a novel approach to find and annotate arithmetic idioms with their corresponding high-level language expressions to significantly simplify manual analysis. In contrast to previous approaches, our method does not require manual work to create the patterns for matching idioms and significantly less manual labour to derive the transformation rules to calculate the original constants. In our evaluation, we compared the results of PIdARCI against the current academic and commercial state-of-the-art Ghidra, RetDec, and Hex Rays / IDA Pro. We show that PIdARCI matches more than 99% of all considered idioms, exceeding the matching rate of the other approaches.},
  keywords={Matched filters;Databases;Semantics;Manuals;Malware;High level languages;Pattern matching},
  doi={10.1109/PST52912.2021.9647781},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{8210757,
  author={de la Torre-Díez, Isabel and Trinchet, Bruno Olivar and Rodrigues, Joel J.P.C. and López-Coronado, Miguel},
  booktitle={2017 IEEE 19th International Conference on e-Health Networking, Applications and Services (Healthcom)}, 
  title={Security analysis of a mHealth app in Android: Problems and solutions}, 
  year={2017},
  volume={},
  number={},
  pages={1-6},
  abstract={In recent years, medicine has seen how technology was going day by day more present to become necessary. At the same time, security became a critical aspect, since private patient medical data are handled. In this field in which gather mobile technologies with medicine, security has great importance. Therefore, it is essential to conduct security audits to mobile applications which deal with private information and confidential patient data. The main objective of this paper is to carry out an audit of security of an mHealth Android application. Taking HeartKeeper application to self-manage cardiac patients, a series of tests and modifications are conducted to check its strengths and weaknesses. The methodology consists in attempting to decompile the application HeartKeeper. Applying to the source code techniques of reverse engineering, we will try to perform an analysis that allows us to carry out the security check of the Android application HeartKeeper. It can be applied to audit security on any other Android application. In this way, it provides developers a tool that allows them to check the security of any Android app. Among these vulnerabilities found, the most relevant is that which allows us to inject code to steal some private information. This information should only be accessible from the application itself and only once the user is authenticated. As solutions, we propose different protections. These are: protection against decompilation, against code analysis, and against modified applications. It is very important to carry out a comprehensive review of the mobile applications' strength, since they are increasingly present in our lives and they manage sensitive and protected data. It is highly recommended to install applications from trusty sources, as they are the official app stores like Google Play Store in Android and iOS App Store.},
  keywords={Androids;Humanoid robots;Medical services;Malware;Conferences;Android;app;audit;mhealth;security},
  doi={10.1109/HealthCom.2017.8210757},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{10320193,
  author={Chen, Guoqiang and Gao, Han and Zhang, Jie and He, Yanru and Cheng, Shaoyin and Zhang, Weiming},
  booktitle={2023 20th Annual International Conference on Privacy, Security and Trust (PST)}, 
  title={Investigating Neural-based Function Name Reassignment from the Perspective of Binary Code Representation}, 
  year={2023},
  volume={},
  number={},
  pages={1-11},
  abstract={Building a model to reassign descriptive names for binary functions is considerable assistance for reverse engineering. Existing methods proposed for this issue are based on the low-level representation of binary code (e.g., assembly code), and especially the recent approaches employed neural-based models on instruction sequences. However, their performance is still unsatisfactory. Meanwhile, modern decompilers provide lifted representations of binary code, and their effectiveness has not been adequately studied. This paper further explores the issue of function name reassignment from the perspective of binary code representation. Specifically, we present a general and flexible NEural-based function name Reassignment framework NER, which leverages a decompiler to obtain a specific representation and applies the corresponding serialization strategy on it. NER then uses an alternative neural network to make predictions. Three levels of representation are investigated, including assembly code, Intermediate Representation (IR), and pseudo-code. We observe the binary code representations are significant for the final performance. It demonstrates that the pseudo-code is the most effective one. Based on these findings, we leverage the framework to implement a reassignment model NER-pc, which has 25% and 10% F1 score improvements against the state-of-the-art methods. Besides, more experiments are conducted to verify the design of NER and the effectiveness of NER-pc.},
  keywords={Privacy;Reverse engineering;Neural networks;Buildings;Binary codes;Predictive models;Security;Binary analysis;Reverse engineering;Function name prediction;Binary code representation;Neural networks},
  doi={10.1109/PST58708.2023.10320193},
  ISSN={2643-4202},
  month={Aug},}@INPROCEEDINGS{10043270,
  author={Yu, Qifan and Zhang, Pengcheng and Dong, Hai and Xiao, Yan and Ji, Shunhui},
  booktitle={2022 29th Asia-Pacific Software Engineering Conference (APSEC)}, 
  title={Bytecode Obfuscation for Smart Contracts}, 
  year={2022},
  volume={},
  number={},
  pages={566-567},
  abstract={Ethereum smart contracts face serious security problems, which not only cause huge economic losses, but also destroy the Ethereum credit system. To solve this problem, code obfuscation techniques are applied to smart contracts to improve their complexity and security. However, the current source code obfuscation methods have insufficient anti-decompilation ability. Therefore, we propose a novel bytecode obfuscation approach called BOSC based on four kinds of bytecode obfuscation techniques, which is directed at solidity. The experimental results show that, after the bytecode obfuscation, the failure rate of decompilation tools is over 99% and only a small amount of gas is consumed.},
  keywords={Economics;Codes;Source coding;Smart contracts;Complexity theory;Security;Faces;Ethereum;Smart Contract;Bytecode Obfusca-tion},
  doi={10.1109/APSEC57359.2022.00083},
  ISSN={2640-0715},
  month={Dec},}@INPROCEEDINGS{6394259,
  author={Yang, Le and He, Huo-jiao},
  booktitle={2012 International Conference on Computer Science and Service System}, 
  title={Research on Java Bytecode Parse and Obfuscate Tool}, 
  year={2012},
  volume={},
  number={},
  pages={50-53},
  abstract={The compiled Java class file is not really binary files, it's just a kind of in-between code. This makes it possible for hackers to decompile the java class file, and in fact the decompiled file is almost the same as the original one. So it's very hard to protect the java application program, and there's a big issue about the security of java class file. This paper treated protecting software and using more costly forms of reverse engineering as the target, and deeply researched reverse engineering and code obfuscation about defense and attack. A prototype of Code obfuscation system (JOT) based on Java byte code is realized.},
  keywords={Java;Software;Reverse engineering;Educational institutions;Security;Arrays;Software protection;Code obfuscation;Java},
  doi={10.1109/CSSS.2012.21},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{10197775,
  author={Lee, Young and McDonald, Arlen and Yang, Jeong},
  booktitle={2023 IEEE/ACIS 21st International Conference on Software Engineering Research, Management and Applications (SERA)}, 
  title={Identifying Code Tampering Using A Bytecode Comparison Analysis Tool}, 
  year={2023},
  volume={},
  number={},
  pages={69-76},
  abstract={The issues related to SolarWinds attacks point out a large concern with modern software development projects in that there are fundamental flaws with existing security infrastructure. The purpose of this research is to investigate to what extent can the SootDiff analysis tool, a bytecode comparison tool, be used to determine if an application has been tampered with by comparing a known good version with a version that is unknown. The compiled and decompiled bytecodes as Jimple representations were compared to analyze the unique differences in identifying code tempering. The results showed that the scope of the variable is important in whether the change was detected. Variables with a scope that was entirely contained within one method could have their names changed without triggering a warning, but global variables to objects could not. The parameter variable and the local variable behave differently. Since the parameter is in the publicly available part of the method Java treats it the same way as it does the global variable. The local variable is strictly private to the method and not made available to the outside. Such findings can support the analysis tool which is useful for identifying potential breaches to detect meaningful changes in code even if it is decompiled.},
  keywords={Java;Codes;Supply chains;Software;Security;Software engineering;SolarWinds;SootDiff;Java;Jimple;bytecode;software supply chain;software supply chain security},
  doi={10.1109/SERA57763.2023.10197775},
  ISSN={2770-8209},
  month={May},}@INPROCEEDINGS{11129273,
  author={Behner, Eva-Maria C. and Enders, Steffen and Padilla, Elmar},
  booktitle={2025 IEEE 10th European Symposium on Security and Privacy (EuroS&P)}, 
  title={SoK: No Goto, No Cry? The Fairy Tale of Flawless Control-Flow Structuring}, 
  year={2025},
  volume={},
  number={},
  pages={411-431},
  abstract={Decompilers play a crucial role in the detailed analysis of malware or firmware, particularly because control-flow structuring allows the recovery of high-level code that is more readable to human analysts. Despite the ongoing debate over their usage of gotos to work around constraints during control-flow structuring, pattern-matching approaches remain prevalent among both commercial and open-source decompilers. With the emergence of pattern-independent restructuring techniques, various attempts have been made to overcome readability limitations, especially concerning the use of gotos. However, despite these advances, recent approaches often fail to thoroughly address several inherent challenges of control-flow structuring, thereby affecting output quality or practicality.In this paper, we systematize the intrinsic challenges of control-flow structuring that every approach must address. In addition, we review existing methods, comparing them, while highlighting both their advantages and limitations with respect to these challenges. Specifically, we emphasize the practicability issues of current pattern-independent restructuring techniques and discuss whether and how future methods might overcome them. Finally, we explore the theoretical potential to mitigate some of these challenges by suggesting methodology ideas for various aspects of control-flow structuring. Overall, this paper enables other researchers to make informed decisions when developing or enhancing control-flow structuring methods, thereby preventing negative side-effects arising from the interdependence of challenges.},
  keywords={Codes;Reviews;Reverse engineering;Static analysis;Malware;Microprogramming;decompilation;control-flow recovery;control-flow structuring;reverse engineering;static analysis},
  doi={10.1109/EuroSP63326.2025.00032},
  ISSN={2995-1356},
  month={June},}@ARTICLE{11052248,
  author={Peng, Xiangzhen and Ma, Tianyu and Zheng, Chengliang and Shen, Zhidong and Cui, Xiaohui},
  journal={IEEE Internet of Things Journal}, 
  title={BCTD-ICS: A Blockchain-Aided Framework for Trusted Detection of Industrial Control System Components}, 
  year={2025},
  volume={12},
  number={18},
  pages={37552-37570},
  abstract={The cybersecurity threats targeting industrial control systems (ICSs) are evolving with increasing sophistication. Addressing the detection blind spots in existing source code analysis techniques, this study reveals a dual security paradox arising from code sensitivity: privacy leakage risks caused by decompilation techniques and integrity verification deficiencies in reverse engineering. This article investigates three critical challenges: 1) what are the component flow process and detection elements of ICS component source code? 2) how can high-performance and reliable tracing and traceability be provided for ICS component source code exceptions and routine detection? and 3) how can privacy enhancement and trusted detection of ICS component source code with high sensitivity be achieved? This article proposes a blockchain-integrated trusted detection framework for ICS (BCTD-ICS), delivering groundbreaking solutions: 1) establishing a lifecycle circulation model that systematically maps component types, stakeholders, and detection parameters; 2) developing a tripartite collaborative architecture [blockchain- identification resolution zero-knowledge proofs (ZKPs)], featuring a traceability mechanism with trusted identification codes (resolution efficiency: 40 ms/105 queries) to eliminate decompilation-induced privacy risks; and 3) creating an industrial-oriented privacy enhancement system utilizing DBSCAN clustering for intelligent sampling (26% compression rate on BCN3D Moveo) and optimizing ZK-SNARK protocols through Shamir’s secret sharing, establishing a backdoor-resistant distributed parameter generation system (time delay increment < 100 ms). Experimentally verified, our solution enables ICS component code detection supply-chain-wise without sensitive data leakage in real-world industries. This work establishes a novel trusted detection paradigm for ICS, advancing detection efficiency and credibility under strict privacy preservation requirements, meeting Industry 4.0 security demands.},
  keywords={Blockchains;Source coding;Security;Codes;Privacy;Supply chains;Protocols;Object recognition;Telecommunication traffic;Internet of Things;Artificial intelligence technology;blockchain;identification resolution technology;industrial control systems (ICSs);source code detection;zero-knowledge proofs (ZKPs)},
  doi={10.1109/JIOT.2025.3583304},
  ISSN={2327-4662},
  month={Sep.},}@INPROCEEDINGS{6222219,
  author={Obermann, D. and Börcsök, J.},
  booktitle={ARCS 2012}, 
  title={Two-Way-Compiler: Additional data saving for generating the original source code of a binary program}, 
  year={2012},
  volume={},
  number={},
  pages={1-4},
  abstract={The Two-Way-Compiler is an approach to show the equivalence between implemented source code and the generated binary program for safety-related software. A compiler which translates a source code into a binary program and restores the original source code out of the generated binary program exactly, like a decompiler, is described. Data that are required to build the original source code back again are especially examined in this paper. Some data are contained in the binary itself and other data lost during compilation. The lost data have to be collected and stored in the binary. With these additional data the decompiler can restore the binary program to the original source code.},
  keywords={Syntactics;Program processors;Optimization;Abstracts;Computer languages;Grammar;binary;compiler;decompiler;source code},
  doi={},
  ISSN={},
  month={Feb},}@ARTICLE{56445,
  author={Siber, V.},
  journal={IEEE Software}, 
  title={Comments, with reply, on 'Reverse-engineering someone else's software: is it legal?' by P. Samuelson}, 
  year={1990},
  volume={7},
  number={4},
  pages={4-},
  abstract={The commenter disagrees with the arguments in the above-titled article by P. Samuelson (ibid., vol.7, no.4, p.90-6, Jan. 1990) that reverse-engineering programs should be legal and that the unauthorized copies of the program created in decompilation are just 'incidental' and thus do not infringe the program's copyright. He also disagrees with Samuelson's contention that there is a trend for the courts to find copyright infringement only where the program that results from the reverse engineering is substantially similar in expression to the decompiled program. He presents a detailed argument to support his viewpoint. Samuelson presents additional information is support of her position.<>},
  keywords={Law;Software;Reverse engineering;Europe;Companies;Market research;Industries},
  doi={10.1109/52.56445},
  ISSN={1937-4194},
  month={July},}@INPROCEEDINGS{6157970,
  author={Jian Jun Hu and Qiaoyan Wen and Tang, Wen and Ai-Fen Sui},
  booktitle={2011 IEEE 13th International Conference on Communication Technology}, 
  title={A key hiding based software encryption protection scheme}, 
  year={2011},
  volume={},
  number={},
  pages={719-722},
  abstract={Today software has already become the critical e-assets integrated with valuable intellectual property, such as functions, processes or secrets, etc. The problem is that software, especially written in intermediate languages (Java, .NET, etc) are easy to be decompiled for reverse engineering, so the proprietary business logic, core algorithm implementation, software licensing code, and copy protection mechanisms of software are more susceptible to malicious reuse. Anyone with special decompile or reverse engineering tools such as .NET Reflect, JAD can exploit the vulnerabilities, steal unique ideas, bypass license checks, etc. In this paper we describe a key hiding based software encryption method to protect the intellectual and copy rights for software.},
  keywords={Software protection;Key-hiding},
  doi={10.1109/ICCT.2011.6157970},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{9445905,
  author={Lu, Ziang and Shao, Zhipeng},
  booktitle={2021 International Conference on Communications, Information System and Computer Engineering (CISCE)}, 
  title={A Research on ELF File Protection Schemes of IOT Application in Electric Power Industry}, 
  year={2021},
  volume={},
  number={},
  pages={105-108},
  abstract={As more and more IOT Applications implemented in electric power industry, source code leaking gradually becomes an important topic for discussion. Some researches have proved that IOT APP could be cracked down and source code (C/C++, JAVA, etc) is likely to be decompiled by attackers with expert skills. And this trend is going to be irreversible with a variety of auto-cracking tools published, which means that the cost of time and cracking technique are unprecedentedly decreased. To avoid source code leaking, some ways of protecting native code in ELF file such as code obfuscation or ELF shell (special in Android) were provided and then applied widely. But these schemes can not meanwhile completely satisfy the performance and secure rate in Linux platform. This paper originally proposes a scheme that protects native code from being decompiled and stolen in situation where ELF file is called by JAVA in Linux. The SM4 encryption algorithm and look-up table are creatively used to achieve the goals of apparently elevating the security within a limited performance price. At the posterior of the paper, a control experiment between one famous open source project and this scheme is introduced to supply the data supporting.},
  keywords={Technical requirements;Java;Ground penetrating radar;Linux;Geophysical measurement techniques;Tools;Table lookup;component;ELF(SO) file protection;look-up table;SM4;native code;IOT application},
  doi={10.1109/CISCE52179.2021.9445905},
  ISSN={},
  month={May},}@INPROCEEDINGS{6405831,
  author={Guo-Hao, Wang and Lie-Hui, Jiang and Jing, Jing and Dan, Li},
  booktitle={2012 Fourth International Conference on Multimedia Information Networking and Security}, 
  title={SEA: Analyzing Memory Access of Executables}, 
  year={2012},
  volume={},
  number={},
  pages={887-891},
  abstract={In modern computer architecture, memory is an indispensable medium that software and systems relies upon when running on the computer. Messages about memory access could reflect attributes of programs, which should be invaluable with decompilation and security-related fields. This paper presents a novel memory access algorithm-SEA (Static Execution Analysis) for analyzing stripped executables. In order to support multi-source architectures, analysis is performed on a uniform intermediate representation, messages about memory access and register usage are recorded on an abstract memory model for further analysis. A tool integrating existing achievements is presented to show the usefulness of SEA. Experimental result has shown that SEA is of great help to solve some critical problems of decompilation and security.},
  keywords={Abstracts;Algorithm design and analysis;Registers;Security;Analytical models;Heuristic algorithms;Software;software analysis;memory access;decompilation;security;abstract memory model},
  doi={10.1109/MINES.2012.199},
  ISSN={2162-8998},
  month={Nov},}@INPROCEEDINGS{11081372,
  author={R, Siva Surya and R, Varuneshan and C, Heltin Genitha},
  booktitle={2025 3rd International Conference on Self Sustainable Artificial Intelligence Systems (ICSSAS)}, 
  title={Designing a Static Malware Analysis Framework for Detecting Malicious Malware Code with Ghidra}, 
  year={2025},
  volume={},
  number={},
  pages={1696-1701},
  abstract={Malware analysis is an integral part of cybersecurity, however traditional signature-based detection techniques are inadequate for advanced obfuscation techniques. This paper proposes a static malware analysis framework for identifying malicious code, using Ghidra. The proposed malware analysis framework decompiles malware samples automatically in order to extract features, while reviewing control flow, scanning opcodes, or extracting embedded strings. Additionally, the system uses integrated tools such as VirusTotal API and PEview to validate or classify signatures and analyze file structure. An experimental evaluation of the proposed framework showed an 89% success rate of malware detection that outperformed the performance of traditional signature based methods (72%) and had a lower false-positive rate (7%) than heuristic based methods (15%) under specific conditions. Results suggest that the proposed framework is effective towards the identification of obfuscated malware while being reliable. Unlike earlier traditional techniques, the system user-friendly utilizes Ghidra's improved, advanced capabilities of decompilation and scripts to offer more precision and automation. The solution provides improvement in cybersecurity with an effective, scalable, and automated, static approach to malware analysis.},
  keywords={Automation;Codes;Computer viruses;Machine learning;Inspection;Feature extraction;Dynamic scheduling;Malware;Reliability;Computer security;Static Malware Analysis;Ghidra;Opcode Inspection;Heuristic Detection;VirusTotal API;PEview;Cybersecurity},
  doi={10.1109/ICSSAS66150.2025.11081372},
  ISSN={},
  month={June},}@INPROCEEDINGS{6114783,
  author={Santin, Mateus Madail and Botelho, Silvia da Silva Costa and Dimuro, Gracaliz Pereira and Rodrigues, Celso Luiz Lopes},
  booktitle={2011 Workshop-School on Theoretical Computer Science}, 
  title={Hand Skill Programming: Using Fuzzy Sets to Program Topobo Kinectis Memory Devices}, 
  year={2011},
  volume={},
  number={},
  pages={67-73},
  abstract={Unlike other sciences such as Mathematics and Biology, for example, computation is presented to students at a later learning stage. Even though they are able to establish sets of procedures, it is alleged that in their first years of elementary school, children do not yet present cognitive structures capable of representing symbolically, through existing computer programming languages, the algorithms associated with such procedures. Within this context, there has appeared recently a robotic kit named Topobo, capable of capturing manual movements carried out in their blocks. This article presents th first result associated with the use of Topobo as a language of manual programming. The study will lead to a decompiler able to furnish, with its control flux and its structure of adequate data, the program which results from the manual manipulation of the system by the child. In a more precise form, this work anticipates the utilization of fuzzy concepts for the representation of knowledge generated from the registers of manual programming of the Topobo elements. The utilization of the fuzzy formalism will allow a qualitative and diffuse description of the knowledge, in a manner very similar to the "intuitive" and "little precise" way which human beings handle information (mainly children), leading to an adequate structure and representation of the data which are being manipulated. In addition to the formalism adopted, the article presents a 3D interface which will be helpful in the performance of the experiments. In possession of the decompiled programs, we intend to evaluate the structure of data and control fluxes which will emerge in order to identify the mental structures utilized in the construction of algorithms through manual programming by children.},
  keywords={Manuals;Three dimensional displays;Programming;Process control;Solid modeling;Hardware;Software;Topobo;logic fuzzy;skill programming;learning environment},
  doi={10.1109/WEIT.2011.30},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{239068,
  author={Ogata, T. and Ono, T. and Watanabe, T. and Ito, K.},
  booktitle={Proceedings IECON '91: 1991 International Conference on Industrial Electronics, Control and Instrumentation}, 
  title={An automatic test program generator}, 
  year={1991},
  volume={},
  number={},
  pages={1372-1374 vol.2},
  abstract={A test program generator that automatically generates test programs for LSI devices from general-purpose device test specifications is described. The AG-5 automatic test program generator consists of a hardware-independent front-end preprocessor that supports entry of device test specifications, a compiler to convert tester hardware and a reverse compiler to ensure that validated test parameter changes are reflected in the test specifications. The AG-5 program generation environment realizes large time savings by automatically generating programs in an easy-to-understand procedural language, and by ensuring that parameter changes in the test program are automatically reflected in the test specifications.<>},
  keywords={Automatic testing;Automatic programming;Circuit testing;Large scale integration;System testing;Program processors;Design engineering;Personnel;Microcomputers;Automatic test pattern generation},
  doi={10.1109/IECON.1991.239068},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{4529875,
  author={Fu, Wen and Zhao, Rongcai and Pang, Jianmin and Zhang, Jingbo},
  booktitle={Seventh IEEE/ACIS International Conference on Computer and Information Science (icis 2008)}, 
  title={Recovering Variable-Argument Functions from Binary Executables}, 
  year={2008},
  volume={},
  number={},
  pages={545-550},
  abstract={Variable-argument functions, such as printf(), are broadly used in C programs because of its flexible usage of pointers. However, the recovery of such a function from a binary executable is not an easy task in the field of reverse compilation. The first problem is how to distinguish a variable-argument function from other functions in binary code. The second is how to implement a variable-argument function in a target program. The aim of this paper is to deal with these problems for IA-64 binary executables. We analyzed a large number of disassembled C programs to see how to implement variable-argument functions in machine code. According to calling conventions on IA-64/Linux platform, we abstracted some instruction patterns to recognize variable-argument functions from binary executables. Besides that, we put forward a normalization method to recover variable-argument lists. We use an example compiled by GCC with -O0 option for demonstration, but our methods are not limited to any particular compiler and compiling option.},
  keywords={Pattern recognition;Program processors;Computer bugs;Testing;Information science;Switching systems;Systems engineering and theory;Binary codes;Linux;High level languages;variable-argument function;reverse compilation;IA-64;calling convention;instruction pattern},
  doi={10.1109/ICIS.2008.84},
  ISSN={},
  month={May},}@INPROCEEDINGS{227946,
  author={Kim, K. and Henschen, L.J.},
  booktitle={Proceedings Fourth International Conference on Software Engineering and Knowledge Engineering}, 
  title={Network-based simple recursive answer evaluation for deductive databases in parallel environment}, 
  year={1992},
  volume={},
  number={},
  pages={63-70},
  abstract={Because of increasing needs and requirements for the use of databases, one always looks for more efficient ways to handle database access. Parallel computing environments draw more attention to achieve the high processing speed and the less expensive processing method. This paper proposes the possibility of using a connectionist model by treating every datum as an active processing unit cooperating with other such units via messages in getting answers in a deductive database, especially with recursion. It uses query compilation and iteration to process the recursive case. The notion of the reverse-compilation which is essential to get the correct answers is introduced in handling recursive cases. It introduces the recursive controller which is dedicated to processing the recursive cases as a sublayer to a central database controller.<>},
  keywords={Centralized control;Parallel processing;Deductive databases},
  doi={10.1109/SEKE.1992.227946},
  ISSN={},
  month={June},}@ARTICLE{683008,
  author={Voas, J.M.},
  journal={Computer}, 
  title={Certifying off-the-shelf software components}, 
  year={1998},
  volume={31},
  number={6},
  pages={53-59},
  abstract={Software components are often delivered in "black boxes" as executable objects whose licenses forbid decompilation back to source code. Often source code can be licensed, but the cost makes doing so prohibitive. We therefore have developed a methodology for determining the quality of off-the-shelf (OTS) components using a set of black box analyses. This methodology will provide developers with information useful for choosing components and for defending themselves legally against someone else's imperfect OTS components.},
  keywords={Computer industry;Licenses;Costs;Certification;Programming profession;Marketing and sales;Automobiles;Bridges;Business;Testing},
  doi={10.1109/2.683008},
  ISSN={1558-0814},
  month={June},}@INPROCEEDINGS{674154,
  author={Collberg, C. and Thomborson, C. and Low, D.},
  booktitle={Proceedings of the 1998 International Conference on Computer Languages (Cat. No.98CB36225)}, 
  title={Breaking abstractions and unstructuring data structures}, 
  year={1998},
  volume={},
  number={},
  pages={28-38},
  abstract={To ensure platform independence, mobile programs are distributed in forms that are isomorphic to the original source code. Such codes are easy to decompile, and hence they increase the risk of malicious reverse engineering attacks. Code obfuscation is one of several techniques which has been proposed to alleviate this situation. An obfuscator is a tool which-through the application of code transformations-converts a program into an equivalent one that is more difficult to reverse engineer. In a previous paper (Collberg et al., 1998) we have described the design of a control flow obfuscator for Java. In this paper we extend the design with transformations that obfuscate data structures and abstractions. In particular we show how to obfuscate classes, arrays, procedural abstractions and built-in data types like strings, integers and booleans.},
  keywords={Data structures;Reverse engineering;Protection;Application software;Java;Cryptography;Computer science;Digital signatures;Hardware;Virtual machining},
  doi={10.1109/ICCL.1998.674154},
  ISSN={1074-8970},
  month={May},}@INPROCEEDINGS{5224963,
  author={Chakraborty, Rajat Subhra and Bhunia, Swarup},
  booktitle={2009 IEEE International Workshop on Hardware-Oriented Security and Trust}, 
  title={Security through obscurity: An approach for protecting Register Transfer Level hardware IP}, 
  year={2009},
  volume={},
  number={},
  pages={96-99},
  abstract={Modern system-on-chip (SoC) designs rely heavily on reusable, verified and bug-free hardware intellectual property (IP) cores. Recent trends of IP piracy and reverse-engineering are causing major revenue loss to the IP vendors. A large majority of hardware IPs comes in register transfer level (RTL) description due to their portability and flexibility to map to any technology platform. In this paper, we propose a key-based security through obscurity approach for protecting RTL hardware IPs. The RTL design is first transformed into a technology-independent gate-level description and the functionality of the resulting gate-level netlist is then changed through modification of its state transition function. This process allows normal operation only on the successful application of a correct initialization sequence. The modified gate-level design is then decompiled to generate an obfuscated version of the RTL. Major RTL constructs and macros are optionally preserved through the transformation process using a forward annotation file. The proposed methodology differs from existing hardware obfuscation as well as watermarking techniques in its ability to achieve simultaneous functional and semantic obfuscation for RTL description of IP at low design overhead. Simulation results for a set of open-source IP cores show that we can achieve high levels of security through a well-formulated obfuscation scheme incurring nominal area, delay and power overhead.},
  keywords={Protection;Watermarking;Cryptography;Open source software;Reverse engineering;Hardware design languages;Design methodology;Computer security;Registers;System-on-a-chip;Hardware IP Protection;IP piracy;RTL obfuscation},
  doi={10.1109/HST.2009.5224963},
  ISSN={},
  month={July},}@INPROCEEDINGS{7430561,
  author={Liu, Yu and Zhang, Yichi and Li, Haibin and Chen, Xu},
  booktitle={2016 IEEE International Conference on Consumer Electronics (ICCE)}, 
  title={A hybrid malware detecting scheme for mobile Android applications}, 
  year={2016},
  volume={},
  number={},
  pages={155-156},
  abstract={This paper proposes a static-dynamic hybrid malware detecting scheme for Android applications. While the static analysis could be defeated by transformation technique sometimes and dynamic analysis needs a high complexity, the suggested methods can automatically deliver an unknown App to static or dynamic analysis path according to whether the Android App can be decompiled(its feature) which overcomes both weakness. The experimental results show that the suggested scheme is effective as its detection accuracy can achieve to 93.33%-99.28%.},
  keywords={Malware;Androids;Humanoid robots;Feature extraction;Complexity theory;Support vector machines;Smart phones},
  doi={10.1109/ICCE.2016.7430561},
  ISSN={2158-4001},
  month={Jan},}@INPROCEEDINGS{9259834,
  author={TAHTACI, Burak and CANBAY, Beyzanur},
  booktitle={2020 Innovations in Intelligent Systems and Applications Conference (ASYU)}, 
  title={Android Malware Detection Using Machine Learning}, 
  year={2020},
  volume={},
  number={},
  pages={1-6},
  abstract={The usage of mobile devices is increasing exponentially. There were lots of critical applications such as banking to health applications are available on mobile devices through mobile applications. This penetration and spread of mobile applications brings some threats. Malicious software(Malware) is one of these dangers. Malware has the potential to cause damage to various scales such as theft of sensitive data, identity and credit card. To reduce the effects of these threats, antiviruses have been developed and malware analysis teams have been established, but human effort may be insufficient in the rapidly growing malware market. For this reason, automated malware scanning solutions should be developed by making use of machine learning algorithms. In this study, machine learning models were created by using the n-gram features of the smali files, which are the decompiled Android packages. The trained models are combined with different feature extraction and feature selection methods and as a result their performances are reported.},
  keywords={Malware;Machine learning;Covariance matrices;Internet;Forestry;Feature extraction;Support vector machines;Malware Detection;Mobile Malwares;Static Code Analysis;Machine Learning;Artificial Neural Neworks;Random Forest},
  doi={10.1109/ASYU50717.2020.9259834},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{5076911,
  author={Wang, Cheng and Pang, Jianmin and Zhao, Rongcai and Liu, Xiaoxian},
  booktitle={2009 International Conference on Communication Software and Networks}, 
  title={Using API Sequence and Bayes Algorithm to Detect Suspicious Behavior}, 
  year={2009},
  volume={},
  number={},
  pages={544-548},
  abstract={Computer viruses have become the main threat of the safety and security of industry. Unfortunately, no mature products of anti-virus can protect computers effectively. This paper presents an approach of virus detection which is based on analysis and distilling of representative behavior characteristic and systemic description of the suspicious behaviors indicated by the sequences of APIs which called under Windows. Based on decompilation analysis, according to the determinant of Bayes algorithm, and by the validation of abundant sample space, the technique implements the virus detection by suspicious behavior identification.},
  keywords={Testing;Probability;Software safety;Computer security;Magnetic heads;Frequency conversion;Communication system software;Software algorithms;Switching systems;Systems engineering and theory;Suspicious Behavior;API Sequence;Bayes Algorithm},
  doi={10.1109/ICCSN.2009.60},
  ISSN={},
  month={Feb},}@INPROCEEDINGS{957843,
  author={Guilfanov, I.},
  booktitle={Proceedings Eighth Working Conference on Reverse Engineering}, 
  title={Simple type system for program reengineering}, 
  year={2001},
  volume={},
  number={},
  pages={357-361},
  abstract={This paper describes a type system used in a disassembler program to produce enhanced disassembly output The type system described in this paper is capable of representing C language types. It operates using the following methodology. First, the type information is collected from the standard C headers and is stored in type library files. The stored information is then used to comment and enhance the disassembly. A simple propagation algorithm for function arguments is described as an illustration of the functionality of the system. The power of the type system presented is that a decompiler can be constructed using a disassembler augmented by this system.},
  keywords={Libraries;Assembly;Reverse engineering;Computer security;Cryptography;High level languages;Humans},
  doi={10.1109/WCRE.2001.957843},
  ISSN={1095-1350},
  month={Oct},}@INPROCEEDINGS{9331988,
  author={Aminuddin, Afrig},
  booktitle={2020 3rd International Conference on Information and Communications Technology (ICOIACT)}, 
  title={Android Assets Protection Using RSA and AES Cryptography to Prevent App Piracy}, 
  year={2020},
  volume={},
  number={},
  pages={461-465},
  abstract={Android is the major operating system for mobile devices. The presence of the Google Play Store creates an ecosystem between the app developers and users. As the ecosystem grows, some pirated apps start to show up. This is possible due to the nature of the Android Application that easily can be extracted and decompiled to reveal the source code and the assets file. This research proposed a methodology to protect the application assets from piracy using the cryptographic algorithm. The assets are encrypted during the compile-time using the Gradle build system provided by the Android Studio. While the decryption is performed in the Android device during the application run-time. The proposed algorithm is the pair of asymmetric algorithm called RSA and the symmetric algorithm called AES. This research shows that RSA-AES gives the best security in protecting the assets of Android applications. Besides, the performance of the algorithm is evaluated based on the speed of the encryption and decryption that reach 106.82 MB/s and 44.42 MB/s respectively.},
  keywords={Performance evaluation;Operating systems;Ecosystems;Public key;Mobile handsets;Internet;Cryptography;Android;Cryptography;Encryption;Decryption},
  doi={10.1109/ICOIACT50329.2020.9331988},
  ISSN={},
  month={Nov},}@INPROCEEDINGS{8299877,
  author={Dalai, Asish Kumar and Das, Shakya Sundar and Jena, Sanjay Kumar},
  booktitle={2017 International Conference on Wireless Communications, Signal Processing and Networking (WiSPNET)}, 
  title={A code obfuscation technique to prevent reverse engineering}, 
  year={2017},
  volume={},
  number={},
  pages={828-832},
  abstract={Reverse engineering is the process of decompiling and disassembling the executables to recover the source code/assembly code embedded within it. While reverse engineering is the process of examining the code, in offensive context the attackers can re-engineer the code which leads to software piracy. Software anti-tamper technology like obfuscation is used to deter both reverse engineering and re-engineering of proprietary software and software-powered systems. Code obfuscation, as a part of software protection, got commercial interest from both vendors and as well as from the clients. Vendors want to keep their proprietary code as secret and customers needs software upon which they can trust. In this article, a code obfuscation technique has been proposed to complicate the process of reverse engineering. The basic idea is to conceal the proprietary code section by using preventive design obfuscation and insertion of self-modifying code at the binary level. The combination of design level obfuscation and the insertion of self-modifying code converts the code into a semantically equivalent one that makes it difficult to reverse engineer. The technique is evaluated using different sorting algorithms. The experimental results quantify the degree of obfuscation, stealth of the code, and effects on execution time and code size.},
  keywords={Reverse engineering;Software;Static analysis;Servers;Tools;Resists;Conferences;Software Security;Code Obfuscation;Reverse Engineering},
  doi={10.1109/WiSPNET.2017.8299877},
  ISSN={},
  month={March},}@INPROCEEDINGS{4656411,
  author={Dolgova, K. and Chernov, A.},
  booktitle={2008 15th Working Conference on Reverse Engineering}, 
  title={Automatic Type Reconstruction in Disassembled C Programs}, 
  year={2008},
  volume={},
  number={},
  pages={202-206},
  abstract={This paper presents an algorithm for automatic type reconstruction from target assembly code compiled by a C compiler. The primitive language types are recovered by an iterative algorithm, which operates over the lattice of primitive types' properties. Layout of composite types is reconstructed by building set of accessible offsets for each composite type. The algorithm is the essential part of a tool for program decompilation being developed by the authors.},
  keywords={Registers;Assembly;Equations;Finite element methods;Construction industry;Algorithm design and analysis;High level languages;decompilation;type reconstruction;reverse engineering},
  doi={10.1109/WCRE.2008.20},
  ISSN={2375-5369},
  month={Oct},}@INPROCEEDINGS{9948365,
  author={Han, Wenjie and Pang, Jianmin and Zhou, Xin and Zhu, Di},
  booktitle={2022 5th International Conference on Advanced Electronic Materials, Computers and Software Engineering (AEMCSE)}, 
  title={Binary vulnerability mining technology based on neural network feature fusion}, 
  year={2022},
  volume={},
  number={},
  pages={257-261},
  abstract={The high complexity of software and the diversity of security vulnerabilities have brought severe challenges to the research of software security vulnerabilities Traditional vulnerability mining methods are inefficient and have problems such as high false positives and high false negatives, which can not meet the growing needs of software security. To solve the above problems, this paper proposes a binary vulnerability mining technology based on neural network feature fusion. Firstly, this method constructs binary vulnerability data sets containing multiple vulnerability types, then decompile them to the pcode intermediate language level, and then extracts relevant feature vectors from binary vulnerability data sets according to Bert fine tuning model and bilstm model respectively. In order to fully obtain the semantic information of vulnerabilities, this method standardized the two, fused them, and carried out relevant experiments. The experimental results show that the accuracy of vulnerability detection on SARD data set is 96.92%, which is higher than other binary vulnerability detection methods based on neural network.},
  keywords={Computers;Neural networks;Semantics;Feature extraction;Software;Data models;Data mining;Vulnerability mining;Decompilation Technology;Deep learning;Neural network},
  doi={10.1109/AEMCSE55572.2022.00058},
  ISSN={},
  month={April},}@INPROCEEDINGS{10123584,
  author={Xiao, Xuangan and Wang, Yizhuo and Hu, Yikun and Gu, Dawu},
  booktitle={2023 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={xVMP: An LLVM-based Code Virtualization Obfuscator}, 
  year={2023},
  volume={},
  number={},
  pages={738-742},
  abstract={Obfuscation techniques are widely used to protect the digital copyright and intellectual property rights of software. Among them, code virtualization is one of the most powerful obfuscation techniques, which hides both the control flow and the data flow of the code, thereby preventing code from being decompiled. However, existing code virtualization solutions are not well-resistant to de-obfuscation techniques (e.g., symbolic execution and frequency analysis), and only target limited program languages and architectures, which are challenging to integrate into the process of software development and maintenance.In this paper, We propose an LLVM-based code virtualization tool, namely xVMP to fulfill a scalable and virtualized instruction-hardened obfuscation. To mask the effects of multiple program languages and architectures, xVMP incorporates the obfuscation process of code virtualization into the compilation, and generates virtualized code based on LLVM intermediate representation (IR). After virtualization, it embeds the interpreter of virtualized code into the IR and compiles to an executable. To enhance the security, xVMP encrypts virtualized instructions in each basic block and decrypts them at runtime to enhance the security of obfuscation. In addition, it supports specified function obfuscation. xVMP identifies the function annotations marked by the developer in the source code to locate the function to protect. We implement the prototype of xVMP, and evaluate it with a microbenchmark and three real-world programs. The experimental results show that xVMP can be more difficult to crack than the state-of-the-art obfuscators, and it can support more source code types and architectures, and can be applied to real-world software. Source Code: https://github.com/GANGE666/xVMP.},
  keywords={Codes;Runtime;Annotations;Source coding;Prototypes;Computer architecture;Intellectual property;Code Virtualization;Obfuscation;Reverse Engineering},
  doi={10.1109/SANER56733.2023.00082},
  ISSN={2640-7574},
  month={March},}@INPROCEEDINGS{1307890,
  author={Curran, D. and Cinneide, M.O. and Hurley, N.J. and Silvestre, G.C.M.},
  booktitle={Proceedings. 2004 International Conference on Information and Communication Technologies: From Theory to Applications, 2004.}, 
  title={Dependency in software watermarking}, 
  year={2004},
  volume={},
  number={},
  pages={569-570},
  abstract={The advent of bytecode languages such as Java and advances in decompilation tools has made it easier to infringe the copyright of software. This presents a serious challenge to the software industry, as modern Internet software is highly distributed and the potential for software piracy is immense. Software watermarking has been proposed as one means of protecting the intellectual property in software. The strategy is to embed secret ownership information (i.e., a 'watermark') in a program that cannot be easily removed by unauthorized parties but that can be reliably extracted by an authorized decoder. We investigate a practical implementation of dynamic graph watermarking, focusing particularly on embedding stealthy watermark generating code in the program's text. Our scheme is based on the premise that watermarking code should not be distinguishable from ordinary program code. This is because one strategy for an attacker whose goal is to destroy the watermark is to attempt to directly locate the watermark generating code within the program text and remove or alter it.},
  keywords={Watermarking;Java;Software tools;Computer industry;Internet;Computer crime;Protection;Intellectual property;Data mining;Decoding},
  doi={10.1109/ICTTA.2004.1307890},
  ISSN={},
  month={April},}@INPROCEEDINGS{7723750,
  author={Dinh, Andrew and Brill, Daniel and Li, Yaohang and He, Wu},
  booktitle={2016 IEEE International Conferences on Big Data and Cloud Computing (BDCloud), Social Computing and Networking (SocialCom), Sustainable Computing and Communications (SustainCom) (BDCloud-SocialCom-SustainCom)}, 
  title={Malware Sequence Alignment}, 
  year={2016},
  volume={},
  number={},
  pages={613-617},
  abstract={Sequence alignment has been used to align DNA sequences to find matching segments of DNA from different specimens. Just as DNA sequences can be used to find similar patterns in DNA, this process can also be used on computer programs to identify when segments of code have been reused. Malware programs generally are made from other malware programs or malware templates. The byte information of these decompiled malware programs can be sequence aligned to identify them as malware from known samples. Although sequence alignment is a time consuming process, when a sequence has been found, this known sample can be used to identify malware files orders of magnitude faster than performing sequence alignment on two complete files.},
  keywords={Malware;DNA;Computers;Big data;Conferences;Cloud computing;Malware;security;sequence alignment;malware detection;Smith-Waterman algorithm;Apache Spark},
  doi={10.1109/BDCloud-SocialCom-SustainCom.2016.96},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{4290993,
  author={Wei, Tao and Mao, Jian and Zou, Wei and Chen, Yu},
  booktitle={31st Annual International Computer Software and Applications Conference (COMPSAC 2007)}, 
  title={Structuring 2-way Branches in Binary Executables}, 
  year={2007},
  volume={1},
  number={},
  pages={115-118},
  abstract={One of the major challenges of control flow analysis in decompilation is to structure 2-way branches into conditionals, loop conditionals and switches. In this paper, we propose a graph-based method to formally describe structures of 2-way branches via the introduction of concepts called "compound branch subgraph" and "cascade branch subgraph". We then present novel structuring algorithms based on such concepts. Compared with previous works, our algorithms are deterministic rather than heuristic, and they do not use complicated data structures such as Interval/DSG. We show that in theory our algorithm is more accurate and efficient than typical current approaches; furthermore, we have applied the algorithm to several real-world binary executables, and experimental results validate such theoretical analysis.},
  keywords={Switches;Algorithm design and analysis;Flow graphs;Computer science;Data structures;Graph theory;Scattering;Level control;Heuristic algorithms;Research and development},
  doi={10.1109/COMPSAC.2007.203},
  ISSN={0730-3157},
  month={July},}@INPROCEEDINGS{5743295,
  author={Zhang, Yichi and Pang, Jianmin and Yue, Feng and Cui, Jinxian},
  booktitle={2010 International Conference on Intelligent System Design and Engineering Application}, 
  title={Fuzzy Neural Network for Malware Detect}, 
  year={2010},
  volume={1},
  number={},
  pages={780-783},
  abstract={The current commercial anti-virus software detects a virus only after the virus has appeared and caused damage. Motivated by the inference technique for detecting viruses, and a recent successful classification method, we explore a system (Radux: Reverse Analysis for Detecting Unsafe eXecutables) for automatically detecting malicious code using the collected dataset of the benign and malicious code. Our system rests on fuzzy inference based on behavior hidden in malicious code. Decompile technique is applied to characterize behavioral and structural properties of binary code, which creates more abstract descriptions of malware. The proposed method can acquire the fuzzy subsets and its membership function in an automatic way with the GD-FNN learning algorithm. The experimental data give support to the validity of this method. Moreover, our system is resilient to common obfuscations used by hackers.},
  keywords={Malware;Fuzzy neural networks;Training;Artificial neural networks;Testing;Binary codes;Computer architecture;fuzzy neural network;malware detection;fuzzy inference;program behavior;GD-FNN},
  doi={10.1109/ISDEA.2010.314},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{9141591,
  author={Maalla, Allam},
  booktitle={2020 IEEE 5th Information Technology and Mechatronics Engineering Conference (ITOEC)}, 
  title={Improves the Operation and Maintenance Technology of DC Transmission Based on the Algorithm of VBE}, 
  year={2020},
  volume={},
  number={},
  pages={1813-1817},
  abstract={At present, VBE is widely used in DC transmission research, and its performance directly affects the actual operation process of DC transmission systems. This research improves the operation and maintenance technology of field personnel and the reliability of DC transmission by studying the program of the VBE system and analyzing its weak links. Our research is to simulate the operating conditions of the VBE system and use the platform to test the VBE to ensure that it is in good working condition. Therefore, research decompiles the VBE system, builds a test platform, sorts out its weak links, and proposes anti-accident measures for research. Both in the theoretical method research and engineering application prospects are in the domestic leading position.},
  keywords={Valves;Monitoring;Threshold voltage;Optical receivers;Cooling;Optical fibers;DC Transmission;Converter Valve;VBE;Single-Ship CPU},
  doi={10.1109/ITOEC49072.2020.9141591},
  ISSN={},
  month={June},}@INPROCEEDINGS{6624963,
  author={Shudrak, Maxim and Zolotarev, Vyacheslav},
  booktitle={Eurocon 2013}, 
  title={The technique of dynamic binary analysis and its application in the information security sphere}, 
  year={2013},
  volume={},
  number={},
  pages={40-45},
  abstract={The article describes static and dynamic analysis techniques and its applicability in information security problems such as software protection against unauthorized research. The basic idea of the article is that techniques of dynamic and static analysis must be used in combination with each other to increase the effectiveness of binary code analysis. In the article authors make contributions in binary code decompilation and dynamic execution analysis techniques. The results are applied to the problem of software protection against unauthorized reverse engineering. Authors used analysis of the basic program control flow algorithm to obfuscate the program and protect it against research.},
  keywords={Binary codes;Software;Complexity theory;Heuristic algorithms;Measurement;Data structures;Databases;dynamic;static analysis;control flow;software protection;obfuscation},
  doi={10.1109/EUROCON.2013.6624963},
  ISSN={},
  month={July},}@INPROCEEDINGS{9718856,
  author={Zhu, Di and Pang, Jianmin and Zhou, Xin and Han, Wenjie},
  booktitle={2021 International Conference on Computer Information Science and Artificial Intelligence (CISAI)}, 
  title={Similarity Measure for Smart Contract Bytecode Based on CFG Feature Extraction}, 
  year={2021},
  volume={},
  number={},
  pages={558-562},
  abstract={As the mainstream of smart contract research, most Ethereum smart contracts do not open their source code, and the bytecode of smart contracts has attracted the attention of researchers. Based on the similarity measurement of smart contract bytecode, a series of tasks such as vulnerability mining, contract upgrading and malicious contract detection can be carried out. This paper proposes a method to measure the similarity of smart contract bytecode. Firstly, the key opcode combination of smart contract is summarized. When traversing the CFG(control flow graph) constructed by decompilation of smart contract bytecode, the opcodes in the basic block are pattern matched, and the features between the basic blocks are extracted according to the in-out degree, so as to enhance the similarity measurement effect of contract semantics in vector space. The experimental results show that the proposed method is greatly improved compared with the baseline.},
  keywords={Information science;Smart contracts;Semantics;Euclidean distance;Feature extraction;Extraterrestrial measurements;Flow graphs;bytecode similarity;basic block;CFG;feature extraction},
  doi={10.1109/CISAI54367.2021.00113},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{9631860,
  author={Wahaz, Rizaldi and Harmana, Rakha Nadhifa and Amiruddin, Amiruddin and Suryadinata, Ardya},
  booktitle={2021 6th International Workshop on Big Data and Information Security (IWBIS)}, 
  title={Is WhatsApp Plus Malicious? A Review Using Static Analysis}, 
  year={2021},
  volume={},
  number={},
  pages={91-96},
  abstract={For cybersecurity activists, reviewing whether an application, including modified applications, is malicious or not is a challenging job. WhatsApp Plus is a messenger application modified from the official WhatsApp application. Comparing the source code of the WhatsApp Plus with the official WhatsApp is one way to review its security or malice. Considering that WhatsApp is very popular and has many users, the results of this investigation are very useful for users to avoid malicious applications. In this study, we have conducted an exploration of the source code of the WhatsApp and WhatsApp Plus applications to find out whether or not WhatsApp Plus has been inserted with malware, spyware, or other malicious code. The exploration used the static analysis method, where the source code of the two applications were decompiled, compared, and analyzed. The de-compilation is done using the MobSF tool and the comparison using the extension of Visual Studio Code called Compare Folders. The differences in the source code found are then analyzed for possible behavior to determine whether it can cause harm, for example stealing user credentials. Although no malicious code was found on WhatsApp Plus, in our study, users must stay alert since they remain vigilant in installing and using WhatsApp Plus because the developer may add malicious code to the next version update.},
  keywords={Deep learning;Freeware;Visualization;Codes;Databases;Information security;Static analysis;Malicious;Source code;Static Analysis;WhatsApp;WhatsApp Plus},
  doi={10.1109/IWBIS53353.2021.9631860},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{7024636,
  author={Shuai, Shao and Guowei, Dong and Tao, Guo and Tianchang, Yang and Chenjie, Shi},
  booktitle={2014 Ninth International Conference on P2P, Parallel, Grid, Cloud and Internet Computing}, 
  title={Analysis on Password Protection in Android Applications}, 
  year={2014},
  volume={},
  number={},
  pages={504-507},
  abstract={Although there has been much research on the leakage of sensitive data in Android applications, most of the existing research focus on how to detect the malware or adware that are intentionally collecting user privacy. There are not much research on analyzing the vulnerabilities of apps that may cause the leakage of privacy. In this paper, we present a vulnerability analyzing method which combines taint analysis and cryptography misuse detection. The four steps of this method are decompile, taint analysis, API call record, cryptography misuse analysis, all of which steps except taint analysis can be executed by the existing tools. We develop a prototype tool PW Exam to analysis how the passwords are handled and if the app is vulnerable to password leakage. Our experiment shows that a third of apps are vulnerable to leak the users' passwords.},
  keywords={Androids;Humanoid robots;Privacy;Smart phones;Encryption;password;leakage;vulnerability;Android apps},
  doi={10.1109/3PGCIC.2014.102},
  ISSN={},
  month={Nov},}@INPROCEEDINGS{5459990,
  author={Chen, Liangyu and Wang, Jianlin and Xu, Ming and Zeng, Zhenbing},
  booktitle={2010 Second International Workshop on Education Technology and Computer Science}, 
  title={Reengineering of Java Legacy System Based on Aspect-Oriented Programming}, 
  year={2010},
  volume={3},
  number={},
  pages={220-223},
  abstract={Legacy System is difficult to be maintained and refactored for lack of necessary documents and source codes. How to generate some valuable information from system runtime behaviors is a big challenge to systems reengineering. In this paper, we attempt to reconstruct class diagram and sequence diagram from the binary bytecode of Java program by reflection and bytecode decompilation. The pattern of Aspect-Oriented Programming is applied to resolve the intricate codes of Interface and Dependency Injection pattern through weaving aspect codes into binary bytecodes during runtime to trace the system behaviors. The experiments show our approach can exactly generate the class diagram and sequence diagram from legacy Java System.},
  keywords={Java;Lamps;Runtime;Reflection;Programming profession;Weaving;Pattern analysis;Unified modeling language;Computer science education;Systems engineering education;component;Java Legacy System;Aspect-Oriented Programming;Runtime Behavior;Reengineering},
  doi={10.1109/ETCS.2010.298},
  ISSN={},
  month={March},}@INPROCEEDINGS{8109245,
  author={Lee, Sung-Hoon and Kim, Seung-Hyun and Kim, SooHyung and Jin, Seung-Hun},
  booktitle={2017 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)}, 
  title={Appwrapping Providing Fine-Grained Security Policy Enforcement Per Method Unit in Android}, 
  year={2017},
  volume={},
  number={},
  pages={36-39},
  abstract={Enterprise mobility management (EMM) solution is widely used to securely protect confidential information stored on an individual's smartphone, while increasing the efficiency because of BYOD policy. The application wrapping (Appwrapping) technology is one way to be applied EMM solutions, by modifying binary applications without the original source code. In the past, Appwrapping was performed to control permissions or APIs to protect privacy on Android. This method is applied collectively to the whole section, not a specific section of the app, so it is difficult to control the section (flow) desired by the user or the manager. In addition, system overhead can occur because the control is applied to the whole section of the app. In this paper, we propose a method to insert an additional security policy code at a certain interval position in the intermediate code of a binary app, so that it can be controlled at a specific interval rather than the whole interval of the app. The proposed method extracts and saves the security policy intermediate code and the related file in advance and then adds the security policy code to the specific method on the intermediate code of the specific activity acquired by decompiling the target app. Finally, the additional security policy code is modified to avoid errors caused by the additional code. We create an automation tool for performance verification, experiment with five commercial office apps, and confirm that the apps work properly with the added EMM security functions.},
  keywords={Privacy;Androids;Humanoid robots;Libraries;Usability;Information security;Appwrapping;EMM;mobile security},
  doi={10.1109/ISSREW.2017.25},
  ISSN={},
  month={Oct},}@ARTICLE{9514711,
  author={Nghi Phu, Tran and Dai Tho, Nguyen and Huy Hoang, Le and Ngoc Toan, Nguyen and Ngoc Binh, Nguyen},
  journal={The Computer Journal}, 
  title={An Efficient Algorithm to Extract Control Flow-Based Features for IoT Malware Detection}, 
  year={2019},
  volume={64},
  number={1},
  pages={599-609},
  abstract={Control flow-based feature extraction method has the ability to detect malicious code with higher accuracy than traditional text-based methods. Unfortunately, this method has been encountered with the NP-hard problem, which is infeasible for the large-sized and high-complexity programs. To tackle this, we propose a control flow-based feature extraction dynamic programming algorithm for fast extraction of control flow-based features with polynomial time O($N^{2}$), where N is the number of basic blocks in decompiled executable codes. From the experimental results, it is demonstrated that the proposed algorithm is more efficient and effective in detecting malware than the existing ones. Applying our algorithm to an Internet of Things dataset gives better results on three measures: Accuracy = 99.05%, False Positive Rate = 1.31% and False Negative Rate = 0.66%.},
  keywords={IoT malware detection;control flow-based features;dynamic programming;CFD;embedded malware},
  doi={10.1093/comjnl/bxaa087},
  ISSN={1460-2067},
  month={Nov},}@INPROCEEDINGS{6888726,
  author={Fukuda, Kazumasa and Tamada, Haruaki},
  booktitle={15th IEEE/ACIS International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing (SNPD)}, 
  title={An obfuscation method to build a fake call flow graph by hooking method calls}, 
  year={2014},
  volume={},
  number={},
  pages={1-6},
  abstract={This paper proposes an obfuscation method against illegal analysis. The proposed method tries to build a fake call flow graph from debugging tools. The call flow graph represents relations among methods, and helps understanding of a program. The fake call flow graph leads misunderstanding of the program. We focus on a hook mechanism of the method call for changing a callee. We conduct two experiments to evaluate the proposed method. First experiment simulates attacks by existing tools: Soot, jad, Procyon, and Krakatau. The Procyon only succeeded decompilation, the others crashed. Second experiment evaluates understandability of the obfuscated program by the hand. Only one subject in the nine subjects answered the correct value. The experiments shows the proposed method has good tolerance against existing tools, and high difficulty of understanding even if the target program is tiny and simple program.},
  keywords={Java;Software;Runtime;Educational institutions;DVD;Buildings;Flow graphs;Call Flow Graph;Obfuscation;Java 7;Hook Mechanism},
  doi={10.1109/SNPD.2014.6888726},
  ISSN={},
  month={June},}@INPROCEEDINGS{10857519,
  author={Yama, Yuto and Uda, Ryuya},
  booktitle={2025 19th International Conference on Ubiquitous Information Management and Communication (IMCOM)}, 
  title={Machine Learning Approach to Malware Classification Using Byte N-Grams on IoT Devices}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={Malware for IoT devices has become popular in recent years. Many detection methods have been proposed to detect the malware, mainly using machine learning, but they are not designed to work on IoT devices and are often implemented using Python. Running a Python program requires the installation of a package, which is impractical given the memory and storage size of IoT devices. In addition, methods that require decompilation, static and dynamic analysis of test samples are difficult to run on IoT devices. Therefore, in this research, we propose a method implemented in C/C++ so that malware detection using byte n-grams and machine learning can be run on IoT devices, and then resource consumption can be measured. Byte n-gram methods are good approaches to detect malware without knowing the execution environment. Moreover, the Top-L approach to information gain can be effectively applied to reduce storage and memory consumption. As a result of the evaluation, when using an SVM model with Top-50000 that maintains effective classification accuracy, the memory consumption was 71.91MB and the storage consumption was 1.3GB, which can be implemented in IoT devices.},
  keywords={Support vector machines;Radio frequency;Accuracy;Memory management;Virtual environments;Machine learning;Malware;Information management;Internet of Things;Python;malware detection;IoT;machine learning},
  doi={10.1109/IMCOM64595.2025.10857519},
  ISSN={},
  month={Jan},}@INPROCEEDINGS{9115191,
  author={Feng, Li and Tao, Chen and Bin, Wang and Jianye, Zhang and Song, Qing},
  booktitle={2020 Asia-Pacific Conference on Image Processing, Electronics and Computers (IPEC)}, 
  title={Research on Information Security Technology of Mobile Application in Electric Power Industry}, 
  year={2020},
  volume={},
  number={},
  pages={51-54},
  abstract={With the continuous popularization of smart terminals, Android and IOS systems are the most mainstream mobile operating systems in the market, and their application types and application numbers are constantly increasing. As an open system, the security issues of Android application emerge in endlessly, such as the reverse decompilation of installation package, malicious code injection, application piracy, interface hijacking, SMS hijacking and input monitoring. These security issues will also appear on mobile applications in the power industry, which will not only result in the embezzlement of applied knowledge copyrights but also lead to serious leakage of users' information and even economic losses. It may even result in the remote malicious control of key facilities, which will cause serious social issues. Under the background of the development of smart grid information construction, also with the application and promotion of power services in mobile terminals, information security protection for mobile terminal applications and interactions with the internal system of the power grid has also become an important research direction. While analyzing the risks faced by mobile applications, this article also enumerates and analyzes the necessary measures for risk resolution.},
  keywords={power industry;mobile application;information security;security reinforcement},
  doi={10.1109/IPEC49694.2020.9115191},
  ISSN={},
  month={April},}@INPROCEEDINGS{5384599,
  author={Yin, Wenjian and Jiang, Liehui and Yin, Qing and Zhou, Lina and Li, Jizhong},
  booktitle={2009 International Forum on Computer Science-Technology and Applications}, 
  title={A Control Flow Graph Reconstruction Method from Binaries Based on XML}, 
  year={2009},
  volume={2},
  number={},
  pages={226-229},
  abstract={The first step of decompilation and other reverse analysis for binary codes is constructing control flow graph of program. Due to the loss of structure in compiled code, extracting a control flow graph from an executable is not simply a matter. The usual way which scans the branch instructions in the disassembly file and creates the CFG can not suitable for multiply architecture and file format. This paper analyzes the structure of assembly program and designs a data information description language based on XML-reverse meta language, which is to describe structured disassembling information and then brings forward the control flow graph reconstruction algorithm. This method abstracts disassembly representations and supports multiple architectures. The testing result shows that this method can reconstruct control flow graph of binaries effectively.},
  keywords={Flow graphs;Reconstruction algorithms;XML;Algorithm design and analysis;Binary codes;Data mining;Information analysis;Assembly;Abstracts;Testing;XML;Control Flow Graph;Decompilation;Reverse Meta Language},
  doi={10.1109/IFCSTA.2009.176},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{7106839,
  author={MengShanshan and Yang Xiaohui and Song Yubo and ZhuKelong and Chen Fei},
  booktitle={International Conference on Cyberspace Technology (CCT 2014)}, 
  title={Android's sensitive data leakage detection based on API monitoring}, 
  year={2014},
  volume={},
  number={},
  pages={1-4},
  abstract={Due to the openness of Android, more and more malware has exploded, and constitutes a huge security threat to Android-based smartphones. This paper proposes a mechanism to study sensitive data leakage by analyzing sensitive APIs, decompiles Android APK to get smali files, and defines a sensitive API library related to user privacy. Then, analyzes the potential threats by detecting the sensitive API in the source code, and determines whether there is a sensitive data leakage. We analyzed 20 applications with the help of the mechanism, and in the paper we present one detailed analysis process.},
  keywords={android;decompile;smali;sensitive API},
  doi={10.1049/cp.2014.1340},
  ISSN={},
  month={Nov},}@INPROCEEDINGS{806948,
  author={Cifuentes, C.},
  booktitle={Sixth Working Conference on Reverse Engineering (Cat. No.PR00303)}, 
  title={The impact of copyright on the development of cutting edge binary reverse engineering technology}, 
  year={1999},
  volume={},
  number={},
  pages={66-76},
  abstract={Reverse engineering of executable code is a growing area of software engineering research and technology development due to a variety of reasons, including the porting of programs to newer and faster machines. In this paper we discuss three core object code reverse engineering technologies: emulation, decompilation, and binary translation, and present their uses in the last decades. These uses point at an economic need for such techniques to the benefit of users of the technology. We then present the extent of copyright protection for binary code and its implications on the development of binary code manipulation tools. Further, we argue that copyright laws should not hinder the development of computer and software technology at a time when hardware is developing at increasingly fast rates and software needs to be made available on such new machines; i.e. economic considerations need to be taken into account.},
  keywords={Reverse engineering;Binary codes;Emulation;Copyright protection;Hardware;Software engineering;Australia;Computer industry;Legislation;Computer science},
  doi={10.1109/WCRE.1999.806948},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{9421647,
  author={Han, Wenjie and Pang, Jianmin and Zhou, Xin and Zhu, Di},
  booktitle={2020 5th International Conference on Mechanical, Control and Computer Engineering (ICMCCE)}, 
  title={Binary software vulnerability detection method based on attention mechanism}, 
  year={2020},
  volume={},
  number={},
  pages={1462-1466},
  abstract={Aiming at the stack overflow vulnerability in binary software, this paper proposes a binary vulnerability detection method based on the attention mechanism. First, this paper analyze the basic characteristics of stack overflow vulnerabilities, and perform data preprocessing on the decompiled files to make the neural network better adapt to the characteristics of stack overflow vulnerabilities, then formulate instruction specifications at the assembly language level, and finally input the data into the fusion attention mechanism Learning in the neural network. This paper compares and analyzes three kinds of neural networks on the CWE121 data set. The experimental results show that after neural network training, the detection method based on the attention mechanism can be effective and accurately discover whether the target area has stack overflow vulnerabilities, thereby greatly improving the detection efficiency.},
  keywords={Training;Computational modeling;Neural networks;Force;Data preprocessing;Software;Data models;Binary;software vulnerability;attention;machine learning},
  doi={10.1109/ICMCCE51767.2020.00320},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{4283870,
  author={Ribic, Samir and Salihbegovic, Adnan},
  booktitle={2007 29th International Conference on Information Technology Interfaces}, 
  title={High Level Language Translator with Machine Code as Representation of the Source Code}, 
  year={2007},
  volume={},
  number={},
  pages={777-782},
  abstract={High level programming languages are usually implemented as compilers, interpreters, pseudo compilers, just in time compilers and compact form interpreters. All of the mentioned approaches have their advantages and disadvantages. The approach proposed in this paper eliminates need for source code as physical entity, making the native machine code the only file that exists and is archived, while the special viewer/editor shows and edits it in a form understandable as a high level language. The viewer/editor acts as integrated all-in-one editor, decompiler and incremental compiler.},
  keywords={High level languages;Program processors;Displays;Programming profession;Reverse engineering;Computer languages;Java;Information technology;Information analysis;Compiling;decompiling;programming languages;reverse engineering},
  doi={10.1109/ITI.2007.4283870},
  ISSN={1330-1012},
  month={June},}@INPROCEEDINGS{5376044,
  author={Li, Yuan-yuan},
  booktitle={2009 International Conference on Computational Intelligence and Security}, 
  title={AOP-Based Attack on Obfuscated Java Code}, 
  year={2009},
  volume={2},
  number={},
  pages={238-241},
  abstract={A new approach to attack on obfuscated code is proposed using the join-point model and the bytecode instrument mechanism provided by AOP. All operations are implemented on bytecode level without acquiring the source code of target program, which makes obfuscation useless. As for attackers, they can modify the behavior of target code without decompiling and recompiling it. As experiment is shown, this approach to attack on obfuscated code is very straightforward and simple to be implemented.},
  keywords={Java;Instruments;Reverse engineering;Costs;Programming;Computational intelligence;Computer security;Computer science;Debugging;Yarn;AOP;obfuscation;attack;decompile;join-point},
  doi={10.1109/CIS.2009.134},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{5319576,
  author={Yi, Ding},
  booktitle={2009 WRI World Congress on Software Engineering}, 
  title={A New Obfuscation Scheme in Constructing Fuzzy Predicates}, 
  year={2009},
  volume={4},
  number={},
  pages={379-382},
  abstract={Based on the technique of code obfuscation in software protection, a new obfuscation scheme in constructing opaque predicates was proposed, which increased the complexity by employing the pseudo-random sequence and a group of Diophantine equations' solutions to construct a family of parameterized opaque predicates. To protect the output of the opaque predicates, the data chain list was dynamically generated. Pseudo-random sequence was also used to disturb the attackers' tracking debug. The complication of decompile was increased through block cryptosystems that convert the output of the opaque predicates into the corresponding judge conditions.},
  keywords={Equations;Random sequences;Cryptography;Java;Data security;Reverse engineering;Software protection;Information security;Software algorithms;Software engineering},
  doi={10.1109/WCSE.2009.402},
  ISSN={},
  month={May},}@INPROCEEDINGS{10077138,
  author={Lv, Di and Zhao, Liang and Chen, Bin},
  booktitle={2022 International Conference on Industrial IoT, Big Data and Supply Chain (IIoTBDSC)}, 
  title={Research Based on LLVM Code Obfuscation Technology}, 
  year={2022},
  volume={},
  number={},
  pages={163-167},
  abstract={Computer programs are executed continuously in a certain relatively fixed order of instructions. Replacing these instructions with another more complex order or with different instructions with the same meaning without changing the result of the program will change the logic of the original instructions without affecting the result of the operation, which is the core principle of code obfuscation. In the compilation process, before the compiler compiles the code into the target machine code, it will transform the code into a kind of intermediate code, and then generate the target code after Control Flow Flattening and string encryption obfuscation of the intermediate code, which will make the decompilation work more difficult, thus realizing a code obfuscation system, and through some test cases, the effectiveness and feasibility of the system is demonstrated.},
  keywords={Codes;Source coding;Operating systems;Supply chains;Reverse engineering;Process control;Transforms;code obfuscation;code safety;Control Flow Flattening obfuscation;String encryption;encryption process},
  doi={10.1109/IIoTBDSC57192.2022.00039},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{9117398,
  author={Kim, Yeoneo and Kim, Jinseob and Liu, Xiao and Cheon, Junseok and Woo, Gyun},
  booktitle={2019 8th International Conference on Innovation, Communication and Engineering (ICICE)}, 
  title={PILDroid: A System for Detecting the Leakage of Privacy Information using the JNI}, 
  year={2019},
  volume={},
  number={},
  pages={153-156},
  abstract={We live in a period of explosive growth of smart device applications. Specifically, the growth rate of Android applications is amazing. And these Android applications often use JNI (Java native interface). However, research on the leakage of private information using JNI is lacking. In this paper, we propose a system for detecting the leakage of private information using JNI. Our system named PILDroid adopts tainted analysis based on static method. PILDroid can perform the analysis more easily and effectively than the assembly-based analysis systems because it decompiles a JNI into LLVM IR instead of assembly language. And this paper demonstrates an experiment to verify the precision and performance. For the test data, we selected five Android applications: three of which are well known malware, two of which are malware made by us. And experiment results, PILDroid determined that there has a leak of privacy information flow from five malware.},
  keywords={Android;taint analysis;static analysis;privacy leakage},
  doi={10.1109/ICICE49024.2019.9117398},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{7889345,
  author={Popić, Srđan and Velikić, Ivan and Teslić, Nikola},
  booktitle={2017 IEEE International Conference on Consumer Electronics (ICCE)}, 
  title={Retrieving the useful information from the binary files compiled by C compiler}, 
  year={2017},
  volume={},
  number={},
  pages={338-339},
  abstract={In order to reuse a software component or verify it, the information about compiler, that is used for compilation of the component, is very significant. Due to unknown build flags and compiler information, third party components usually cannot be reused. When it comes to the matter of software components developed in C language, the only place to look for this information is in compiled binary file. Since there are no standards for C language that bind compiler to leave any information about itself in binary file, the information is not expected to be found. However, the information can be found in most of the binary files. This paper investigates what is the possibility of retrieving the information about compiler name and version based on the content of the binary code, without decompiling the binary code. The information retrieving opens up new possibilities for reusing the components and verifying the software requirements as well.},
  keywords={Software;Testing;Conferences;Feature extraction;Binary codes;Training;Consumer electronics},
  doi={10.1109/ICCE.2017.7889345},
  ISSN={2158-4001},
  month={Jan},}@INPROCEEDINGS{5678251,
  author={Yin, Qing and Liu, Xuying and Jiang, Liehui and Liu, Jinfen and Liu, Yong},
  booktitle={2010 2nd International Conference on Information Engineering and Computer Science}, 
  title={Research on High-Level Control Structure Recovery Based on Control Tree}, 
  year={2010},
  volume={},
  number={},
  pages={1-4},
  abstract={Aiming at the problem of control structure nesting relation that has not been resolved in existing control structure recovery algorithms, a novel method to recover high-level control structure based on control tree is presented. Firstly, the method structures control flow graph based on existing control flow graph structuring algorithms. Secondly, the method constructs control tree in reverse post order based on the information of control structure gained via structuring algorithm, and finally high-level control structure is able to be recovered by traversing control tree in post order. Experimental results show that the method can recover high-level control structure truly and effectively to provide exact information of control structure for high-level language code generation afterwards and improve veracity of decompilation results.},
  keywords={Compounds;Flow graphs;Algorithm design and analysis;Data structures;High level languages;Process control},
  doi={10.1109/ICIECS.2010.5678251},
  ISSN={2156-7387},
  month={Dec},}@ARTICLE{774940,
  author={Cifuentes, C. and Fitzgerald, A.},
  journal={IT Professional}, 
  title={Is reverse engineering always legal?}, 
  year={1999},
  volume={1},
  number={2},
  pages={42-48},
  abstract={Reverse engineering-the process of looking at lower levels of abstraction to understand higher levels-is not limited to decompiling programs, as many believe. It is an excellent way to pinpoint what you need to build an interface or change a system to reflect new business goals. But unraveling someone's code opens up a legal can of worms, and as reverse engineering becomes more popular, some people are taking time out from their Y2K worries to say, "is this legal?" This in and of itself is not new-the law seems consistently to be an afterthought to solving technological problems-but in this case, the current preoccupation with reverse engineering may cause the two disciplines to finally stop and consider each other. The courts may realize that if we want to achieve a global electronic society, the law has to make it easier for systems to become interoperable, correct, and secure. Software and system developers may realize that long-standing legal principles can actually work for them, not tie their hands and, more important, that they can influence the laws being made. Unfortunately, we seem to be taking one step forward and two steps back in trying to make this happen. Laws in four key regions-the US, EU, Japan, and Australia-reveal foundational inconsistencies in attitudes about reverse engineering. And recent US legislation, both enacted and proposed, is conflicted.},
  keywords={Law;Reverse engineering;Legal factors;Games;Legislation;Manufacturing;Copyright protection;Government;Permission;Software},
  doi={10.1109/6294.774940},
  ISSN={1941-045X},
  month={March},}@INPROCEEDINGS{9638928,
  author={Fang, Zhan and Liu, Jun and Huang, Ribian and Chen, Peng and Li, Xin and Chen, Xiao},
  booktitle={2021 4th International Conference on Robotics, Control and Automation Engineering (RCAE)}, 
  title={Research on Multi-model Android Malicious Application Detection Based on Feature Fusion}, 
  year={2021},
  volume={},
  number={},
  pages={147-151},
  abstract={With the widespread use of the Android operating system, the number of applications on the platform is increasing, and malicious applications are also emerging. How to effectively identify android malware applications to prevent and protect the security of the mobile terminal is a crucial issue. This paper uses the feature fusion method and directly call the library function to extract the permissions and API features of the APK file, then decompile the APK file to obtain the opcode features and merge the three features with multiple features to generate a feature vector. Finally it use a multi-model neural network HYDRA to learn fusion feature vector, so that it can identify and detect malware. The work also compare it with other single-feature machine learning algorithms to verify its effect. Experimental results show that the accuracy of the multi-model neural network detection method based on feature fusion reaches 98.92%, which is better than other single-model feature methods.},
  keywords={Machine learning algorithms;Automation;Operating systems;Neural networks;Feature extraction;Malware;Libraries;android malicious applications;decompile;feature fusion;neural network},
  doi={10.1109/RCAE53607.2021.9638928},
  ISSN={},
  month={Nov},}@INPROCEEDINGS{10594168,
  author={Wu, Liang},
  booktitle={2024 IEEE 4th International Conference on Electronic Technology, Communication and Information (ICETCI)}, 
  title={A Malicious Code Detection Strategy Based on Feature Fusion}, 
  year={2024},
  volume={},
  number={},
  pages={1502-1506},
  abstract={Due to its weak characteristics, the general malware software detection technology has the weakness of inaccurate detection and inefficiency. Therefore, a malicious application or software detection mechanism is designed based on feature fusion. The detection mechanism based on OPC X-gram and malicious applications or software is improved, and the malicious applications or software detection mechanism based on OPC X-gram with multi-X value combination can mine the expressive logic sequence of malicious applications or software and improve the detection ability of malicious application or software. The potential feature representation mechanism of OPC X-gram is designed, and the decompiling component is used to get the source of the procedure to be tested. Then the source parts to be analyzed is extracted. Combined with the OPC X-gram sequences with multiple X values, the recognizable sequences are screened out by using the content feature recognition method, and the malicious application or software classification training is carried out on the OPC X-gram logic sequences with different X values by using KNN and RF classification algorithms, and finally the OPC X-gram will be used. The inferring sequence will be f made up by logic analysis again. By the experiment analysis, the proposed multi-X value OPC X-gram approach is better than the bin-file X-gram sequence logic and the single-X value OPC X-gram in terms of the accuracy of the potential threat application or software classification.},
  keywords={Training;Radio frequency;Accuracy;Nearest neighbor methods;Feature extraction;Software;Malware;Decompiling;Code detection;Training;Feature extraction},
  doi={10.1109/ICETCI61221.2024.10594168},
  ISSN={},
  month={May},}@INPROCEEDINGS{4722068,
  author={Zhang, Jingbo and Zhao, Rongcai and Pang, Jianmin and Fu, Wen},
  booktitle={2008 International Conference on Computer Science and Software Engineering}, 
  title={Formal Abstraction of Semantics for Detecting Malicious Code}, 
  year={2008},
  volume={2},
  number={},
  pages={350-353},
  abstract={Semantics-based malware detection is a considerable technique to find out the semantically equivalent malicious codes with different layout. This paper presents an abstraction of instructions from lower-level program form to an intermediate representation which describes the program semantics. This abstraction is depended on decompilation technology. We detect malicious code based on patterns, which are obtained by previous experience of malware analysis, and build on top of the abstraction above. At last, we evaluate our method informally, and the result shows that our method is more resilient to detect obfuscated malicious code transformed by several obfuscation policies.},
  keywords={Computer science;Software engineering;Switching systems;Systems engineering and theory;Cities and towns;Pattern analysis;Software design;Computer security;Information security;Protection},
  doi={10.1109/CSSE.2008.990},
  ISSN={},
  month={Dec},}@ARTICLE{168865,
  author={Ackerman, L.F.},
  journal={IEEE Software}, 
  title={After Accolade: time for new laws? (reverse engineering)}, 
  year={1992},
  volume={9},
  number={6},
  pages={100-102},
  abstract={The debate concerning reverse engineering, decompilation and intermediate copying of software is reviewed. The effects of the Sega Enterprises vs. Accolade court case on this debate are discussed. It is argued that if computer professionals want to ensure that they will be able to continue to work in an environment that promotes innovation and the sharing of ideas, they must demand clear and well-thought-out intellectual-property laws for software and a judicial system capable of handling complex technical cases. They must also take an active role in the development of the laws under which they must work. Representative arguments from both side of the issue are presented in the form of selected quotes.<>},
  keywords={Reverse engineering;Law;Legal factors;Assembly;Technological innovation;Intellectual property;Protection;Sorting;Computer industry;Companies},
  doi={10.1109/52.168865},
  ISSN={1937-4194},
  month={Nov},}@INPROCEEDINGS{5696852,
  author={Kuang, Jian and Cao, Bei and Bian, Jiali},
  booktitle={2010 International Conference on Advanced Intelligence and Awarenss Internet (AIAI 2010)}, 
  title={A protective mechanism using variable-instruction-sets encryption for Java applications in mobile terminal platforms}, 
  year={2010},
  volume={},
  number={},
  pages={19-22},
  abstract={In some mobile terminal platforms, such as Android, OMS (Open Mobile System), etc, the compiled Java application files could be easily decompiled, so the security of source codes in Java application is a problem. In this paper, we analyze traditional protective methods for Java application files. Then a class-loading mechanism using variable-instruction-sets encryption is raised. Variable-instruction-sets encryption is a highly reliable and efficient algorithm which is applied on instruction level. Test results on prototype machine show that this mechanism is effective.},
  keywords={DEX;ClassLoader;class-loading;variable-instruction-sets encryption},
  doi={10.1049/cp.2010.0712},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{5658423,
  author={Zhang Yichi and Pang Jianmin and Zhao Rongcai and Guo Zhichang},
  booktitle={2010 IEEE International Conference on Intelligent Computing and Intelligent Systems}, 
  title={Artificial neural network for decision of software maliciousness}, 
  year={2010},
  volume={2},
  number={},
  pages={622-625},
  abstract={With the rapidly development of virus technology, the number of malicious code has continued to increase. So it is imperative to optimize the traditional manual analysis method by automatic maliciousness decision system. Motivated by the inference technique for detecting viruses, and a recent successful classification method, we explore Radux-an automatic software maliciousness decision system. It rests on artificial neural network based on behavior hidden in malicious code. Decompile technique is applied to characterize behavioral and structural properties of binary code, which creates more abstract descriptions of malware. Experiment shows that this system can decision software maliciousness efficiently.},
  keywords={Artificial neural networks;Malware;Software;Computers;artificial neural network;maliciousness decision;software behavior},
  doi={10.1109/ICICISYS.2010.5658423},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{8859456,
  author={Huang, Song and Yang, Sen and Hui, Zhanwei and Yao, Yongming and Chen, Lele and Liu, Jialuo and Chen, Qiang},
  booktitle={2019 IEEE 19th International Conference on Software Quality, Reliability and Security Companion (QRS-C)}, 
  title={Runtime-Environment Testing Method for Android Applications}, 
  year={2019},
  volume={},
  number={},
  pages={534-535},
  abstract={One of the key problems in app testing is to improve the test coverage of apps. However, current testing techniques, whether in code coverage or activity coverage, are not satisfactory. To address this limitation, we present an algorithm for generating test runtime-environment-set to exercise mobile apps. Our approach is based on code analysis to systematically test the targeted code of the Android apps. It analyzes the decompiled code that identifies the code related to Android SDK version, generating the corresponding test cases with the runtime-environment set. We also implement our approach on Android, and validate the method with the existing widely used strategies. An empirical study of the practical usefulness of the technique has been presented on 6 widely-used industrial apps. 18 unique crashes have been found, and the method coverage has been increased by far 9.8% to 130.4% on those apps.},
  keywords={Testing;Smart phones;Runtime environment;Tools;Google;Computer crashes;Mobile testing, code analysis, android version, runtime environment set generation},
  doi={10.1109/QRS-C.2019.00111},
  ISSN={},
  month={July},}@INPROCEEDINGS{4722065,
  author={Zhang, Jingbo and Fu, Wen and Pang, Jianmin and Zhao, Rongcai},
  booktitle={2008 International Conference on Computer Science and Software Engineering}, 
  title={Using Propositional Calculas to Accurately Structure Control-Flow from Binary Executables}, 
  year={2008},
  volume={2},
  number={},
  pages={338-341},
  abstract={In recent years, there has been a growing need for analyst to explore inside the binary executables for the reasons of decompilation, security analysis, reverse engineering, etc. It is very helpful to recover the high-level control structure information, such as loops and conditionals, from arbitrary control-flow of low-level code.This paper presents a novel approach to structure control-flow graphs in binary executables, which are normally represented by unconditional or conditional jumps. We firstly formalize control flow information of the instructions into expressions of propositional calculus. Then the control flow information can be propagated along the execution path. At last, high-level control structures are identified and recovered through the result of calculation.},
  keywords={Calculus;Logic;Binary codes;Computer science;Software engineering;Control systems;Switching systems;Systems engineering and theory;Cities and towns;Computer security},
  doi={10.1109/CSSE.2008.991},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{11205440,
  author={Adamec, Matej and Turčaník, Michal},
  booktitle={2025 Communication and Information Technologies (KIT)}, 
  title={Malware Detection with LLM}, 
  year={2025},
  volume={},
  number={},
  pages={1-7},
  abstract={The increasing sophistication of malware poses critical challenges to traditional detection techniques, particularly in the face of polymorphic and evasive threats. Recent advances in Natural Language Processing (NLP), specifically through the deployment of large language models (LLMs), offer promising capabilities for addressing these challenges. This study evaluates the effectiveness of three LLMs-GPT-2, T5, and CodeBERT-in detecting malware from decompiled.c code derived from Portable Executable (PE) files. The models were tested on a balanced dataset containing real-world malware and benign samples, preprocessed using a custom tokenization and classification pipeline. Experimental results indicate that GPT-2 and T5 achieved strong performance. The study confirms the viability of transformerbased LLMs for source-code-based malware detection, particularly GPT-2 and T5, and emphasizes the importance of model selection and dataset quality. Future work will focus on refining these architectures using larger, more diverse training sets and incorporating class-weighted loss functions to further improve detection balance and reduce false positives.},
  keywords={Training;Codes;Large language models;Refining;Pipelines;Transformers;Malware;Tokenization;Information and communication technology;Faces;LLM;Malware Detection;GPT 2;T5;CodeBERT},
  doi={10.1109/KIT67756.2025.11205440},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{5232171,
  author={Qiang, Wang and Jianmin, Pang and Wen, Fu and Feng, Yue},
  booktitle={2009 International Forum on Information Technology and Applications}, 
  title={Graphical Annotation of Suspicious Behaviors}, 
  year={2009},
  volume={3},
  number={},
  pages={504-506},
  abstract={SVG (scalable vector graphics) is a kind of vector image which based on XML. It has many advantages such as high quality of image, flexibility of file format, less occupation of resource and supporting dynamic interaction. SVG is compatible with XML, HTML4, XHTML languages and it accords with the criterions including CSS, XSL and DOM. In this paper we first use decompile technology to analyze suspicious code and detect suspicious behavior. The adopt SVG for annotating suspicious behavior, finally the result is presented in graphical format. The relevant experiment shows that our method is easy to be understand and effective.},
  keywords={Databases;Prototypes;Information technology;XML;Computer aided instruction;Data flow computing;US Department of Transportation;Switching systems;Systems engineering and theory;Graphics;XML;SVG;graphical annotation;suspicious behaviors},
  doi={10.1109/IFITA.2009.191},
  ISSN={},
  month={May},}@INPROCEEDINGS{8572021,
  author={Corcalciuc, Horia V.},
  booktitle={2018 Conference Grid, Cloud & High Performance Computing in Science (ROLCG)}, 
  title={Low-Level Control-Flow Manipulation Techniques}, 
  year={2018},
  volume={},
  number={},
  pages={1-4},
  abstract={Contrary to interacting with software remotely at runtime, commercial software may be altered by an attacker that is able to to change the meaning of the program at will by decompiling and recompiling the program. An attacker is able to coerce control-flow, manipulate predicates in order to lead the program into a favourable state. The aim of this paper is to present a strictly limited set of low-level attack patterns and to draw a parallel to exploits carried out against system software that cannot be tampered with.},
  keywords={Runtime;Software packages;Software protection;Physics;Unified modeling language;Taxonomy;security;software protection;predicate logic;control flow;UML},
  doi={10.1109/ROLCG.2018.8572021},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{8005920,
  author={Hong, Zhao and Nan, Guo},
  booktitle={2017 IEEE International Conference on Computational Science and Engineering (CSE) and IEEE International Conference on Embedded and Ubiquitous Computing (EUC)}, 
  title={Java Source Code Protection Based on JNI and AES Algorithm}, 
  year={2017},
  volume={1},
  number={},
  pages={846-849},
  abstract={In the Java web security field, the encryption and decryption code of the traditional Java source code protection scheme, which is based on custom class loader encryption, can be easily decompiled. This effect results in the leakage of the source code and the low efficiency of encryption and decryption. This study proposes a scheme based on the Java Native Interface (JNI) and the Advanced Encryption Standard (AES) to protect the Java source code. The proposed scheme adopts the JNI for calling the encryption and decryption's codes implemented by C/C ++, and the encryption and decryption's codes adopt an improved AES encryption algorithm. This scheme greatly improves both the encryption and decryption of the implementation efficiency and the security of the source code.},
  keywords={Encryption;Java;Algorithm design and analysis;Standards;Electronic mail;Advanced Encryption Standard (AES);Data Encryption Standard (DES);Java Native Interface (JNI);Java;encryption},
  doi={10.1109/CSE-EUC.2017.169},
  ISSN={},
  month={July},}@INPROCEEDINGS{6845664,
  author={Hua Deng and Jifu Zhang and Xiaoli Chai},
  booktitle={2014 IEEE Workshop on Electronics, Computer and Applications}, 
  title={The design and implementation of Flash animation watermarking}, 
  year={2014},
  volume={},
  number={},
  pages={489-491},
  abstract={In view of the problems that exist in the copyright protection of Flash, a kind of digital watermark design scheme based on Flash animation is proposed. This scheme chooses the grey scale images including the more copyright information as the watermark information, and inserted them into the SWF files that are read in the byte array. The experiment demonstrates that, while it does not influence the playing result, this scheme can ensure the invisibility, high hiding capacity, etc. that are characteristic of the watermark, and can resist the decompilation attack effectively.},
  keywords={Encryption;Watermarking;Flash animation;watermarking;SWF file},
  doi={10.1109/IWECA.2014.6845664},
  ISSN={},
  month={May},}@INPROCEEDINGS{10965404,
  author={Li, Kun and Liu, Yanyan and Wang, Xuchen and Li, Guopeng and Ma, Ziyue},
  booktitle={2023 International Conference on Information Processing and Network Provisioning (ICIPNP)}, 
  title={Research on Recognition of Android Counterfeit Application Based on Siamese Network}, 
  year={2023},
  volume={},
  number={},
  pages={218-222},
  abstract={In recent years, with the popularity of mobile phones and mobile Internet, the download volume and application rate of third-party applications for smart phones, namely APP, have increased rapidly, and criminals have taken advantage of users' trust in well-known apps to produce similar interfaces and functions, induce users to download and install, steal users' personal information, property or spread malware, not only causing losses to users, but also disrupting normal market order. In order to identify counterfeit APP more quickly and effectively, this paper proposes a counterfeit APP recognition model based on twin network. The model first decompiles and extracts the name, package name, icon, and signature information of the APP, then filters out suspected counterfeit applications by calculating the editing distance of the name, and finally calculates the icon similarity based on the twin network model to determine whether the application is counterfeit. In this paper, datasets containing multiple types of phishing applications are used for experiments, and the effects of VGG16, ResNet50, and ViT algorithms on the recognition results are compared as the basic feature extraction networks. The results show that the accuracy of the ViT-based twin network architecture reaches 85.12%, which can effectively identify counterfeit applications.},
  keywords={Training;Knowledge engineering;Accuracy;Phishing;Network architecture;Feature extraction;Probability distribution;Malware;Smart phones;Residual neural networks;Counterfeit APP;deep learning;Twin networks},
  doi={10.1109/ICIPNP62754.2023.00052},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{11139736,
  author={Bhattacharjee, Srijita and Patil, Param and Patil, Vishal and Nage, Pranav},
  booktitle={2025 7th International Conference on Energy, Power and Environment (ICEPE)}, 
  title={Hybrid Multi-Stage Framework for Advanced Malware Detection: Enhancing Accuracy & Resilience}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={Malware detection is one of the parts of the modern cybersecurity system that requires precision and scalability against the ever-evolving threats. This paper will present a multi-staged hybrid framework for malware detection that combines static analysis, machine learning, and rule-based approaches. The files are processed through a sequence of stages: hash-based matching, machine learning classification, YARA rule evaluation, and decompiled code analysis. This further helps in accuracy and reduces the false prediction. The last decision will aggregate the outputs of all the stages using weighted scoring and achieving the final overall accuracy as 94.8% with a dataset of 8,932 samples. A layered approach ensures that a comprehensive analysis is provided along with a strong, scalable solution for malware detection. Our findings indicate that the multiplexing of various methods for detection may significantly boost the accuracy of detection along with minimizing the shortcomings inherent in each technique.},
  keywords={Multiplexing;Accuracy;Codes;Databases;Scalability;Machine learning;Static analysis;Feature extraction;Malware;Resilience;Malware detection;AI-driven analysis;YARA rules;Radare2;behavioral analysis;feature extraction;multi staged;enhancing malware detection;signature based;machine learning based;de-compilation for malware analysis},
  doi={10.1109/ICEPE65965.2025.11139736},
  ISSN={2832-8973},
  month={May},}@INPROCEEDINGS{882428,
  author={Min-Soo Jung and Do-Woo Kim and Kyoo-Seok Park and Min Jin and Wu Woan Kim and Sang-Chun Lee and Jong-Bong Kang},
  booktitle={Proceedings of the First International Conference on Web Information Systems Engineering}, 
  title={A static Java classfile analyzer}, 
  year={2000},
  volume={1},
  number={},
  pages={468-472 vol.1},
  abstract={It is not easy to analyze and code programs in Java because those programs in the object oriented language hide much information, including in particular the execution process of the programs. Classfile, however, contains useful information that can trace the execution process. The authors implement a static Java classfile analyzer that can show the relationships among classes; caller/callee relationships, inheritance hierarchies, and detailed information within classes. Our analyzer can also display decompiled source programs from the given class files. It can help users to understand Java programs better, and help Java programs to be designed and developed in an efficient manner.},
  keywords={Java;Information analysis;Virtual machining;Program processors;Navigation;Chemistry;Displays;Robustness;Hardware;Operating systems},
  doi={10.1109/WISE.2000.882428},
  ISSN={},
  month={June},}@ARTICLE{10858047,
  author={Ji, Weixing and Huo, Yuanhong and Wang, Yizhuo and Gao, Yujin and Shi, Feng},
  journal={Chinese Journal of Electronics}, 
  title={Control Structure Analysis and Recovery of Embedded Binaries}, 
  year={2017},
  volume={26},
  number={6},
  pages={1118-1124},
  abstract={Existing decompilers use rule-based algorithms to transform unstructured Control flow graph (CFG) into equivalent high-level programming language constructs with “goto” statements. One problem of such approaches is that they generate a large number of “goto”s in the output code, which reduce the readability and hinder the understanding of input binaries. A global search algorithm is proposed based on structural analysis. This algorithm restructures a CFG and generates fewer number of “goto” statements than the rule-based algorithm does. We also present a Genetic algorithm (GA) for the global search approach to locate near optimal solutions for large CFGs. Evaluation results on a set of real CFGs show that the genetic algorithm-based heuristic for global search is capable of finding high-quality solutions.},
  keywords={Computer languages;Codes;Transforms;Flow graphs;Genetic algorithms;Decompiling;Control flow graph restructuring;Structural analysis;Genetic algorithm (GA)},
  doi={10.1049/cje.2017.09.003},
  ISSN={2075-5597},
  month={November},}@INBOOK{10649762,
  author={Domas, Stephanie and Domas, Christopher},
  booktitle={x86 Software Reverse-Engineering, Cracking, and Counter-Measures}, 
  title={Advanced Techniques}, 
  year={2024},
  volume={},
  number={},
  pages={245-249},
  abstract={Summary <p>This chapter describes at a high level some advanced techniques and tools on the cutting edge of reverse engineering. Timeless debugging is also known as reverse debugging. Binary instrumentation is when security professionals inject code to watch or modify a process as it executes. This can be useful for finding memory leaks, tracing key checks, performing anti&#x2010;anti&#x2010;debugging, etc. Normally, for reversing and cracking, it's necessary to learn and write tools for each new architecture. The idea of intermediate representations is to translate all assembly code for all architectures to the same language. The idea of decompiling is to recover original source code from advanced automated analysis of assembly code. Automatic structure recovery involves automatically finding patterns and links in memory to make inferences about the data types used. Visualization can be used to deepen the understanding of file structure and execution. Theorem provers use mathematics to analyze code, including reduction, deobfuscation, boundaries, inputs, etc.</p>},
  keywords={Debugging;Codes;Instruments;Software;Engines;Data visualization;Computer architecture},
  doi={10.1002/9781394277131.ch16},
  ISSN={},
  publisher={Wiley},
  isbn={9781394199907},
  url={https://ieeexplore.ieee.org/document/10649762},}@INPROCEEDINGS{6992244,
  author={Hang Dong and Chengze Li and Ting Li and Yuejin Du and Guoai Xu},
  booktitle={2014 Communications Security Conference (CSC 2014)}, 
  title={Research on the security model of mobile application}, 
  year={2014},
  volume={},
  number={},
  pages={1-5},
  abstract={Security problem of mobile application is a great challenge that mobile internet facing nowadays. Traditional detection and protection methods can't protect users from the emergence of a large number of malwares well, nor can they prevent normal applications from being decompiled and repacked by hackers. In that case, this paper proposes a security model of mobile application which includes two main stages. First, static and dynamic analysis technology are combined together and a double-staining algorithm is proposed to catch application behaviours so as to improve the accuracy of analysis. Then a reinforce framework for mobile application is proposed based on encryption and custom loader. The proposed model can not only detect whether applications are malicious, but also protect apps from being tampered by malicious developers, which will promote the development of security system of mobile internet.},
  keywords={Security Model;Mobile Internet;Software Protection;Malware Detection},
  doi={10.1049/cp.2014.0751},
  ISSN={},
  month={May},}@INPROCEEDINGS{9410081,
  author={Chen, Lu and Ma, Yuanyuan and Shao, Zhipeng and Chen, Mu},
  booktitle={2021 13th International Conference on Measuring Technology and Mechatronics Automation (ICMTMA)}, 
  title={Mobile application reinforcement method based on control flow and data flow confusion}, 
  year={2021},
  volume={},
  number={},
  pages={345-348},
  abstract={At present, mobile applications are developing rapidly, and the methods of attacking mobile applications by reverse engineering to obtain the core logic of the program are becoming more and more intense. In the face of malicious tampering, permission bypassing or obtaining core intellectual property rights through reverse engineering of mobile application, this paper proposes a mobile application reinforcement method based on control flow and data flow confusion, and factors affecting the accuracy and complexity of program analysis extracted for mobile applications, analyze its own characteristics and the relationship between them, detailed analysis of the implementation principle and code of the variable target compiler, in the syntax analysis and semantic analysis stage, the corresponding code obfuscation algorithm is implemented. Through obfuscation, the compiled program is strengthened at the three levels of grammar, control flow, and data flow. Experiments show that even if the source code of mobile application reinforced by this method is obtained through decompilation, the internal logic of the application cannot be known, and the next attack cannot be initiated.},
  keywords={Java;Program processors;Mechatronics;Reverse engineering;Semantics;Intellectual property;Syntactics;control flow;data flow;security reinforcement;mobile application},
  doi={10.1109/ICMTMA52658.2021.00080},
  ISSN={2157-1481},
  month={Jan},}@INPROCEEDINGS{8965960,
  author={Yu, Qing and Ma, Kuolang and Wang, Zuohua},
  booktitle={2019 12th International Congress on Image and Signal Processing, BioMedical Engineering and Informatics (CISP-BMEI)}, 
  title={Android Malicious Code Detection Based on Secondary Pruning Optimization}, 
  year={2019},
  volume={},
  number={},
  pages={1-5},
  abstract={In this paper, we propose a detection algorithm for Android malicious code based on integrated multi-feature. By decompiling and processing APK files, the multi-class behavior features of Android application are extracted, and the classification is achieved through an integrated learning framework based on quadratic pruning optimization. The prototype system automatically detects the malicious code of the Android platform and analyzes the validity of the algorithm through experimental verification.},
  keywords={Classification algorithms;Malware;Feature extraction;Optimization;Predictive models;Security;Android;Multi-feature;Optimization;Pruning},
  doi={10.1109/CISP-BMEI48845.2019.8965960},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{11241815,
  author={Johri, Siddharth and Bose, Adyot and Jha, Shaaswat K and Kakkar, Misha and Mehrotra, Deepti},
  booktitle={2025 12th International Conference on Reliability, Infocom Technologies and Optimization (Trends and Future Directions) (ICRITO)}, 
  title={AMADel: Android Malware Analysis Using Deep Learning}, 
  year={2025},
  volume={},
  number={},
  pages={1-5},
  abstract={Malware Detection is a nuanced activity that often requires human intervention and complex sandboxing methodology to detect complex and obfuscated malware. Human intervention is not practical for a large sample size of untested applications. Android, being the most used and heavily built-upon mobile operating system, is no stranger to having malware embedded in its packaged applications. This paper proposes an innovative ensemble deep learning model designed to classify Android applications as benign or malicious, known as AMADel. AMADeL includes three Convolutional Neural Networks (CNNs) models ensembled together, which were trained on images generated using DEX bytecode obtained by decompiling APKs using Androguard. The APK files were sourced from the AndroZoo dataset. The dataset was prepared and used to train various models. The standalone CNNs gave the highest accuracy of 86.14%. Pre-trained models, such as ResNet50 and VGG16, achieved accuracies of 81.19% and 82.18%, respectively. However, the proposed AMADel attained an accuracy of over 90%.},
  keywords={Deep learning;Accuracy;Operating systems;Neural networks;Market research;Malware;Reliability;Convolutional neural networks;Optimization;Residual neural networks;Android;Malware Detection;Deep Learning;Convolution Neural Networks;DEX bytecode;ResNet50;VGG19},
  doi={10.1109/ICRITO66076.2025.11241815},
  ISSN={2769-2884},
  month={Sep.},}@INPROCEEDINGS{10937558,
  author={Krishnaswamy, Nitin and Mandadi, Sanjana and Nelson, Micah and Slater, Timothy and Liu, Benson},
  booktitle={2024 IEEE MIT Undergraduate Research Technology Conference (URTC)}, 
  title={MBASED: Practical Simplifications of Mixed Boolean-Arithmetic Obfuscation}, 
  year={2024},
  volume={},
  number={},
  pages={1-5},
  abstract={Mixed Boolean-Arithmetic (MBA) obfuscation is a technique that complicates boolean expressions by combining arithmetic and boolean operations. It obstructs the process of reverse engineering by making code more difficult to analyze. This paper presents the Binary Ninja plugin, MBASED (Mixed Boolean-Arithmetic Simplification Engine for Deobfuscation), which performs MBA deobfuscation on C programs. It utilizes novel simplification methods that take ideas from compiler construction and simplification performed on parse trees. MBASED is the first practical implementation of MBA deobfuscation in an industry-grade decompiler. Its extensible framework allows users to incorporate their own simplification passes.},
  keywords={Codes;Reverse engineering;Malware;Libraries;Security;Engines;Arithmetic;security;reverse engineering;deobfuscation;decompiler;Mixed Boolean-Arithmetic},
  doi={10.1109/URTC65039.2024.10937558},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{10625666,
  author={Zhao, Shu-Han and Li, Yong-Zhen and Wang, Zhen-Zhen and Jin, Zhe-Xue},
  booktitle={2024 4th International Conference on Information Communication and Software Engineering (ICICSE)}, 
  title={Research on Security Protection Mechanism of Android APP}, 
  year={2024},
  volume={},
  number={},
  pages={35-38},
  abstract={Based on the idea of a digital signature, an Android program protection scheme is proposed. First, check whether there is a security file when the program starts, download it from the server if there is no security file, and perform subsequent verification if there is; Secondly, the gatekeeper mechanism is used to determine whether the installation address of the software is from the specified server by asking, and if it is, the subsequent verification is made, and if it is not, the program is directly exited; Then, the signature authentication is performed based on the server, and the hash value in the security file is compared with the decrypted hash value. If the hash value is consistent, the file is not tampered with; Finally, the integrity of the file is verified, and the installation is allowed if every value in the security file is verified. The application protection method can identify the installation files from unknown sources and prevent the installation. The whole process adopts the method of JNI call, the application core code is placed in the Java layer, the digital signature mechanism and integrity verification are placed in the Native layer, and the Java layer is packaged into the.so library, the Java layer calls the.so library through the JNI, which can effectively prevent decompilation.},
  keywords={Java;Operating systems;Logic gates;Libraries;Malware;Security;Servers;Security file;“Gatekeeper mechanism”;Server-based digital signature;Integrity verification;JNI technology},
  doi={10.1109/ICICSE61805.2024.10625666},
  ISSN={},
  month={May},}@INPROCEEDINGS{5384667,
  author={Fei, Huang and Qing, Yin and Liehui, Jiang and Xian, Yu},
  booktitle={2009 International Forum on Computer Science-Technology and Applications}, 
  title={Technical Study of ARM Library Identification Based on Dynamic Signature}, 
  year={2009},
  volume={2},
  number={},
  pages={456-459},
  abstract={Library function identification plays a significant part in decompilation process. Based on studying recent achievements on static library functions, combining with the binary coding formats of ARM and Thumb assemble codes, a method for dynamically obtaining library functions' characteristic files on binary level is described, which deals with applications working on ARM processor. Firstly function modules are extracted from applications, then recognized functions in applications will be matched with dynamic signatures of library functions by hashing. This paper makes deep study on obtaining and matching function modules in ARM static library functions identification and presents with strategy on dynamic signature's generating and static matching, which solves the problem of massive library files and matching efficiency. The results prove effective through testing.},
  keywords={Software libraries;Pattern matching;Character recognition;Program processors;Thumb;Assembly;Pattern recognition;Computer languages;Data mining;Computer applications;library function;ARM;Thumb;pattern matching;characteristic signature},
  doi={10.1109/IFCSTA.2009.234},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{6621569,
  author={Hsueh, Hsiang-Yuan and Huang, Kun-Fu and Wu, Wei-Ming and Li, Chih-Lin},
  booktitle={2013 6th IEEE/International Conference on Advanced Infocomm Technology (ICAIT)}, 
  title={Evaluating the risk of Android application: Design and implementation of static analysis system}, 
  year={2013},
  volume={},
  number={},
  pages={236-237},
  abstract={A risk-evaluation-based system for static analysis of Android application is proposed as a reference model. As the known malicious software and normal applications are continuously collected and decompiled, the content in the application can be extracted and stored in local repository. A feature discovery routine is periodically executed to find the characteristic of malware families. For application to be evaluated, the risk information of the application is the similarity to the features discovered in the system.},
  keywords={Malware;Androids;Humanoid robots;Android;malware detection;static analysis;risk evaluation},
  doi={10.1109/ICAIT.2013.6621569},
  ISSN={},
  month={July},}@INPROCEEDINGS{1541163,
  author={Bermudo, N. and Krall, A. and Horspool, N.},
  booktitle={Fifth IEEE International Workshop on Source Code Analysis and Manipulation (SCAM'05)}, 
  title={Control flow graph reconstruction for assembly language programs with delayed instructions}, 
  year={2005},
  volume={},
  number={},
  pages={107-116},
  abstract={Most software for embedded systems, including digital signal processing systems, is coded in assembly language. For both understanding the software and for reverse compiling it to a higher level language, we need to construct a control flow graph (CFG). However CFG construction is complicated by architectural features which include VLIW parallelism, predicated instructions and branches with delay slots. We describe an efficient algorithm for the construction of a CFG, where the parallelism has been eliminated, instructions are reordered and delay slots have been eliminated. The algorithm's effectiveness has been demonstrated by its use in a reverse compiler for the Texas Instruments C60 series of digital signal processors.},
  keywords={Flow graphs;Delay;Signal processing algorithms;Embedded software;Software systems;Embedded system;Digital signal processing;Assembly systems;VLIW;Instruments},
  doi={10.1109/SCAM.2005.6},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{65381,
  author={Reynolds, R.G. and Maletic, J.I. and Porvin, S.E.},
  booktitle={[Proceedings 1989] IEEE International Workshop on Tools for Artificial Intelligence}, 
  title={PM: a metrics driven plan compiler}, 
  year={1989},
  volume={},
  number={},
  pages={677-684},
  abstract={The partial metrics (PM) project, whose goal is to investigate the metrics-driven acquisition of planning knowledge, is discussed. The approach taken can be thought of as reverse compilation. Abstract plans are generated from source programs in a given target language. This process involves the integration of traditional compiler techniques with certain AI (artificial intelligence) paradigms. The current prototype's design is described. This prototype's capabilities are demonstrated by taking an Ada target program generated by a plan in the Programmer's Apprentice system and creating another plan using the PM knowledge compiler. The plan produced by the prototype possesses many of the original plan's features.<>},
  keywords={Prototypes;Aggregates;Artificial intelligence;Automatic programming;Libraries;Knowledge engineering;Computer science;Program processors;Knowledge based systems;System performance},
  doi={10.1109/TAI.1989.65381},
  ISSN={},
  month={Oct},}@ARTICLE{6171162,
  author={Cesare, Silvio and Xiang, Yang and Zhou, Wanlei},
  journal={IEEE Transactions on Computers}, 
  title={Malwise—An Effective and Efficient Classification System for Packed and Polymorphic Malware}, 
  year={2013},
  volume={62},
  number={6},
  pages={1193-1206},
  abstract={Signature-based malware detection systems have been a much used response to the pervasive problem of malware. Identification of malware variants is essential to a detection system and is made possible by identifying invariant characteristics in related samples. To classify the packed and polymorphic malware, this paper proposes a novel system, named Malwise, for malware classification using a fast application-level emulator to reverse the code packing transformation, and two flowgraph matching algorithms to perform classification. An exact flowgraph matching algorithm is employed that uses string-based signatures, and is able to detect malware with near real-time performance. Additionally, a more effective approximate flowgraph matching algorithm is proposed that uses the decompilation technique of structuring to generate string-based signatures amenable to the string edit distance. We use real and synthetic malware to demonstrate the effectiveness and efficiency of Malwise. Using more than 15,000 real malware, collected from honeypots, the effectiveness is validated by showing that there is an 88 percent probability that new malware is detected as a variant of existing malware. The efficiency is demonstrated from a smaller sample set of malware where 86 percent of the samples can be classified in under 1.3 seconds.},
  keywords={Malware;Flow graphs;Entropy;Databases;Emulation;Classification algorithms;Approximation algorithms;Computer security;malware;control flow;structural classification;structured control flow;unpacking},
  doi={10.1109/TC.2012.65},
  ISSN={1557-9956},
  month={June},}@ARTICLE{8443103,
  author={Chu, Gordon and Apthorpe, Noah and Feamster, Nick},
  journal={IEEE Internet of Things Journal}, 
  title={Security and Privacy Analyses of Internet of Things Children’s Toys}, 
  year={2019},
  volume={6},
  number={1},
  pages={978-985},
  abstract={This paper investigates the security and privacy of Internet-connected children's smart toys through case studies of three commercially available products. We conduct network and application vulnerability analyses of each toy using static and dynamic analysis techniques, including application binary decompilation and network monitoring. We discover several publicly undisclosed vulnerabilities that violate the Children's Online Privacy Protection Rule as well as the toys' individual privacy policies. These vulnerabilities, especially security flaws in network communications with first-party servers, are indicative of a disconnect between many Internet of Things toy developers and security and privacy best practices despite increased attention to Internet-connected toy hacking risks.},
  keywords={Toy manufacturing industry;Privacy;Servers;Mobile applications;Internet of Things;Authentication;Data security;Internet of Things (IoT);privacy},
  doi={10.1109/JIOT.2018.2866423},
  ISSN={2327-4662},
  month={Feb},}@INPROCEEDINGS{8327566,
  author={Bragagnolo, Santiago and Rocha, Henrique and Denker, Marcus and Ducasse, Stephane},
  booktitle={2018 International Workshop on Blockchain Oriented Software Engineering (IWBOSE)}, 
  title={SmartInspect: solidity smart contract inspector}, 
  year={2018},
  volume={},
  number={},
  pages={9-18},
  abstract={Solidity is a language used for smart contracts on the Ethereum blockchain. Smart contracts are embedded procedures stored with the data they act upon. Debugging smart contracts is a really difficult task since once deployed, the code cannot be reexecuted and inspecting a simple attribute is not easily possible because data is encoded. In this paper, we address the lack of inspectability of a deployed contract by analyzing contract state using decompilation techniques driven by the contract structure definition. Our solution, SmartInspect, also uses a mirror-based architecture to represent locally object responsible for the interpretation of the contract state. SmartInspect allows contract developers to better visualize and understand the contract stored state without needing to redeploy, nor develop any ad-hoc code.},
  keywords={Contracts;Tools;Inspection;Debugging;Indexes;Blockchain;Inspecting;Solidity;Smart Contracts},
  doi={10.1109/IWBOSE.2018.8327566},
  ISSN={},
  month={March},}@INPROCEEDINGS{1219003,
  author={Stitt, G. and Lysecky, R. and Vahid, F.},
  booktitle={Proceedings 2003. Design Automation Conference (IEEE Cat. No.03CH37451)}, 
  title={Dynamic hardware/software partitioning: a first approach}, 
  year={2003},
  volume={},
  number={},
  pages={250-255},
  abstract={Partitioning an application among software running on a microprocessor and hardware co-processor in on-chip configurable logic has been shown to improve performance and energy consumption in embedded systems. Meanwhile, dynamic software optimization methods have shown the usefulness and feasibility of runtime program optimization, but those optimizations do not achieve as much as partitioning. We introduce a first approach to dynamic hardware/software partitioning. We describe our system architecture and initial on-chip tools, including profiler, decompiler, synthesis, and placement and routing tools for a simplified configurable logic fabric, able to perform dynamic partitioning of real benchmarks. We show speedups averaging 2.6 for five benchmarks taken from Powerstone, Netbench and our own benchmarks.},
  keywords={Hardware;Optimization methods;System-on-a-chip;Logic;Application software;Embedded software;Software performance;Microprocessors;Coprocessors;Energy consumption},
  doi={10.1145/775832.775896},
  ISSN={},
  month={June},}@ARTICLE{1274043,
  author={Zhang, F. and D'Hollander, E.H.},
  journal={IEEE Transactions on Software Engineering}, 
  title={Using hammock graphs to structure programs}, 
  year={2004},
  volume={30},
  number={4},
  pages={231-245},
  abstract={Advanced computer architectures rely mainly on compiler optimizations for parallelization, vectorization, and pipelining. Efficient-code generation is based on a control dependence analysis to find the basic blocks and to determine the regions of control. However, unstructured branch statements, such as jumps and goto's, render the control flow analysis difficult, time-consuming, and result in poor code generation. Branches are part of many programming languages and occur in legacy and maintenance code as well as in assembler, intermediate languages, and byte code. A simple and effective technique is presented to convert unstructured branches into hammock graph control structures. Using three basic transformations, an equivalent program is obtained in which all control statements have a well-defined scope. In the interest of predication and branch prediction, the number of control variables has been minimized, thereby allowing a limited code replication. The correctness of the transformations has been proven using an axiomatic proof rule system. With respect to previous work, the algorithm is simpler and the branch conditions are less complex, making the program more readable and the code generation more efficient. Additionally, hammock graphs define single entry single exit regions and therefore allow localized optimizations. The restructuring method has been implemented into the parallelizing compiler FPT and allows to extract parallelism in unstructured programs. The use of hammock graph transformations in other application areas such as vectorization, decompilation, and assembly program restructuring is also demonstrated.},
  keywords={Optimizing compilers;Assembly;Program processors;Parallel processing;Flow graphs;Computer architecture;Pipeline processing;Computer languages;Application software;Parallel programming},
  doi={10.1109/TSE.2004.1274043},
  ISSN={1939-3520},
  month={April},}@INPROCEEDINGS{8728471,
  author={Akarsh, S. and Simran, K. and Poornachandran, Prabaharan and Menon, Vijay Krishna and Soman, K.P.},
  booktitle={2019 5th International Conference on Advanced Computing & Communication Systems (ICACCS)}, 
  title={Deep Learning Framework and Visualization for Malware Classification}, 
  year={2019},
  volume={},
  number={},
  pages={1059-1063},
  abstract={In this paper we propose a deep learning framework for classification of malware. There has been an enormous increase in the volume of malware generated lately which represents a genuine security danger to organizations and people. So as to battle the expansion of malwares, new strategies are needed to quickly identify and classify malware. Malimg dataset, a publicly available benchmark data set was used for the experimentation. The architecture used in this work is a hybrid cost-sensitive network of one-dimensional Convolutional Neural Network (CNN) and Long Short-Term Memory (LSTM) network which obtained an accuracy of 94.4%, an increase in performance compared to work done by [1] which got 84.9%. Hyper parameter tuning is done on deep learning architecture to set the parameters. A learning rate of 0.01 was taken for all experiments. Train-test split of 70-30% was done during experimentation. This facilitates to find how well the models perform on imbalanced data sets. Usual methods like disassembly, decompiling, de-obfuscation or execution of the binary need not be done in this proposed method. The source code and the trained models are made publicly available for further research.},
  keywords={Malware;Feature extraction;Deep learning;Computer architecture;Logic gates;Convolution;Malware;image processing;machine learning;deep learning;cost-sensitive learning},
  doi={10.1109/ICACCS.2019.8728471},
  ISSN={2575-7288},
  month={March},}@INPROCEEDINGS{9519451,
  author={Zhang, Zhuo and Ye, Yapeng and You, Wei and Tao, Guanhong and Lee, Wen-chuan and Kwon, Yonghwi and Aafer, Yousra and Zhang, Xiangyu},
  booktitle={2021 IEEE Symposium on Security and Privacy (SP)}, 
  title={OSPREY: Recovery of Variable and Data Structure via Probabilistic Analysis for Stripped Binary}, 
  year={2021},
  volume={},
  number={},
  pages={813-832},
  abstract={Recovering variables and data structure information from stripped binary is a prominent challenge in binary program analysis. While various state-of-the-art techniques are effective in specific settings, such effectiveness may not generalize. This is mainly because the problem is inherently uncertain due to the information loss in compilation. Most existing techniques are deterministic and lack a systematic way of handling such uncertainty. We propose a novel probabilistic technique for variable and structure recovery. Random variables are introduced to denote the likelihood of an abstract memory location having various types and structural properties such as being a field of some data structure. These random variables are connected through probabilistic constraints derived through program analysis. Solving these constraints produces the posterior probabilities of the random variables, which essentially denote the recovery results. Our experiments show that our technique substantially outperforms a number of state-of-the-art systems, including IDA, Ghidra, Angr, and Howard. Our case studies demonstrate the recovered information improves binary code hardening and binary decompilation.},
  keywords={Privacy;Uncertainty;Systematics;Binary codes;Probabilistic logic;Data structures;Random variables;Binary-Analysis;Reverse-Engineering;Type-Inference;Probabilistic-Analysis},
  doi={10.1109/SP40001.2021.00051},
  ISSN={2375-1207},
  month={May},}@ARTICLE{9921221,
  author={Gao, Yun and Hasegawa, Hirokazu and Yamaguchi, Yukiko and Shimada, Hajime},
  journal={IEEE Access}, 
  title={Malware Detection by Control-Flow Graph Level Representation Learning With Graph Isomorphism Network}, 
  year={2022},
  volume={10},
  number={},
  pages={111830-111841},
  abstract={With society’s increasing reliance on computer systems and network technology, the threat of malicious software grows more and more serious. In the field of information security, malware detection has been a key problem that academia and industry are committed to solving. Machine learning is an effective method for processing large-scale data, such as the Gradient Boosting Decision Tree (GBDT) and deep neural network technology. Although these types of detection methods can deal with cyber threats, most feature extraction methods are based on the statistical information features of portable executable (PE) files and thus lack the decompiled code and execution flow structure of the PE samples. Therefore, we propose a Control-Flow Graph (CFG)- and Graph Isomorphism Network (GIN)-based malware classification system. The feature vectors of CFG basic blocks are generated using the large-scale pre-trained language model MiniLM, which is beneficial for the GIN to further learn and compress the CFG-based representation, and classified with multi-layer perceptron. In addition, we evaluated the effectiveness of the representation under different dimensions and classifiers. To evaluate our method, we set up a CFG-based malware detection graph dataset from a PE file of the Blue Hexagon Open Dataset for Malware Analysis (BODMAS), which we call the Malware Geometric Binary Dataset (MGD-BINARY) and collected the experimental results of CFG representation in different dimensions and classifier settings. The evaluation results show that our proposal has proved an Accuracy metric of 0.99160 and achieved 0.99148 Area Under the Curve (AUC) results.},
  keywords={Malware;Feature extraction;Codes;Data mining;Analytical models;Machine learning;Natural language processing;Graphics;Malware detection;machine learning;static analysis;graph classification},
  doi={10.1109/ACCESS.2022.3215267},
  ISSN={2169-3536},
  month={},}@ARTICLE{10186242,
  author={Costa, Leonardo da and Moia, Vitor},
  journal={IEEE Access}, 
  title={A Lightweight and Multi-Stage Approach for Android Malware Detection Using Non-Invasive Machine Learning Techniques}, 
  year={2023},
  volume={11},
  number={},
  pages={73127-73144},
  abstract={Android has been a constant target of cybercriminals that try to attack one of the most used operating systems, commonly using malicious applications (denominated malware) that, once installed on a device, can harm users in several ways. Existing malware detection solutions are usually invasive as they obtain classification features by performing reverse engineering, decompilation, or disassembly of the analyzed application, which infringes licenses and terms of use of applications. In addition, these solutions often employ a single machine learning (ML) model to detect various types of malware, resulting in several false alarms. In this context, we propose an approach to detect Android malware consisting of a set of specific-type detectors in which each one performs a multi-stage analysis, based on rules and ML techniques, in different phases of the application cycle (before and after its installation). Our approach also differs from state-of-the-art solutions by being non-invasive, since it leverages a process to obtain application’s features that does not infringe licenses and terms of use of applications. In addition, according to experiments performed on a real Android smartphone, our proposal presents the following additional advantages over state-of-the-art solutions: a more efficient process to classify applications that is three times faster and requires ten times less CPU usage in some cases (saving device energy); and a better detection performance, with higher balanced accuracy, nine times less false positive cases, and ten times less false negative cases.},
  keywords={Malware;Feature extraction;Smart phones;Operating systems;Proposals;Detectors;Behavioral sciences;Androids;Noninvasive treatment;Android;machine learning;malware detection;multi-stage analysis;non-invasive feature extraction},
  doi={10.1109/ACCESS.2023.3296606},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{9453483,
  author={Alsabbagh, Wael and Langendörfer, Peter},
  booktitle={2021 22nd IEEE International Conference on Industrial Technology (ICIT)}, 
  title={A Stealth Program Injection Attack against S7-300 PLCs}, 
  year={2021},
  volume={1},
  number={},
  pages={986-993},
  abstract={Industrial control systems (ICSs) consist of programmable logic controllers (PLCs) which communicate with an engineering station on one side, and control a certain physical process on the other side. Siemens PLCs, particularly S7-300 controllers, are widely used in industrial systems, and modern critical infrastructures heavily rely on them. But unfortunately, security features are largely absent in such devices or ignored/disabled because security is often at odds with operations. As a consequence of the already reported vulnerabilities, it is possible to leverage PLCs and perhaps even the corporate IT network. In this paper we show that S7-300 PLCs are vulnerable and demonstrate that exploiting the execution process of the logic program running in a PLC is feasible. We discuss a replay attack that compromises the password protected PLCs, then we show how to retrieve the Bytecode from the target and decompile the Bytecode to STL source code. Afterwards we present how to conduct a typical injection attack showing that even a very tiny modification in the code is sufficient to harm the target system. Finally we combine the replay attack with the injection approach to achieve a stronger attack – the stealth program injection attack – which can hide the previous modification by engaging a fake PLC, impersonating the real infected device. For real scenarios, we implemented all our attacks on a real industrial setting using S7-300 PLC. We eventually suggest mitigation approaches to secure systems against such threats.},
  keywords={Conferences;Programmable logic devices;Process control;Critical infrastructure;Security;Password;S7-300 PLCs;Injection Attack;Stealthy Attack;Replay Attack;Fake PLC},
  doi={10.1109/ICIT46573.2021.9453483},
  ISSN={},
  month={March},}@INPROCEEDINGS{8600052,
  author={Zhao, Lichao and Li, Dan and Zheng, Guangcong and Shi, Wenbo},
  booktitle={2018 IEEE 18th International Conference on Communication Technology (ICCT)}, 
  title={Deep Neural Network Based on Android Mobile Malware Detection System Using Opcode Sequences}, 
  year={2018},
  volume={},
  number={},
  pages={1141-1147},
  abstract={Malware detection is more challenging due to the increase in android malicious programs and the current problems of android malicious detection. This paper proposes an android mobile malware detection system based on deep neural network, a novel malware detection method which uses optimized deep Convolutional Neural Network to learn from opcode sequences. In the proposed detection system, the optimized Convolutional Neural Network is trained multiple times by the raw operation code sequence extracted from the decompiled android file, so that the feature information can be effectively learned and the malicious program can be detected more accurately. More critically, the k-max pooling method with better results was adopted in the pooling operation phase, and which improves the detection effect of the proposed method. The experimental results show that the detection system achieved the accuracy of 99%, which is 2%-11 % higher than the accuracy of the machine learning detection algorithms when using the same dataset. It also ensures that the indicators such as Fl-score, Recall and Precision are maintained above 97%.},
  keywords={Feature extraction;Malware;Convolutional neural networks;Matrix converters;Data mining;Smart phones;malware detection;opcode;k-max pooling;Convolutional Neural Network},
  doi={10.1109/ICCT.2018.8600052},
  ISSN={2576-7828},
  month={Oct},}@INPROCEEDINGS{8029506,
  author={Tang, Junwei and Li, Ruixuan and Han, Hongmu and Zhang, Heng and Gu, Xiwu},
  booktitle={2017 IEEE Trustcom/BigDataSE/ICESS}, 
  title={Detecting Permission Over-claim of Android Applications with Static and Semantic Analysis Approach}, 
  year={2017},
  volume={},
  number={},
  pages={706-713},
  abstract={Android access control granularity based on its permission mechanism is relatively coarse, which cannot effectively protect the user privacy. Many Android applications do not strictly abide by the principle of least privilege (PLP). Both benign and malicious apps may request more permissions than those they really use. We rethink previous permission over-claim problem of Android applications, and extend it to three kinds of problems: Explicit Permission Over-claim, Implicit Permission Over-claim and Ad Library Permission Over-claim. The latter two problems are new that have not been raised by any previous work. Static analysis is to decompile the applications to generate intermediate code and then analyze the usage of permissions. Our static analysis on 10710 applications shows that 76.08% of them may have Explicit Permission Over-claim problem, among those there are 424 applications that have sensitive permissions, which are only used in the advertisement library's code of the applications rather than developer's own code. They have Ad Library Permission Over-claim problem. The main idea of our semantic analysis is to calculate the semantic similarity between apps' descriptions and function phrases. If the similarity exceeds a certain threshold, the app is considered relevant to the corresponding function. We compare the results of the semantic analysis with those of manual reading of 102 Android application descriptions. The F-measures of the three chosen functions are 80.82%, 70.48% and 89.62%, respectively. The evaluation results show our method can efficiently detect the above three kinds of permission over claim problems which indicates that our method would be helpful for normal users to have a clear understanding of permission usage of Android applications.},
  keywords={Androids;Humanoid robots;Libraries;Semantics;Smart phones;Security;Privacy;Mobile security;Android system;permission overclaim problem;static analysis;semantic analysis},
  doi={10.1109/Trustcom/BigDataSE/ICESS.2017.303},
  ISSN={2324-9013},
  month={Aug},}
