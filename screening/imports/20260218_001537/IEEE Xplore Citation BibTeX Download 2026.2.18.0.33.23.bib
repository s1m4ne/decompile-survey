@INPROCEEDINGS{9708687,
  author={Aslanyan, Hayk and Movsisyan, Hovhannes and Arutunian, Mariam and Sargsyan, Sevak},
  booktitle={2021 Ivannikov Ispras Open Conference (ISPRAS)}, 
  title={Bin2Source: Matching Binary to Source Code}, 
  year={2021},
  volume={},
  number={},
  pages={3-7},
  abstract={Code comparison methods and tools are widely spread. However, most of the approaches target either only source code or only binary code, and methods for matching binary to source code are less investigated. In this article, we introduce Bin2Source: a tool for matching binary to source code. It gets as input a binary code (without debug information) and source code with its compilation commands. As a result, the tool returns matched functions and instructions of binary and source code. The major advantage of Bin2Source compared with existing tools is the capacity to perform instruction-to-instruction matching. The tool can be used for copyright infringements detection, algorithm recovery from binaries, third-party software detection in binaries, bugs detection, etc. Additionally, we propose a testing system to evaluate our tool's results. According to the developed testing system, Bin2Source has 85.66% precision, 83.26% recall, and 84.35% F1 score on average.},
  keywords={Computer bugs;Binary codes;Copyright protection;Software;Detection algorithms;Testing;code static analysis;code clones;reverse engineering},
  doi={10.1109/ISPRAS53967.2021.00006},
  ISSN={2767-9535},
  month={Dec},}@INPROCEEDINGS{9724320,
  author={Alrabaee, Saed and Choo, Kim-Kwang Raymond and Qbea'h, Mohammad and Khasawneh, Mahmoud},
  booktitle={2021 IEEE 20th International Conference on Trust, Security and Privacy in Computing and Communications (TrustCom)}, 
  title={BinDeep: Binary to Source Code Matching Using Deep Learning}, 
  year={2021},
  volume={},
  number={},
  pages={1100-1107},
  abstract={Mapping a binary function taken from a compiled binary to the same function in the original source code has many security applications, such as discovering reused free open source code in malware binaries. To facilitate malware analysis, we present BINDEEP, a framework that learns the semantic relationships among binary functions based on assembly code. It also learns semantic information about the source functions in order to carry out function matching. We demonstrate how BINDEEP can be applied to fingerprint the origin of functions in malware binaries, and then benchmark its performance against that of five competing systems (i.e., RESOURCE, the Binary Analysis Tool (BAT), BinPro, Statistical Machine Translation (SMT), and FOSSIL). The findings show that BINDEEP is more robust and achieves significant improvement over these existing systems when confronted with changes introduced by code transformation methods or the use of different compilers and optimization levels. Furthermore, BINDEEP is able to discover source packages in malware binaries, such as Zeus and Citadel, that match those listed in existing security reports.},
  keywords={Privacy;Codes;Program processors;Semantics;Reverse engineering;Manuals;Malware;binary code;machine learning;malicious code},
  doi={10.1109/TrustCom53373.2021.00150},
  ISSN={2324-9013},
  month={Oct},}@INPROCEEDINGS{11352404,
  author={Zhao, Shiwu and Zheng, Ningjun and Li, Haoyu and Feng, Ruizhi and Chen, Xingchen and Tan, Ru and Liu, Qixu},
  booktitle={2025 28th International Symposium on Research in Attacks, Intrusions and Defenses (RAID)}, 
  title={DEPHP: A Source Code Recovery Method for PHP Bytecode with Improved Structural Analysis}, 
  year={2025},
  volume={},
  number={},
  pages={77-91},
  abstract={Over the past decade, PHP has consistently been one of the most popular server-side programming languages among developers for web development. To protect intellectual property, various PHP source code obfuscation and encryption methods have been developed, which has led to difficulties in performing security analysis on PHP source code. Previous work has demonstrated the feasibility of recovering source code by extracting bytecode from PHP during dynamic execution. However, there is still a lack of a universal decompilation method for this kind of bytecode, tailored to PHP’s unique syntax. Thus, we propose a systematic decompilation framework for PHP bytecode. First, we design a unified intermediate representation that eliminates the differences between bytecodes from different PHP versions. Then, we introduce a structural analysis algorithm specifically for PHP syntax, improving upon existing methods to better accommodate PHP’s unique syntax. We use over 3 million lines of PHP code as a dataset and compiled it into PHP bytecode. After decompiling it with our method, we successfully recovered 92% of the classes and 85% of the methods. Furthermore, from the encrypted dataset containing 37 SQL injection and 31 XSS vulnerability patterns, we fully restored the original vulnerability patterns and reconstructed the exploitation chains. Furthermore, we identified a series of vulnerabilities in real-world projects and were assigned 6 new CVE IDs1, demonstrating the correctness of our method and its ability to assist in static analysis for vulnerability discovery.1CVE-2025-45046, CVE-2025-45047, CVE-2025-45048, CVE-2025-45049, CVE-2025-45050, CVE-2025-45052},
  keywords={Codes;Systematics;Source coding;Trees (botanical);Process control;Static analysis;Intellectual property;Syntactics;SQL injection;Protection;decompilation;structural analysis;code protection;PHP bytecode;vulnerability detection},
  doi={10.1109/RAID67961.2025.00032},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{7113109,
  author={Ďurfina, Lukáš and Křoustek, Jakub and Zemek, Petr},
  booktitle={2013 Third World Congress on Information and Communication Technologies (WICT 2013)}, 
  title={Retargetable machine-code decompilation in your web browser}, 
  year={2013},
  volume={},
  number={},
  pages={57-62},
  abstract={Machine-code decompilation, belonging to the area of reverse engineering, has found its applications in many real-world areas. Analysis of malicious software, search for vulnerabilities, and source-code recovery are some of the most important uses. As there exists a diversity of different platforms on which software can be run, an existence of a generic decompiler would be highly appreciated. The present paper describes such a tool. In this paper, we provide a description of a retargetable decompiler that is being developed within the Lissom project. First, we give an introduction into the area of machine-code decompilation, including a brief discussion of existing tools. Then, we describe the concept and architecture of the decompiler. As it is available in the form of a web service, we also provide its description. Finally, we summarize our results, present a case study of using the tool for analysing malicious software, and conclude the paper by several remarks on future research.},
  keywords={World Wide Web;reverse engineering;decompilation;retargetable decompiler;web service;Lissom},
  doi={10.1109/WICT.2013.7113109},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{10596484,
  author={TehraniJamsaz, Ali and Chen, Hanze and Jannesari, Ali},
  booktitle={2024 IEEE International Parallel and Distributed Processing Symposium Workshops (IPDPSW)}, 
  title={GraphBinMatch: Graph-Based Similarity Learning for Cross-Language Binary and Source Code Matching}, 
  year={2024},
  volume={},
  number={},
  pages={506-515},
  abstract={Matching binary to source code and vice versa has various applications in different fields, such as computer security, software engineering, and reverse engineering. Even though there exist methods that try to match source code with binary code to accelerate the reverse engineering process, most of them are designed to focus on one programming language. However, in real life, programs are developed using different programming languages depending on their requirements. Thus, cross-language binary-to-source code matching has recently gained more attention. Nonetheless, the existing approaches still struggle to have precise predictions due to the inherent difficulties when the problem of matching binary code and source code needs to be addressed across programming languages. In this paper, we address the problem of cross-language binary source code matching. We propose GraphBinMatch, an approach based on a graph neural network that learns the similarity between binary and source codes. We evaluate GraphBinMatch on several tasks, such as cross-language binary-to-source code matching and cross-language source-to-source matching. We also evaluate the performance of our approach on single-language binary-to-source code matching. Experimental results show that GraphBinMatch significantly outperforms state-of-the-art, with improvements as high as 15% over the F1 score.},
  keywords={Computer languages;Distributed processing;Source coding;Reverse engineering;Binary codes;Programming;Graph neural networks;cross-language;code similarity;binary-source matching},
  doi={10.1109/IPDPSW63119.2024.00103},
  ISSN={},
  month={May},}@INPROCEEDINGS{8667977,
  author={Feng, Muyue and Mao, Weixuan and Yuan, Zimu and Xiao, Yang and Ban, Gu and Wang, Wei and Wang, Shiyang and Tang, Qian and Xu, Jiahuan and Su, He and Liu, Binghong and Huo, Wei},
  booktitle={2019 IEEE 26th International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={Open-Source License Violations of Binary Software at Large Scale}, 
  year={2019},
  volume={},
  number={},
  pages={564-568},
  abstract={Open-source licenses are widely used in open-source projects. However, developers using or modifying the source code of open-source projects do not always strictly follow the licenses. GPL and AGPL, two of the most popular copyleft licenses, are most likely to be violated, because they require developers to open-source the entire project if any code under GPL/AGPL protection is included whether modified or not. There are few license violation detectors focusing on binary software, owning to the challenge of mapping binary code to source code efficiently and accurately at large scale. In this paper, we propose a scalable and fully-automated system to check open-source license violation of binary software at large scale. We match source code to binary code by analyzing file attributes of executable files and code features that are not affected by compilation and could vary between projects. Moreover, to break the barrier of large-scale analysis, we introduce an automatic extractor to parse executable files from installation packages that are broadly available in software download sites. In empirical experiments of binary-to-source mapping, we have got a remarkable high accuracy of 99.5% and recall of 95.6% without significant loss of precision. Besides, 2270 pairs of binary-to-source mapping relationships are discovered, with 110 license violations of GPL and AGPL licenses related to 7.2% of the 1000 real-world binary software projects.},
  keywords={Licenses;Open source software;Feature extraction;Binary codes;Libraries;Arrays},
  doi={10.1109/SANER.2019.8667977},
  ISSN={1534-5351},
  month={Feb},}@INPROCEEDINGS{8115648,
  author={Kim, Soomin and Faerevaag, Markus and Jung, Minkyu and Jung, Seungll and Oh, DongYeop and Lee, JongHyup and Cha, Sang Kil},
  booktitle={2017 32nd IEEE/ACM International Conference on Automated Software Engineering (ASE)}, 
  title={Testing intermediate representations for binary analysis}, 
  year={2017},
  volume={},
  number={},
  pages={353-364},
  abstract={Binary lifting, which is to translate a binary executable to a high-level intermediate representation, is a primary step in binary analysis. Despite its importance, there are only few existing approaches to testing the correctness of binary lifters. Furthermore, the existing approaches suffer from low test coverage, because they largely depend on random test case generation. In this paper, we present the design and implementation of the first systematic approach to testing binary lifters. We have evaluated the proposed system on 3 state-of-the-art binary lifters, and found 24 previously unknown semantic bugs. Our result demonstrates that writing a precise binary lifter is extremely difficult even for those heavily tested projects.},
  keywords={Semantics;Computer bugs;Binary codes;Testing;Tools;Software;C++ languages},
  doi={10.1109/ASE.2017.8115648},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{1374303,
  author={Emmerik, M.V. and Waddington, T.},
  booktitle={11th Working Conference on Reverse Engineering}, 
  title={Using a decompiler for real-world source recovery}, 
  year={2004},
  volume={},
  number={},
  pages={27-36},
  abstract={Despite their 40 year history, native executable decompilers have found very limited practical application in commercial projects. The success of Java decompilers is well known, and a few decompilers perform well by recognising patterns from specific compilers. This work describes the experience gained from applying a native executable decompiler, assisted by a commercial disassembler and hand editing, to a real-world Windows-based application. The clients had source code for a prototype version of the program, and an executable that performed better, for which the source code was not available. The project was to recover the algorithm at the core of the program, and if time permitted, the recovery of other pieces of source code. Despite the difficulties, the core algorithm was successfully decompiled, and a portion of the rest of the program as well. There were surprises, including the ability to recover almost all original class names, and the complete class hierarchy.},
  keywords={Prototypes;Java;Reverse engineering;History;Software maintenance;Australia;Pattern recognition;Speech analysis;Mathematics;User interfaces;Reverse engineering;decompilation;source code recovery;native executable file;experience},
  doi={10.1109/WCRE.2004.42},
  ISSN={1095-1350},
  month={Nov},}@INPROCEEDINGS{738514,
  author={Cifuentes, C. and Simon, D. and Fraboulet, A.},
  booktitle={Proceedings. International Conference on Software Maintenance (Cat. No. 98CB36272)}, 
  title={Assembly to high-level language translation}, 
  year={1998},
  volume={},
  number={},
  pages={228-237},
  abstract={Translation of assembly code to high-level language code is of importance in the maintenance of legacy code, as well as in the areas of program understanding, porting, and recovery of code. We present techniques used in the asm2c translator, a SPARC assembly to C translator. The techniques involve data and control flow analyses. The data flow analysis eliminates machine dependencies from the assembly code and recovers high-level language expressions. The control flow analysis recovers control structure statements. Simple data type recovery is also done. The presented techniques are extensions and improvements on previously developed CISC techniques. The choice of intermediate representation allows for both RISC and CISC assembly code to be supported by the analyses. We tested asm2c against SPEC95 SPARC assembly programs generated by a C compiler. Results using both unoptimized and optimized assembly code are presented.},
  keywords={Assembly;High level languages;Information analysis;Data analysis;Reduced instruction set computing;Testing;Portfolios;Hardware;Computer science;Information systems},
  doi={10.1109/ICSM.1998.738514},
  ISSN={1063-6773},
  month={Nov},}@INPROCEEDINGS{9425937,
  author={Mauthe, Noah and Kargén, Ulf and Shahmehri, Nahid},
  booktitle={2021 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={A Large-Scale Empirical Study of Android App Decompilation}, 
  year={2021},
  volume={},
  number={},
  pages={400-410},
  abstract={Decompilers are indispensable tools in Android malware analysis and app security auditing. Numerous academic works also employ an Android decompiler as the first step in a program analysis pipeline. In such settings, decompilation is frequently regarded as a "solved" problem, in that it is simply expected that source code can be accurately recovered from an app. While a large proportion of methods in an app can typically be decompiled successfully, it is common that at least some methods fail to decompile. In order to better understand the practical applicability of techniques in which decompilation is used as part of an automated analysis, it is important to know the actual expected failure rate of Android decompilation. To this end, we have performed what is, to the best of our knowledge, the first large-scale study of Android decompilation failure rates. We have used three sets of apps, consisting of, respectively, 3,018 open-source apps, 13,601 apps from a recent crawl of Google Play, and a collection of 24,553 malware samples. In addition to the state-of-the-art Dalvik bytecode decompiler jadx, we used three popular Java decompilers. While jadx achieves an impressively low failure rate of only 0.02% failed methods per app on average, we found that it manages to recover source code for all methods in only 21% of the Google Play apps.We have also sought to better understand the degree to which in-the-wild obfuscation techniques can prevent decompilation. Our empirical evaluation, complemented with an indepth manual analysis of a number of apps, indicate that code obfuscation is quite rarely encountered, even in malicious apps. Moreover, decompilation failures mostly appear to be caused by technical limitations in decompilers, rather than by deliberate attempts to thwart source-code recovery by obfuscation. This is an encouraging finding, as it indicates that near-perfect Android decompilation is, at least in theory, achievable, with implementation-level improvements to decompilation tools.},
  keywords={Java;Conferences;Pipelines;Process control;Manuals;Tools;Malware;Android;mobile apps;decompilation;obfuscation;reverse engineering;malware},
  doi={10.1109/SANER50967.2021.00044},
  ISSN={1534-5351},
  month={March},}@INPROCEEDINGS{9637076,
  author={Schütte, Julian and Titze, Dennis},
  booktitle={2019 International Workshop on Secure Internet of Things (SIOT)}, 
  title={liOS: Lifting iOS Apps for Fun and Profit}, 
  year={2019},
  volume={},
  number={},
  pages={1-10},
  abstract={Although iOS is the second most popular mobile operating system and is often considered the more secure one, approaches to automatically analyze iOS applications are scarce and generic app analysis frameworks do not exist. This is on the one hand due to the closed ecosystem putting obstacles in the way of reverse engineers and on the other hand due to the complexity of reverse engineering and analyzing app binaries. Reliably lifting accurate call graphs, control flows, and data dependence graphs from binary code, as well as reconstructing object-oriented high-level concepts is a non-trivial task and the choice of the lifted target representation determines the analysis capabilities. None of the various existing intermediate representations is a perfect fit for all types of analysis, while the detection of vulnerabilities requires techniques ranging from simple pattern matching to complex inter-procedural data flow analyses. We address this gap by introducing liOS, a binary lifting and analysis framework for iOS applications that extracts lifted information from several frontends and unifies them in a “supergraph” representation that tolerates missing parts and is further extended and interlinked by liOS “passes”. A static analysis of the binary is then realized in the form of graph traversal queries, which can be considered as an advancement of classic program query languages. We illustrate this approach by means of a typical JavaScript/Objective-C bridge, which can lead to remote code execution in iOS applications.},
  keywords={Analytical models;Protocols;Operating systems;Reverse engineering;Static analysis;Mobile communication;Reliability},
  doi={10.1109/SIOT48044.2019.9637076},
  ISSN={2690-8557},
  month={Sep.},}
