@INPROCEEDINGS{7249466,
  author={Qiu, Lingzhi and Zhang, Zixiong and Shen, Ziyi and Sun, Guozi},
  booktitle={2015 IEEE International Conference on Communications (ICC)}, 
  title={AppTrace: Dynamic trace on Android devices}, 
  year={2015},
  volume={},
  number={},
  pages={7145-7150},
  abstract={Mass vulnerabilities involved in the Android alternative applications could threaten the security of the launched device or users data. To analyze the alternative applications, generally, researchers would like to observe applications' runtime features first. Then they need to decompile the target application and read the complicated code to figure out what the application really does. Traditional dynamic analysis methodology, for instance, the TaintDroid, uses dynamic taint tracking technique to mark information at source APIs. However, TaintDroid is limited to constraint on requiring target application to run in custom sandbox that might be not compatible with all the Android versions. For solving this problem and helping analysts to have insight into the runtime behavior, this paper presents AppTrace, a novel dynamic analysis system that uses dynamic instrumentation technique to trace member methods of target application that could be deployed in any version above Android 4.0. The paper presents an evaluation of AppTrace with 8 apps from Google Play as well as 50 open source apps from F-Droid. The results show that AppTrace could trace methods of target applications successfully and notify users effectively when some sensitive APIs are invoked.},
  keywords={Androids;Humanoid robots;Java;Runtime;Instruments;Smart phones;Security},
  doi={10.1109/ICC.2015.7249466},
  ISSN={1938-1883},
  month={June},}@INPROCEEDINGS{8080433,
  author={Kostka, Bartosz and Kwiecieli, Jaroslaw and Kowalski, Jakub and Rychlikowski, Pawel},
  booktitle={2017 IEEE Conference on Computational Intelligence and Games (CIG)}, 
  title={Text-based adventures of the golovin AI agent}, 
  year={2017},
  volume={},
  number={},
  pages={181-188},
  abstract={The domain of text-based adventure games has been recently established as a new challenge of creating the agent that is both able to understand natural language, and acts intelligently in text-described environments. In this paper, we present our approach to tackle the problem. Our agent, named Golovin, takes advantage of the limited game domain. We use genre-related corpora (including fantasy books and decompiled games) to create language models suitable to this domain. Moreover, we embed mechanisms that allow us to specify, and separately handle, important tasks as fighting opponents, managing inventory, and navigating on the game map. We validated usefulness of these mechanisms, measuring agent's performance on the set of 50 interactive fiction games. Finally, we show that our agent plays on a level comparable to the winner of the last year Text-Based Adventure AI Competition.},
  keywords={Games;Artificial intelligence;Natural language processing;Conferences;Engines},
  doi={10.1109/CIG.2017.8080433},
  ISSN={2325-4289},
  month={Aug},}@ARTICLE{10925357,
  author={Nethala, Sainag and Chopra, Pronoy and Kamaluddin, Khaja and Alam, Shahid and Alharbi, Soltan and Alsaffar, Mohammad},
  journal={IEEE Access}, 
  title={A Deep Learning-Based Ensemble Framework for Robust Android Malware Detection}, 
  year={2025},
  volume={13},
  number={},
  pages={46673-46696},
  abstract={The exponential growth of Android applications has resulted in a surge of malware threats, posing severe risks to user privacy and data security. To address these challenges, this study introduces a novel malware detection approach utilizing an ensemble of Convolutional Neural Networks (CNNs) for enhanced classification accuracy. The methodology incorporates a multi-phase process, starting with the extraction and preprocessing of APK (Android app) files. The preprocessing phase involves decompressing, decompiling, and transforming the APK files into bytecode and Dex files. The extracted byte data is converted into 1D vectors and reshaped into 2D grayscale images, enabling efficient feature learning through CNNs. The proposed ensemble of CNN-based models undergoes comprehensive training, validation, and evaluation, demonstrating superior performance compared to existing approaches. We used two popular Android datasets to evaluate the performance of our proposed model. Specifically, the model achieves an accuracy of 98.65%, F1-score of 96.43% on the Drebin dataset and attains 97.91% accuracy, 96.73% of F1-score on the AMD dataset. These results confirm the mode’s ability to effectively identify Android malware with high precision and reliability, outperforming traditional techniques. This research not only underscores the potential of our proposed approach in malware detection but also sets a foundation for future advancements. Future efforts will focus on real-time malware detection, integration with mobile security frameworks, and evaluation across diverse datasets to ensure adaptability to emerging malware threats.},
  keywords={Malware;Accuracy;Feature extraction;Machine learning;Deep learning;Static analysis;Real-time systems;Random forests;Computational modeling;Support vector machines;Android malware detection;convolutional neural networks;malware classification;machine learning;ensemble learning;attention mechanism;Meta-CNN;deep learning},
  doi={10.1109/ACCESS.2025.3551152},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{4291043,
  author={Zhang, Jingbo and Zhao, Rongcai and Pang, Jianmin},
  booktitle={31st Annual International Computer Software and Applications Conference (COMPSAC 2007)}, 
  title={Parameter and Return-value Analysis of Binary Executables}, 
  year={2007},
  volume={1},
  number={},
  pages={501-508},
  abstract={The recovery of parameter and return-value plays an important role in decompilation, reverse engineering, binary translation and software maintenance etc. Furthermore, related approaches are very useful to inter- procedural analyzing and slicing of binary executable. However, the operations on parameters and return- values always appear obscure after the optimizing phases of a compiler, which will make the recovery hard to realize. In this paper, we present a flow-insensitive but context-sensitive algorithm based on data dependence analysis to get back parameters and return- values. In addition, we discuss our experimental results obtained by applying our techniques to a static binary translation framework. Evidence shows that our method performs well in analyzing the parameters and return-values of executables. We use an IA-64 executable for demonstration, but our techniques are not limited to any particular architecture.},
  keywords={Data analysis;Algorithms;Optimizing compilers;Computer architecture;Information analysis;Registers;Switching systems;Systems engineering and theory;Reverse engineering;Software maintenance},
  doi={10.1109/COMPSAC.2007.163},
  ISSN={0730-3157},
  month={July},}@ARTICLE{10299644,
  author={Rodriguez-Bazan, Horacio and Sidorov, Grigori and Escamilla-Ambrosio, Ponciano Jorge},
  journal={IEEE Access}, 
  title={Android Ransomware Analysis Using Convolutional Neural Network and Fuzzy Hashing Features}, 
  year={2023},
  volume={11},
  number={},
  pages={121724-121738},
  abstract={Most of the time, cybercriminals look for new ways to bypass security controls by improving their attacks. In the 1980s, attackers developed malware to kidnap user data by requesting payments. Malware is called a ransomware. Recently, they have demanded payment in Bitcoin or any other cryptocurrency. Ransomware is one of the most dangerous threats on the Internet, and this type of malware could affect almost all devices. Malware cipher device data, making them inaccessible to users. In this study, a new method for Android ransomware classification was proposed. This method implements a Convolutional Neural Network (CNN) for malware classification based on images. This paper presents a novel method for transforming an Android Application Package (APK) into a grayscale image. The image creation relies on using Natural Language Processing (NLP) techniques for text cleaning and Fuzzy Hashing to represent the decompiled code from the APK in a set of hashes after preprocessing using NLP techniques. The image is composed of  $n$  fuzzy hashes that represent the APK. The method was tested using a dataset of 7,765 Android ransomware samples obtained from external researchers and public sources. The accuracy of the proposed method was higher than that of other methods in the literature.},
  keywords={Operating systems;Ransomware;Natural language processing;Classification algorithms;XML;Metadata;Matched filters;Androids;Convolutional neural networks;Deep learning;Fuzzy systems;Android ransomware;convolutional neural network;deep learning;fuzzy hashing;malware classification;ransomware},
  doi={10.1109/ACCESS.2023.3328314},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{10050059,
  author={Wang, Zhifeng and Wu, Wanxuan and Zeng, Chunyan and Yao, Jialong and Yang, Yang and Xu, Hongmin},
  booktitle={2022 International Conference on Intelligent Education and Intelligent Research (IEIR)}, 
  title={Smart Contract Vulnerability Detection for Educational Blockchain Based on Graph Neural Networks}, 
  year={2022},
  volume={},
  number={},
  pages={8-14},
  abstract={With the development of blockchain technology, more and more attention has been paid to the intersection of blockchain and education, and various educational evaluation systems and E-learning systems are developed based on blockchain technology. Among them, Ethereum smart contract is favored by developers for its “event-triggered” mechanism for building education intelligent trading systems and intelligent learning platforms. However, due to the immutability of blockchain, published smart contracts cannot be modified, so problematic contracts cannot be fixed by modifying the code in the educational blockchain. In recent years, security incidents due to smart contract vulnerabilities have caused huge property losses, so the detection of smart contract vulnerabilities in educational blockchain has become a great challenge. To solve this problem, this paper proposes a graph neural network (GNN) based vulnerability detection for smart contracts in educational blockchains. Firstly, the bytecodes are decompiled to get the opcode. Secondly, the basic blocks are divided, and the edges between the basic blocks according to the opcode execution logic are added. Then, the control flow graphs (CFG) are built. Finally, we designed a GNN-based model for vulnerability detection. The experimental results show that the proposed method is effective for the vulnerability detection of smart contracts. Compared with the traditional approaches, it can get good results with fewer layers of the GCN model, which shows that the contract bytecode and GCN model are efficient in vulnerability detection.},
  keywords={Source coding;Image edge detection;Smart contracts;Education;Semantics;Predictive models;Graph neural networks;bytecode;educational blockchain;smart contract;vulnerability detection},
  doi={10.1109/IEIR56323.2022.10050059},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{558851,
  author={Cifuentes, C.},
  booktitle={Proceedings of WCRE '96: 4rd Working Conference on Reverse Engineering}, 
  title={Partial automation of an integrated reverse engineering environment of binary code}, 
  year={1996},
  volume={},
  number={},
  pages={50-56},
  abstract={The constant development of newer and faster machines requires software to be made available on those new machines at a rate faster than what it takes to develop the software. The use of binary translation techniques to migrate software from one machine to another is effective-it makes software available in little time without incurring reprogramming costs. However the development of such a tool is in itself an issue, as with each new architecture, a new tool needs to be written. The author presents a partially automated integrated environment for the reverse engineering of binary or executable code. This environment is suitable for the development of disassemblers, binary translators and decompilers.},
  keywords={Automation;Reverse engineering;Binary codes;Software tools;Investments;Software systems;Assembly;Operating systems;Computer science;Costs},
  doi={10.1109/WCRE.1996.558851},
  ISSN={},
  month={Nov},}@INPROCEEDINGS{9719255,
  author={Han, Xiang and Li, Chao and Li, Xin and Lu, Tianliang},
  booktitle={2021 International Conference on Computer Information Science and Artificial Intelligence (CISAI)}, 
  title={Research on APT Attack Detection Technology Based on DenseNet Convolutional Neural Network}, 
  year={2021},
  volume={},
  number={},
  pages={440-448},
  abstract={The detection of malicious code and variants of advanced persistent threat(APT) attacks is the main way to deal with APT attacks at this stage. APT attack organizations usually use code deformation, shelling, obfuscation and other methods to avoid detection to bypass APT attack malicious code detection. Aiming at the status quo, this paper proposes an APT attack detection scheme based on DenseNet convolutional neural network. First, the binary sample of the malicious code of the APT attack are preprocessed with some operations such as decompression and decompilation. APT attack malicious code samples are running in a sandbox with anti-code escaping technology, and the acquired data are converted into grayscale images. Then, we perform feature extraction and family clustering operations on the pre-processed image. Finally, the DenseNet convolutional neural network model is trained and tested on the sample data of the APT attack malicious code of eight families. The experimental results show that the average accuracy of the proposed scheme for the detection of APT attack malicious code and its variants can reach 98.84%. While cutting off the APT attack chain, it has a high detection accuracy.},
  keywords={Information science;Data preprocessing;Organizations;Gray-scale;Feature extraction;Malware;Data models;advanced persistent threat attack;malicious code;gray-scale image;deep learning;DenseNet convolutional neural network},
  doi={10.1109/CISAI54367.2021.00091},
  ISSN={},
  month={Sep.},}@ARTICLE{10195953,
  author={Zhang, Pengcheng and Yu, Qifan and Xiao, Yan and Dong, Hai and Luo, Xiapu and Wang, Xiao and Zhang, Meng},
  journal={IEEE Transactions on Software Engineering}, 
  title={BiAn: Smart Contract Source Code Obfuscation}, 
  year={2023},
  volume={49},
  number={9},
  pages={4456-4476},
  abstract={With the rising prominence of smart contracts, security attacks targeting them have increased, posing severe threats to their security and intellectual property rights. Existing simplistic datasets hinder effective vulnerability detection, raising security concerns. To address these challenges, we propose BiAn, a source code level smart contract obfuscation method that generates complex vulnerability test datasets. BiAn protects contracts by obfuscating data flows, control flows, and code layouts, increasing complexity and making it harder for attackers to discover vulnerabilities. Our experiments with buggy contracts showed an average complexity enhancement of approximately 174% after obfuscation. Decompilers Vandal and Gigahorse had total failure rate increments of 38.8% and 40.5% respectively. Obfuscated contracts also decreased vulnerability detection rates in more than 50% of cases for ten widely-used static analysis detection tools.},
  keywords={Smart contracts;Codes;Source coding;Security;Complexity theory;Intellectual property;Layout;Blockchain;Ethereum;smart contract;source code;obfuscation},
  doi={10.1109/TSE.2023.3298609},
  ISSN={1939-3520},
  month={Sep.},}@INPROCEEDINGS{4145122,
  author={He, Haifeng and Trimble, John and Perianayagam, Somu and Debray, Saumya and Andrews, Gregory},
  booktitle={International Symposium on Code Generation and Optimization (CGO'07)}, 
  title={Code Compaction of an Operating System Kernel}, 
  year={2007},
  volume={},
  number={},
  pages={283-298},
  abstract={General-purpose operating systems, such as Linux, are increasingly being used in embedded systems. Computational resources are usually limited, and embedded processors often have a limited amount of memory. This makes code size especially important. This paper describes techniques for automatically reducing the memory footprint of general-purpose operating systems on embedded platforms. The problem is complicated by the fact that kernel code tends to be quite different from ordinary application code, including the presence of a significant amount of hand-written assembly code, multiple entry points, implicit control flow paths involving interrupt handlers, and frequent indirect control flow via function pointers. We use a novel "approximate decompilation" technique to apply source-level program analysis to hand-written assembly code. A prototype implementation of our ideas on an Intel x86 platform, applied to a Linux kernel that has been configured to exclude unnecessary code, obtains a code size reduction of close to 24%},
  keywords={Compaction;Operating systems;Kernel;Embedded system;Linux;Assembly;Cellular phones;Runtime;Prototypes;Hardware},
  doi={10.1109/CGO.2007.3},
  ISSN={},
  month={March},}@ARTICLE{9869841,
  author={Zhang, Mei and Chen, Wanli},
  journal={IEEE Access}, 
  title={Fault Diagnosis of Power Transformer Based on SSA—MDS Pretreatment}, 
  year={2022},
  volume={10},
  number={},
  pages={92505-92515},
  abstract={Aiming at the problems of coupling between transformer input characteristics and low accuracy of transformer fault diagnosis, SSA-MDS and other soft technologies are used to analyze the key characteristics of transformer faults, so as to improve the accuracy of transformer fault diagnosis. The SSA algorithm cascade MDS algorithm to process the DGA data is proposed. Subsequently, the TSSA-RF model is introduced to classify the DGA data. The DGA data is first mapped to a high-dimensional space. Next, the optimal feature subset is encoded using the SSA algorithm to reduce irrelevant and redundant features. In this study, the correlation between the optimal feature dimension and the transformer fault diagnosis accuracy is investigated. the expression of the optimal feature subset is obtained by decompiling the SSA operator. The pre-processed data are classified using the RF model, and the TSSA -RF model for classifying the DGA data is found with the highest accuracy through the comparison of different optimization algorithms. After the RF model is optimized using the TSSA algorithm, its accuracy increases by 7.89%, and the accuracy of the TSSA -RF model is obtained as 92.11%. The example results show that compared with the original data, the proposed data processing algorithm improves the diagnostic accuracy of transformer by 11.97 % in the RF model. Compared with multiple preprocessing methods, SSA-MDS has the highest accuracy. Compared with the original data, the accuracy of TSSA-RF model increases by 11.64 %.},
  keywords={Oil insulation;Fault diagnosis;Optimization;Data models;Power transformer insulation;Classification algorithms;Classification tree analysis;Power transformer;fault diagnosis;RF~model;TSSA algorithm;feature extraction},
  doi={10.1109/ACCESS.2022.3202982},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{6577696,
  author={Ramón, Óscar Sánchez and Vanderdonckt, Jean and Molina, Jesús García},
  booktitle={IEEE 7th International Conference on Research Challenges in Information Science (RCIS)}, 
  title={Re-engineering graphical user interfaces from their resource files with UsiResourcer}, 
  year={2013},
  volume={},
  number={},
  pages={1-12},
  abstract={This paper addresses the problem of modernizing graphical user interfaces of interactive applications by re-engineering their resource files in four phases: resource decompilation, which extracts resource files from the executable code of an interactive application; modeling the source user interface, which transforms extracted resources into a resource model; resource to user interface transformation, which transforms the resource model into a Concrete User Interface model, and forward engineering, which offers two alternatives: after editing the user interface model, a new interface could be generated or recompiled into a resource to be incorporated back. The paper motivates and details this re-engineering approach by focusing on methods and algorithms implemented in UsiResourcer, a software tool that reverse engineers MS Windows resource files into a Concrete User Interface Model for further process. A discussion on the generalization of the approach is also provided.},
  keywords={Graphical user interfaces;Unified modeling language;Analytical models;Reverse engineering;HTML;Transforms;User Interfaces;Modernization;Model Driven Engineering;Reverse Engineering;Reengineering},
  doi={10.1109/RCIS.2013.6577696},
  ISSN={2151-1357},
  month={May},}@INPROCEEDINGS{10298504,
  author={Xiong, Jiaqi and Chen, Guoqiang and Chen, Kejiang and Gao, Han and Cheng, Shaoyin and Zhang, Weiming},
  booktitle={2023 38th IEEE/ACM International Conference on Automated Software Engineering (ASE)}, 
  title={HexT5: Unified Pre-Training for Stripped Binary Code Information Inference}, 
  year={2023},
  volume={},
  number={},
  pages={774-786},
  abstract={Decompilation is a widely used process for reverse engineers to significantly enhance code readability by lifting assembly code to a higher-level C-like language, pseudo-code. Nevertheless, the process of compilation and stripping irreversibly discards high-level semantic information that is crucial to code comprehension, such as comments, identifier names, and types. Existing approaches typically recover only one type of information, making them suboptimal for semantic inference. In this paper, we treat pseudo-code as a special programming language, then present a unified pre-trained model, HexT5, that is trained on vast amounts of natural language comments, source identifiers, and pseudo-code using novel pseudo-code-based pre-training objectives. We fine-tune HexT5 on various downstream tasks, including code summarization, variable name recovery, function name recovery, and similarity detection. Comprehensive experiments show that HexT5 achieves state-of-the-art performance on four downstream tasks, and it demonstrates the robust effectiveness and generalizability of HexT5 for binary-related tasks.},
  keywords={Computer languages;Semantics;Natural languages;Binary codes;Object recognition;Data mining;Task analysis;Reverse Engineering;Deep Learning;Binary Diffing;Information Inference;Programming Language Model},
  doi={10.1109/ASE56229.2023.00099},
  ISSN={2643-1572},
  month={Sep.},}@INPROCEEDINGS{10911787,
  author={Zhang, Lixia and Liu, Tianxu and Shen, Kaihui and Chen, Cheng},
  booktitle={2024 6th International Conference on Robotics, Intelligent Control and Artificial Intelligence (RICAI)}, 
  title={A Novel Approach to Malicious Code Detection Using CNN-BiLSTM and Feature Fusion}, 
  year={2024},
  volume={},
  number={},
  pages={745-755},
  abstract={With the rapid advancement of Internet technology, the threat of malware to computer systems and network security has intensified. Malware affects individual privacy and security and poses risks to critical infrastructures of enterprises and nations. The increasing quantity and complexity of malware, along with its concealment and diversity, challenge traditional detection techniques. Static detection methods struggle against variants and packed malware, while dynamic methods face high costs and risks that limit their application. Consequently, there is an urgent need for novel and efficient malware detection techniques to improve accuracy and robustness.This study first employs the minhash algorithm to convert binary files of malware into grayscale images, followed by the extraction of global and local texture features using GIST and LBP algorithms. Additionally, the study utilizes IDA Pro to decompile and extract opcode sequences, applying N-gram and tf-idf algorithms for feature vectorization. The fusion of these features enables the model to comprehensively capture the behavioral characteristics of malware.In terms of model construction, a CNN-BiLSTM fusion model is designed to simultaneously process image features and opcode sequences, enhancing classification performance. Experimental validation on multiple public datasets demonstrates that the proposed method significantly outperforms traditional detection techniques in terms of accuracy, recall, and F1 score, particularly in detecting variants and obfuscated malware with greater stability.The research presented in this paper offers new insights into the development of malware detection technologies, validating the effectiveness of feature and model fusion, and holds promising application prospects.},
  keywords={Deep learning;Training;Support vector machines;Adaptation models;Technological innovation;Accuracy;Explainable AI;Transfer learning;Feature extraction;Malware;Malware Detection;Deep Learning;Feature Fusion},
  doi={10.1109/RICAI64321.2024.10911787},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{10183629,
  author={S, Hrushik Raj and P, Thejaswini and Nandi, Sukumar},
  booktitle={2023 IEEE Guwahati Subsection Conference (GCON)}, 
  title={Reverse Engineering techniques for Android systems: A Systematic approach}, 
  year={2023},
  volume={},
  number={},
  pages={1-6},
  abstract={The Google Play Store has over 3 million Android apps available for download, making it the largest app store in the world. With such a vast number of apps available, there is a growing need for security and analysis, which has led to an increase in the use of reverse engineering tools and techniques. In this paper we provide an overview of the main tools used in Android reverse engineering, which are used for various activities including decompiling apk files, converting Java into Intermediate Languages (IL), and inspecting an application's Java code. The study's finding shows App Cloner and Mt manager tools have the highest precision and capabilities in optimizing and analyzing the security of the applications. This paper concludes with a discussion of the most effective reverse engineering tools and the future prospects of improvements possible for these tools.},
  keywords={Surveys;Java;Systematics;Codes;Reverse engineering;Software systems;Internet;reverse engineering tools;code obfuscation;android application},
  doi={10.1109/GCON58516.2023.10183629},
  ISSN={},
  month={June},}@ARTICLE{5390346,
  author={Flynn, Michael J. and Hoevel, Lee W.},
  journal={IBM Journal of Research and Development}, 
  title={Measures of ideal execution architectures}, 
  year={1984},
  volume={28},
  number={4},
  pages={356-369},
  abstract={This paper is a study in ideal computer architectures or program representations. We define measures of “ideal” architectures that are related to the higher-level representation used to describe a program at the source language level. Traditional machine architectures name operations and objects which are presumed to be present in the host machine: a memory space of certain size, ALU operations, etc. An ideal language-based architecture is based on a specific higher-level (source) language, and uses the operations in that language to describe transformations over objects in that language. The notion of ideal is necessarily constrained. The object program representation must be easily decompilable (i.e., the source is readily reconstructable). It is assumed that the source itself is a good representation for the original problem; thus any nonassignment operation present in the source program statement appears as a single instruction (operation) in the ideal representation. All named objects are defined with respect to the scope of definition of the source program. For simplicity of discussion, statistical behavior of the program and language is assumed to be unknown; Huffman codes are not used. From the above, canonic interpretive (CI) measures are developed. CI measures apply to both the space needed to represent a program and the time needed to interpret it. Example-based CI measures are evaluated for a variety of contemporary architectures, both host-and language-oriented, as well as a CI-derived language-oriented architecture.},
  keywords={},
  doi={10.1147/rd.284.0356},
  ISSN={0018-8646},
  month={July},}@INPROCEEDINGS{7363353,
  author={Xu, Junfeng and Zhang, Li and Sun, Yunchuan and Lin, Dong and Mao, Ye},
  booktitle={2015 IEEE International Conference on Computer and Information Technology; Ubiquitous Computing and Communications; Dependable, Autonomic and Secure Computing; Pervasive Intelligence and Computing}, 
  title={Toward a Secure Android Software Protection System}, 
  year={2015},
  volume={},
  number={},
  pages={2068-2074},
  abstract={At present, Regular Android software, injected in malicious code, is one of the important factors of that Android virus run rampant. Protecting the Android software has become a focus of attention in academia and industry. Addressing the safety protection issues of the Android software, this paper will present some new schemes for Android software security technology to reinforce java code. On the basis of existing research results, we will propose some recommendable solutions to prevent android applications being decompiled and cracked. Take advantage of these methods, we will build the Android software protection system, which will mostly eliminate the feasibility of the secondary packaging for Android software, and extend the Android software safety lifecycle as long as possible.},
  keywords={Conferences;Computers;Information technology;Ubiquitous computing},
  doi={10.1109/CIT/IUCC/DASC/PICOM.2015.307},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{9474328,
  author={Hua, Jiayi and Li, Yuanchun and Wang, Haoyu},
  booktitle={2021 IEEE Security and Privacy Workshops (SPW)}, 
  title={MMGuard: Automatically Protecting On-Device Deep Learning Models in Android Apps}, 
  year={2021},
  volume={},
  number={},
  pages={71-77},
  abstract={On-device deep learning models have shown growing popularity in mobile apps, which allows offline model inference while preserving user privacy. However, on-device deep learning models also introduce security challenges, i.e., the trained models can be easily stolen or even be tampered by attackers. Recent studies suggested that most of the on-device models are lacking of sufficient protection, i.e., can be stolen by decompiling the apps directly. In this work, we present MMGUARD, an automated framework for building mutual authentication between Android apps and deep neural network models, which can thus protect on-device models from being easily attacked (piracy and tampering). Unlike existing model protect methods, our approach does not require model re-training or any prior knowledge of the training data. The key idea of MMGUARD is to verify the deep learning model in the app before inference, i.e., feeding owner- and apprelated information to it, which can greatly increase the effort of model hacking. We evaluate MMGUARD on 5 popular image classification DNNs and 43 real world Android apps from Google Play. Experiment results suggest that MMGUARD introduces negligible latency on models and can be automatically applied to real world apps.},
  keywords={Deep learning;Training;Privacy;Neural networks;Training data;Data models;User experience;Model protection;deep learning;mobile app;on-device model;model attack.},
  doi={10.1109/SPW53761.2021.00019},
  ISSN={},
  month={May},}@INPROCEEDINGS{7739575,
  author={Alam, Md. Jawaherul and Goodrich, Michael T. and Johnson, Timothy},
  booktitle={2016 IEEE Symposium on Visualization for Cyber Security (VizSec)}, 
  title={J-Viz: Finding algorithmic complexity attacks via graph visualization of Java bytecode}, 
  year={2016},
  volume={},
  number={},
  pages={1-8},
  abstract={We describe a security visualization tool for finding algorithmic complexity attacks in Java bytecode. Our tool, which we call J-Viz, visualizes connected directed graphs derived from Java bytecode according to a canonical node ordering, which we call the sibling-first recursive (SFR) numbering. The particular graphs we consider are derived from applying Shiver's k-CFA framework to Java bytecode, and our visualizer includes helpful links between the nodes of an input graph and the Java bytecode that produced it, as well as a decompiled version of that Java bytecode. We show through experiments involving test cases provided by DARPA that the canonical drawing paradigm used in J-Viz is effective for identifying potential security vulnerabilities for algorithmic complexity attacks.},
  keywords={Visualization;Java;Security;Software;Complexity theory;Algorithm design and analysis;Software algorithms},
  doi={10.1109/VIZSEC.2016.7739575},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{8076511,
  author={Jiang, Zhongqing and Zhou, Anmin and Liu, Liang and Jia, Peng and Liu, Luping and Zuo, Zheng},
  booktitle={2017 7th IEEE International Conference on Electronics Information and Emergency Communication (ICEIEC)}, 
  title={CrackDex: Universal and automatic DEX extraction method}, 
  year={2017},
  volume={},
  number={},
  pages={53-60},
  abstract={With Android application packing technology evolving, there are more and more ways to harden APPs. Manually unpacking APPs becomes more difficult as the time needed for analyzing increase exponentially. At the beginning, the packing technology is designed to prevent APPs from being easily decompiled, tampered and re-packed. But unfortunately, many malicious APPs start to use packing service to protect themselves. At present, most of the antivirus software focus on APPs that are unpacked, which means if malicious APPs apply the packing service, they can easily escape from a lot of antivirus software. Therefore, we should not only emphasize the importance of packing, but also concentrate on the unpacking technology. Only by doing this can we protect the normal APPs, and not miss any harmful APPs at the same time. In this paper, we first systematically study a lot of DEX packing and unpacking technologies, then propose and develop a universal unpacking system, named CrackDex, which is capable of extracting the original DEX file from the packed APP. We propose three core technologies: simulation execution, DEX reassembling, and DEX restoration, to get the unpacked DEX file. CrackDex is a part of the Dalvik virtual machine, and it monitors the execution of functions to locate the unpacking point in the portable interpreter, then launches the simulation execution, collects the data of original DEX file through corresponding structure pointer, finally fulfills the unpacking process by reassembling the data collected. The results of our experiments show that CrackDex can be used to effectively unpack APPs that are packed by packing service in a universal approach without any other knowledge of packing service.},
  keywords={Androids;Humanoid robots;Encryption;Manuals;Libraries;simulation execution;DEX reassembling;DEX restoration},
  doi={10.1109/ICEIEC.2017.8076511},
  ISSN={2377-844X},
  month={July},}@INPROCEEDINGS{7024656,
  author={Yuxin, Ding and Wei, Dai and Yibin, Zhang and Chenglong, Xue},
  booktitle={2014 Ninth International Conference on P2P, Parallel, Grid, Cloud and Internet Computing}, 
  title={Malicious Code Detection Using Opcode Running Tree Representation}, 
  year={2014},
  volume={},
  number={},
  pages={616-621},
  abstract={An opcode behavior based method is proposed to detect malware. Opcode behaviors are represented as opcode sequences from a decompiled executable. To accurately describe the malware behaviors, we construct the opcode running tree to simulate the dynamic execution of a program, and opcode n-grams are extracted to represent the features of an executable. The experimental results show that the opcode behaviors extracted by this method can fully represent the behavior characteristics of an executable. Compared with the detection method based the opcode distributions, the proposed method has higher overall accuracy and a lower false positive rate.},
  keywords={Malware;Feature extraction;Support vector machines;Image edge detection;Accuracy;Training;Flow graphs;opcode behavior; malware detection; control flow; machine learning; security},
  doi={10.1109/3PGCIC.2014.140},
  ISSN={},
  month={Nov},}@ARTICLE{10334519,
  author={Chen, Xin and Yu, Dongjin and Cai, Xinxin and Jiang, He and Yu, Haihua},
  journal={IEEE Transactions on Reliability}, 
  title={Android Malware Family Clustering Based on Multiple Features}, 
  year={2024},
  volume={73},
  number={2},
  pages={1202-1215},
  abstract={Familiar analysis for malware plays an important role in comprehending the diversity of malicious behaviors and identifying the emerging security threats. Existing studies mainly focus on classifying malware into known families by supervised learning. However, these methods face two main challenges, 1) the lack of a large amount of labeled data and 2) the poor effectiveness in identifying unknown families of malware. To overcome these challenges, we propose a new method called multiple features (MulFC) based on unsupervised learning. In the method, we first leverage a decompiling tool to extract multiple features, including manifest features, application programming interface (API) features, and opcode features. Then, the opcode features are preprocessed to filter out the redundant ones to reduce the calculation cost. After that, we adopt the Jaccard index to calculate the similarities between malware and construct a malware network. Finally, InfoMap is applied to perform the clustering on the basis of the malware network. Overall, MulFC does not require the use of labeled data and can identify unknown families of malware. Experiments are conducted on two datasets for the performance evaluation of MulFC. The experimental results show that MulFC achieves 0.810 in terms of normalized mutual information, 0.576 in terms of adjusted rand index, 0.620 in terms of the Fowlkes–Mallows index, and 0.805 in terms of V-measure on average, and outperforms the state-of-the-art baseline method by 0.060, 0.054, 0.038, and 0.065, respectively.},
  keywords={Malware;Feature extraction;Operating systems;Indexes;Costs;Data mining;Androids;Unsupervised learning;Android malware;InfoMap;malware family clustering;multiple features;unsupervised learning},
  doi={10.1109/TR.2023.3332090},
  ISSN={1558-1721},
  month={June},}@INPROCEEDINGS{10545392,
  author={Ayub, Adeen and Jo, Wooyeon and Ahmed, Irfan},
  booktitle={2024 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)}, 
  title={Charlie, Charlie, Charlie on Industrial Control Systems: PLC Control Logic Attacks by Design, Not by Chance}, 
  year={2024},
  volume={},
  number={},
  pages={182-193},
  abstract={Programmable logic controllers (PLCs) in industrial control systems (ICS) run a control logic program to monitor and control critical infrastructures in real-time, such as nuclear plants and power grids. Attackers target PLC control logic remotely to sabotage or disrupt physical processes. Network intrusion detection systems (IDS) are increasingly used to detect malicious control logic. This paper demonstrates that standard IDS features in a protocol message header and payload are not resilient for detecting (control logic) binary programs, such as entropy, n-gram, and decompilation. It identifies and utilizes a PLC design feature, redundant address pins (RAP), unexplored in the literature, to bypass IDS for injecting a small piece of programmable malicious code (PMC) into a PLC's control logic as an initial attack vector, allowing it to execute with every scan cycle. We propose three unique attack methods (GizmoSplit, BuffWarp, and EnigmaFlow) using PMC as a proof of concept that blends control logic with network traffic via payload encoding, small-size payloads, or sparse memory addressing. The GizmoSplit attack divides the control logic into small gadgets and writes them in random memory locations in a PLC; PMC modifies the stack with the location of the gadgets to execute them as return-oriented programming. The BuffWarp attack employs a small-size buffer where the attacker writes malicious code periodically to bypass stateful inspection at the payload level; PMC, in turn, keeps moving the buffer content to consecutive memory locations to execute. The EnigmaFlow attack encodes control logic and sends it to a PLC's typically unused memory region, which PMC decodes and executes. The evaluation results indicate that these attacks are stealthy and can subvert IDS utilizing standard message header and payload features. This work points to a research gap in intrusion detection that caters to control logic attacks exploiting PLC design features.},
  keywords={Codes;Process control;Telecommunication traffic;Feature extraction;Control systems;Malware;Encoding;industrial control systems;programmable logic controllers;ICS attacks;control logic;intrusion detection systems},
  doi={10.1109/HOST55342.2024.10545392},
  ISSN={2765-8406},
  month={May},}@INPROCEEDINGS{8945606,
  author={Tirkey, Anand and Mohapatra, Ramesh Kumar and Kumar, Lov},
  booktitle={2019 26th Asia-Pacific Software Engineering Conference (APSEC)}, 
  title={Anatomizing Android Malwares}, 
  year={2019},
  volume={},
  number={},
  pages={450-457},
  abstract={Android OS being the popular choice of majority users also faces the constant risk of breach of confidentiality, integrity and availability (CIA). Effective mitigation efforts needs to identified in order to protect and uphold the CIA triad model, within the android ecosystem. In this paper, we propose a novel method of android malware classification using Object-Oriented Software Metrics and machine learning algorithms. First, android apps are decompiled and Object-Oriented Metrics are obtained. VirusTotal service is used to tag an app either as malware or benign. Object-Oriented Metrics and malware tag are clubbed together into a dataset. Eighty different machine-learned models are trained over five thousand seven hundred and seventy four android apps. We evaluate the performance and stability of these models using it's malware classification accuracy and AUC (area under ROC curve) values. Our method yields an accuracy and AUC of 99.83% and 1.0 respectively.},
  keywords={Malware;Measurement;Object oriented modeling;Tools;Feature extraction;Support vector machines;Neural networks;android;malware detection;machine learning;object oriented metrics},
  doi={10.1109/APSEC48747.2019.00067},
  ISSN={2640-0715},
  month={Dec},}@INPROCEEDINGS{9073578,
  author={Xylogiannopoulos, Konstantinos F. and Karampelas, Panagiotis and Alhajj, Reda},
  booktitle={2019 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM)}, 
  title={Text Mining for Malware Classification Using Multivariate All Repeated Patterns Detection}, 
  year={2019},
  volume={},
  number={},
  pages={887-894},
  abstract={Mobile phones have become nowadays a commodity to the majority of people. Using them, people are able to access the world of Internet and connect with their friends, their colleagues at work or even unknown people with common interests. This proliferation of the mobile devices has also been seen as an opportunity for the cyber criminals to deceive smartphone users and steel their money directly or indirectly, respectively, by accessing their bank accounts through the smartphones or by blackmailing them or selling their private data such as photos, credit card data, etc. to third parties. This is usually achieved by installing malware to smartphones masking their malevolent payload as a legitimate application and advertise it to the users with the hope that mobile users will install it in their devices. Thus, any existing application can easily be modified by integrating a malware and then presented it as a legitimate one. In response to this, scientists have proposed a number of malware detection and classification methods using a variety of techniques. Even though, several of them achieve relatively high precision in malware classification, there is still space for improvement. In this paper, we propose a text mining all repeated pattern detection method which uses the decompiled files of an application in order to classify a suspicious application into one of the known malware families. Based on the experimental results using a real malware dataset, the methodology tries to correctly classify (without any misclassification) all randomly selected malware applications of 3 categories with 3 different families each.},
  keywords={Malware;Androids;Humanoid robots;Mobile handsets;Social network services;Text mining;Payloads;Android malware detection;malware family classification;text mining;ARPaD;LERP-RSA},
  doi={10.1145/3341161.3350841},
  ISSN={2473-991X},
  month={Aug},}@INPROCEEDINGS{10776359,
  author={Kurniawan, Fandi and Stiawan, Deris and Antoni, Darius and Heriyanto, Ahmad and Idris, Mohd. Yazid and Budiarto, Rahmad},
  booktitle={2024 11th International Conference on Electrical Engineering, Computer Science and Informatics (EECSI)}, 
  title={Hybrid Machine Learning Model for Anticipating Cyber Crime Malware in Android: Work on Progress}, 
  year={2024},
  volume={},
  number={},
  pages={499-505},
  abstract={Improvements in information technology bring new challenges in cyber security, especially on the Android platform which is the main target of malware attacks. The National Cyber and Crypto Agency (BSSN) as the national cybersecurity institute recorded millions of attacks involving the Android Package Kit (.apk) application for electronic wedding invitations in Indonesia. This research aims to develop a hybrid machine learning model to detect and anticipate malware on Android devices, using algorithms such as Support Vector Machine (SVM), Random Forest (RF), and K-nearest neighbors (KNN). The main challenges are the limited number of representative datasets and the lack of effective detection techniquesThis research utilizes a primary server with a virtual machine (VM) to analyze the security of Android applications using mobSF and Frida, involving decompilation, TLS testing, and sensitive feature extraction. The system also depends on an Android emulator and Android Debug Bridge (ADB) for simulation, along with PostgreSQL, Job Scheduler, and Remote Desktop Protocol (RDP) for data management and task scheduling. The dataset comprises 1314 malware samples and 770 benign samples, totaling 2048 Android applications, with an average analysis time of 35 minutes per application. Through data collection and pre-processing, as well as model training and evaluation, it is hoped that the proposed framework can improve the accuracy of malware detection, making a significant contribution in protecting Android users from ever-evolving cyber threats. After performing a comparison using the algorithms mentioned above, it was found that the Random Forest algorithm showed the best performance with an accuracy of 97.11%, a precision of 97.22%, and a recall of 97.11%.},
  keywords={Support vector machines;Radio frequency;Accuracy;Machine learning algorithms;Operating systems;Nearest neighbor methods;Feature extraction;Malware;Computer crime;Random forests;Malware android;machine learning;malware detection;hybrid analysis},
  doi={10.1109/EECSI63442.2024.10776359},
  ISSN={},
  month={Sep.},}@INPROCEEDINGS{9315052,
  author={Ogwara, Noah Oghenefego and Petrova, Krassie and Bobby Yang, Mee Loong},
  booktitle={2020 30th International Telecommunication Networks and Applications Conference (ITNAC)}, 
  title={MOBDroid: An Intelligent Malware Detection System for Improved Data Security in Mobile Cloud Computing Environments}, 
  year={2020},
  volume={},
  number={},
  pages={1-6},
  abstract={We propose an intelligent malware detection system (MOBDroid) that aims to protect the end-user's mobile device (MD) in mobile cloud computing (MCC) environment. MOBDroid utilizes the Android Operating System (OS) permission-based security system. The APK files of 28,306 benign and malicious applications (apps) collected from the AndroZoo and RmvDroid malware repositories were used in the system development process. The apps were decompiled in order to extract their manifest files and construct a dataset comprising the permissions requested by each of the apps. We identified some unique permissions that could be used to distinguish between malicious and benign apps and performed a series of experiments using a machine learning (ML) model; the model drew on the ML.net library and was implemented in C#.net. In the experiments conducted, we obtained classification accuracy of 96.89%, a detection rate of 98.65%, and false negative rate of 1.35%. The results indicate that our model compares very favorably to other models reported in the extant literature.},
  keywords={Malware;Classification algorithms;Feature extraction;Data models;Cloud computing;Mobile applications;Communications technology;MOBDroid;mobile cloud computing;malware detection;data security;mobile devices;machine learning},
  doi={10.1109/ITNAC50341.2020.9315052},
  ISSN={2474-154X},
  month={Nov},}@INPROCEEDINGS{10195624,
  author={Xia, Bing and Ge, Yunxiang and Yang, Ruinan and Yin, Jiabin and Pang, Jianmin and Tang, Chongjun},
  booktitle={2023 IEEE 10th International Conference on Cyber Security and Cloud Computing (CSCloud)/2023 IEEE 9th International Conference on Edge Computing and Scalable Cloud (EdgeCom)}, 
  title={BContext2Name: Naming Functions in Stripped Binaries with Multi-Label Learning and Neural Networks}, 
  year={2023},
  volume={},
  number={},
  pages={167-172},
  abstract={Conducting binary function naming helps reverse engineers understand the internal workings of the code and perform malicious code analysis without accessing the source code. However, the loss of debugging information poses the challenge of insufficient high-level semantic information description for stripping binary code function naming. Meanwhile, the existing binary function naming scheme has one function label for only one sample. The long-tail effect of function labels for a single sample makes the machine learning-based prediction models face the challenge. To obtain a function correlation label and improve the propensity score of uncommon tail labels, we propose a multi-label learning-based binary function naming model BContext2Name. This model automatically generates relevant labels for binary function naming by function context information with the help of PfastreXML model. The experimental results show that BContext2Name can enrich function labels and alleviate the long-tail effect that exists for a single sample class. To obtain high-level semantics of binary functions, we align pseudocode and basic blocks based on disassembly and decompilation, identify concrete or abstract values of API parameters by variable tracking, and construct API-enhanced control flow graphs. Finally, a seq2seq neural network translation model with attention mechanism is constructed between function multi-label learning and enhanced control flow graphs. Experiments on the dataset reveal that the F1 values of the BContext2Name model improve by 3.55% and 15.23% over the state-of-the-art XFL and Nero, respectively. This indicates that function multi-label learning can provide accurate labels for binary functions and can help reverse analysts understand the inner working mechanism of binary code. Code and data for this evaluation are available at https://github.com/CSecurityZhongYuan/BContext2Name.},
  keywords={Cloud computing;Source coding;Semantics;Neural networks;Binary codes;Tail;Malware;Program analysis;Software reverse engineering;Binary code;Neural network translation;Multi-Label learning},
  doi={10.1109/CSCloud-EdgeCom58631.2023.00037},
  ISSN={2693-8928},
  month={July},}@INPROCEEDINGS{11052915,
  author={MK, Nagarajan and Dinesh, Rayavarapu Lakshmi Narasimha and S, Ratna Selvan and Nagamaiah, Mothadaka and Anjaneyulu, Kolakani Venkata Prasanna},
  booktitle={2025 International Conference on Computational Robotics, Testing and Engineering Evaluation (ICCRTEE)}, 
  title={Comprehensive Research on Mobile Application Security Assessment}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={The increasing use of mobile apps has raised generalized concerns regarding security threats, like malware and leakage of data. Most malicious applications masquerade as normal apps to steal private information from users. Conventional security approaches, both static analysis and dynamic analysis, have natural limitations when utilized individually. For the purpose of enhancing mobile security, this work suggests a Comprehensive Mobile Application Security Analysis Framework which combines static analysis, dynamic analysis, malware analysis, and reverse engineering techniques in the interest of identifying security defects in Android applications.The framework employs MoBSF for static analysis, Frida for dynamic instrumentation, VirusTotal for malware detection, and Apktool and Quark for reverse engineering. Apktool enables low-level decompilation of smali code, while Quark focuses on malware behavior detection through API call analysis. All these tools facilitate a comprehensive analysis of APK vulnerabilities, runtime threats, and malicious payloads.In this research paper, we explore various methodologies to analyze and improve mobile application security accuracy through static analysis, dynamic analysis, malware detection, and reverse engineering.This study shows how an integrated approach combining all four techniques improves detection accuracy, reducing false positives and uncovering hidden security threats. Results show that the hybrid approach effectively detects both known and unknown malware, making it an efficient approach for mobile application security assessments. Future enhance automation; explore machine learning enhancements for improved zero-day threat detection.},
  keywords={Runtime;Accuracy;Computer viruses;Reverse engineering;Static analysis;Malware;Threat assessment;Mobile security;Mobile applications;Security;Mobile Security;Static analysis;Dynamic Analysis;Reverse Engineering;Malware Detection;Android security;APK security},
  doi={10.1109/ICCRTEE64519.2025.11052915},
  ISSN={},
  month={May},}@INPROCEEDINGS{10410676,
  author={Bosse, Stefan and Polle, Christoph},
  booktitle={2023 10th International Conference on Future Internet of Things and Cloud (FiCloud)}, 
  title={Tiny Machine Learning Virtualization for IoT and Edge Computing using the REXA VM}, 
  year={2023},
  volume={},
  number={},
  pages={122-129},
  abstract={Tiny Machine Learning is a new approach that is being used for data-driven prediction classification and regression on microcontrollers using local sensor data. The models are typically learned off-line and sent to the microcontroller for use as binary objects or frozen and converted static data. This approach is not universal or flexible. The REXA VM, which can virtualize embedded systems and sensor nodes and includes a general machine learning framework that supports arbitrary dynamic artificial neural network and decision tree models, is introduced in this study. The models are delivered as text files with highly compressed program code that are enclosed in code frames with embedded data (model parameters). The VM offers fundamental computations for ANN and DT models (Microservices). Using a decompiler, models can be updated (retrained) and sent to other nodes (mobile models). It can be demonstrated that virtualization using a bytecode machine and just-in-time compiler is still appropriate and effective for extremely low-resource processors.},
  keywords={Codes;Microcontrollers;Computational modeling;Artificial neural networks;Data models;Internet of Things;Virtualization;Virtualization;Virtual Machines;Tiny ML;Sensor Networks;Embedded Systems;Microservices},
  doi={10.1109/FiCloud58648.2023.00026},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{10491696,
  author={Xia, Bing and Tang, Chongjun and Liu, Wenbo and Chu, Shihao and Dong, Yu},
  booktitle={2023 IEEE Intl Conf on Parallel & Distributed Processing with Applications, Big Data & Cloud Computing, Sustainable Computing & Communications, Social Computing & Networking (ISPA/BDCloud/SocialCom/SustainCom)}, 
  title={A Firmware Vulnerability Detection Method Based on Feature Filtering}, 
  year={2023},
  volume={},
  number={},
  pages={1069-1076},
  abstract={Open source code reuse and code cross-platform deployment accelerate the spread of software vulnerabilities, and pose challenges for accurate detection of cross-platform vulnerabilities. The binary vulnerability similarity detection method based on machine learning lacks a fine-grained vulnerability similarity feature filtering mechanism, and cannot solve cross-function vulnerabilities triggered by data dependencies, resulting in a high vulnerability false positive rate in existing solutions, which limits practical applications. Software code vulnerabilities are usually caused by function key statements. Therefore, based on binary function decompilation, we identify the key statement that causes the vulnerability, analyze the cross-function data dependency of the key statements, extract the code similarity features and code vulnerability features of the key statements, and propose a feature filtering-based Binary vulnerability detection method SimFilter. SimFilter calculates the similarity of key statements by comparing the characteristics of function key statements, and infers the similarity of binary function vulnerabilities based on the similarity of key statements. The experimental results show that the vulnerability semantic features extracted by SimFilter are highly interpretable, and the accuracy rate is increased by 10.8% compared with other models. At the same time, we analyzed and evaluated the impact of different similarity features on the accuracy of SimFilter, and gave the best empirical value of the SimFilter model in firmware vulnerability detection.},
  keywords={Analytical models;Codes;Filtering;Source coding;Semantics;Machine learning;Feature extraction;Open Source Software;Vulnerability Detection;Binary Similarity;Internet Of Things;Data Dependency},
  doi={10.1109/ISPA-BDCloud-SocialCom-SustainCom59178.2023.00172},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{10500201,
  author={Adams, Shawn C. and Zheng, Yuliang},
  booktitle={SoutheastCon 2024}, 
  title={A Blockchain Smart Contract Framework Using Interpreted Programming Languages and Decentralized Storage}, 
  year={2024},
  volume={},
  number={},
  pages={222-230},
  abstract={We present a model for an alternative to Ethereum Virtual Machine (EVM) smart contract blockchain networks which relies on an interpreted programming language and a distributed file system. Specifically we present the model by integrating the Interplanetary File System (IPFS) for decentralized files storage and Python as the interpreted programming language. IPFS ensures that contract code does not change by using content/hash-based addressing. The address of the file can be passed between nodes to recreate the files locally as long as nodes are running an IPFS node as well. In this implementation, we design the model to work with an existing prototype blockchain which was built with IPFS integration. The use of Python to write the code helps ensure transparency as the code does not need to be compiled and thus would not need to be run through a decompiler to make deployed code human-readable. We describe how the data is extracted and validated from a transaction before the code is executed locally and it's respective state updated and stored on the blockchain.},
  keywords={Codes;File systems;Smart contracts;Prototypes;Virtual machining;Blockchains;InterPlanetary File System;blockchain;smart contracts;python;IPFS},
  doi={10.1109/SoutheastCon52093.2024.10500201},
  ISSN={1558-058X},
  month={March},}@INPROCEEDINGS{7041862,
  author={Medina, Laura Victoria Morales and Rueda, Sandra Julieta},
  booktitle={2014 IEEE Latin-America Conference on Communications (LATINCOM)}, 
  title={Identifying Android malware instructions}, 
  year={2014},
  volume={},
  number={},
  pages={1-7},
  abstract={Android is a very attractive platform for malware developers because it is widely used. There is a need to understand how malware works and how it can exploit a system's security architecture. To do so, this work decompiles Android malware applications to study their source code and to look for patterns, regarding instructions, method calls, and permission usage. The goal is to define a set of instruction-based signatures that identify dangerous behavior and to use the identified signatures as a base for developing tools for code analysis.},
  keywords={Malware;Androids;Humanoid robots;Receivers;Smart phones;Java;smartphone security;permission management},
  doi={10.1109/LATINCOM.2014.7041862},
  ISSN={2330-989X},
  month={Nov},}@INPROCEEDINGS{10188657,
  author={Borrello, Pietro and Easdon, Catherine and Schwarzl, Martin and Czerny, Roland and Schwarz, Michael},
  booktitle={2023 IEEE Security and Privacy Workshops (SPW)}, 
  title={CustomProcessingUnit: Reverse Engineering and Customization of Intel Microcode}, 
  year={2023},
  volume={},
  number={},
  pages={285-297},
  abstract={Microcode provides an abstraction layer over the instruction set to decompose complex instructions into simpler micro-operations that can be more easily implemented in hardware. It is an essential optimization to simplify the design of x86 processors. However, introducing an additional layer of software beneath the instruction set poses security and reliability concerns. The microcode details are confidential to the manufacturers, preventing independent auditing or customization of the microcode. Moreover, microcode patches are signed and encrypted to prevent unauthorized patching and reverse engineering. However, recent research has recovered decrypted microcode and reverse-engineered read/write debug mechanisms on Intel Goldmont (Atom), making analysis and customization of microcode possible on a modern Intel microarchitecture. In this work, we present the first framework for static and dynamic analysis of Intel microcode. Building upon prior research, we reverse-engineer Goldmont microcode semantics and reconstruct the patching primitives for microcode customization. For static analysis, we implement a Ghidra processor module for decompilation and analysis of decrypted microcode. For dynamic analysis, we create a UEFI application that can trace and patch microcode to provide complete microcode control on Goldmont systems. Leveraging our framework, we reverse-engineer the confidential Intel microcode update algorithm and perform the first security analysis of its design and implementation. In three further case studies, we illustrate the potential security and performance benefits of microcode customization. We provide the first x86 Pointer Authentication Code (PAC) microcode implementation and its security evaluation, design and implement fast software breakpoints that are more than 1000x faster than standard breakpoints, and present constant-time microcode division, illustrating the potential security and performance benefits of microcode customization.},
  keywords={Microarchitecture;Instruction sets;Reverse engineering;Software algorithms;Static analysis;Software;Hardware},
  doi={10.1109/SPW59333.2023.00031},
  ISSN={2770-8411},
  month={May},}@INPROCEEDINGS{10589897,
  author={Lin, Wei and Guo, Qingli and Yu, DongSong and Yin, Jiawei and Gong, Qi and Gong, Xiaorui},
  booktitle={2024 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={ReIFunc: Identifying Recurring Inline Functions in Binary Code}, 
  year={2024},
  volume={},
  number={},
  pages={670-680},
  abstract={Function inlining, although a common phenomenon, can greatly hinder the readability of the binary code obtained through decompilation. Identifying inline functions in the binary code is additionally challenging as there is no clear boundary between an inlined function and its caller function, the instructions of the same function might differ during inline expansion, and existing graph-schema methods for inline function identification cannot handle the vast number of functions involved due to their complexity. To address the challenge, in this paper, we propose an effective inline function identification solution named ReIFunc, which combines subgraph isomorphism and deep learning to identify these recurring inline functions (RIFs). Our evaluation shows that ReIFunc can effectively match functions within a broad candidate set with a high precision rate exceeding 99% while maintaining an acceptable recall, thus getting rid of the constraints imposed by the limited size of the candidate set.},
  keywords={Deep learning;Analytical models;Buildings;Binary codes;Software;Optimization;binary analysis;inline function identification;subgraph isomorphism;representation learning model},
  doi={10.1109/SANER60148.2024.00074},
  ISSN={2640-7574},
  month={March},}@INPROCEEDINGS{11166547,
  author={Seixas, Vinicius and Elish, Karim},
  booktitle={2025 International Conference on Artificial Intelligence, Computer, Data Sciences and Applications (ACDSA)}, 
  title={High-Accuracy Android Ransomware Detection Using SMALI Code-Based Analysis}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={Ransomware targeting the Android platform continues to pose a serious threat to users and organizations, with increasing sophistication and widespread impact. This paper introduces a high-accuracy detection framework that leverages static analysis of SMALI code—a low-level representation generated during APK decompilation—to identify Android ransomware. Unlike approaches that rely on Java-level reconstruction or dynamic behavior, our method extracts meaningful features such as permission usage, API calls, cryptographic operations, and component structure directly from SMALI and manifest files. The framework constructs a structured dataset from these features and applies various machine learning classifiers to distinguish ransomware from benign applications. Experiments conducted on two publicly available datasets, including AMD and CI-CAndMal2017, demonstrate the framework’s effectiveness. The Random Forest classifier achieved a peak accuracy of 98.89%, with the ensemble and model also performing competitively. The results highlight the promise of SMALI-based static analysis for efficient, scalable, and interpretable ransomware detection.},
  keywords={Accuracy;Operating systems;Computational modeling;Static analysis;Organizations;Feature extraction;Ransomware;Cryptography;Random forests;Android;ransomware;static analysis;machine learning},
  doi={10.1109/ACDSA65407.2025.11166547},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{11086752,
  author={Luo, Rui and Ge, Hui and Jin, Xiao and Qin, Zhendong and Liu, Lihua},
  booktitle={2025 10th International Conference on Intelligent Computing and Signal Processing (ICSP)}, 
  title={Binary Code Similarity Detection by Fusing Graph Attention Network and Abstract Syntax Tree}, 
  year={2025},
  volume={},
  number={},
  pages={1247-1253},
  abstract={Since the introduction of deep learning-based binary code similarity detection methods, there has been a proliferation of methods using graph neural networks to learn semantic information from intermediate representations such as control flow graphs. Graph Attention Network (GAT) is a graph neural network model based on the attention mechanism, the core idea of which is to dynamically aggregate information from adjacent nodes by adaptively learning the importance weights between nodes in the graph, which can enhance the training effect of the model by incorporating the attention mechanism. The structured representation advantage of Abstract Syntax Trees (AST) is reflected in the hierarchical decomposition of program syntax structures, which effectively captures the logical semantics and contextual dependencies of the code, a feature that makes AST robust against the obfuscation of cross-architecture binary code. However, there has not yet been an approach that fuses graph attention networks and abstract syntax trees in the field of binary code similarity detection, so we propose a cross-architecture binary code similarity detection approach that fuses abstract syntax trees and graph attention networks. We use the open-source dataset provided by Asteria, decompile the binary code using the binary analysis tool IDA pro to extract the abstract syntax tree as the feature source of the neural network, and deeply optimize GAT for the limitations of processing tree data structure to improve its ability to learn the semantic information of AST. We trained TreeLSTM, plain GAT, and deeply optimized GAT neural network models respectively, and compared them. The experimental results show that the training speed of our proposed method is improved by 54.63% compared to the TreeLSTM-based method, and the AUC and Accuracy metrics are basically comparable.},
  keywords={Training;Tree data structures;Attention mechanisms;Fuses;Semantics;Binary codes;Syntactics;Feature extraction;Graph neural networks;Data mining;binary code similarity;graph attention network;abstract syntax tree},
  doi={10.1109/ICSP65755.2025.11086752},
  ISSN={},
  month={May},}@INPROCEEDINGS{11029887,
  author={Verbeek, Freek and Shokri, Ali and Engel, Daniel and Ravindran, Binoy},
  booktitle={2025 IEEE/ACM 47th International Conference on Software Engineering (ICSE)}, 
  title={Formally Verified Binary-Level Pointer Analysis}, 
  year={2025},
  volume={},
  number={},
  pages={42-53},
  abstract={Binary-level pointer analysis can be of use in symbolic execution, testing, verification, and decompilation of software binaries. In various such contexts, it is crucial that the result is trustworthy, i.e., it can be formally established that the pointer designations are overapproximative. This paper presents an approach to formally proven correct binary-level pointer analysis. A salient property of our approach is that it first generically considers what proof obligations a generic abstract domain for pointer analysis must satisfy. This allows easy instantiation of different domains, varying in precision, while preserving the correctness of the analysis. In the trade-off between scalability and precision, such customization allows “meaningful” precision (sufficiently precise to ensure basic sanity properties, such as that relevant parts of the stack frame are not overwritten during function execution) while also allowing coarse analysis when pointer computations have become too obfuscated during compilation for sound and accurate bounds analysis. We experiment with three different abstract domains with high, medium, and low precision. Evaluation shows that our approach is able to derive designations for memory writes soundly in COTS binaries, in a context-sensitive interprocedural fashion.},
  keywords={Accuracy;Scalability;Software;Testing;Software engineering;binary analysis;pointer analysis;formal methods},
  doi={10.1109/ICSE55347.2025.00231},
  ISSN={1558-1225},
  month={April},}@INPROCEEDINGS{8284326,
  author={Gupta, Chetna and Bhatt, Arpita Jadhav and Mittal, Sangeeta},
  booktitle={2017 Tenth International Conference on Contemporary Computing (IC3)}, 
  title={Disassembling and patching iOS applications at assembly level}, 
  year={2017},
  volume={},
  number={},
  pages={1-6},
  abstract={There are many mobile operating systems for different smartphones. iOS is one of them available exclusively on Apple devices. It offers various features such as GPS tracking, Siri, multi touch gestures, biometric authentication etc. The functionality of an iOS device can be expanded by installing third party applications, available from App store. Apple follows a mandatory code signing process to ensure that applications are developed by trusted enterprises/developers and no malware exists on App Store. However, past attacks on iOS devices such as ikee, Wirelurker have revealed that Apple's code signing process is not sufficient to ensure the security of its devices. Considering past attacks on iOS devices and with view of analyzing the behavior of iOS applications, this paper aims to describe how an analyst can perform reverse engineering of iOS applications by disassembling, decompiling and debugging application's code using Disassembler to discover the vulnerable areas.},
  keywords={Malware;Smart phones;Tools;Mobile communication;Operating systems;Electronic mail;Reverse engineering;Reverse Engineering;Disassembling;Interactive Disassembler;Code Patching;iOS application},
  doi={10.1109/IC3.2017.8284326},
  ISSN={2572-6129},
  month={Aug},}@ARTICLE{11098869,
  author={Ghimire, Ashutosh and Lingala, Sahasra Rao and Zhang, Junjie and Alsulami, Faris and Amsaad, Fathi},
  journal={IEEE Access}, 
  title={A Survey on Application of AI on Reverse Engineering for Software Analysis and Security}, 
  year={2025},
  volume={13},
  number={},
  pages={152903-152913},
  abstract={Reverse engineering process serves essential functions in software analysis and security auditing and malware detection but requires significant time and effort. Researchers and practitioners now investigate how Artificial Intelligence (AI) technology can automate and improve different reverse engineering procedures. This survey provides an extensive evaluation of recent AI-based reverse engineering techniques which focus on software decompilation and function identification as well as control flow recovery and vulnerability analysis. The paper presents a classification system for existing methods while comparing them through an analysis of their development from traditional rule-based systems to contemporary deep learning frameworks. The research examines fundamental datasets together with field tools and evaluation metrics. This paper establishes a fundamental understanding of AI integration in reverse engineering for software security while discussing future development directions.},
  keywords={Reverse engineering;Software;Codes;Security;Malware;Artificial intelligence;Surveys;Source coding;Static analysis;Logic;Reverse engineering;software security;malware detection;anomalies;threat analysis},
  doi={10.1109/ACCESS.2025.3593456},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{11307212,
  author={Rajendran, Megala and Al-Nussairi, Ahmed Kateb J. and Abdulhasan, Maki Mahdi and Sreseh, Saleh Naji and Owaied, Huda Qasim},
  booktitle={2025 Second International Conference on Intelligent Technologies for Sustainable Electric and Communications Systems (iTech SECOM)}, 
  title={AI-Based Malware Classification in Android Apps Using Vision Transformer (ViT) on Bytecode Images}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={The rapid proliferation of Android applications has made mobile platforms a prime target for malware attacks. To address the growing concern of malicious apps, this study presents an AI-based malware classification approach using Vision Transformer (ViT) on bytecode images of Android applications. Traditional malware detection techniques, including signature-based and heuristic methods, often fail to detect novel and obfuscated malware due to limited generalization and static rule-based systems. These limitations have necessitated the need for more intelligent and adaptive solutions that can handle complex and evolving malware patterns. To overcome these challenges, we propose a novel framework: Real-Time Malware Detection in App Stores using Bytecode Image Generation and Vision Transformer-Based Classification (RAMViD). In this approach, Android APK files are first decompiled to extract Dalvik bytecode, which is then transformed into grayscale images representing the byte patterns of the application. These images are fed into a finetuned Vision Transformer model that learns intricate visual features of benign and malicious patterns for accurate classification. The proposed method can be integrated into app store infrastructures to perform real-time malware analysis during the app submission process. This ensures proactive filtering of malicious applications before they reach end-users, enhancing platform security without manual intervention. Experimental results demonstrate that the ViT-based classification framework outperforms conventional CNN-based models in accuracy and robustness. The system achieves high detection rates with reduced false positives, highlighting its effectiveness in identifying both known and previously unseen malware. This solution offers a scalable, automated, and intelligent alternative for securing Android ecosystems.},
  keywords={Computer vision;Visualization;Accuracy;Operating systems;Static analysis;Transformers;Malware;Real-time systems;Robustness;Security;Android Malware Detection;Vision Transformer;Bytecode Image;Real-Time Analysis;Deep Learning;Static Analysis;Mobile App Security},
  doi={10.1109/iTechSECOM64750.2025.11307212},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{11023499,
  author={Wang, Yanzhong and Liang, Ruigang and Li, Yilin and Hu, Peiwei and Chen, Kai and Zhang, Bolun},
  booktitle={2025 IEEE Symposium on Security and Privacy (SP)}, 
  title={TypeForge: Synthesizing and Selecting Best-Fit Composite Data Types for Stripped Binaries}, 
  year={2025},
  volume={},
  number={},
  pages={1-18},
  abstract={Static binary analysis is a widely used approach for ensuring the security of closed-source software. However, the absence of type information in stripped binaries, particularly for composite data types, poses significant challenges for both static analyzers and reverse engineering experts in achieving efficient and accurate analysis. Existing methods often struggle with inaccuracies and scalability limitations when dealing with such data types. To address these problems, we present Typeforge, a novel approach inspired by the workflow of reverse engineering experts, which uses a two-stage synthesis-selection strategy to automate the recovery of composite data types from stripped binaries. We design a new graph structure, the Type Flow Graph (TFG) to represent type information within stripped binaries. In the first stage, TFG-based Type Synthesis focuses on efficiently and accurately building constraints and synthesizing possible composite type declarations from the stripped binaries. In the second stage, we propose an LLM-assisted double-elimination framework to select the best-fit type declaration from the candidates by assessing the readability of the decompiled code. Our comparison with state-of-the-art approaches demonstrates that TYPEFORGE achieves F1 scores of 81.7% and 88.2% in Composite Data Type Identification and Layout Recovery, respectively, substantially outperforming existing methods. Additionally, TYPEFORGE achieves an F1 score of 72.1% in Relationship Recovery, a particularly challenging task for previous approaches. Furthermore, TYPEFORGE has significantly lower time overhead, requiring only about 3.8% of the time taken by OSPREY, the best-performing existing approach, making it a promising solution for various real-world reverse engineering tasks.},
  keywords={Privacy;Codes;Accuracy;Scalability;Reverse engineering;Layout;Buildings;Software;Security;Flow graphs},
  doi={10.1109/SP61157.2025.00193},
  ISSN={2375-1207},
  month={May},}@ARTICLE{11242121,
  author={Huang, Jing and Wang, Min and Hu, Yupeng},
  journal={IEEE Internet of Things Journal}, 
  title={FirmCCF: Detecting Custom Cryptographic Function Vulnerabilities Through Query-Driven Approaches}, 
  year={2026},
  volume={13},
  number={2},
  pages={2988-2999},
  abstract={Cryptographic techniques are widely used to safeguard software against privacy breaches. Efficiently detecting encryption algorithms in software to determine whether they meet security requirements is a critical task. However, traditional static and dynamic detection methods often suffer from high false alarm rates or low efficiency, as they cannot fully capture the structural and semantic features of cryptographic algorithms. In this article, we propose FirmCCF, a vulnerability detection tool for custom cryptographic functions in Internet of Things (IoT) devices. FirmCCF leverages an improved deep learning encoder–decoder classification model, CodeT5-cate, to identify and classify cryptographic functions in source code and decompiled firmware. It then outputs highly structured meta-level attributes of cryptographic functions via a large language model (LLM) and detects vulnerabilities through a query-driven approach. FirmCCF achieves 99.97% accuracy, 99.72% recall, and 99.86%  $F1$ -score in detecting cryptographic functions from binary files. We further define seven security rules, encode them as queries, and use them to uncover seven categories of vulnerabilities. An evaluation of 40902 function codes revealed 46 vulnerabilities, including eight previously unknown issues. Our work highlights the urgent need for systematic assessment solutions to detect and mitigate vulnerabilities in custom cryptographic functions.},
  keywords={Cryptography;Encryption;Codes;Salt;Software algorithms;Software;Heuristic algorithms;Feature extraction;Internet of Things;Threat modeling;CodeT5-cate;custom cryptographic function;query-driven},
  doi={10.1109/JIOT.2025.3631834},
  ISSN={2327-4662},
  month={Jan},}@INPROCEEDINGS{10679822,
  author={Wang, Zhoukai and Xu, Zuoyan and Zhang, Yaling and Song, Xin and Wang, Yichuan},
  booktitle={2024 International Conference on Networking and Network Applications (NaNA)}, 
  title={Research on Code Virtualization Methods for Cloud Applications}, 
  year={2024},
  volume={},
  number={},
  pages={287-292},
  abstract={With the vigorous development of technologies such as the Internet, mobile devices, and the Internet of Things, cloud services have gained a crucial position in our life and have become an essential part of daily operations for modern enterprises and organizations. However, existing cloud application security solutions have failed to address the problem of runtime binary code security, focusing only on vulnerabilities inherent to the applications themselves. Code virtualization, also known as virtualization obfuscation, is a technique that protects software from malicious analysis by obfuscating the code. It hides the code’s control flow and data flow, thereby preventing the code from being decompiled. In this paper, we introduce a code virtualization method, VMENP, which splits the code into multiple modules and uses polymorphic and modular encryption mechanisms to secure binary code at runtime. Specifically, VMENP divides the protected program into several modules, designs a virtual instruction set along with its corresponding interpreter, encrypts each instruction individually after converting it into intermediate representations, and then encrypts it again at the basic block level. After compiling the segmented code into polymorphic bytecode sequences, it embeds the virtual code’s interpreter into the IR. During runtime, the protected code is dynamically decrypted and executed by the basic block level, with each basic block’s storage and execution in memory in a short time window. VMENP identifies functions annotated in the source code to locate the functions that need protection. This paper uses a large amount of $\mathrm{C} / \mathrm{C}++$ code to perform tests in a real cloud environment. Experimental results show that VMENP achieves a good balance between the granularity of protection and the performance overhead of the protected programs, while successfully protecting $\mathrm{C} / \mathrm{C}++$ code and programs running on X86/64 and ARM32/64 architectures.},
  keywords={Cloud computing;Codes;Runtime;Instruction sets;Reverse engineering;Computer architecture;Binary codes;Cloud application security;code virtualization;code obfuscation;polymorphic Routines;reverse engineering},
  doi={10.1109/NaNA63151.2024.00054},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{10743227,
  author={Chen, Yingchao and Wang, Junchao and Zhou, Xin and Pang, Jianmin},
  booktitle={2024 9th International Conference on Intelligent Computing and Signal Processing (ICSP)}, 
  title={Software Diversification Protection Methods for Binary Programs}, 
  year={2024},
  volume={},
  number={},
  pages={285-291},
  abstract={Software diversification is an effective software protection method against reverse engineering and code reuse attacks, which can provide heterogeneous redundant execution bodies for mimetic defense mechanisms. Most existing software diversification methods require access to the source code, which can provide defenders with more valuable information for devising effective defense strategies. However, due to commercial copyright and the purpose of preventing software piracy, developers often keep their software closed-source, making it difficult to access the source code. Therefore, a method called R2BF (ReCooking and Randomizing Binary File) is proposed, which combines decompilation and diversification compilation techniques to address the difficulty of obtaining the source code. This method involves diversifying the source code through compilation to achieve software diversification for binary executable files. Security and performance testing of diversified C programs has shown that diversified binary executable files can mitigate vulnerabilities resulting from code reuse, validating that this method can enhance the security of binary programs and is feasible for software protection. The diversified binary executable files are nearly identical to the original, non-diversified files in terms of file size and execution time, and may even exhibit acceleration and optimization effects in certain scenarios.},
  keywords={Software testing;Codes;Source coding;Software protection;Software algorithms;Reverse engineering;Signal processing algorithms;Software;Security;Optimization;component;program protection;software diversification;decompilation;diversification compilation},
  doi={10.1109/ICSP62122.2024.10743227},
  ISSN={},
  month={April},}@ARTICLE{11267408,
  author={Priambodo, Tegar Ganang Satrio and Prabowo, Angela Oryza and Puspitarini, Annisa Dwi and Winarso, Raihan Adam Handoyo and Aisyah, Nur and Pratama, Mohammad Yoga and Purwitasari, Diana and Pratomo, Baskoro Adi},
  journal={IEEE Access}, 
  title={MalQwen: Fine Tuned LLM for Static Android Malware Analysis Report}, 
  year={2025},
  volume={13},
  number={},
  pages={208483-208497},
  abstract={The Android operating system continues to face escalating security challenges, primarily due to its open-source nature and the rapid proliferation of applications from untrusted sources. Traditional static analysis tools lack the flexibility to capture evolving malware behaviors, limiting their interpretability and scalability. Large Language Models (LLMs) are now applied in cybersecurity for malware detection, phishing classification, and cyber threat intelligence. However, their use has not been extended to producing detailed and interpretable Android malware analysis reports. This study integrates LLMs into Android malware analysis by creating a dataset for instruction tuning and fine-tuning the Qwen-7B model using the LoRA method. The model MalQwen is developed by fine-tuning Qwen 2.5-7B with 429 malware samples containing decompiled code and expert labeled security reports. MalQwen outperforms models like Gemini and LLaMA, achieving a BERTscore of 0.84 for SMS malware and a Perplexity score of 3.30 for Scareware. These findings confirm MalQwen’s superior performance in generating precise malware reports, validating LLMs as a powerful new method for Android malware analysis.},
  keywords={Malware;Codes;Operating systems;Feature extraction;Static analysis;Security;Cyber threat intelligence;Training;Data mining;Adaptation models;Android malware analysis;large language model;LoRA fine-tuning;static analysis;report generation},
  doi={10.1109/ACCESS.2025.3637047},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{7921975,
  author={Li, Xiang and Zheng, Chao and Zhang, Chengwei and Li, Shu and Guo, Li and Xu, Jie},
  booktitle={2017 8th International Conference on Information and Communication Systems (ICICS)}, 
  title={AppTwins: A new approach to identify app package in network traffic}, 
  year={2017},
  volume={},
  number={},
  pages={222-227},
  abstract={The smartphone applications have taken place of the web browser and became the user's primary internet entrance. One application's popularity can be measured by its downloading times, and it is valuable for commercial advertising. Identifying app installation packages from network traffic is one of the most feasible approaches to collect these data. But asymmetric routing, incomplete capture and so on make it challenging to determine app's name at large scale in network traffic. With these constraints, we proposed AppTwins, an efficient, robust and automatical approach which has the ability to determine corrupted package's name. The identification consists of three distinct steps. Step 1, identify app packages with a stream fuzzy hash fingerprint database in live network traffic. Step 2, the unprecedented ones were captured and decompiled to acquire new app's name, a fingerprint was also calculated. Step3, update the database with new app's name and fingerprint. AppTwins achieves up a recall rate of 97.63% and a precision rate of 96.44% when app packages are almost complete. Furthermore, It can also identify incomplete app packages in the real traffic where there are no name or URL.},
  keywords={Fingerprint recognition;Telecommunication traffic;Databases;Routing;Algorithm design and analysis;Uniform resource locators;Context;app package;identify method;network traffic;incomplete capture;high concurrency},
  doi={10.1109/IACS.2017.7921975},
  ISSN={},
  month={April},}@INPROCEEDINGS{10590654,
  author={Guo, Yaqiong and Chen, Jingnan and Xu, Zichao},
  booktitle={2024 10th IEEE International Conference on Intelligent Data and Security (IDS)}, 
  title={Android Application Reinforcement Method Based on 5G Terminal Device}, 
  year={2024},
  volume={},
  number={},
  pages={53-58},
  abstract={This paper presents a novel Android application reinforcement method designed for 5G smartphones, addressing the security vulnerabilities inherent in Android's open-source na-ture. The method involves extracting key functions from Android applications, decompiling them into Smali code, and then trans-forming them into C++ code. This code is virtualized at compile time and repackaged into a new APK file, offering a more efficient reinforcement approach compared to traditional methods. It uses less computational power and storage while meeting the high safety standards of 5G technology. This approach is particularly effective against automated, low-threshold reverse engineering tools, which have challenged previous hardening methods. In our experiments, we analyzed six common Android shell tools on enhanced applications, demonstrating the ineffectiveness of these tools against our method. Our reinforcement overcomes the easy recovery issue of traditional methods and shows strong resistance to general reverse-engineering tools. We evaluated the performance pre- and post-hardening in terms of CPU utilization, size, and runtime memory usage. For instance, CPU utilization post-hardening increased by 0.9% for Gaud Map, 4.8% for WPS, and 1.3 % for public comments. The use of native Layer code and function localization enhances program efficiency, offsetting the performance overhead of fusion, thus maintaining overall performance stability. Our method's robustness against common reverse-engineering tools, with minimal impact on CPU usage, application size, and memory usage, confirms its practicality for deployment in the 5G ecosystem.},
  keywords={Performance evaluation;Codes;5G mobile communication;Operating systems;Resists;C++ languages;Static analysis;Android;5G Technology;Application Reinforcement;Smali Code;Decompilation;Code Virtualization},
  doi={10.1109/IDS62739.2024.00017},
  ISSN={},
  month={May},}@ARTICLE{10711263,
  author={Hartman, Corey M. and Rimal, Bhaskar P. and de Leon, Daniel Conte and Budhathoki, Nirmal},
  journal={IEEE Security & Privacy}, 
  title={Cross-Architecture Binary Function Fingerprinting}, 
  year={2025},
  volume={23},
  number={2},
  pages={71-80},
  abstract={By combining the SLEIGH decompiler in Ghidra with an machine learning-based technique we can fingerprint reused functions across processor architectures with high accuracy. This opens the door for reverse engineers and antivirus tools to more effectively identify vulnerable and malware code.},
  keywords={Codes;Object recognition;Malware;Internet of Things;Fingerprint recognition;Libraries;Systems architecture;Accuracy;Optimization;Source coding;Machine learning},
  doi={10.1109/MSEC.2024.3468153},
  ISSN={1558-4046},
  month={March},}@INPROCEEDINGS{11118682,
  author={Naliapara, Heli and Singhvi, Puru and Shukla, Pratham and Mirkar, Sulalah},
  booktitle={2025 IEEE International Conference on Emerging Technologies and Applications (MPSec ICETA)}, 
  title={MAIA - Malware Analysis and Intelligence Assistant}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={As cyber threats become more complex, the need for innovative tools in cybersecurity is paramount. MAIA (Malware Analysis and Intelligence Assistant), addresses this demand by automating malware reverse engineering to enhance threat analysis capabilities. It integrates advanced unpacking techniques, decompilation using Ghidra, and artificial intelligence analysis allowing for an indepth understanding of its structure, behaviors, and concealed functions. By enabling detailed static analysis and AI-driven insights, it assists cybersecurity teams in rapidly identifying and countering malicious tactics. Through comprehensive report generation and an interactive user interface, it equips cybersecurity professionals with actionable data to strengthen digital defenses. MAIA exemplifies the integration of AI with traditional malware analysis, aiming to bolster proactive threat mitigation and incident response efforts.},
  keywords={Codes;Automation;Prevention and mitigation;Reverse engineering;Static analysis;Manuals;User interfaces;Malware;Computer security;Artificial intelligence;Malware Analysis;Reverse Engineering;Artificial Intelligence;Incident Response;Static Code Analysis;Threat Intelligence;Automated Malware Analysis;Cyber Threat Mitigation;Cyber Defense Tools;AI-driven Cybersecurity Solutions},
  doi={10.1109/MPSecICETA64837.2025.11118682},
  ISSN={},
  month={Feb},}@INPROCEEDINGS{11028410,
  author={Izrailov, Konstantin and Kotenko, Igor and Buinevich, Mikhail},
  booktitle={2025 International Conference on Industrial Engineering, Applications and Manufacturing (ICIEAM)}, 
  title={Reengineering Modern Industrial Software to Find Vulnerabilities Based on Genetic Algorithms}, 
  year={2025},
  volume={},
  number={},
  pages={918-923},
  abstract={Modern industry is built, among other things, on software, the presence of vulnerabilities in which is a significant problem. It is more rational to search for vulnerabilities in those representations of the program (source code, algorithms, architecture, etc.) on the basis of which they were developed. However, as a rule, there is difficult-to-analyze machine code available. Obtaining higher-level representations is possible by reverse engineering, carried out in various ways, such as expert, algorithmic, intelligent, enumeration and logging. The qualitative comparison of these representations is given. The current study is devoted to a new method of reverse engineering based on the use of genetic algorithms. The course of the research and the following main scientific results are briefly described: the methodology of reverse engineering of a software system, the model of the life cycle of a program with multi-level vulnerabilities, the concept of genetic de-evolution of program representations, scientific, methodological and algorithmic instrumentation for genetic decompilation, an architectural block for conducting genetic de-evolution of representations with functionality for searching for multi-level vulnerabilities. All results are novel, as well as theoretically and practically significant.},
  keywords={Industries;Source coding;Instruments;Reverse engineering;Software algorithms;Information security;Genetics;Software systems;Manufacturing;Genetic algorithms;software;vulnerability;information security;reverse engineering;genetic algorithms},
  doi={10.1109/ICIEAM65163.2025.11028410},
  ISSN={2993-4060},
  month={May},}@INPROCEEDINGS{11264981,
  author={Hossain Mollah, Mohammad Sarwar and Bin Marhusin, Mohd Fadzli and Omar, Syaril Nizam},
  booktitle={2025 IEEE International Conference on Artificial Intelligence in Engineering and Technology (IICAIET)}, 
  title={An Enhanced Hybrid Deep Learning Architecture for Android Malware Detection Using CFG and DeepWalk Embeddings}, 
  year={2025},
  volume={},
  number={},
  pages={455-460},
  abstract={Android malware propagation poses increasing security risks to mobile ecosystems, with conventional detection techniques fighting an uphill battle against advanced evasion strategies and polymorphic variants that take advantage of static analysis limitations. Existing approaches including signature-based detection and conventional machine learning techniques have moderate performance against advanced obfuscation techniques and cannot capture complex structural relationships inherent in malicious code execution behavior. These limitations necessitate advanced techniques capable of carrying out in-depth structural analysis and dynamic pattern detection for malware detection. This paper proposes a new hybrid deep learning technique that combines Control Flow Graph (CFG) analysis with Deep Graph Convolutional Neural Networks (DeepGraphCNNs) and Temporal Convolutional Networks (TCN) to overcome current limitations. Our technique meticulously reverse-engineers APK packages, decompiles Dalvik bytecode to extract CFG representations and utilizes sophisticated graph embedding methods (DeepWalk, Node2Vec, Word2Vec) in the feature transformation process. The experiment is conducted on 2,349 samples from CICMalAnal2017 and MalwareBazar. Our DeepWalk-DeepGraphCNNs and TCN model demonstrated superior performance with 95.10% accuracy and 93.67% AUC-ROC. Our experimental results ensure the success of the technique for addressing contemporary Android security issues.},
  keywords={Deep learning;Accuracy;Ecosystems;Static analysis;Feature extraction;Malware;Mobile security;Graph neural networks;Convolutional neural networks;Flow graphs;Android security;Malware detection;Graph neural networks;CFG;Hybrid deep learning;Graph embedding;Mobile cybersecurity},
  doi={10.1109/IICAIET67254.2025.11264981},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{1386146,
  author={},
  booktitle={Source Code Analysis and Manipulation, Fourth IEEE International Workshop on}, 
  title={Fourth IEEE International Workshop on Source Code Analysis and Manipulation}, 
  year={2004},
  volume={},
  number={},
  pages={c1-},
  abstract={The following topics are dealt with: decompilation; program slicing; restructuring; aspect-oriented programming; software maintenance; and source code.},
  keywords={},
  doi={10.1109/SCAM.2004.10},
  ISSN={},
  month={Sep.},}
