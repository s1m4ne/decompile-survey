# スクリーニング基準: デコンパイル研究 v2.1（整合性修正版）

## 目的とスコープ
本スクリーニングは、**機械学習（ML/DL）を中核に用いて**「バイナリ/アセンブリ等から**高級言語のソースコード相当**を復元する、または**デコンパイル擬似コードを“ソースに近づける”**研究」を対象とする。

ここでいう「ソースコード相当」には、次を含む：
- 高級言語ソース（C/C++/Rust 等）
- **構造化された擬似コード**（制御構造・式・型などが復元/改善され、ソースに近い）
- **AST / 高レベルIR**（ソース再構成・高級化のための表現として提示されるもの）

一方、**解析のための低レベルIRへの単純なlifting（IR-only）**は対象外（後述 EX-B1）。

---

## 採択条件（すべて満たす）
### 条件IN1: ML/DL を中核に用いている
- Transformer / LLM / language model / neural network / deep learning / machine learning 等を使用
- **重要**: ルールベースや統計のみで、ML/DLが主要要素でない場合は除外（EX-?）

### 条件IN2: 「デコンパイル（復元/高級化）」が主目的である
- 研究の主目的が、以下のいずれかであること：
  - **高級言語ソースの復元**（例: C/C++/Rust 等のコード生成）
  - **デコンパイル擬似コードの修復・高級化**（例: 可読性向上、構造回復、制御構造回復、型推定、変数名復元、式の簡約 等）
- **重要**: デコンパイルが “特徴量抽出や前処理として使われるだけ” の場合は除外（EX-A*）

### 条件IN3: 入出力の範囲を満たす（入力1つ **かつ** 出力1つ）
**入力（いずれか）**
- binary（機械語バイナリ）
- assembly（逆アセンブル結果を含む）
- decompiler output（既存デコンパイラの擬似コード）

**出力（いずれか）**
- 高級言語のソースコード（C/C++/Rust等）
- 擬似コードの修復・高級化（「ソースに近づける」変換を含む）
- AST / 高レベルIR（ソース再構成・高級化が目的として明確な場合）

---

## 除外条件（いずれか該当で除外）
### EX-A: 目的が別タスク（デコンパイルは手段）
以下が主目的で、デコンパイル/復元が副次的（特徴量・前処理・説明用）なら除外：
- matching / retrieval（コード検索・類似度・clone/similarity）
- identification（関数識別・バイナリ識別・family分類・属性推定）
- SCA（Software Composition Analysis）
- summarization（要約・コメント生成・説明文生成が主）
- vulnerability detection（脆弱性検出・予測）
- patch detection（パッチ検出・差分識別）
- verification（等価性検証・正当性証明・バグ検証）

> 判定ガイド:
> - 評価指標が F1/AUC/検出率/分類精度中心 → 多くはEX-Aに該当しやすい  
> - 生成物が“コード”でも、目的が検出・識別なら除外

#### EX-A 下位コード（記録用）
- EX-A1: classification / identification が主目的
- EX-A2: retrieval / similarity / clone が主目的
- EX-A3: vulnerability / patch / verification が主目的
- EX-A4: summarization / explanation が主目的

### EX-B: 変換先が「ソース相当の復元/高級化」ではない
- **EX-B1: IR-only**（解析用の低レベルIR止まりで、ソース再構成/高級化が主目的でない）
- EX-B2: 逆アセンブル結果の整形のみ（disassemblyの可読化・コメント付け等）で復元がない
- EX-B3: 出力が特徴量/埋め込み/グラフ/ラベル等で、コード生成・擬似コード高級化がない
- EX-B4: デコンパイル対象が本スコープ外（例: 量子回路など、ソフトウェアバイナリ復元と別物）

### EX-C: 論文タイプが評価・整理中心で、新規復元手法が主でない
- ベンチマーク、データセット、チュートリアル、サーベイ、ツール紹介が中心で、
  **新規のMLベース復元手法の提案・検証が主ではない**場合は除外  
  （※ただし「新規タスク設定＋強いベースライン提供」等で復元研究として明確に寄与する場合は採択可）

#### EX-C 下位コード（記録用）
- EX-C1: survey/tutorial/benchmark/dataset/tool overview が中心
- EX-C2: 復元手法の提案はあるが **評価がほぼ無い/極めて弱い**（主張が検証されていない）

---

## 判定の注意点（運用ルール）
### 1) “decompile” という語の有無で判断しない
- タイトル/アブストラクトに "decompile" があっても、EX-A〜Cに当たれば exclude

### 2) “復元の主目的” を優先して判定する
- 同じ生成でも目的が違えば扱いが変わる：
  - 生成コードで **脆弱性検出** → exclude（EX-A3）
  - 生成コードで **擬似コード修復/ソース復元** → include（IN2）

### 3) 境界例の取り扱い（迷ったときの決め方）
- **採択寄り（include）**:
  - 変数名復元、型推定、制御構造回復などが主で、擬似コード/ソースを改善している
  - 既存デコンパイラ出力の「ソースに近い変換」をMLで行う
  - AST/高レベルIRでも「ソース再構成・高級化」が目的として明確
- **除外寄り（exclude）**:
  - バイナリの埋め込み学習が主で、最終成果が検索/識別/検出（EX-A）
  - 解析・検出パイプラインの一部としてデコンパイルを使うだけ（EX-A）
  - 低レベルIRへのliftingのみが主（EX-B1）

---

## 記録用: 判定ラベル（最終運用形）
- Decision: I(include) / E(exclude) / U(unsure)
- Reason code:
  - include: IN1IN2IN3
  - exclude: EX-A1/EX-A2/EX-A3/EX-A4/EX-B1/EX-B2/EX-B3/EX-B4/EX-C1/EX-C2
- Note: 境界例なら「何が足りない/どこが曖昧か」を1行

---

## 出力形式指定プロンプト（abs引用つき・短すぎず長すぎず）

各論文について、**Title と Abstract のみ**を根拠にスクリーニング結果を出力せよ。Markdown記法を用いてよい。**1件あたり5〜12行程度**に収め、長文の解説は避ける。判断は本ルール（IN1–IN3 / EX-A* / EX-B* / EX-C*）に従う。

### 出力テンプレ（1論文＝1ブロック）
- **[ID] Title:** （タイトル）
- **Decision:** ✅Include（IN1IN2IN3） / ❌Exclude（EX-??） / ❓Unsure（理由）
- **Reason code:** IN1IN2IN3 または EX-A1/EX-A2/EX-A3/EX-A4/EX-B1/EX-B2/EX-B3/EX-B4/EX-C1/EX-C2（または不足点）
- **Key evidence (Abstract quotes):**
  - C1(ML/DL): “…”  
  - C2(目的): “…”  
  - C3(入出力): “…”  
  - （Excludeの場合）決定打: “…”  
- **Rationale (2–4 bullets):**
  - （上の引用を指し示す形で、IN/EXに該当する理由を短く箇条書き）
- **Note (optional, 1 line):** 境界/不明点があれば「何が足りないか」「全文確認が必要か」を1行

### 引用ルール（必須）
- 引用は **Abstractからの直引用**のみ。各引用は**最長25語程度**、長い場合は…で省略可。
- ✅Includeのときは、原則として **C1/C2/C3をそれぞれ最低1つ**引用して根拠化する。
- ❌Excludeのときは、最も支配的な除外理由（EX-コード）を裏付ける **決定打の引用を1つ**入れる（必要なら補助引用を追加）。
- ❓Unsureのときは、**不足している要素（入力/出力/目的/ML中核）**がAbstractから確定できないことを引用で示し、必要なら全文確認へ回す。