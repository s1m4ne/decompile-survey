@article{Enders2022,
 abstract = {Analyzing third-party software such as malware or firmware is a crucial task for security analysts. Although various approaches for automatic analysis exist and are the subject of ongoing research, analysts often have to resort to manual static analysis to get a deep understanding of a given binary sample. Since the source code of encountered samples is rarely available, analysts regularly employ decompilers for easier and faster comprehension than analyzing a binary's disassembly. In this paper, we introduce our decompilation approach dewolf. We developed a variety of improvements over the previous academic state-of-the-art decompiler and some novel algorithms to enhance readability and comprehension, focusing on manual analysis. To evaluate our approach and to obtain a better insight into the analysts' needs, we conducted three user surveys. The results indicate that dewolf is suitable for malware comprehension and that its output quality noticeably exceeds Ghidra and Hex-Rays in certain aspects. Furthermore, our results imply that decompilers aiming at manual analysis should be highly configurable to respect individual user preferences. Additionally, future decompilers should not necessarily follow the unwritten rule to stick to the code-structure dictated by the assembly in order to produce readable output. In fact, the few cases where dewolf already cracks this rule lead to its results considerably exceeding other decompilers. We publish a prototype implementation of dewolf and all survey results on GitHub. },
 author = {Enders, Steffen AND Behner, C., Eva-Maria AND Bergmann, Niklas AND Rybalka, Mariia AND Padilla, Elmar AND Hui, Xue, Er AND Low, Henry AND Sim, Nicholas},
 doi = {https://doi.org/10.48550/arXiv.2205.06719},
 howpublished = {\url{https://arxiv.org/pdf/2205.06719}},
 month = {may},
 note = {},
 title = {dewolf: Improving Decompilation by leveraging User Surveys},
 year = {2022}
}

@article{Udeshi2024,
 abstract = {Cybersecurity attacks on embedded devices for industrial control systems and cyber-physical systems may cause catastrophic physical damage as well as economic loss. This could be achieved by infecting device binaries with malware that modifies the physical characteristics of the system operation. Mitigating such attacks benefits from reverse engineering tools that recover sufficient semantic knowledge in terms of mathematical equations of the implemented algorithm. Conventional reverse engineering tools can decompile binaries to low-level code, but offer little semantic insight. This paper proposes the REMaQE automated framework for reverse engineering of math equations from binary executables. Improving over state-of-the-art, REMaQE handles equation parameters accessed via registers, the stack, global memory, or pointers, and can reverse engineer object-oriented implementations such as C++ classes. Using REMaQE, we discovered a bug in the Linux kernel thermal monitoring tool "tmon". To evaluate REMaQE, we generate a dataset of 25,096 binaries with math equations implemented in C and Simulink. REMaQE successfully recovers a semantically matching equation for all 25,096 binaries. REMaQE executes in 0.48 seconds on average and in up to 2 seconds for complex equations. Real-time execution enables integration in an interactive math-oriented reverse engineering workflow. },
 author = {Udeshi, Meet AND Krishnamurthy, Prashanth AND Pearce, Hammond AND Karri, Ramesh AND Khorrami, Farshad},
 doi = {https://doi.org/10.48550/arXiv.2305.06902},
 howpublished = {\url{https://arxiv.org/pdf/2305.06902}},
 month = {apr},
 note = {},
 title = {REMaQE: Reverse Engineering Math Equations from Executables},
 year = {2024}
}
