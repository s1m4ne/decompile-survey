了解。いま固まってきた「統合（歴史＋LLM/ML）版」の計画を、決定事項ベースでまとめます。

---

## 目的と基本方針

* **コーパスは1つ（Corpus-All）**：歴史もLLM/MLも同じ母集団から採択する
* **深掘り基準は年ではなく method_tag（ML/Neural/LLM）**：
  2017境界で“選定”しない（必要なら分析用の年代区分として使うだけ）

---

## 検索戦略（Identification）

### クエリは2ファミリーで固定（歴史/LLMで分けない）

* **Family A（Core-Decomp）**：`decompil*`（＋decompiler等）
  → “decompilationと明記する”文献を広く回収
* **Family B（Recall-Boost）**：`reverse compilation / source recovery / program reconstruction / structuring / type recovery / identifier recovery …`（＋binary/asm/bytecode等で文脈固定）
  → `decompil*`と書かない古典・周辺・要素技術を拾う
  ※Bは**ML語を必須にしない**（歴史も拾うため）

### 期間運用

* 既存の **2017–2026の結果は活用**
* 不足する **pre-2017を同じA/Bで追加実行**（DB制約で期間分割してOK）
* 追加ソースとして

  * **Snowballing（前方/後方）**
  * **古い会場の手動サーチ（必要なら）**
    をIdentificationの内訳として記録

---

## スクリーニングとPRISMA（1本化）

* **PRISMAは1つ**（Identification→Dedup→T/A→Full-text→Included）
* **IC/ECは全期間で同一**（歴史/LLMで別基準にしない）
* v8ルール等で T/A 判定 → 本文判定へ

---

## 網羅性担保（査読の盾：2本立て）

### (A) 統合QGS

* **歴史＋評価/ベンチ＋ML/LLMを混ぜたQGS（30–50本）**を作る
* 目標：**DB検索＋snowballing合成でQGS回収率95%程度**
* 未回収は理由コードでログ化 → **Family B語彙/運用を調整**

### (B) 統合Snowballing＋飽和条件

* **seed = QGS + 採択論文の代表（古典/評価/ML混在）**
* 前方/後方を反復し、**飽和条件**（例：2周連続で新規採択がほぼ増えない）で停止
* 各周回で「候補→dedup→採択」の数をログ化
* **本番snowballは“採択確定後（Included）から”**回す
  （QGS調整用の軽いpre-snowballは区別してログ）

---

## 採択後の扱い（同じデータで二つの見方）

### 共通タグ（全論文）

* Era（年代）、Component（工程）、Output（L1–L4）、Eval（評価タイプ）、Artifact等

### 深掘り対象（Corpus-ML = method_tagで抽出）

* `method_tag ∈ {ML, neural, LLM}` の論文だけ
  → モデル/データ/学習/プロンプト/比較/再現性まで詳細抽出
* 非MLは基本、歴史・評価史・ベースラインとして扱い、深掘りはしない（例外は評価/ベンチ更新など）

※PRISMAに別フローを作らず、**Included: N / ML-subset: n** を図注かLLM章冒頭に明記＋method_tagルールをMethodに1段落。

---

## 歴史パートの書き方（“研究史”として守る）

* **採択は論文（＋博士論文）中心**で統一
* 本文では **Era×Componentで層化して節目だけ紹介**（ルール化）
* ツール史などを言いたい場合は、コーパスに混ぜず **timeline_ledger（公式裏取り）**を付録扱い

---

この計画だと、「歴史もLLM/MLも同じコーパス・同じ選定基準で網羅性を担保」しつつ、「深掘りはmethod_tagで自然に分かれる」形になります。必要なら次は、**QGSの枠（Era×Component×Methodの表）**と、**Family B（Recall-Boost）の統合語彙セット**を具体化すると一気に実装に落ちます。
