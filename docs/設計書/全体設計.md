了解。さっきの「1/3（全体方針）」を、**検索〜絞り込み〜管理〜執筆**の“ステップ順”で読みやすく書き直します（内容は同じで、構造だけ整理します）。
※まだ **2/3, 3/3** は出しません（あなたの指定通り、今回は1つ目だけ）。

---

# 1/3 全体方針：統合コーパスで「歴史」と「LLM」を扱う（手順ベース）

## ステップ0：基本方針（この文書で確定している前提）

* **統合コーパス（1コーパス）で進める**
  歴史・非ML古典・ML/LLM研究を、同じ母集団として集めて管理する。
* **LLMは網羅性重視**（可能な限り全件を拾う）
* **歴史は収集は同じ粒度で拾うが、記述は代表選定でまとめる**（全件を細かく解説しない）
* **統合コーパスのスクリーニングは「LLM必須」にしない**（非LLM古典も拾えるようにする）
* スクリーニング基準は **スコープベースのIC/EC**（ステップ3.2で確定済み。パイプライン非依存）

---

## ステップ1：検索（収集の入口）

### 1.1 方針（確定）

* **引用追跡（前方・後方）を必須**にする
  DB検索だけで落ちやすい古典・分野横断（PL/SE/SEC）を補う。
* **ミニQGSを必須**にする
  用語揺れ・DB偏りを補正するため、最初に少数の代表（seed/QGS）を持つ。

### 1.2 使用DBセット（確定）

* **主要DB（4つ）**：ACM Digital Library / IEEE Xplore / Web of Science / arXiv
* **補助DB（2つ）**：NDSS / USENIX（個別に検索する。まだ未実施だが方針として決定）

### 1.3 検索クエリ（確定）

2系統のクエリで title / abstract を検索する。**期間制限は設けない（全年代対象）**。歴史の古典から最新のLLM研究まで、統合コーパスとして同一の検索で収集する。

#### Q1: メインクエリ（decompil* 直接同義語）

```
decompil* OR "reverse compilation" OR "reverse compiler"
```

* `decompil*` で decompilation, decompiler, decompiling 等をカバー
* `"reverse compilation"` は古典（Cifuentes 博士論文タイトル等）で使われる直接同義語
* `"reverse compiler"` も同様
* これらはバイナリ文脈以外ではほぼ使われないため、AND 条件なしで精度が保てる

#### Q2: 補完クエリ（decompil* を使わない表現 × バイナリ文脈）

```
(
  "source code recovery" OR "source recovery"
  OR "binary-to-source" OR "binary to source"
  OR "binary lifting" OR "instruction lifting"
  OR "lifting to IR" OR "lifting to LLVM"
  OR "assembly-to-C" OR "assembly to C"
  OR "program reconstruction"
)
AND
(
  "binary code" OR "machine code" OR "assembly code"
  OR executable OR disassembly OR disassembler
  OR bytecode OR "binary analysis" OR "stripped binary"
)
```

* 第1項: デコンパイルと同じことを指すが `decompil*` を使わない表現群
* 第2項: バイナリ文脈に限定するための AND
* ML/LLM 層は設けない（手法種別による制限なし、スクリーニング基準と整合）

#### Q1 と Q2 の関係

| | Q1 | Q2 |
|---|---|---|
| 役割 | `decompil*` を明示的に使う論文 | `decompil*` を使わずにデコンパイルをしている論文 |
| AND条件 | なし（語自体が十分にspecific） | あり（復元表現 × バイナリ文脈） |
| 期待ヒット | 主力（500件台） | 補完（数十〜100件台） |

* Q1 ∩ Q2 の重複はステップ2の重複排除で吸収
* QGS の seed 論文で Q1 にも Q2 にも引っかからない論文が見つかった場合、語彙を追加する

### 1.4 未決（検索実施時に決める）

* QGS の seed 論文選定と検証結果（Q1/Q2 のカバー率）
* 検索の停止条件、ログ粒度
* 補助 DB（NDSS / USENIX）の具体的な検索手順
* ※既存の検索ログ（screening/imports/）は LLM パート単体を想定した試行であり、参照用として保持

---

## ステップ2：統合（重複排除・コーパス化）

### 2.1 方針（確定）

* 複数ソースから集めた結果を **1つの統合コーパスに集約**して管理する。
* 同一論文が「歴史の節目」かつ「LLM対象」になり得るため、統合後は **複数ラベル（タグ）で管理する**（二重カウントではなく“同一レコードの複数タグ”）。

### 2.2 重複排除ルール（確定）

* **3段階で実施する**：
  1. **DOI照合**：DOIが一致するレコードを統合（最優先）
  2. **タイトル正規化照合**：DOIがない／異なる場合、タイトルを正規化して一致判定
  3. **著者名照合**：上記で漏れた重複を著者名ベースで確認・捕捉

### 2.3 タグ体系（確定）

* パイプライン基準で3軸の分類タグを定義（ステップ3.3参照）:
  * パイプライン段タグ（P1〜P9, P0-e2e）← 歴史パートの「箱」と直結
  * 手法タグ（M-rule〜M-na）← LLMパートの抽出に使用
  * 貢献種別タグ（C-method〜C-survey）
* 同一論文に複数タグ付与可能（二重カウントではなく複数ラベル管理）

---

## ステップ3：スクリーニング（含む/除外の判断）

### 3.1 方針（確定）

* 統合コーパスのスクリーニングは **「LLM必須」にしない**
  → 非LLMの古典も拾えることを優先。
* スクリーニング基準は **スコープベースのIC/ECを採用**（ステップ3.2参照）
  → v2までのML/DL必須条件を撤廃し、デコンパイルのスコープに基づいて判定する。
  → パイプライン（P1–P9）はスクリーニング後の分類タグとしてのみ使用。

### 3.2 スクリーニング基準

#### スコープ

本サーベイはデコンパイルを対象とする。すなわち、コンパイル済みソフトウェアバイナリから高水準のソースコード表現を再構成する研究、およびその再構成を構成する要素技術とデコンパイラ出力の評価を含む。

> **設計意図**: スクリーニング基準はパイプライン（P1–P9）に依存しない。パイプラインはスクリーニング後の分類タグとして使用するが、採否判定そのものには用いない。これにより、自ら定義した分類枠組みが検索・スクリーニングの結果を規定する循環（self-fulfilling taxonomy）を回避する。

#### 採択条件（Inclusion Criteria — すべて満たす）

| | 条件 |
|---|---|
| **IC1** | デコンパイルまたはその構成要素技術（逆アセンブル、IR変換、制御構造回復、型回復、シンボル回復等）を、ソフトウェアバイナリを対象として扱っている。 |
| **IC2** | 手法の提案、評価枠組みの提案、ツール・基盤の設計、実証的調査、または体系的な分類・整理のいずれかで技術的貢献を行っている。 |
| **IC3** | 全文がアクセス可能であり、英語で記述されている。 |

> **IC1の補足**: 「構成要素技術」の列挙は例示であり限定列挙ではない。デコンパイルの過程で失われた情報（制御構造、型、シンボル等）の回復に寄与する技術であれば該当する。「ソフトウェアバイナリを対象として」は、入力がネイティブバイナリ（ELF, PE, Mach-O等）またはバイトコード（JVM, .NET等）であることを意味し、ソースコードやハードウェア記述のみを対象とする研究を除外する。
>
> **IC2の補足**: 技術的貢献の種別は、スクリーニング後の分類タグ（C-method / C-eval / C-infra / C-empirical / C-survey）に対応する。IC2は「貢献がある」ことを求めるのみで、貢献の種別によって採否を分けない。

#### 除外条件（Exclusion Criteria — いずれか該当で除外）

| | 条件 | 典型例 |
|---|---|---|
| **EC1** | デコンパイラ出力を下流タスクの入力として利用するのみで、デコンパイル自体の改善には貢献しない。 | デコンパイル結果を用いた脆弱性検出、マルウェア分類、バイナリコード類似度検索。 |
| **EC2** | ソフトウェアバイナリのデコンパイルとは本質的に異なる対象を扱っている。 | 量子回路の逆変換、ハードウェア記述言語の合成逆変換、3Dモデルの分解、「decompilation」の比喩的用法。 |
| **EC3** | 技術的内容が不十分である。 | ポスター、1–2頁のデモ論文、エディトリアル。ただし博士論文・テクニカルレポートは内容が十分であれば採択する。 |
| **EC4** | 同一研究のより完全なバージョンが存在する。 | 会議版と論文誌版がある場合、最も完全なもののみ採択。 |

> **EC1の境界判定**: 論文がデコンパイラ出力を利用しつつ、デコンパイル精度の向上にもフィードバックしている場合（例：脆弱性検出の過程で型推論を改善する手法を提案）はIC1–IC2を満たし採択対象となる。判断基準は「デコンパイル自体の改善に技術的貢献があるか」。
>
> **EC2の境界判定**: バイトコード（JVM, .NET, Dalvik等）のデコンパイルはIC1を満たす。WebAssemblyのデコンパイルも同様。一方、ソースコード間の変換（トランスパイル）はデコンパイルではなくEC2に該当する。

#### 補足

- コンパイラ理論（SSA構築等）のようにバイナリを対象としない文献はIC1を満たさずコーパス外とするが、サーベイ本文中で背景として引用することは可能。
- 手法の種類（ルールベース、形式的、統計的、ニューラル、LLM、ハイブリッド）による制限はない。手法種別はスクリーニング後の分類タグとして記録する。

### 3.3 分類タグ（採択後に付与、3軸）

* **軸1: パイプライン段**（P1-decode〜P9-eval, P0-e2e）
* **軸2: 手法**（M-rule / M-formal / M-stat / M-neural / M-llm / M-hybrid / M-na）
* **軸3: 貢献種別**（C-method / C-eval / C-infra / C-empirical / C-survey）

### 3.4 旧未決事項の解決状況

* ~~v8をどう一般化するか~~ → スコープベースのIC/ECに転換し解決
* ~~統合スコープの境界（disassembly/liftingのみ等）~~ → IC1の「構成要素技術」として採択対象に含めることで解決
* ~~パイプライン依存の循環問題~~ → スクリーニング基準からパイプラインを分離し、分類タグとしてのみ使用することで解決

---

## ステップ4：まとめ方（歴史とLLMでの扱い分け）

### 4.1 LLMパートの扱い（確定）

* **LLM関連は原則すべて扱う**（網羅性重視で分類・整理する）

### 4.2 歴史パートの扱い（確定）

* 収集段階では統合コーパスの一部として **同じ粒度で拾う**
* 記述段階では **代表（節目）を選んで説明**する（全件を個別解説しない）

### 4.3 未決

* 「代表」の決め方（選定基準・採択数）
* ~~歴史の分類軸（例：8コンポーネント）をどこまで本文で使うか~~ → パイプライン9段をそのまま分類軸・歴史パートの「箱」として使用する方針で確定

---

## ステップ5：検討事項として保持（いまは決めない）

* **史実台帳（Tier運用）を採用するか**
  （ツール史・公開年など“史実”の根拠管理方法。現時点では検討事項。）

---

次は **2/3：歴史パートの詳細方針（同じくステップ順）** を出します。
