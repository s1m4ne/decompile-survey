@INPROCEEDINGS{10545392,
  author={Ayub, Adeen and Jo, Wooyeon and Ahmed, Irfan},
  booktitle={2024 IEEE International Symposium on Hardware Oriented Security and Trust (HOST)}, 
  title={Charlie, Charlie, Charlie on Industrial Control Systems: PLC Control Logic Attacks by Design, Not by Chance}, 
  year={2024},
  volume={},
  number={},
  pages={182-193},
  abstract={Programmable logic controllers (PLCs) in industrial control systems (ICS) run a control logic program to monitor and control critical infrastructures in real-time, such as nuclear plants and power grids. Attackers target PLC control logic remotely to sabotage or disrupt physical processes. Network intrusion detection systems (IDS) are increasingly used to detect malicious control logic. This paper demonstrates that standard IDS features in a protocol message header and payload are not resilient for detecting (control logic) binary programs, such as entropy, n-gram, and decompilation. It identifies and utilizes a PLC design feature, redundant address pins (RAP), unexplored in the literature, to bypass IDS for injecting a small piece of programmable malicious code (PMC) into a PLC's control logic as an initial attack vector, allowing it to execute with every scan cycle. We propose three unique attack methods (GizmoSplit, BuffWarp, and EnigmaFlow) using PMC as a proof of concept that blends control logic with network traffic via payload encoding, small-size payloads, or sparse memory addressing. The GizmoSplit attack divides the control logic into small gadgets and writes them in random memory locations in a PLC; PMC modifies the stack with the location of the gadgets to execute them as return-oriented programming. The BuffWarp attack employs a small-size buffer where the attacker writes malicious code periodically to bypass stateful inspection at the payload level; PMC, in turn, keeps moving the buffer content to consecutive memory locations to execute. The EnigmaFlow attack encodes control logic and sends it to a PLC's typically unused memory region, which PMC decodes and executes. The evaluation results indicate that these attacks are stealthy and can subvert IDS utilizing standard message header and payload features. This work points to a research gap in intrusion detection that caters to control logic attacks exploiting PLC design features.},
  keywords={Codes;Process control;Telecommunication traffic;Feature extraction;Control systems;Malware;Encoding;industrial control systems;programmable logic controllers;ICS attacks;control logic;intrusion detection systems},
  doi={10.1109/HOST55342.2024.10545392},
  ISSN={2765-8406},
  month={May},}@INPROCEEDINGS{11052915,
  author={MK, Nagarajan and Dinesh, Rayavarapu Lakshmi Narasimha and S, Ratna Selvan and Nagamaiah, Mothadaka and Anjaneyulu, Kolakani Venkata Prasanna},
  booktitle={2025 International Conference on Computational Robotics, Testing and Engineering Evaluation (ICCRTEE)}, 
  title={Comprehensive Research on Mobile Application Security Assessment}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={The increasing use of mobile apps has raised generalized concerns regarding security threats, like malware and leakage of data. Most malicious applications masquerade as normal apps to steal private information from users. Conventional security approaches, both static analysis and dynamic analysis, have natural limitations when utilized individually. For the purpose of enhancing mobile security, this work suggests a Comprehensive Mobile Application Security Analysis Framework which combines static analysis, dynamic analysis, malware analysis, and reverse engineering techniques in the interest of identifying security defects in Android applications.The framework employs MoBSF for static analysis, Frida for dynamic instrumentation, VirusTotal for malware detection, and Apktool and Quark for reverse engineering. Apktool enables low-level decompilation of smali code, while Quark focuses on malware behavior detection through API call analysis. All these tools facilitate a comprehensive analysis of APK vulnerabilities, runtime threats, and malicious payloads.In this research paper, we explore various methodologies to analyze and improve mobile application security accuracy through static analysis, dynamic analysis, malware detection, and reverse engineering.This study shows how an integrated approach combining all four techniques improves detection accuracy, reducing false positives and uncovering hidden security threats. Results show that the hybrid approach effectively detects both known and unknown malware, making it an efficient approach for mobile application security assessments. Future enhance automation; explore machine learning enhancements for improved zero-day threat detection.},
  keywords={Runtime;Accuracy;Computer viruses;Reverse engineering;Static analysis;Malware;Threat assessment;Mobile security;Mobile applications;Security;Mobile Security;Static analysis;Dynamic Analysis;Reverse Engineering;Malware Detection;Android security;APK security},
  doi={10.1109/ICCRTEE64519.2025.11052915},
  ISSN={},
  month={May},}@INPROCEEDINGS{10410676,
  author={Bosse, Stefan and Polle, Christoph},
  booktitle={2023 10th International Conference on Future Internet of Things and Cloud (FiCloud)}, 
  title={Tiny Machine Learning Virtualization for IoT and Edge Computing using the REXA VM}, 
  year={2023},
  volume={},
  number={},
  pages={122-129},
  abstract={Tiny Machine Learning is a new approach that is being used for data-driven prediction classification and regression on microcontrollers using local sensor data. The models are typically learned off-line and sent to the microcontroller for use as binary objects or frozen and converted static data. This approach is not universal or flexible. The REXA VM, which can virtualize embedded systems and sensor nodes and includes a general machine learning framework that supports arbitrary dynamic artificial neural network and decision tree models, is introduced in this study. The models are delivered as text files with highly compressed program code that are enclosed in code frames with embedded data (model parameters). The VM offers fundamental computations for ANN and DT models (Microservices). Using a decompiler, models can be updated (retrained) and sent to other nodes (mobile models). It can be demonstrated that virtualization using a bytecode machine and just-in-time compiler is still appropriate and effective for extremely low-resource processors.},
  keywords={Codes;Microcontrollers;Computational modeling;Artificial neural networks;Data models;Internet of Things;Virtualization;Virtualization;Virtual Machines;Tiny ML;Sensor Networks;Embedded Systems;Microservices},
  doi={10.1109/FiCloud58648.2023.00026},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{10491696,
  author={Xia, Bing and Tang, Chongjun and Liu, Wenbo and Chu, Shihao and Dong, Yu},
  booktitle={2023 IEEE Intl Conf on Parallel & Distributed Processing with Applications, Big Data & Cloud Computing, Sustainable Computing & Communications, Social Computing & Networking (ISPA/BDCloud/SocialCom/SustainCom)}, 
  title={A Firmware Vulnerability Detection Method Based on Feature Filtering}, 
  year={2023},
  volume={},
  number={},
  pages={1069-1076},
  abstract={Open source code reuse and code cross-platform deployment accelerate the spread of software vulnerabilities, and pose challenges for accurate detection of cross-platform vulnerabilities. The binary vulnerability similarity detection method based on machine learning lacks a fine-grained vulnerability similarity feature filtering mechanism, and cannot solve cross-function vulnerabilities triggered by data dependencies, resulting in a high vulnerability false positive rate in existing solutions, which limits practical applications. Software code vulnerabilities are usually caused by function key statements. Therefore, based on binary function decompilation, we identify the key statement that causes the vulnerability, analyze the cross-function data dependency of the key statements, extract the code similarity features and code vulnerability features of the key statements, and propose a feature filtering-based Binary vulnerability detection method SimFilter. SimFilter calculates the similarity of key statements by comparing the characteristics of function key statements, and infers the similarity of binary function vulnerabilities based on the similarity of key statements. The experimental results show that the vulnerability semantic features extracted by SimFilter are highly interpretable, and the accuracy rate is increased by 10.8% compared with other models. At the same time, we analyzed and evaluated the impact of different similarity features on the accuracy of SimFilter, and gave the best empirical value of the SimFilter model in firmware vulnerability detection.},
  keywords={Analytical models;Codes;Filtering;Source coding;Semantics;Machine learning;Feature extraction;Open Source Software;Vulnerability Detection;Binary Similarity;Internet Of Things;Data Dependency},
  doi={10.1109/ISPA-BDCloud-SocialCom-SustainCom59178.2023.00172},
  ISSN={},
  month={Dec},}@INPROCEEDINGS{10500201,
  author={Adams, Shawn C. and Zheng, Yuliang},
  booktitle={SoutheastCon 2024}, 
  title={A Blockchain Smart Contract Framework Using Interpreted Programming Languages and Decentralized Storage}, 
  year={2024},
  volume={},
  number={},
  pages={222-230},
  abstract={We present a model for an alternative to Ethereum Virtual Machine (EVM) smart contract blockchain networks which relies on an interpreted programming language and a distributed file system. Specifically we present the model by integrating the Interplanetary File System (IPFS) for decentralized files storage and Python as the interpreted programming language. IPFS ensures that contract code does not change by using content/hash-based addressing. The address of the file can be passed between nodes to recreate the files locally as long as nodes are running an IPFS node as well. In this implementation, we design the model to work with an existing prototype blockchain which was built with IPFS integration. The use of Python to write the code helps ensure transparency as the code does not need to be compiled and thus would not need to be run through a decompiler to make deployed code human-readable. We describe how the data is extracted and validated from a transaction before the code is executed locally and it's respective state updated and stored on the blockchain.},
  keywords={Codes;File systems;Smart contracts;Prototypes;Virtual machining;Blockchains;InterPlanetary File System;blockchain;smart contracts;python;IPFS},
  doi={10.1109/SoutheastCon52093.2024.10500201},
  ISSN={1558-058X},
  month={March},}@INPROCEEDINGS{10188657,
  author={Borrello, Pietro and Easdon, Catherine and Schwarzl, Martin and Czerny, Roland and Schwarz, Michael},
  booktitle={2023 IEEE Security and Privacy Workshops (SPW)}, 
  title={CustomProcessingUnit: Reverse Engineering and Customization of Intel Microcode}, 
  year={2023},
  volume={},
  number={},
  pages={285-297},
  abstract={Microcode provides an abstraction layer over the instruction set to decompose complex instructions into simpler micro-operations that can be more easily implemented in hardware. It is an essential optimization to simplify the design of x86 processors. However, introducing an additional layer of software beneath the instruction set poses security and reliability concerns. The microcode details are confidential to the manufacturers, preventing independent auditing or customization of the microcode. Moreover, microcode patches are signed and encrypted to prevent unauthorized patching and reverse engineering. However, recent research has recovered decrypted microcode and reverse-engineered read/write debug mechanisms on Intel Goldmont (Atom), making analysis and customization of microcode possible on a modern Intel microarchitecture. In this work, we present the first framework for static and dynamic analysis of Intel microcode. Building upon prior research, we reverse-engineer Goldmont microcode semantics and reconstruct the patching primitives for microcode customization. For static analysis, we implement a Ghidra processor module for decompilation and analysis of decrypted microcode. For dynamic analysis, we create a UEFI application that can trace and patch microcode to provide complete microcode control on Goldmont systems. Leveraging our framework, we reverse-engineer the confidential Intel microcode update algorithm and perform the first security analysis of its design and implementation. In three further case studies, we illustrate the potential security and performance benefits of microcode customization. We provide the first x86 Pointer Authentication Code (PAC) microcode implementation and its security evaluation, design and implement fast software breakpoints that are more than 1000x faster than standard breakpoints, and present constant-time microcode division, illustrating the potential security and performance benefits of microcode customization.},
  keywords={Microarchitecture;Instruction sets;Reverse engineering;Software algorithms;Static analysis;Software;Hardware},
  doi={10.1109/SPW59333.2023.00031},
  ISSN={2770-8411},
  month={May},}@INPROCEEDINGS{10589897,
  author={Lin, Wei and Guo, Qingli and Yu, DongSong and Yin, Jiawei and Gong, Qi and Gong, Xiaorui},
  booktitle={2024 IEEE International Conference on Software Analysis, Evolution and Reengineering (SANER)}, 
  title={ReIFunc: Identifying Recurring Inline Functions in Binary Code}, 
  year={2024},
  volume={},
  number={},
  pages={670-680},
  abstract={Function inlining, although a common phenomenon, can greatly hinder the readability of the binary code obtained through decompilation. Identifying inline functions in the binary code is additionally challenging as there is no clear boundary between an inlined function and its caller function, the instructions of the same function might differ during inline expansion, and existing graph-schema methods for inline function identification cannot handle the vast number of functions involved due to their complexity. To address the challenge, in this paper, we propose an effective inline function identification solution named ReIFunc, which combines subgraph isomorphism and deep learning to identify these recurring inline functions (RIFs). Our evaluation shows that ReIFunc can effectively match functions within a broad candidate set with a high precision rate exceeding 99% while maintaining an acceptable recall, thus getting rid of the constraints imposed by the limited size of the candidate set.},
  keywords={Deep learning;Analytical models;Buildings;Binary codes;Software;Optimization;binary analysis;inline function identification;subgraph isomorphism;representation learning model},
  doi={10.1109/SANER60148.2024.00074},
  ISSN={2640-7574},
  month={March},}@INPROCEEDINGS{11166547,
  author={Seixas, Vinicius and Elish, Karim},
  booktitle={2025 International Conference on Artificial Intelligence, Computer, Data Sciences and Applications (ACDSA)}, 
  title={High-Accuracy Android Ransomware Detection Using SMALI Code-Based Analysis}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={Ransomware targeting the Android platform continues to pose a serious threat to users and organizations, with increasing sophistication and widespread impact. This paper introduces a high-accuracy detection framework that leverages static analysis of SMALI code—a low-level representation generated during APK decompilation—to identify Android ransomware. Unlike approaches that rely on Java-level reconstruction or dynamic behavior, our method extracts meaningful features such as permission usage, API calls, cryptographic operations, and component structure directly from SMALI and manifest files. The framework constructs a structured dataset from these features and applies various machine learning classifiers to distinguish ransomware from benign applications. Experiments conducted on two publicly available datasets, including AMD and CI-CAndMal2017, demonstrate the framework’s effectiveness. The Random Forest classifier achieved a peak accuracy of 98.89%, with the ensemble and model also performing competitively. The results highlight the promise of SMALI-based static analysis for efficient, scalable, and interpretable ransomware detection.},
  keywords={Accuracy;Operating systems;Computational modeling;Static analysis;Organizations;Feature extraction;Ransomware;Cryptography;Random forests;Android;ransomware;static analysis;machine learning},
  doi={10.1109/ACDSA65407.2025.11166547},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{11086752,
  author={Luo, Rui and Ge, Hui and Jin, Xiao and Qin, Zhendong and Liu, Lihua},
  booktitle={2025 10th International Conference on Intelligent Computing and Signal Processing (ICSP)}, 
  title={Binary Code Similarity Detection by Fusing Graph Attention Network and Abstract Syntax Tree}, 
  year={2025},
  volume={},
  number={},
  pages={1247-1253},
  abstract={Since the introduction of deep learning-based binary code similarity detection methods, there has been a proliferation of methods using graph neural networks to learn semantic information from intermediate representations such as control flow graphs. Graph Attention Network (GAT) is a graph neural network model based on the attention mechanism, the core idea of which is to dynamically aggregate information from adjacent nodes by adaptively learning the importance weights between nodes in the graph, which can enhance the training effect of the model by incorporating the attention mechanism. The structured representation advantage of Abstract Syntax Trees (AST) is reflected in the hierarchical decomposition of program syntax structures, which effectively captures the logical semantics and contextual dependencies of the code, a feature that makes AST robust against the obfuscation of cross-architecture binary code. However, there has not yet been an approach that fuses graph attention networks and abstract syntax trees in the field of binary code similarity detection, so we propose a cross-architecture binary code similarity detection approach that fuses abstract syntax trees and graph attention networks. We use the open-source dataset provided by Asteria, decompile the binary code using the binary analysis tool IDA pro to extract the abstract syntax tree as the feature source of the neural network, and deeply optimize GAT for the limitations of processing tree data structure to improve its ability to learn the semantic information of AST. We trained TreeLSTM, plain GAT, and deeply optimized GAT neural network models respectively, and compared them. The experimental results show that the training speed of our proposed method is improved by 54.63% compared to the TreeLSTM-based method, and the AUC and Accuracy metrics are basically comparable.},
  keywords={Training;Tree data structures;Attention mechanisms;Fuses;Semantics;Binary codes;Syntactics;Feature extraction;Graph neural networks;Data mining;binary code similarity;graph attention network;abstract syntax tree},
  doi={10.1109/ICSP65755.2025.11086752},
  ISSN={},
  month={May},}@INPROCEEDINGS{11029887,
  author={Verbeek, Freek and Shokri, Ali and Engel, Daniel and Ravindran, Binoy},
  booktitle={2025 IEEE/ACM 47th International Conference on Software Engineering (ICSE)}, 
  title={Formally Verified Binary-Level Pointer Analysis}, 
  year={2025},
  volume={},
  number={},
  pages={42-53},
  abstract={Binary-level pointer analysis can be of use in symbolic execution, testing, verification, and decompilation of software binaries. In various such contexts, it is crucial that the result is trustworthy, i.e., it can be formally established that the pointer designations are overapproximative. This paper presents an approach to formally proven correct binary-level pointer analysis. A salient property of our approach is that it first generically considers what proof obligations a generic abstract domain for pointer analysis must satisfy. This allows easy instantiation of different domains, varying in precision, while preserving the correctness of the analysis. In the trade-off between scalability and precision, such customization allows “meaningful” precision (sufficiently precise to ensure basic sanity properties, such as that relevant parts of the stack frame are not overwritten during function execution) while also allowing coarse analysis when pointer computations have become too obfuscated during compilation for sound and accurate bounds analysis. We experiment with three different abstract domains with high, medium, and low precision. Evaluation shows that our approach is able to derive designations for memory writes soundly in COTS binaries, in a context-sensitive interprocedural fashion.},
  keywords={Accuracy;Scalability;Software;Testing;Software engineering;binary analysis;pointer analysis;formal methods},
  doi={10.1109/ICSE55347.2025.00231},
  ISSN={1558-1225},
  month={April},}@ARTICLE{11098869,
  author={Ghimire, Ashutosh and Lingala, Sahasra Rao and Zhang, Junjie and Alsulami, Faris and Amsaad, Fathi},
  journal={IEEE Access}, 
  title={A Survey on Application of AI on Reverse Engineering for Software Analysis and Security}, 
  year={2025},
  volume={13},
  number={},
  pages={152903-152913},
  abstract={Reverse engineering process serves essential functions in software analysis and security auditing and malware detection but requires significant time and effort. Researchers and practitioners now investigate how Artificial Intelligence (AI) technology can automate and improve different reverse engineering procedures. This survey provides an extensive evaluation of recent AI-based reverse engineering techniques which focus on software decompilation and function identification as well as control flow recovery and vulnerability analysis. The paper presents a classification system for existing methods while comparing them through an analysis of their development from traditional rule-based systems to contemporary deep learning frameworks. The research examines fundamental datasets together with field tools and evaluation metrics. This paper establishes a fundamental understanding of AI integration in reverse engineering for software security while discussing future development directions.},
  keywords={Reverse engineering;Software;Codes;Security;Malware;Artificial intelligence;Surveys;Source coding;Static analysis;Logic;Reverse engineering;software security;malware detection;anomalies;threat analysis},
  doi={10.1109/ACCESS.2025.3593456},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{11307212,
  author={Rajendran, Megala and Al-Nussairi, Ahmed Kateb J. and Abdulhasan, Maki Mahdi and Sreseh, Saleh Naji and Owaied, Huda Qasim},
  booktitle={2025 Second International Conference on Intelligent Technologies for Sustainable Electric and Communications Systems (iTech SECOM)}, 
  title={AI-Based Malware Classification in Android Apps Using Vision Transformer (ViT) on Bytecode Images}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={The rapid proliferation of Android applications has made mobile platforms a prime target for malware attacks. To address the growing concern of malicious apps, this study presents an AI-based malware classification approach using Vision Transformer (ViT) on bytecode images of Android applications. Traditional malware detection techniques, including signature-based and heuristic methods, often fail to detect novel and obfuscated malware due to limited generalization and static rule-based systems. These limitations have necessitated the need for more intelligent and adaptive solutions that can handle complex and evolving malware patterns. To overcome these challenges, we propose a novel framework: Real-Time Malware Detection in App Stores using Bytecode Image Generation and Vision Transformer-Based Classification (RAMViD). In this approach, Android APK files are first decompiled to extract Dalvik bytecode, which is then transformed into grayscale images representing the byte patterns of the application. These images are fed into a finetuned Vision Transformer model that learns intricate visual features of benign and malicious patterns for accurate classification. The proposed method can be integrated into app store infrastructures to perform real-time malware analysis during the app submission process. This ensures proactive filtering of malicious applications before they reach end-users, enhancing platform security without manual intervention. Experimental results demonstrate that the ViT-based classification framework outperforms conventional CNN-based models in accuracy and robustness. The system achieves high detection rates with reduced false positives, highlighting its effectiveness in identifying both known and previously unseen malware. This solution offers a scalable, automated, and intelligent alternative for securing Android ecosystems.},
  keywords={Computer vision;Visualization;Accuracy;Operating systems;Static analysis;Transformers;Malware;Real-time systems;Robustness;Security;Android Malware Detection;Vision Transformer;Bytecode Image;Real-Time Analysis;Deep Learning;Static Analysis;Mobile App Security},
  doi={10.1109/iTechSECOM64750.2025.11307212},
  ISSN={},
  month={Oct},}@INPROCEEDINGS{11023499,
  author={Wang, Yanzhong and Liang, Ruigang and Li, Yilin and Hu, Peiwei and Chen, Kai and Zhang, Bolun},
  booktitle={2025 IEEE Symposium on Security and Privacy (SP)}, 
  title={TypeForge: Synthesizing and Selecting Best-Fit Composite Data Types for Stripped Binaries}, 
  year={2025},
  volume={},
  number={},
  pages={1-18},
  abstract={Static binary analysis is a widely used approach for ensuring the security of closed-source software. However, the absence of type information in stripped binaries, particularly for composite data types, poses significant challenges for both static analyzers and reverse engineering experts in achieving efficient and accurate analysis. Existing methods often struggle with inaccuracies and scalability limitations when dealing with such data types. To address these problems, we present Typeforge, a novel approach inspired by the workflow of reverse engineering experts, which uses a two-stage synthesis-selection strategy to automate the recovery of composite data types from stripped binaries. We design a new graph structure, the Type Flow Graph (TFG) to represent type information within stripped binaries. In the first stage, TFG-based Type Synthesis focuses on efficiently and accurately building constraints and synthesizing possible composite type declarations from the stripped binaries. In the second stage, we propose an LLM-assisted double-elimination framework to select the best-fit type declaration from the candidates by assessing the readability of the decompiled code. Our comparison with state-of-the-art approaches demonstrates that TYPEFORGE achieves F1 scores of 81.7% and 88.2% in Composite Data Type Identification and Layout Recovery, respectively, substantially outperforming existing methods. Additionally, TYPEFORGE achieves an F1 score of 72.1% in Relationship Recovery, a particularly challenging task for previous approaches. Furthermore, TYPEFORGE has significantly lower time overhead, requiring only about 3.8% of the time taken by OSPREY, the best-performing existing approach, making it a promising solution for various real-world reverse engineering tasks.},
  keywords={Privacy;Codes;Accuracy;Scalability;Reverse engineering;Layout;Buildings;Software;Security;Flow graphs},
  doi={10.1109/SP61157.2025.00193},
  ISSN={2375-1207},
  month={May},}@ARTICLE{11242121,
  author={Huang, Jing and Wang, Min and Hu, Yupeng},
  journal={IEEE Internet of Things Journal}, 
  title={FirmCCF: Detecting Custom Cryptographic Function Vulnerabilities Through Query-Driven Approaches}, 
  year={2026},
  volume={13},
  number={2},
  pages={2988-2999},
  abstract={Cryptographic techniques are widely used to safeguard software against privacy breaches. Efficiently detecting encryption algorithms in software to determine whether they meet security requirements is a critical task. However, traditional static and dynamic detection methods often suffer from high false alarm rates or low efficiency, as they cannot fully capture the structural and semantic features of cryptographic algorithms. In this article, we propose FirmCCF, a vulnerability detection tool for custom cryptographic functions in Internet of Things (IoT) devices. FirmCCF leverages an improved deep learning encoder–decoder classification model, CodeT5-cate, to identify and classify cryptographic functions in source code and decompiled firmware. It then outputs highly structured meta-level attributes of cryptographic functions via a large language model (LLM) and detects vulnerabilities through a query-driven approach. FirmCCF achieves 99.97% accuracy, 99.72% recall, and 99.86%  $F1$ -score in detecting cryptographic functions from binary files. We further define seven security rules, encode them as queries, and use them to uncover seven categories of vulnerabilities. An evaluation of 40902 function codes revealed 46 vulnerabilities, including eight previously unknown issues. Our work highlights the urgent need for systematic assessment solutions to detect and mitigate vulnerabilities in custom cryptographic functions.},
  keywords={Cryptography;Encryption;Codes;Salt;Software algorithms;Software;Heuristic algorithms;Feature extraction;Internet of Things;Threat modeling;CodeT5-cate;custom cryptographic function;query-driven},
  doi={10.1109/JIOT.2025.3631834},
  ISSN={2327-4662},
  month={Jan},}@INPROCEEDINGS{10679822,
  author={Wang, Zhoukai and Xu, Zuoyan and Zhang, Yaling and Song, Xin and Wang, Yichuan},
  booktitle={2024 International Conference on Networking and Network Applications (NaNA)}, 
  title={Research on Code Virtualization Methods for Cloud Applications}, 
  year={2024},
  volume={},
  number={},
  pages={287-292},
  abstract={With the vigorous development of technologies such as the Internet, mobile devices, and the Internet of Things, cloud services have gained a crucial position in our life and have become an essential part of daily operations for modern enterprises and organizations. However, existing cloud application security solutions have failed to address the problem of runtime binary code security, focusing only on vulnerabilities inherent to the applications themselves. Code virtualization, also known as virtualization obfuscation, is a technique that protects software from malicious analysis by obfuscating the code. It hides the code’s control flow and data flow, thereby preventing the code from being decompiled. In this paper, we introduce a code virtualization method, VMENP, which splits the code into multiple modules and uses polymorphic and modular encryption mechanisms to secure binary code at runtime. Specifically, VMENP divides the protected program into several modules, designs a virtual instruction set along with its corresponding interpreter, encrypts each instruction individually after converting it into intermediate representations, and then encrypts it again at the basic block level. After compiling the segmented code into polymorphic bytecode sequences, it embeds the virtual code’s interpreter into the IR. During runtime, the protected code is dynamically decrypted and executed by the basic block level, with each basic block’s storage and execution in memory in a short time window. VMENP identifies functions annotated in the source code to locate the functions that need protection. This paper uses a large amount of $\mathrm{C} / \mathrm{C}++$ code to perform tests in a real cloud environment. Experimental results show that VMENP achieves a good balance between the granularity of protection and the performance overhead of the protected programs, while successfully protecting $\mathrm{C} / \mathrm{C}++$ code and programs running on X86/64 and ARM32/64 architectures.},
  keywords={Cloud computing;Codes;Runtime;Instruction sets;Reverse engineering;Computer architecture;Binary codes;Cloud application security;code virtualization;code obfuscation;polymorphic Routines;reverse engineering},
  doi={10.1109/NaNA63151.2024.00054},
  ISSN={},
  month={Aug},}@INPROCEEDINGS{10743227,
  author={Chen, Yingchao and Wang, Junchao and Zhou, Xin and Pang, Jianmin},
  booktitle={2024 9th International Conference on Intelligent Computing and Signal Processing (ICSP)}, 
  title={Software Diversification Protection Methods for Binary Programs}, 
  year={2024},
  volume={},
  number={},
  pages={285-291},
  abstract={Software diversification is an effective software protection method against reverse engineering and code reuse attacks, which can provide heterogeneous redundant execution bodies for mimetic defense mechanisms. Most existing software diversification methods require access to the source code, which can provide defenders with more valuable information for devising effective defense strategies. However, due to commercial copyright and the purpose of preventing software piracy, developers often keep their software closed-source, making it difficult to access the source code. Therefore, a method called R2BF (ReCooking and Randomizing Binary File) is proposed, which combines decompilation and diversification compilation techniques to address the difficulty of obtaining the source code. This method involves diversifying the source code through compilation to achieve software diversification for binary executable files. Security and performance testing of diversified C programs has shown that diversified binary executable files can mitigate vulnerabilities resulting from code reuse, validating that this method can enhance the security of binary programs and is feasible for software protection. The diversified binary executable files are nearly identical to the original, non-diversified files in terms of file size and execution time, and may even exhibit acceleration and optimization effects in certain scenarios.},
  keywords={Software testing;Codes;Source coding;Software protection;Software algorithms;Reverse engineering;Signal processing algorithms;Software;Security;Optimization;component;program protection;software diversification;decompilation;diversification compilation},
  doi={10.1109/ICSP62122.2024.10743227},
  ISSN={},
  month={April},}@ARTICLE{11267408,
  author={Priambodo, Tegar Ganang Satrio and Prabowo, Angela Oryza and Puspitarini, Annisa Dwi and Winarso, Raihan Adam Handoyo and Aisyah, Nur and Pratama, Mohammad Yoga and Purwitasari, Diana and Pratomo, Baskoro Adi},
  journal={IEEE Access}, 
  title={MalQwen: Fine Tuned LLM for Static Android Malware Analysis Report}, 
  year={2025},
  volume={13},
  number={},
  pages={208483-208497},
  abstract={The Android operating system continues to face escalating security challenges, primarily due to its open-source nature and the rapid proliferation of applications from untrusted sources. Traditional static analysis tools lack the flexibility to capture evolving malware behaviors, limiting their interpretability and scalability. Large Language Models (LLMs) are now applied in cybersecurity for malware detection, phishing classification, and cyber threat intelligence. However, their use has not been extended to producing detailed and interpretable Android malware analysis reports. This study integrates LLMs into Android malware analysis by creating a dataset for instruction tuning and fine-tuning the Qwen-7B model using the LoRA method. The model MalQwen is developed by fine-tuning Qwen 2.5-7B with 429 malware samples containing decompiled code and expert labeled security reports. MalQwen outperforms models like Gemini and LLaMA, achieving a BERTscore of 0.84 for SMS malware and a Perplexity score of 3.30 for Scareware. These findings confirm MalQwen’s superior performance in generating precise malware reports, validating LLMs as a powerful new method for Android malware analysis.},
  keywords={Malware;Codes;Operating systems;Feature extraction;Static analysis;Security;Cyber threat intelligence;Training;Data mining;Adaptation models;Android malware analysis;large language model;LoRA fine-tuning;static analysis;report generation},
  doi={10.1109/ACCESS.2025.3637047},
  ISSN={2169-3536},
  month={},}@INPROCEEDINGS{10590654,
  author={Guo, Yaqiong and Chen, Jingnan and Xu, Zichao},
  booktitle={2024 10th IEEE International Conference on Intelligent Data and Security (IDS)}, 
  title={Android Application Reinforcement Method Based on 5G Terminal Device}, 
  year={2024},
  volume={},
  number={},
  pages={53-58},
  abstract={This paper presents a novel Android application reinforcement method designed for 5G smartphones, addressing the security vulnerabilities inherent in Android's open-source na-ture. The method involves extracting key functions from Android applications, decompiling them into Smali code, and then trans-forming them into C++ code. This code is virtualized at compile time and repackaged into a new APK file, offering a more efficient reinforcement approach compared to traditional methods. It uses less computational power and storage while meeting the high safety standards of 5G technology. This approach is particularly effective against automated, low-threshold reverse engineering tools, which have challenged previous hardening methods. In our experiments, we analyzed six common Android shell tools on enhanced applications, demonstrating the ineffectiveness of these tools against our method. Our reinforcement overcomes the easy recovery issue of traditional methods and shows strong resistance to general reverse-engineering tools. We evaluated the performance pre- and post-hardening in terms of CPU utilization, size, and runtime memory usage. For instance, CPU utilization post-hardening increased by 0.9% for Gaud Map, 4.8% for WPS, and 1.3 % for public comments. The use of native Layer code and function localization enhances program efficiency, offsetting the performance overhead of fusion, thus maintaining overall performance stability. Our method's robustness against common reverse-engineering tools, with minimal impact on CPU usage, application size, and memory usage, confirms its practicality for deployment in the 5G ecosystem.},
  keywords={Performance evaluation;Codes;5G mobile communication;Operating systems;Resists;C++ languages;Static analysis;Android;5G Technology;Application Reinforcement;Smali Code;Decompilation;Code Virtualization},
  doi={10.1109/IDS62739.2024.00017},
  ISSN={},
  month={May},}@ARTICLE{10711263,
  author={Hartman, Corey M. and Rimal, Bhaskar P. and de Leon, Daniel Conte and Budhathoki, Nirmal},
  journal={IEEE Security & Privacy}, 
  title={Cross-Architecture Binary Function Fingerprinting}, 
  year={2025},
  volume={23},
  number={2},
  pages={71-80},
  abstract={By combining the SLEIGH decompiler in Ghidra with an machine learning-based technique we can fingerprint reused functions across processor architectures with high accuracy. This opens the door for reverse engineers and antivirus tools to more effectively identify vulnerable and malware code.},
  keywords={Codes;Object recognition;Malware;Internet of Things;Fingerprint recognition;Libraries;Systems architecture;Accuracy;Optimization;Source coding;Machine learning},
  doi={10.1109/MSEC.2024.3468153},
  ISSN={1558-4046},
  month={March},}@INPROCEEDINGS{11118682,
  author={Naliapara, Heli and Singhvi, Puru and Shukla, Pratham and Mirkar, Sulalah},
  booktitle={2025 IEEE International Conference on Emerging Technologies and Applications (MPSec ICETA)}, 
  title={MAIA - Malware Analysis and Intelligence Assistant}, 
  year={2025},
  volume={},
  number={},
  pages={1-6},
  abstract={As cyber threats become more complex, the need for innovative tools in cybersecurity is paramount. MAIA (Malware Analysis and Intelligence Assistant), addresses this demand by automating malware reverse engineering to enhance threat analysis capabilities. It integrates advanced unpacking techniques, decompilation using Ghidra, and artificial intelligence analysis allowing for an indepth understanding of its structure, behaviors, and concealed functions. By enabling detailed static analysis and AI-driven insights, it assists cybersecurity teams in rapidly identifying and countering malicious tactics. Through comprehensive report generation and an interactive user interface, it equips cybersecurity professionals with actionable data to strengthen digital defenses. MAIA exemplifies the integration of AI with traditional malware analysis, aiming to bolster proactive threat mitigation and incident response efforts.},
  keywords={Codes;Automation;Prevention and mitigation;Reverse engineering;Static analysis;Manuals;User interfaces;Malware;Computer security;Artificial intelligence;Malware Analysis;Reverse Engineering;Artificial Intelligence;Incident Response;Static Code Analysis;Threat Intelligence;Automated Malware Analysis;Cyber Threat Mitigation;Cyber Defense Tools;AI-driven Cybersecurity Solutions},
  doi={10.1109/MPSecICETA64837.2025.11118682},
  ISSN={},
  month={Feb},}@INPROCEEDINGS{11028410,
  author={Izrailov, Konstantin and Kotenko, Igor and Buinevich, Mikhail},
  booktitle={2025 International Conference on Industrial Engineering, Applications and Manufacturing (ICIEAM)}, 
  title={Reengineering Modern Industrial Software to Find Vulnerabilities Based on Genetic Algorithms}, 
  year={2025},
  volume={},
  number={},
  pages={918-923},
  abstract={Modern industry is built, among other things, on software, the presence of vulnerabilities in which is a significant problem. It is more rational to search for vulnerabilities in those representations of the program (source code, algorithms, architecture, etc.) on the basis of which they were developed. However, as a rule, there is difficult-to-analyze machine code available. Obtaining higher-level representations is possible by reverse engineering, carried out in various ways, such as expert, algorithmic, intelligent, enumeration and logging. The qualitative comparison of these representations is given. The current study is devoted to a new method of reverse engineering based on the use of genetic algorithms. The course of the research and the following main scientific results are briefly described: the methodology of reverse engineering of a software system, the model of the life cycle of a program with multi-level vulnerabilities, the concept of genetic de-evolution of program representations, scientific, methodological and algorithmic instrumentation for genetic decompilation, an architectural block for conducting genetic de-evolution of representations with functionality for searching for multi-level vulnerabilities. All results are novel, as well as theoretically and practically significant.},
  keywords={Industries;Source coding;Instruments;Reverse engineering;Software algorithms;Information security;Genetics;Software systems;Manufacturing;Genetic algorithms;software;vulnerability;information security;reverse engineering;genetic algorithms},
  doi={10.1109/ICIEAM65163.2025.11028410},
  ISSN={2993-4060},
  month={May},}@INPROCEEDINGS{11264981,
  author={Hossain Mollah, Mohammad Sarwar and Bin Marhusin, Mohd Fadzli and Omar, Syaril Nizam},
  booktitle={2025 IEEE International Conference on Artificial Intelligence in Engineering and Technology (IICAIET)}, 
  title={An Enhanced Hybrid Deep Learning Architecture for Android Malware Detection Using CFG and DeepWalk Embeddings}, 
  year={2025},
  volume={},
  number={},
  pages={455-460},
  abstract={Android malware propagation poses increasing security risks to mobile ecosystems, with conventional detection techniques fighting an uphill battle against advanced evasion strategies and polymorphic variants that take advantage of static analysis limitations. Existing approaches including signature-based detection and conventional machine learning techniques have moderate performance against advanced obfuscation techniques and cannot capture complex structural relationships inherent in malicious code execution behavior. These limitations necessitate advanced techniques capable of carrying out in-depth structural analysis and dynamic pattern detection for malware detection. This paper proposes a new hybrid deep learning technique that combines Control Flow Graph (CFG) analysis with Deep Graph Convolutional Neural Networks (DeepGraphCNNs) and Temporal Convolutional Networks (TCN) to overcome current limitations. Our technique meticulously reverse-engineers APK packages, decompiles Dalvik bytecode to extract CFG representations and utilizes sophisticated graph embedding methods (DeepWalk, Node2Vec, Word2Vec) in the feature transformation process. The experiment is conducted on 2,349 samples from CICMalAnal2017 and MalwareBazar. Our DeepWalk-DeepGraphCNNs and TCN model demonstrated superior performance with 95.10% accuracy and 93.67% AUC-ROC. Our experimental results ensure the success of the technique for addressing contemporary Android security issues.},
  keywords={Deep learning;Accuracy;Ecosystems;Static analysis;Feature extraction;Malware;Mobile security;Graph neural networks;Convolutional neural networks;Flow graphs;Android security;Malware detection;Graph neural networks;CFG;Hybrid deep learning;Graph embedding;Mobile cybersecurity},
  doi={10.1109/IICAIET67254.2025.11264981},
  ISSN={},
  month={Aug},}
